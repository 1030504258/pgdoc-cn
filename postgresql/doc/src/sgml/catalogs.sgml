<!-- doc/src/sgml/catalogs.sgml -->
<!--
 Documentation of the system catalogs, directed toward PostgreSQL developers
 -->

<chapter id="catalogs">
 <!-- 
 <title>System Catalogs</title> 
 -->
 <title>系统表</title>

  <!--
<para>
   The system catalogs are the place where a relational database
   management system stores schema metadata, such as information about
   tables and columns, and internal bookkeeping information.
   <productname>PostgreSQL</productname>'s system catalogs are regular
   tables.  You can drop and recreate the tables, add columns, insert
   and update values, and severely mess up your system that way.
   Normally, one should not change the system catalogs by hand, there
   are always SQL commands to do that.  (For example, <command>CREATE
   DATABASE</command> inserts a row into the
   <structname>pg_database</structname> catalog &mdash; and actually
   creates the database on disk.)  There are some exceptions for
   particularly esoteric operations, such as adding index access methods.
  </para>
-->
<para>
系统表是关系型数据库管理系统存放结构元数据的地方，比如表和字段以及内部登记信息等。
<productname>PostgreSQL</productname>的系统表就是普通表。你可以删除然后重建这些表、
增加列、插入和更新数值，然后彻底把系统搞垮。不应该手工修改系统表，
通常总有 SQL 命令可以做这些事情。比如，<command>CREATE DATABASE</command>
向<structname>pg_database</structname>表插入一行，并且实际上在磁盘上创建该数据库。
有几种特别深奥的操作例外，比如增加索引访问方法。
</para>

 <sect1 id="catalogs-overview">
  <!-- 
  <title>Overview</title> 
  -->
  <title>概述</title>

  <!--
<para>
   <xref linkend="catalog-table"> lists the system catalogs.
   More detailed documentation of each catalog follows below.
  </para>
-->
<para>
<xref linkend="catalog-table">列出了系统表。每个表更详细的文档在后面。
</para>

  <!--
<para>
   Most system catalogs are copied from the template database during
   database creation and are thereafter database-specific. A few
   catalogs are physically shared across all databases in a cluster;
   these are noted in the descriptions of the individual catalogs.
  </para>
-->
<para>
大多数系统表都是在数据库创建的过程中从模版数据库中拷贝过来的，因此都是数据库相关的。
少数表是在一个集群中物理上所有数据库共享的；这些表在独立的表的描述中用指明了。
</para>

  <table id="catalog-table">
   <!-- 
   <title>System Catalogs</title>
   -->
   <title>系统表</title>

   <tgroup cols="2">
    <thead>
     <row>
      <!-- 
  <entry>Catalog Name</entry>
      <entry>Purpose</entry> 
  -->
  <entry>表名字</entry>
      <entry>用途</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><link linkend="catalog-pg-aggregate"><structname>pg_aggregate</structname></link></entry>
      <!-- 
  <entry>aggregate functions</entry> 
  -->
  <entry>聚集函数</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-am"><structname>pg_am</structname></link></entry>
      <!-- 
  <entry>index access methods</entry> 
  -->
  <entry>索引访问方法</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-amop"><structname>pg_amop</structname></link></entry>
      <!-- 
  <entry>access method operators</entry> 
  -->
  <entry>访问方法操作符</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-amproc"><structname>pg_amproc</structname></link></entry>
      <!-- 
  <entry>access method support procedures</entry> 
  -->
  <entry>访问方法支持过程</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-attrdef"><structname>pg_attrdef</structname></link></entry>
      <!-- 
  <entry>column default values</entry> 
  -->
  <entry>字段缺省值</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link></entry>
      <!-- 
  <entry>table columns (<quote>attributes</quote>)</entry> 
  -->
  <entry>表的列(<quote>属性</quote>)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link></entry>
      <!-- 
  <entry>authorization identifiers (roles)</entry> 
  -->
  <entry>认证标识符(角色)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-auth-members"><structname>pg_auth_members</structname></link></entry>
      <!-- 
  <entry>authorization identifier membership relationships</entry>
  -->
  <entry>认证标识符成员关系</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-cast"><structname>pg_cast</structname></link></entry>
      <!-- 
  <entry>casts (data type conversions)</entry> 
  -->
  <entry>转换(数据类型转换)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-class"><structname>pg_class</structname></link></entry>
      <!-- 
  <entry>tables, indexes, sequences, views (<quote>relations</quote>)</entry> 
  -->
  <entry>表、索引、序列、视图 (<quote>关系</quote>)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-constraint"><structname>pg_constraint</structname></link></entry>
      <!-- 
  <entry>check constraints, unique constraints, primary key constraints, foreign key constraints</entry> 
  -->
  <entry>检查约束、唯一约束、主键约束、外键约束</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-collation"><structname>pg_collation</structname></link></entry>
      <!-- 
  <entry>collations (locale information)</entry> 
  -->
  <entry>排序规则 (本地信息)</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-conversion"><structname>pg_conversion</structname></link></entry>
      <!-- 
  <entry>encoding conversion information</entry> 
  -->
  <entry>编码转换信息</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-database"><structname>pg_database</structname></link></entry>
      <!-- 
  <entry>databases within this database cluster</entry> 
  -->
  <entry>本集群内的数据库</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-db-role-setting"><structname>pg_db_role_setting</structname></link></entry>
      <!-- 
  <entry>per-role and per-database settings</entry> 
  -->
  <entry>每个角色和每个数据库设置</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-default-acl"><structname>pg_default_acl</structname></link></entry>
      <!-- 
  <entry>default privileges for object types</entry> 
  -->
  <entry>对象类型的缺省权限</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-depend"><structname>pg_depend</structname></link></entry>
      <!-- 
  <entry>dependencies between database objects</entry> 
  -->
  <entry>数据库对象之间的依赖性</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-description"><structname>pg_description</structname></link></entry>
      <!-- 
  <entry>descriptions or comments on database objects</entry> 
  -->
  <entry>数据库对象的描述或注释</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-enum"><structname>pg_enum</structname></link></entry>
      <!-- 
  <entry>enum label and value definitions</entry> 
  -->
  <entry>定义枚举标签和值</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-event-trigger"><structname>pg_event_trigger</structname></link></entry>
      <!-- 
  <entry>event triggers</entry> 
  -->
  <entry>事件触发器</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-extension"><structname>pg_extension</structname></link></entry>
      <!-- 
  <entry>installed extensions</entry> 
  -->
  <entry>安装扩展</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-foreign-data-wrapper"><structname>pg_foreign_data_wrapper</structname></link></entry>
      <!-- 
  <entry>foreign-data wrapper definitions</entry> 
  -->
  <entry>定义外部数据封装器</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-foreign-server"><structname>pg_foreign_server</structname></link></entry>
      <!-- 
  <entry>foreign server definitions</entry> 
  -->
  <entry>定义外部服务器</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-foreign-table"><structname>pg_foreign_table</structname></link></entry>
      <!-- 
  <entry>additional foreign table information</entry> 
  -->
  <entry>附加的外部表信息</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-index"><structname>pg_index</structname></link></entry>
      <!-- 
  <entry>additional index information</entry> 
  -->
  <entry>附加的索引信息</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-inherits"><structname>pg_inherits</structname></link></entry>
      <!-- 
  <entry>table inheritance hierarchy</entry> 
  -->
  <entry>表继承层次</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-language"><structname>pg_language</structname></link></entry>
      <!-- 
  <entry>languages for writing functions</entry> 
  -->
  <entry>用于写函数的语言</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-largeobject"><structname>pg_largeobject</structname></link></entry>
      <!-- 
  <entry>data pages for large objects</entry> 
  -->
  <entry>大对象的数据页</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-largeobject-metadata"><structname>pg_largeobject_metadata</structname></link></entry>
      <!-- 
  <entry>metadata for large objects</entry> 
  -->
  <entry>大对象的元数据</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link></entry>
      <!-- 
  <entry>schemas</entry>
  -->
  <entry>模式</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link></entry>
      <!-- 
  <entry>access method operator classes</entry> 
  -->
  <entry>访问方法操作符类</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link></entry>
      <!-- 
  <entry>operators</entry> 
  -->
  <entry>操作符</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link></entry>
      <!-- 
  <entry>access method operator families</entry> 
  -->
  <entry>访问方法操作符族</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-pltemplate"><structname>pg_pltemplate</structname></link></entry>
      <!-- 
  <entry>template data for procedural languages</entry> 
  -->
  <entry>过程语言使用的模板数据</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link></entry>
      <!-- 
  <entry>functions and procedures</entry> 
  -->
  <entry>函数和过程</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-range"><structname>pg_range</structname></link></entry>
      <!-- 
  <entry>information about range types</entry> 
  -->
  <entry>有关范围类型的信息</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-rewrite"><structname>pg_rewrite</structname></link></entry>
      <!-- 
  <entry>query rewrite rules</entry>
  -->
  <entry>查询重写规则</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-seclabel"><structname>pg_seclabel</structname></link></entry>
      <!-- 
  <entry>security labels on database objects</entry> 
  -->
  <entry>数据库对象上的安全标签</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-shdepend"><structname>pg_shdepend</structname></link></entry>
      <!-- 
  <entry>dependencies on shared objects</entry> 
  -->
  <entry>在共享对象上的依赖性</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-shdescription"><structname>pg_shdescription</structname></link></entry>
      <!-- 
  <entry>comments on shared objects</entry> 
  -->
  <entry>共享对象上的注释</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-shseclabel"><structname>pg_shseclabel</structname></link></entry>
      <!-- 
  <entry>security labels on shared database objects</entry> 
  -->
  <entry>共享数据对象上的安全标签</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-statistic"><structname>pg_statistic</structname></link></entry>
      <!-- 
  <entry>planner statistics</entry> 
  -->
  <entry>优化器统计</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link></entry>
      <!-- 
  <entry>tablespaces within this database cluster</entry> 
  -->
  <entry>这个数据库集群里面的表空间</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-trigger"><structname>pg_trigger</structname></link></entry>
      <!-- 
  <entry>triggers</entry> 
  -->
  <entry>触发器</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-ts-config"><structname>pg_ts_config</structname></link></entry>
      <!-- 
  <entry>text search configurations</entry>
  -->
  <entry>文本搜索配置</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-ts-config-map"><structname>pg_ts_config_map</structname></link></entry>
      <!-- 
  <entry>text search configurations' token mappings</entry> 
  -->
  <entry>文本搜索配置的标记映射</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-ts-dict"><structname>pg_ts_dict</structname></link></entry>
      <!-- 
  <entry>text search dictionaries</entry> 
  -->
  <entry>文本搜索字典</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-ts-parser"><structname>pg_ts_parser</structname></link></entry>
      <!-- 
  <entry>text search parsers</entry> 
  -->
  <entry>文本搜索解析器</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-ts-template"><structname>pg_ts_template</structname></link></entry>
      <!-- 
  <entry>text search templates</entry> 
  -->
  <entry>文本搜索模板</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-type"><structname>pg_type</structname></link></entry>
      <!-- 
  <entry>data types</entry> 
  -->
  <entry>数据类型</entry>
     </row>

     <row>
      <entry><link linkend="catalog-pg-user-mapping"><structname>pg_user_mapping</structname></link></entry>
      <!-- 
  <entry>mappings of users to foreign servers</entry> 
  -->
  <entry>对外部服务器进行映射的用户</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-aggregate">
  <title><structname>pg_aggregate</structname></title>

  <indexterm zone="catalog-pg-aggregate">
   <primary>pg_aggregate</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_aggregate</structname> stores information about
   aggregate functions.  An aggregate function is a function that
   operates on a set of values (typically one column from each row
   that matches a query condition) and returns a single value computed
   from all these values.  Typical aggregate functions are
   <function>sum</function>, <function>count</function>, and
   <function>max</function>.  Each entry in
   <structname>pg_aggregate</structname> is an extension of an entry
   in <structname>pg_proc</structname>.  The <structname>pg_proc</structname>
   entry carries the aggregate's name, input and output data types, and
   other information that is similar to ordinary functions.
  </para>
-->
<para>
存储与聚集函数有关的信息。聚集函数是对一个数值集(通常每个匹配查询条件的行中的一个字段)
进行操作的函数，它返回从这些值中计算出的一个数值。典型的聚集函数是<function>sum</function>, 
<function>count</function>, <function>max</function>。<structname>pg_aggregate</structname>
里的每条记录都是一条<structname>pg_proc</structname>里面的记录的扩展。<structname>pg_proc</structname>
记录承载该聚集的名字、输入和输出数据类型，以及其它一些和普通函数类似的信息。
</para>

  <table>
   <!-- 
   <title><structname>pg_aggregate</> Columns</title> 
   -->
   <title><structname>pg_aggregate</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>aggfnoid</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry><structname>pg_proc</structname> OID of the aggregate function</entry> 
  -->
  <entry>此聚集函数的<structname>pg_proc</structname> OID</entry>
     </row>
     <row>
      <entry><structfield>aggtransfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Transition function</entry> 
  -->
  <entry>转换函数</entry>
     </row>
     <row>
      <entry><structfield>aggfinalfn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Final function (zero if none)</entry> 
  -->
  <entry>最终处理函数(如果没有则为零)</entry>
     </row>
     <row>
      <entry><structfield>aggsortop</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Associated sort operator (zero if none)</entry> 
  -->
  <entry>关联排序操作符(如果没有则为零)</entry>
     </row>
     <row>
      <entry><structfield>aggtranstype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Data type of the aggregate function's internal transition (state) data</entry> 
  -->
  <entry>此聚集函数的内部转换(状态)数据的数据类型</entry>
     </row>
     <row>
      <entry><structfield>agginitval</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
     <!-- 
 <entry>
       The initial value of the transition state.  This is a text
       field containing the initial value in its external string
       representation.  If this field is null, the transition state
       value starts out null.
      </entry> 
  -->
   <entry>
       转换状态的初始值。这是一个文本数据域，它包含初始值的外部字符串表现形式。
   如果数据域是 null ，那么转换状态值从 null 开始。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   New aggregate functions are registered with the <xref
   linkend="sql-createaggregate">
   command.  See <xref linkend="xaggr"> for more information about
   writing aggregate functions and the meaning of the transition
   functions, etc.
  </para>
-->
<para>
新聚集函数是用<xref linkend="sql-createaggregate">命令注册的。参阅<xref linkend="xaggr">
获取关于编写聚集函数以及转换函数的含义等的更多信息。
</para>

 </sect1>


 <sect1 id="catalog-pg-am">
  <title><structname>pg_am</structname></title>

  <indexterm zone="catalog-pg-am">
   <primary>pg_am</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_am</structname> stores information about index
   access methods.  There is one row for each index access method supported by
   the system.  The contents of this catalog are discussed in detail in
   <xref linkend="indexam">.
  </para>
-->
<para>
<structname>pg_am</structname>存储有关索引访问方法的信息。系统支持的每种索引访问方法都有一行。
这个表的内容在<xref linkend="indexam">详细讨论。
</para>

  <table>
   <!-- 
   <title><structname>pg_am</> Columns</title> 
   -->
   <title><structname>pg_am</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <!-- 
  <entry>Row identifier (hidden attribute; must be explicitly selected)</entry> 
  -->
  <entry>行标识符(隐藏属性; 必须明确选择)</entry>
     </row>

     <row>
      <entry><structfield>amname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <!-- 
  <entry>Name of the access method</entry> 
  -->
  <entry>访问方法的名字</entry>
     </row>

     <row>
      <entry><structfield>amstrategies</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <!-- 
  <entry>Number of operator strategies for this access method,
       or zero if access method does not have a fixed set of operator
       strategies</entry> 
   -->
   <entry>这个访问方法的操作符策略个数，或者如果访问方法没有一个固定的操作符策略集则为0。
   </entry>
     </row>

     <row>
      <entry><structfield>amsupport</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <!-- 
  <entry>Number of support routines for this access method</entry> 
  -->
  <entry>这个访问方法的支持过程个数</entry>
     </row>

     <row>
      <entry><structfield>amcanorder</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>Does the access method support ordered scans sorted by the
       indexed column's value?</entry>
   -->
   <entry>这种访问方式是否支持通过索引字段值的命令扫描排序？</entry>
     </row>

     <row>
      <entry><structfield>amcanorderbyop</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>Does the access method support ordered scans sorted by the result
       of an operator on the indexed column?</entry> 
   -->
   <entry>这种访问方式是否支持通过索引字段上操作符的结果的命令扫描排序？</entry>
     </row>

     <row>
      <entry><structfield>amcanbackward</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>Does the access method support backward scanning?</entry> 
  -->
  <entry>这种访问方式是否支持向后扫描？</entry>
     </row>

     <row>
      <entry><structfield>amcanunique</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>Does the access method support unique indexes?</entry> 
  -->
  <entry>这种访问方式是否支持唯一索引?</entry>
     </row>

     <row>
      <entry><structfield>amcanmulticol</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>Does the access method support multicolumn indexes?</entry> 
  -->
  <entry>这种访问方式是否支持多字段索引?</entry>
     </row>

     <row>
      <entry><structfield>amoptionalkey</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>Does the access method support a scan without any constraint
       for the first index column?</entry> 
   -->
   <entry>这种访问方式是否支持第一个索引字段上没有任何约束的扫描?</entry>
     </row>

     <row>
      <entry><structfield>amsearcharray</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>Does the access method support <literal>ScalarArrayOpExpr</> searches?</entry>
  -->
  <entry>这种访问方式是否支持<literal>ScalarArrayOpExpr</>搜索?</entry>
     </row>

     <row>
      <entry><structfield>amsearchnulls</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>Does the access method support <literal>IS NULL</>/<literal>NOT NULL</> searches?</entry> 
  -->
  <entry>这种访问方式是否支持<literal>IS NULL</>/<literal>NOT NULL</>搜索?</entry>
     </row>

     <row>
      <entry><structfield>amstorage</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>Can index storage data type differ from column data type?</entry> 
  -->
  <entry>允许索引存储的数据类型与列的数据类型不同?</entry>
     </row>

     <row>
      <entry><structfield>amclusterable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>Can an index of this type be clustered on?</entry> 
  -->
  <entry>允许在一个这种类型的索引上群集?</entry>
     </row>

     <row>
      <entry><structfield>ampredlocks</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>Does an index of this type manage fine-grained predicate locks?</entry> 
  -->
  <entry>允许这种类型的一个索引管理细粒度的谓词锁定?</entry>
     </row>

     <row>
      <entry><structfield>amkeytype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Type of data stored in index, or zero if not a fixed type</entry> 
  -->
  <entry>存储在索引里的数据的类型，如果不是一个固定的类型则为0</entry>
     </row>

     <row>
      <entry><structfield>aminsert</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry><quote>Insert this tuple</quote> function</entry> 
  -->
  <entry><quote>插入这个行</quote> 函数</entry>
     </row>

     <row>
      <entry><structfield>ambeginscan</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry><quote>Prepare for index scan</quote> function</entry> 
  -->
  <entry><quote>准备索引扫描</quote> 函数</entry>
     </row>

     <row>
      <entry><structfield>amgettuple</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!--
  <entry><quote>Next valid tuple</quote> function, or zero if none</entry>
  -->
  <entry><quote>下一个有效行</quote> 函数, 如果没有则为0</entry>
     </row>

     <row>
      <entry><structfield>amgetbitmap</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry><quote>Fetch all valid tuples</quote> function, or zero if none</entry> 
  -->
  <entry><quote>抓取所有有效行</quote> 函数, 如果没有则为0</entry>
     </row>

     <row>
      <entry><structfield>amrescan</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry><quote>(Re)start index scan</quote> function</entry> 
  -->
  <entry><quote>（重新）开始索引扫描</quote> 函数</entry>
     </row>

     <row>
      <entry><structfield>amendscan</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry><quote>Clean up after index scan</quote> function</entry> 
  -->
  <entry><quote>索引扫描后清理</quote> 函数</entry>
     </row>

     <row>
      <entry><structfield>ammarkpos</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry><quote>Mark current scan position</quote> function</entry> 
  -->
  <entry><quote>标记当前扫描位置</quote> 函数</entry>
     </row>

     <row>
      <entry><structfield>amrestrpos</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry><quote>Restore marked scan position</quote> function</entry>
  -->
  <entry><quote>恢复已标记的扫描位置</quote> 函数</entry>
     </row>

     <row>
      <entry><structfield>ambuild</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry><quote>Build new index</quote> function</entry> 
  -->
  <entry><quote>建立新索引</quote> 函数</entry>
     </row>

     <row>
      <entry><structfield>ambuildempty</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry><quote>Build empty index</quote> function</entry> 
  -->
  <entry><quote>建立空索引</quote> 函数</entry>
     </row>

     <row>
      <entry><structfield>ambulkdelete</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Bulk-delete function</entry> 
  -->
  <entry>批量删除函数</entry>
     </row>

     <row>
      <entry><structfield>amvacuumcleanup</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Post-<command>VACUUM</command> cleanup function</entry> 
  -->
  <entry><command>VACUUM</command> 后的清理函数</entry>
     </row>

     <row>
      <entry><structfield>amcanreturn</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Function to check whether index supports index-only scans,
       or zero if none</entry> 
   -->
   <entry>检查是否索引支持唯一索引扫描的函数，如果没有则为0</entry>
     </row>

     <row>
      <entry><structfield>amcostestimate</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Function to estimate cost of an index scan</entry> 
  -->
  <entry>估计一个索引扫描开销的函数</entry>
     </row>

     <row>
      <entry><structfield>amoptions</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Function to parse and validate <structfield>reloptions</> for an index</entry> 
  -->
  <entry>为一个索引分析和确认<structfield>reloptions</>的函数</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-amop">
  <title><structname>pg_amop</structname></title>

  <indexterm zone="catalog-pg-amop">
   <primary>pg_amop</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_amop</structname> stores information about
   operators associated with access method operator families.  There is one
   row for each operator that is a member of an operator family.  A family
   member can be either a <firstterm>search</> operator or an
   <firstterm>ordering</> operator.  An operator
   can appear in more than one family, but cannot appear in more than one
   search position nor more than one ordering position within a family.
   (It is allowed, though unlikely, for an operator to be used for both
   search and ordering purposes.)
  </para>
-->
<para>
<structname>pg_amop</structname>表存储有关和访问方法操作符族关联的信息。
如果一个操作符是一个操作符族中的成员，那么在这个表中会占据一行。
一个族成员是一个<firstterm>search</>操作符或一个<firstterm>ordering</>操作符。
一个操作符可以在多个族中出现，但是不能在一个族中的多个搜索位置或多个排序位置中出现。
（尽管不太可能，但这是允许的，一个操作符可以被搜索和排序目的使用。）
</para>

  <table>
   <!-- 
   <title><structname>pg_amop</> Columns</title> 
   -->
   <title><structname>pg_amop</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <!-- 
  <entry>Row identifier (hidden attribute; must be explicitly selected)</entry>
  -->
  <entry>行标识符(隐藏属性；必须明确选择)</entry>
     </row>

     <row>
      <entry><structfield>amopfamily</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The operator family this entry is for</entry> 
  -->
  <entry>这个项的操作符族</entry>
     </row>

     <row>
      <entry><structfield>amoplefttype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Left-hand input data type of operator</entry>
  -->
  <entry>操作符的左输入类型</entry>
     </row>

     <row>
      <entry><structfield>amoprighttype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Right-hand input data type of operator</entry> 
  -->
  <entry>操作符的右输入类型</entry>
     </row>

     <row>
      <entry><structfield>amopstrategy</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <!-- 
  <entry>Operator strategy number</entry> 
  -->
  <entry>操作符策略数</entry>
     </row>

     <row>
      <entry><structfield>amoppurpose</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <!-- 
  <entry>Operator purpose, either <literal>s</> for search or
       <literal>o</> for ordering</entry> 
   -->
   <entry>操作符目的, <literal>s</>为搜索或<literal>o</>为排序</entry>
     </row>

     <row>
      <entry><structfield>amopopr</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <!-- 
  <entry>OID of the operator</entry> 
  -->
  <entry>该操作符的OID</entry>
     </row>

     <row>
      <entry><structfield>amopmethod</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-am"><structname>pg_am</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Index access method operator family is for</entry> 
  -->
  <entry>索引访问方式操作符族</entry>
     </row>

     <row>
      <entry><structfield>amopsortfamily</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The btree operator family this entry sorts according to, if an
       ordering operator; zero if a search operator</entry> 
   -->
   <entry>如果是一个排序操作符，则为这个项排序所依据的btree操作符族；
   如果是一个搜索操作符，则为0</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   A <quote>search</> operator entry indicates that an index of this operator
   family can be searched to find all rows satisfying
   <literal>WHERE</>
   <replaceable>indexed_column</>
   <replaceable>operator</>
   <replaceable>constant</>.
   Obviously, such an operator must return boolean, and its left-hand input
   type must match the index's column data type.
  </para>
-->
<para>
<quote>搜索</>操作符表明这个操作符族的一个索引可以被搜索，找到所有满足
<literal>WHERE</> <replaceable>indexed_column</> <replaceable>operator</> <replaceable>constant</>的行。
显然，这样的操作符必须返回布尔值，并且它的左输入类型必须匹配索引的字段数据类型。
</para>

  <!--
<para>
   An <quote>ordering</> operator entry indicates that an index of this
   operator family can be scanned to return rows in the order represented by
   <literal>ORDER BY</>
   <replaceable>indexed_column</>
   <replaceable>operator</>
   <replaceable>constant</>.
   Such an operator could return any sortable data type, though again
   its left-hand input type must match the index's column data type.
   The exact semantics of the <literal>ORDER BY</> are specified by the
   <structfield>amopsortfamily</structfield> column, which must reference
   a btree operator family for the operator's result type.
  </para>
-->
<para>
<quote>排序</>操作符表明这个操作符族的一个索引可以被扫描，返回以
<literal>ORDER BY</> <replaceable>indexed_column</> <replaceable>operator</> <replaceable>constant</>
顺序表示的行。这样的操作符可以返回任意可排序的数据类型，它的左输入类型也必须匹配索引的字段数据类型。
<literal>ORDER BY</>的确切的语义是由<structfield>amopsortfamily</structfield>字段指定的，
该字段必须为操作符的返回类型引用一个btree操作符族。
</para>

  <note>
   <!--
<para>
    At present, it's assumed that the sort order for an ordering operator
    is the default for the referenced opfamily, i.e., <literal>ASC NULLS
    LAST</>.  This might someday be relaxed by adding additional columns
    to specify sort options explicitly.
   </para>
-->
<para>
目前，假设排序操作符的排序顺序是被族缺省引用的，也就是<literal>ASC NULLS LAST</>。
这可以通过添加附加的行来明确声明排序选项来释放。
</para>
  </note>

  <!--
<para>
   An entry's <structfield>amopmethod</> must match the
   <structname>opfmethod</> of its containing operator family (including
   <structfield>amopmethod</> here is an intentional denormalization of the
   catalog structure for performance reasons).  Also,
   <structfield>amoplefttype</> and <structfield>amoprighttype</> must match
   the <structfield>oprleft</> and <structfield>oprright</> fields of the
   referenced <structname>pg_operator</> entry.
  </para>
-->
<para>
一个项的<structfield>amopmethod</>必须匹配它包含的操作符族的<structname>opfmethod</>
（包括<structfield>amopmethod</>是故意违反性能原因的表结构的规范化）。同样，
<structfield>amoplefttype</>和<structfield>amoprighttype</>必须匹配引用的
<structname>pg_operator</>的<structfield>oprleft</>和<structfield>oprright</>。
</para>

 </sect1>


 <sect1 id="catalog-pg-amproc">
  <title><structname>pg_amproc</structname></title>

  <indexterm zone="catalog-pg-amproc">
   <primary>pg_amproc</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_amproc</structname> stores information about
   support procedures associated with access method operator families.  There
   is one row for each support procedure belonging to an operator family.
  </para>
-->
<para>
<structname>pg_amproc</structname>存储有关与访问方法操作符族相关联的支持过程的信息。
每个属于某个操作符族的支持过程都占有一行。
</para>

  <table>
   <!-- 
   <title><structname>pg_amproc</structname> Columns</title> 
   -->
   <title><structname>pg_amproc</structname> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <!-- 
  <entry>Row identifier (hidden attribute; must be explicitly selected)</entry> 
  -->
  <entry>行标识符(隐藏属性; 必须明确选择)</entry>
     </row>

     <row>
      <entry><structfield>amprocfamily</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The operator family this entry is for</entry> 
  -->
  <entry>该项的操作符族</entry>
     </row>

     <row>
      <entry><structfield>amproclefttype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Left-hand input data type of associated operator</entry> 
  -->
  <entry>相关操作符的左输入数据类型</entry>
     </row>

     <row>
      <entry><structfield>amprocrighttype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Right-hand input data type of associated operator</entry> 
  -->
  <entry>相关操作符的右输入数据类型</entry>
     </row>

     <row>
      <entry><structfield>amprocnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <!-- 
  <entry>Support procedure number</entry> 
  -->
  <entry>支持过程编号</entry>
     </row>

     <row>
      <entry><structfield>amproc</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry>OID of the procedure</entry> 
  -->
  <entry>过程的 OID</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   The usual interpretation of the
   <structfield>amproclefttype</> and <structfield>amprocrighttype</> fields
   is that they identify the left and right input types of the operator(s)
   that a particular support procedure supports.  For some access methods
   these match the input data type(s) of the support procedure itself, for
   others not.  There is a notion of <quote>default</> support procedures for
   an index, which are those with <structfield>amproclefttype</> and
   <structfield>amprocrighttype</> both equal to the index opclass's
   <structfield>opcintype</>.
  </para>
-->
<para>
<structfield>amproclefttype</>和<structfield>amprocrighttype</>字段的习惯解释，
他们标识一个特定支持过程支持的操作符的左和右输入类型。对于某些访问方式，
他们匹配支持过程本身的输入数据类型，对其他的则不这样。有一个对索引的<quote>缺省</>
支持过程的概念，<structfield>amproclefttype</>和<structfield>amprocrighttype</>
都等于索引操作符类的<structfield>opcintype</>。
</para>

 </sect1>


 <sect1 id="catalog-pg-attrdef">
  <title><structname>pg_attrdef</structname></title>

  <indexterm zone="catalog-pg-attrdef">
   <primary>pg_attrdef</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_attrdef</structname> stores column default values.  The main information
   about columns is stored in <structname>pg_attribute</structname>
   (see below).  Only columns that explicitly specify a default value
   (when the table is created or the column is added) will have an
   entry here.
  </para>
-->
<para>
<structname>pg_attrdef</structname>表存储字段缺省值。字段的主要信息存放在<structname>pg_attribute</structname>
(见下文)。只有明确声明一个缺省值(该表何时创建或字段何时增加)的字段在这里有行。
</para>

  <table>
   <!-- 
   <title><structname>pg_attrdef</> Columns</title> 
   -->
   <title><structname>pg_attrdef</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <!-- 
  <entry>Row identifier (hidden attribute; must be explicitly selected)</entry> 
  -->
  <entry>行标识符(隐藏属性;必须明确选择)</entry>
     </row>

     <row>
      <entry><structfield>adrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The table this column belongs to</entry> 
  -->
  <entry>这个字段所属的表</entry>
     </row>

     <row>
      <entry><structfield>adnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <!-- 
  <entry>The number of the column</entry> 
  -->
  <entry>字段数目</entry>
     </row>

     <row>
      <entry><structfield>adbin</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <!-- 
  <entry>The internal representation of the column default value</entry> 
  -->
  <entry>字段缺省值的内部表现形式</entry>
     </row>

     <row>
      <entry><structfield>adsrc</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <!-- 
  <entry>A human-readable representation of the default value</entry>
  -->
  <entry>人类可读的缺省值的内部表现形式</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

   <!--
<para>
    The <structfield>adsrc</structfield> field is historical, and is best
    not used, because it does not track outside changes that might affect
    the representation of the default value.  Reverse-compiling the
    <structfield>adbin</structfield> field (with <function>pg_get_expr</> for
    example) is a better way to display the default value.
   </para>
-->
<para>
<structfield>adsrc</structfield>是历史遗留，最好不要使用它，
因为它并未跟踪可能影响缺省值表现形式的外部变化。反编译<structfield>adbin</structfield>
字段(比如，用<function>pg_get_expr</>)是更好的显示缺省值的方法。
</para>

 </sect1>


 <sect1 id="catalog-pg-attribute">
  <title><structname>pg_attribute</structname></title>

  <indexterm zone="catalog-pg-attribute">
   <primary>pg_attribute</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_attribute</structname> stores information about
   table columns.  There will be exactly one
   <structname>pg_attribute</structname> row for every column in every
   table in the database.  (There will also be attribute entries for
   indexes, and indeed all objects that have <structname>pg_class</structname>
   entries.)
  </para>
-->
<para>
<structname>pg_attribute</structname>表存储关于表的字段的信息。数据库里每个表的每个字段都在
<structname>pg_attribute</structname>里有一行。还有用于索引，以及所有在
<structname>pg_class</structname>里有记录的对象。
</para>

  <!--
<para>
   The term attribute is equivalent to column and is used for
   historical reasons.
  </para>
-->
<para>
术语属性等效于列/字段，使用它是历史原因。
</para>

  <table>
   <!-- 
   <title><structname>pg_attribute</> Columns</title> 
   -->
   <title><structname>pg_attribute</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>attrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The table this column belongs to</entry>
  -->
  <entry>此字段所属的表</entry>
     </row>

     <row>
      <entry><structfield>attname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <!-- 
  <entry>The column name</entry> 
  -->
  <entry>字段名字</entry>
     </row>

     <row>
      <entry><structfield>atttypid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The data type of this column</entry> 
  -->
  <entry>这个字段的数据类型</entry>
     </row>

     <row>
      <entry><structfield>attstattarget</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   <structfield>attstattarget</structfield> controls the level of detail
       of statistics accumulated for this column by
       <xref linkend="sql-analyze">.
       A zero value indicates that no statistics should be collected.
       A negative value says to use the system default statistics target.
       The exact meaning of positive values is data type-dependent.
       For scalar data types, <structfield>attstattarget</structfield>
       is both the target number of <quote>most common values</quote>
       to collect, and the target number of histogram bins to create. 
   -->
   控制<xref linkend="sql-analyze">为这个字段积累的统计细节的级别。零值表示不收集统计信息。
   负数表示使用系统缺省的统计对象。正数值的确切信息是和数据类型相关的。对于标量数据类型，
   <structfield>attstattarget</structfield>既是要收集的<quote>最常用数值</quote>
   的目标数目，也是要创建的柱状图的目标数量。
      </entry>
     </row>

     <row>
      <entry><structfield>attlen</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   A copy of <literal>pg_type.typlen</literal> of this column's
       type 
   -->
   是本字段类型的<literal>pg_type.typlen</literal>的拷贝
      </entry>
     </row>

     <row>
      <entry><structfield>attnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
      <!-- 
  The number of the column.  Ordinary columns are numbered from 1
       up.  System columns, such as <structfield>oid</structfield>,
       have (arbitrary) negative numbers.
   -->
   字段数目。普通字段是从 1 开始计数的。系统字段
   (比如<structfield>oid</structfield>)有(任意)负数。
      </entry>
     </row>

     <row>
      <entry><structfield>attndims</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Number of dimensions, if the column is an array type; otherwise 0.
       (Presently, the number of dimensions of an array is not enforced,
       so any nonzero value effectively means <quote>it's an array</>.) 
   -->
   如果该字段是数组，那么是维数，否则是 0 。目前，一个数组的维数并未强制，
   因此任何非零值都表示<quote>这是一个数组</>。
      </entry>
     </row>

     <row>
      <entry><structfield>attcacheoff</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Always -1 in storage, but when loaded into a row descriptor
       in memory this might be updated to cache the offset of the attribute
       within the row 
   -->
   在磁盘上的时候总是 -1 ，但是如果加载入内存中的行描述器中，
   它可能会被更新以缓冲在行中字段的偏移量。
      </entry>
     </row>

     <row>
      <entry><structfield>atttypmod</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   <structfield>atttypmod</structfield> records type-specific data
       supplied at table creation time (for example, the maximum
       length of a <type>varchar</type> column).  It is passed to
       type-specific input functions and length coercion functions.
       The value will generally be -1 for types that do not need <structfield>atttypmod</>. 
   -->
   记录创建新表时支持的类型特定的数据(比如一个<type>varchar</type>字段的最大长度)。
   它传递给类型相关的输入函数和长度转换函数当做第三个参数。
   其值对那些不需要<structfield>atttypmod</>的类型通常为 -1 。
      </entry>
     </row>

     <row>
      <entry><structfield>attbyval</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   A copy of <literal>pg_type.typbyval</> of this column's type 
   -->
   这个字段类型的<literal>pg_type.typbyval</>的拷贝。
      </entry>
     </row>

     <row>
      <entry><structfield>attstorage</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Normally a copy of <literal>pg_type.typstorage</> of this
       column's type.  For TOAST-able data types, this can be altered
       after column creation to control storage policy. 
   -->
   这个字段的类型的<literal>pg_type.typstorage</>的拷贝。对于可压缩的数据类型(TOAST)，
   这个字段可以在字段创建之后改变，以便于控制存储策略。
      </entry>
     </row>

     <row>
      <entry><structfield>attalign</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   A copy of <literal>pg_type.typalign</> of this column's type 
   -->
   这个字段类型的<literal>pg_type.typalign</>的拷贝
      </entry>
     </row>

     <row>
      <entry><structfield>attnotnull</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   This represents a not-null constraint.  It is possible to
       change this column to enable or disable the constraint. 
   -->
   这代表一个非空约束。可以改变这个字段以打开或者关闭这个约束。
      </entry>
     </row>

     <row>
      <entry><structfield>atthasdef</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   This column has a default value, in which case there will be a
       corresponding entry in the <structname>pg_attrdef</structname>
       catalog that actually defines the value. 
   -->
   这个字段有一个缺省值，此时它对应<structname>pg_attrdef</structname>
   表里实际定义此值的记录。
      </entry>
     </row>

     <row>
      <entry><structfield>attisdropped</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   This column has been dropped and is no longer valid.  A dropped
       column is still physically present in the table, but is
       ignored by the parser and so cannot be accessed via SQL. 
   -->
   这个字段已经被删除了，不再有效。一个已经删除的字段物理上仍然存在表中，
   但会被分析器忽略，因此不能再通过 SQL 访问。
      </entry>
     </row>

     <row>
      <entry><structfield>attislocal</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   This column is defined locally in the relation.  Note that a column can
       be locally defined and inherited simultaneously. 
   -->
   这个字段是局部定义在关系中的。请注意一个字段可以同时是局部定义和继承的。
      </entry>
     </row>

     <row>
      <entry><structfield>attinhcount</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   The number of direct ancestors this column has.  A column with a
       nonzero number of ancestors cannot be dropped nor renamed. 
   -->
   这个字段所拥有的直接祖先的个数。如果一个字段的祖先个数非零，
   那么它就不能被删除或重命名。
      </entry>
     </row>

     <row>
      <entry><structfield>attcollation</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-collation"><structname>pg_collation</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   The defined collation of the column, or zero if the column is
       not of a collatable data type. 
   -->
   这个字段定义的排序规则，如果这个字段不是排序规则数据类型则为0。
      </entry>
     </row>

     <row>
      <entry><structfield>attacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Column-level access privileges, if any have been granted specifically
       on this column 
   -->
   如果在这个字段上明确的获得任意，则为字段级访问权限。
      </entry>
     </row>

     <row>
      <entry><structfield>attoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Attribute-level options, as <quote>keyword=value</> strings
   -->
   属性级选项，使用<quote>keyword=value</>格式的字符串
      </entry>
     </row>

     <row>
      <entry><structfield>attfdwoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Attribute-level foreign data wrapper options, as <quote>keyword=value</> strings
-->
属性级外部数据封装器选项，使用<quote>keyword=value</>格式的字符串
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   In a dropped column's <structname>pg_attribute</structname> entry,
   <structfield>atttypid</structfield> is reset to zero, but
   <structfield>attlen</structfield> and the other fields copied from
   <structname>pg_type</> are still valid.  This arrangement is needed
   to cope with the situation where the dropped column's data type was
   later dropped, and so there is no <structname>pg_type</> row anymore.
   <structfield>attlen</structfield> and the other fields can be used
   to interpret the contents of a row of the table.
  </para>
-->
<para>
在一个已被删除字段的<structname>pg_attribute</structname>记录里，
<structfield>atttypid</structfield>将被重置为零，但是<structfield>attlen</structfield>
和其它从<structname>pg_type</>拷贝的仍然有效。
这么安排是为了对付后来被删除的字段的数据类型也被删除的情况，因为这个时候不再有
<structname>pg_type</>行了。<structfield>attlen</structfield>和其它字段可以用于解析表中一行内容。
</para>
 </sect1>


 <sect1 id="catalog-pg-authid">
  <title><structname>pg_authid</structname></title>

  <indexterm zone="catalog-pg-authid">
   <primary>pg_authid</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_authid</structname> contains information about
   database authorization identifiers (roles).  A role subsumes the concepts
   of <quote>users</> and <quote>groups</>.  A user is essentially just a
   role with the <structfield>rolcanlogin</> flag set.  Any role (with or
   without <structfield>rolcanlogin</>) can have other roles as members; see
   <link linkend="catalog-pg-auth-members"><structname>pg_auth_members</structname></link>.
  </para>
-->
<para>
<structname>pg_authid</structname>包含有关数据库认证标识符(角色)的信息。
一个角色体现<quote>用户</>和<quote>组</>的概念。一个用户实际上只是一个设置了
<structfield>rolcanlogin</>标志的角色。任何角色(不管是否设置了<structfield>rolcanlogin</>标志)
都可以有其它角色做为成员；参阅<link linkend="catalog-pg-auth-members"><structname>pg_auth_members</structname></link>。
</para>

  <!--
<para>
   Since this catalog contains passwords, it must not be publicly readable.
   <link linkend="view-pg-roles"><structname>pg_roles</structname></link>
   is a publicly readable view on
   <structname>pg_authid</structname> that blanks out the password field.
  </para>
-->
<para>
因为这个系统表包含口令，所以它不是公共可读的。<link linkend="view-pg-roles"><structname>pg_roles</structname></link>
是一个在<structname>pg_authid</structname>上的可读视图，只是把口令域填成了空白。
</para>

  <!--
<para>
   <xref linkend="user-manag"> contains detailed information about user and
   privilege management.
  </para>
-->
<para>
<xref linkend="user-manag">包含用户和权限管理的详细信息。
</para>

  <!--
<para>
   Because user identities are cluster-wide,
   <structname>pg_authid</structname>
   is shared across all databases of a cluster: there is only one
   copy of <structname>pg_authid</structname> per cluster, not
   one per database.
  </para>
-->
<para>
因为用户标识是集群范围的，<structname>pg_authid</structname>
在一个集群里所有的数据库之间是共享的：每个集群只有一个<structname>pg_authid</structname>
拷贝，而不是每个数据库一个。
</para>

  <table>
   <!-- 
   <title><structname>pg_authid</> Columns</title> 
   -->
   <title><structname>pg_authid</> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <!-- 
  <entry>Row identifier (hidden attribute; must be explicitly selected)</entry> 
  -->
  <entry>行标识符(隐藏属性; 必须明确选择)</entry>
     </row>

     <row>
      <entry><structfield>rolname</structfield></entry>
      <entry><type>name</type></entry>
      <!-- 
  <entry>Role name</entry> 
  -->
  <entry>角色名称</entry>
     </row>

     <row>
      <entry><structfield>rolsuper</structfield></entry>
      <entry><type>bool</type></entry>
      <!-- 
  <entry>Role has superuser privileges</entry> 
  -->
  <entry>角色拥有超级用户权限</entry>
     </row>

     <row>
      <entry><structfield>rolinherit</structfield></entry>
      <entry><type>bool</type></entry>
      <!-- 
  <entry>Role automatically inherits privileges of roles it is a
       member of</entry> 
   -->
   <entry>角色自动继承其所属角色的权限</entry>
     </row>

     <row>
      <entry><structfield>rolcreaterole</structfield></entry>
      <entry><type>bool</type></entry>
      <!-- 
  <entry>Role can create more roles</entry> 
  -->
  <entry>角色可以创建更多角色</entry>
     </row>

     <row>
      <entry><structfield>rolcreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <!-- 
  <entry>Role can create databases</entry> 
  -->
  <entry>角色可以创建数据库</entry>
     </row>

     <row>
      <entry><structfield>rolcatupdate</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>
       <!-- 
   Role can update system catalogs directly.  (Even a superuser cannot do
       this unless this column is true) 
   -->
   角色可以直接更新系统表。如果没有设置这个字段为真，即使超级用户也不能这么做。
      </entry>
     </row>

     <row>
      <entry><structfield>rolcanlogin</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>
       <!-- 
   Role can log in. That is, this role can be given as the initial
       session authorization identifier 
   -->
   角色可以登录，也就是说，这个角色可以给予会话认证标识符。
      </entry>
     </row>

     <row>
      <entry><structfield>rolreplication</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>
       <!-- 
   Role is a replication role. That is, this role can initiate streaming
       replication (see <xref linkend="streaming-replication">) and set/unset
       the system backup mode using <function>pg_start_backup</> and
       <function>pg_stop_backup</> 
   -->
   角色是一个复制的角色。也就是说，这个角色可以发起流复制
   （参阅<xref linkend="streaming-replication">）和使用
   <function>pg_start_backup</>和<function>pg_stop_backup</>
   设置/取消设置系统备份模式。
      </entry>
     </row>

     <row>
      <entry><structfield>rolconnlimit</structfield></entry>
      <entry><type>int4</type></entry>
      <entry>
       <!-- 
   For roles that can log in, this sets maximum number of concurrent
       connections this role can make.  -1 means no limit. 
   -->
   对于可以登录的角色，限制其最大并发连接数量。-1 表示没有限制。
      </entry>
     </row>

     <row>
      <entry><structfield>rolpassword</structfield></entry>
      <entry><type>text</type></entry>
      <entry>
       <!-- 
   Password (possibly encrypted); null if none.  If the password
       is encrypted, this column will begin with the string <literal>md5</>
       followed by a 32-character hexadecimal MD5 hash.  The MD5 hash
       will be of the user's password concatenated to their user name.
       For example, if user <literal>joe</> has password <literal>xyzzy</>,
       <productname>PostgreSQL</> will store the md5 hash of
       <literal>xyzzyjoe</>.  A password that does not follow that
       format is assumed to be unencrypted. 
   -->
   口令(可能是加密的)；如果没有则为 NULL。如果密码是加密的，该字段将以<literal>md5</>
   字符串开始，后面跟着一个32字符的十六进制MD5哈希值。该MD5哈希将是用户的口令加上用户名。
   例如，如果用户<literal>joe</>的口令为<literal>xyzzy</>，<productname>PostgreSQL</>
   将存储MD5哈希为<literal>xyzzyjoe</>。不遵从这个格式的密码被假设为未加密的。
      </entry>
     </row>

     <row>
      <entry><structfield>rolvaliduntil</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <!-- 
  <entry>Password expiry time (only used for password authentication);
       null if no expiration</entry> 
   -->
   <entry>口令失效时间(只用于口令认证)；如果没有失效期，则为 null</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-auth-members">
  <title><structname>pg_auth_members</structname></title>

  <indexterm zone="catalog-pg-auth-members">
   <primary>pg_auth_members</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_auth_members</structname> shows the membership
   relations between roles.  Any non-circular set of relationships is allowed.
  </para>
-->
<para>
<structname>pg_auth_members</structname>显示角色之间的成员关系。任何非闭环的关系集合都是允许的。
</para>

  <!--
<para>
   Because user identities are cluster-wide,
   <structname>pg_auth_members</structname>
   is shared across all databases of a cluster: there is only one
   copy of <structname>pg_auth_members</structname> per cluster, not
   one per database.
  </para>
-->
<para>
因为用户标识是集群范围的，<structname>pg_auth_members</structname>
是在一个集群里的所有数据库之间共享的：每个集群里只有一个<structname>pg_auth_members</structname>
拷贝，而不是每个数据库一个。
</para>

  <table>
   <!-- 
   <title><structname>pg_auth_members</> Columns</title> 
   -->
   <title><structname>pg_auth_members</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>roleid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <!-- 
  <entry>ID of a role that has a member</entry> 
  -->
  <entry>拥有有成员的角色的 ID</entry>
     </row>

     <row>
      <entry><structfield>member</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <!-- 
  <entry>ID of a role that is a member of <structfield>roleid</></entry>
  -->
  <entry>属于<structfield>roleid</>角色的一个成员的角色的 ID</entry>
     </row>

     <row>
      <entry><structfield>grantor</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <!-- 
  <entry>ID of the role that granted this membership</entry> 
  -->
  <entry>赋予此成员关系的角色的 ID</entry>
     </row>

     <row>
      <entry><structfield>admin_option</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>True if <structfield>member</> can grant membership in
       <structfield>roleid</> to others</entry> 
   -->
   <entry>如果<structfield>member</>可以把<structfield>roleid</>
   角色的成员关系赋予其它角色，则为真。</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-cast">
  <title><structname>pg_cast</structname></title>

  <indexterm zone="catalog-pg-cast">
   <primary>pg_cast</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_cast</structname> stores data type conversion
   paths, both built-in and user-defined.
  </para>
-->
<para>
<structname>pg_cast</structname>表存储数据类型转换路径，包括内置路径和用户定义的路径。
</para>

  <!--
<para>
   It should be noted that <structname>pg_cast</structname> does not represent
   every type conversion that the system knows how to perform; only those that
   cannot be deduced from some generic rule.  For example, casting between a
   domain and its base type is not explicitly represented in
   <structname>pg_cast</structname>.  Another important exception is that
   <quote>automatic I/O conversion casts</>, those performed using a data
   type's own I/O functions to convert to or from <type>text</> or other
   string types, are not explicitly represented in
   <structname>pg_cast</structname>.
  </para>
-->
<para>
应该注意，<structname>pg_cast</structname>并不表示系统知道如何执行的每种类型转换；
只表示那些不能从某些通用法则中推导出的。例如，在一个域类型和它的基本类型之间的转换，
不是明确的由<structname>pg_cast</structname>表示的。另外一个重要的例外是
<quote>automatic I/O conversion casts</>，这些使用数据类型自己的I/O函数转换为或从
<type>text</>或其他字符串类型转换的执行，不是由<structname>pg_cast</structname>明确表示的。

</para>

  <table>
   <!-- 
   <title><structname>pg_cast</> Columns</title> 
   -->
   <title><structname>pg_cast</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <!-- 
  <entry>Row identifier (hidden attribute; must be explicitly selected)</entry> 
  -->
  <entry>行标识符(隐藏属性; 必须明确选择)</entry>
     </row>

     <row>
      <entry><structfield>castsource</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <!-- 
  <entry>OID of the source data type</entry> 
  -->
  <entry>源数据类型的 OID</entry>
     </row>

     <row>
      <entry><structfield>casttarget</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <!-- 
  <entry>OID of the target data type</entry>
  -->
  <entry>目标数据类型的 OID</entry>
     </row>

     <row>
      <entry><structfield>castfunc</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
<!-- 
       The OID of the function to use to perform this cast.  Zero is
       stored if the cast method doesn't require a function.
 -->
 用于执行这个转换的函数的 OID 。如果转换方式不需要一个函数，那么为零。
      </entry>
     </row>

     <row>
      <entry><structfield>castcontext</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Indicates what contexts the cast can be invoked in.
       <literal>e</> means only as an explicit cast (using
       <literal>CAST</> or <literal>::</> syntax).
       <literal>a</> means implicitly in assignment
       to a target column, as well as explicitly.
       <literal>i</> means implicitly in expressions, as well as the
       other cases. 
   -->
   标识这个转换可以在什么环境里调用。<literal>e</>表示只能进行明确的转换
   (使用<literal>CAST</>或<literal>::</>语法)。<literal>a</>
   表示在赋值给目标字段的时候隐含调用，也可以明确调用。<literal>i</>
   表示在表达式中隐含，当然也包括其它情况。
      </entry>
     </row>
     <row>
      <entry><structfield>castmethod</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Indicates how the cast is performed.
       <literal>f</> means that the function specified in the <structfield>castfunc</> field is used.
       <literal>i</> means that the input/output functions are used.
       <literal>b</> means that the types are binary-coercible, thus no conversion is required. 
   -->
   标识转换是怎么执行的。<literal>f</>表示使用了在<structfield>castfunc</>字段里指定的函数。
   <literal>i</>表示使用了输入/输出函数。<literal>b</>表示该类型是二进制兼容的，
   因此不需要什么转换。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   The cast functions listed in <structname>pg_cast</structname> must
   always take the cast source type as their first argument type, and
   return the cast destination type as their result type.  A cast
   function can have up to three arguments.  The second argument,
   if present, must be type <type>integer</>; it receives the type
   modifier associated with the destination type, or -1
   if there is none.  The third argument,
   if present, must be type <type>boolean</>; it receives <literal>true</>
   if the cast is an explicit cast, <literal>false</> otherwise.
  </para>
-->
<para>
在<structname>pg_cast</structname>里列出的类型转换函数必须总是以类型转换的源类型作为它的第一个参数类型，
并且返回类型转换的目的类型作为它的结果类型。一个类型转换函数最多有三个参数。如果出现了第二个参数，
必须是<type>integer</>类型；它接受与目标类型关联的修饰词，如果没有，就是 -1 。如果出现了第三个参数，
那么必须是<type>boolean</>类型；如果该类型转换是一种明确的转换，那么它接受<literal>true</>，否则接受<literal>false</>。
</para>

  <!--
<para>
   It is legitimate to create a <structname>pg_cast</structname> entry
   in which the source and target types are the same, if the associated
   function takes more than one argument.  Such entries represent
   <quote>length coercion functions</> that coerce values of the type
   to be legal for a particular type modifier value.
  </para>
-->
<para>
在<structname>pg_cast</structname>里创建一条源类型和目标类型相同的记录是合理的，
只要相关联的函数接受多过一个参数。这样的记录代表<quote>长度转换函数</>，
他们把该类型的数值转换为对特定的类型修饰词数值合法的值。
</para>

  <!--
<para>
   When a <structname>pg_cast</structname> entry has different source and
   target types and a function that takes more than one argument, it
   represents converting from one type to another and applying a length
   coercion in a single step.  When no such entry is available, coercion
   to a type that uses a type modifier involves two steps, one to
   convert between data types and a second to apply the modifier.
  </para>
-->
<para>
如果一条<structname>pg_cast</structname>记录有着不同的原类型和目标类型，
并且有一个接收多于一个参数的函数，那么它就意味着用一个步骤从一种类型转换到另外一种类型，
同时还附加一个长度转换。如果没有这样的记录，那么转换成一个使用了类型修饰词的类型涉及两个步骤，
一个是在数据类型之间转换，另外一个是附加修饰词。
</para>
 </sect1>

 <sect1 id="catalog-pg-class">
  <title><structname>pg_class</structname></title>

  <indexterm zone="catalog-pg-class">
   <primary>pg_class</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_class</structname> catalogs tables and most
   everything else that has columns or is otherwise similar to a
   table.  This includes indexes (but see also
   <structname>pg_index</structname>), sequences, views, materialized
   views, composite types, and TOAST tables; see <structfield>relkind</>.
   Below, when we mean all of these
   kinds of objects we speak of <quote>relations</quote>.  Not all
   columns are meaningful for all relation types.
  </para>
-->
<para>
<structname>pg_class</structname>表记载表和几乎所有有字段或者是那些类似表的东西。
包括索引(不过还要参阅<structname>pg_index</structname>)、序列、视图、物化视图、
复合类型和一些特殊关系类型；参阅<structfield>relkind</>。在下面，
当指所有这些对象的时候说<quote>关系</quote>(relations)。不是所有字段对所有关系类型都有意义。
</para>

  <table>
   <!-- 
   <title><structname>pg_class</> Columns</title> 
   -->
   <title><structname>pg_class</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <!-- 
  <entry>Row identifier (hidden attribute; must be explicitly selected)</entry> 
  -->
  <entry>行标识符(隐藏属性; 必须明确选择)</entry>
     </row>

     <row>
      <entry><structfield>relname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <!-- 
  <entry>Name of the table, index, view, etc.</entry> 
  -->
  <entry>表、索引、视图等的名字。</entry>
     </row>

     <row>
      <entry><structfield>relnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   The OID of the namespace that contains this relation 
   -->
   包含这个关系的名字空间(模式)的 OID
      </entry>
     </row>

     <row>
      <entry><structfield>reltype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   The OID of the data type that corresponds to this table's row type,
       if any (zero for indexes, which have no <structname>pg_type</> entry) 
   -->
   如果有，则为对应这个表的行类型的数据类型的OID(索引为零，它们没有<structname>pg_type</>记录)。
      </entry>
     </row>

     <row>
      <entry><structfield>reloftype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   For typed tables, the OID of the underlying composite type,
       zero for all other relations
   -->
   对于类型表，为底层复合类型的OID，对于所有其他关系为0
      </entry>
     </row>

     <row>
      <entry><structfield>relowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Owner of the relation</entry> 
  -->
  <entry>关系所有者</entry>
     </row>

     <row>
      <entry><structfield>relam</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-am"><structname>pg_am</structname></link>.oid</literal></entry>
      <!-- 
  <entry>If this is an index, the access method used (B-tree, hash, etc.)</entry> 
  -->
  <entry>如果行是索引，那么就是所用的访问模式(B-tree, hash 等等)</entry>
     </row>

     <row>
      <entry><structfield>relfilenode</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <!-- 
  <entry>Name of the on-disk file of this relation; zero means this
       is a <quote>mapped</> relation whose disk file name is determined
       by low-level state</entry> 
   -->
   <entry>这个关系在磁盘上的文件的名字，0表示这是一个<quote>映射的</>关系，
   它的文件名取决于行级别的状态</entry>
     </row>

     <row>
      <entry><structfield>reltablespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   The tablespace in which this relation is stored.  If zero,
       the database's default tablespace is implied.  (Not meaningful
       if the relation has no on-disk file.) 
   -->
   这个关系存储所在的表空间。如果为零，则意味着使用该数据库的缺省表空间。
   如果关系在磁盘上没有文件，则这个字段没有什么意义。
      </entry>
     </row>

     <row>
      <entry><structfield>relpages</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Size of the on-disk representation of this table in pages (of size
       <symbol>BLCKSZ</symbol>).  This is only an estimate used by the
       planner.  It is updated by <command>VACUUM</command>,
       <command>ANALYZE</command>, and a few DDL commands such as
       <command>CREATE INDEX</command>. 
   -->
   以页(大小为<symbol>BLCKSZ</symbol>)的此表在磁盘上的形式的大小。
   它只是规划器用的一个近似值，是由<command>VACUUM</command>,<command>ANALYZE</command>
   和几个 DDL 命令，比如<command>CREATE INDEX</command>更新。
      </entry>
     </row>

     <row>
      <entry><structfield>reltuples</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Number of rows in the table.  This is only an estimate used by the
       planner.  It is updated by <command>VACUUM</command>,
       <command>ANALYZE</command>, and a few DDL commands such as
       <command>CREATE INDEX</command>. 
   -->
   表中行的数目。只是规划器使用的一个估计值，由<command>VACUUM</command>,<command>ANALYZE</command>
   和几个 DDL 命令，比如<command>CREATE INDEX</command>更新。
      </entry>
     </row>

     <row>
      <entry><structfield>relallvisible</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Number of pages that are marked all-visible in the table's
       visibility map.  This is only an estimate used by the
       planner.  It is updated by <command>VACUUM</command>,
       <command>ANALYZE</command>, and a few DDL commands such as
       <command>CREATE INDEX</command>. 
   -->
   在表的可见映射中标记所有可见的页的数目。只是规划器使用的一个估计值，
   由<command>VACUUM</command>,<command>ANALYZE</command>
   和几个 DDL 命令，比如<command>CREATE INDEX</command>更新。
      </entry>
     </row>

     <row>
      <entry><structfield>reltoastrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   OID of the TOAST table associated with this table, 0 if none.  The
       TOAST table stores large attributes <quote>out of line</quote> in a
       secondary table. 
   -->
   与此表关联的 TOAST 表的 OID ，如果没有为 0 。TOAST 表在一个从属表里<quote>离线</quote>存储大字段。
      </entry>
     </row>

     <row>
      <entry><structfield>reltoastidxid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   For a TOAST table, the OID of its index.  0 if not a TOAST table. 
   -->
   对于 TOAST 表是它的索引的 OID ，如果不是 TOAST 表则为 0
      </entry>
     </row>

     <row>
      <entry><structfield>relhasindex</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
      <!-- 
  True if this is a table and it has (or recently had) any indexes
  -->
  如果它是一个表而且至少有(或者最近有过)一个索引，则为真。
      </entry>
     </row>

     <row>
      <entry><structfield>relisshared</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   True if this table is shared across all databases in the cluster.  Only
       certain system catalogs (such as <structname>pg_database</structname>)
       are shared.
   -->
   如果该表在整个集群中由所有数据库共享则为真。只有某些系统表
   (比如<structname>pg_database</structname>)是共享的。
      </entry>
     </row>

     <row>
      <entry><structfield>relpersistence</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   <literal>p</> = permanent table, <literal>u</> = unlogged table,
       <literal>t</> = temporary table 
   -->
   <literal>p</> = permanent table（永久表）, <literal>u</> = unlogged table（未加载的表）,
       <literal>t</> = temporary table （临时表）
      </entry>
     </row>

     <row>
      <entry><structfield>relkind</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   <literal>r</> = ordinary table, <literal>i</> = index,
       <literal>S</> = sequence, <literal>v</> = view,
       <literal>m</> = materialized view,
       <literal>c</> = composite type, <literal>t</> = TOAST table,
       <literal>f</> = foreign table
 -->
 <literal>r</> = ordinary table（普通表）, <literal>i</> = index（索引）,
       <literal>S</> = sequence（序列）, <literal>v</> = view（视图）,
       <literal>m</> = materialized view（物化视图）,
       <literal>c</> = composite type（复合类型）, <literal>t</> = TOAST table（TOAST 表）,
       <literal>f</> = foreign table（外部表）

      </entry>
     </row>

     <row>
      <entry><structfield>relnatts</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Number of user columns in the relation (system columns not
       counted).  There must be this many corresponding entries in
       <structname>pg_attribute</structname>.  See also
       <literal>pg_attribute.attnum</literal>. 
   -->
   关系中用户字段数目(除了系统字段以外)。在<structname>pg_attribute</structname>
   里肯定有相同数目对应行。又见<literal>pg_attribute.attnum</literal>。
      </entry>
     </row>

     <row>
      <entry><structfield>relchecks</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Number of <literal>CHECK</> constraints on the table; see
       <link linkend="catalog-pg-constraint"><structname>pg_constraint</structname></link> catalog 
   -->
   表里的<literal>CHECK</>约束的数目；参阅<link linkend="catalog-pg-constraint"><structname>pg_constraint</structname></link>表
      </entry>
     </row>

     <row>
      <entry><structfield>relhasoids</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   True if we generate an OID for each row of the relation
   -->
   如果为关系中每行都生成一个 OID 则为真
      </entry>
     </row>

     <row>
      <entry><structfield>relhaspkey</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   True if the table has (or once had) a primary key 
   -->
   如果这个表有一个(或者曾经有一个)主键，则为真。
      </entry>
     </row>

     <row>
      <entry><structfield>relhasrules</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   True if table has (or once had) rules; see
       <link linkend="catalog-pg-rewrite"><structname>pg_rewrite</structname></link> catalog 
   -->
   如表有（或曾经有）规则就为真；参阅<link linkend="catalog-pg-rewrite"><structname>pg_rewrite</structname></link>表
      </entry>
     </row>

     <row>
      <entry><structfield>relhastriggers</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   True if table has (or once had) triggers; see
       <link linkend="catalog-pg-trigger"><structname>pg_trigger</structname></link> catalog 
   -->
   如果表有(或者曾经有)触发器，则为真；参阅<link linkend="catalog-pg-trigger"><structname>pg_trigger</structname></link>表
      </entry>
     </row>

     <row>
      <entry><structfield>relhassubclass</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>True if table has (or once had) any inheritance children</entry> 
  -->
  <entry>如果有(或者曾经有)任何继承的子表，为真。</entry>
     </row>

     <row>
      <entry><structfield>relispopulated</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>True if relation is populated (this is true for all
       relations other than some materialized views)</entry> 
   -->
   <entry>如果关系是填充的则为真（对所有关系为真，除了一些物化视图）</entry>
     </row>

     <row>
      <entry><structfield>relfrozenxid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   All transaction IDs before this one have been replaced with a permanent
       (<quote>frozen</>) transaction ID in this table.  This is used to track
       whether the table needs to be vacuumed in order to prevent transaction
       ID wraparound or to allow <literal>pg_clog</> to be shrunk.  Zero
       (<symbol>InvalidTransactionId</symbol>) if the relation is not a table. 
   -->
   该表中所有在这个之前的事务 ID 已经被一个固定的(<quote>frozen</>)事务 ID 替换。
   这用于跟踪该表是否需要为了防止事务 ID 重叠或者允许收缩<literal>pg_clog</>
   而进行清理。如果该关系不是表则为零(<symbol>InvalidTransactionId</symbol>)。
      </entry>
     </row>

     <row>
      <entry><structfield>relminmxid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   All multitransaction IDs before this one have been replaced by a
       transaction ID in this table.  This is used to track
       whether the table needs to be vacuumed in order to prevent multitransaction ID
       ID wraparound or to allow <literal>pg_clog</> to be shrunk.  Zero
       (<symbol>InvalidTransactionId</symbol>) if the relation is not a table. 
   -->
   该表中所有在这个之前的多事务 ID 已经被一个事务 ID 替换。
   这用于跟踪该表是否需要为了防止多事务 ID 重叠或者允许收缩<literal>pg_clog</>
   而进行清理。如果该关系不是表则为零(<symbol>InvalidTransactionId</symbol>)。
      </entry>
     </row>

     <row>
      <entry><structfield>relacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Access privileges; see
       <xref linkend="sql-grant"> and
       <xref linkend="sql-revoke">
       for details 
   -->
   访问权限。参阅<xref linkend="sql-grant">和<xref linkend="sql-revoke">获取详细信息。
      </entry>
     </row>

     <row>
      <entry><structfield>reloptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Access-method-specific options, as <quote>keyword=value</> strings 
   -->
   访问方法特定的选项，使用<quote>keyword=value</>格式的字符串
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   Several of the Boolean flags in <structname>pg_class</> are maintained
   lazily: they are guaranteed to be true if that's the correct state, but
   may not be reset to false immediately when the condition is no longer
   true.  For example, <structfield>relhasindex</> is set by
   <command>CREATE INDEX</command>, but it is never cleared by
   <command>DROP INDEX</command>.  Instead, <command>VACUUM</command> clears
   <structfield>relhasindex</> if it finds the table has no indexes.  This
   arrangement avoids race conditions and improves concurrency.
  </para>
-->
<para>
<structname>pg_class</>中的几个布尔标识是懒于维护的：如果这是正确的状态则他们被保证为真，
但是当状态不再是真时不会被立马重新设置为假。例如，<structfield>relhasindex</>
是由<command>CREATE INDEX</command>设置的，但是从不用<command>DROP INDEX</command>删除。
相反，如果发现表没有索引了，由<command>VACUUM</command>清除<structfield>relhasindex</>。
这个安排避免了竞态条件，提高了并发性。
</para>
 </sect1>

 <sect1 id="catalog-pg-event-trigger">
  <title><structname>pg_event_trigger</structname></title>

  <indexterm zone="catalog-pg-event-trigger">
   <primary>pg_event_trigger</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_event_trigger</structname> stores event triggers.
   See <xref linkend="event-triggers"> for more information.
  </para>
-->
<para>
<structname>pg_event_trigger</structname>表存储时间触发器。参阅<xref linkend="event-triggers">
获取详细信息。
</para>

  <table>
   <!-- 
   <title><structname>pg_event_trigger</> Columns</title> 
   -->
   <title><structname>pg_event_trigger</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>evtname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <!-- 
  <entry>Trigger name (must be unique)</entry>
  -->
  <entry>触发器名字(必须是唯一的)</entry>
     </row>

     <row>
      <entry><structfield>evtevent</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <!-- 
  <entry>Identifies the event for which this trigger fires</entry> 
  -->
  <entry>标识触发器触发的事件</entry>
     </row>

     <row>
      <entry><structfield>evtowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Owner of the event trigger</entry> 
  -->
  <entry>事件触发器的所有者</entry>
     </row>

     <row>
      <entry><structfield>evtfoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The function to be called</entry> 
  -->
  <entry>要被调用的函数</entry>
     </row>

     <row>
      <entry><structfield>evtenabled</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Controls in which <xref linkend="guc-session-replication-role"> modes
       the event trigger fires.
       <literal>O</> = trigger fires in <quote>origin</> and <quote>local</> modes,
       <literal>D</> = trigger is disabled,
       <literal>R</> = trigger fires in <quote>replica</> mode,
       <literal>A</> = trigger fires always. 
   -->
   控制在哪个<xref linkend="guc-session-replication-role">模块中触发事件触发器。
   <literal>O</> = 触发器在<quote>origin</> 和 <quote>local</>模块里面触发，
   <literal>D</> = 禁用触发器，<literal>R</> = 触发器在<quote>replica</>模块里面触发，
   <literal>A</> = 触发器总是触发。
      </entry>
     </row>

     <row>
      <entry><structfield>evttags</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
        <!-- 
Command tags for which this trigger will fire.  If NULL, the firing
        of this trigger is not restricted on the basis of the command tag. 
-->
这个触发器将要触发的命令标签。如果为NULL，这个触发器的触发不受命令标签的基础限制。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-constraint">
  <title><structname>pg_constraint</structname></title>

  <indexterm zone="catalog-pg-constraint">
   <primary>pg_constraint</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_constraint</structname> stores check, primary
   key, unique, foreign key, and exclusion constraints on tables.
   (Column constraints are not treated specially.  Every column constraint is
   equivalent to some table constraint.)
   Not-null constraints are represented in the <structname>pg_attribute</>
   catalog, not here.
  </para>
-->
<para>
<structname>pg_constraint</structname>存储表上的检查约束、主键、唯一约束、外键约束和排除约束。
字段约束不会得到特殊对待。每个字段约束都等效于某些表约束。非空约束记录在
<structname>pg_attribute</>表中。
</para>

  <!--
<para>
   User-defined constraint triggers (created with <command>CREATE CONSTRAINT
   TRIGGER</>) also give rise to an entry in this table.
  </para>
-->
<para>
未定义的约束触发器（用<command>CREATE CONSTRAINT TRIGGER</>创建）也在此表中产生一个条目。
</para>

  <!--
<para>
   Check constraints on domains are stored here, too.
  </para>
-->
<para>
在域上面的检查约束也存储在这里。
</para>

  <table>
   <!-- 
   <title><structname>pg_constraint</> Columns</title> 
   -->
   <title><structname>pg_constraint</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <!-- 
  <entry>Row identifier (hidden attribute; must be explicitly selected)</entry> 
  -->
  <entry>行标识符(隐藏属性; 必须明确选择)</entry>
     </row>

     <row>
      <entry><structfield>conname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <!-- 
  <entry>Constraint name (not necessarily unique!)</entry> 
  -->
  <entry>约束名(不一定是唯一的!)</entry>
     </row>

     <row>
      <entry><structfield>connamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   The OID of the namespace that contains this constraint
   -->
   包含这个约束的名字空间的 OID
      </entry>
     </row>

     <row>
      <entry><structfield>contype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
        <!-- 
<literal>c</> = check constraint,
        <literal>f</> = foreign key constraint,
        <literal>p</> = primary key constraint,
        <literal>u</> = unique constraint,
        <literal>t</> = constraint trigger,
        <literal>x</> = exclusion constraint 
-->
<literal>c</> = 检查约束,
        <literal>f</> = 外键约束,
        <literal>p</> = 主键约束,
        <literal>u</> = 唯一约束,
        <literal>t</> = 约束触发器,
        <literal>x</> = 排除约束
      </entry>
     </row>

     <row>
      <entry><structfield>condeferrable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>Is the constraint deferrable?</entry> 
  -->
  <entry>这个约束可以推迟吗?</entry>
     </row>

     <row>
      <entry><structfield>condeferred</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>Is the constraint deferred by default?</entry> 
  -->
  <entry>缺省时这个约束是否推迟的?</entry>
     </row>

     <row>
      <entry><structfield>convalidated</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>Has the constraint been validated?
       Currently, can only be false for foreign keys and CHECK constraints</entry> 
   -->
   <entry>这个约束经过验证了吗？目前，外键约束和CHECK约束只能是假</entry>
     </row>

     <row>
      <entry><structfield>conrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The table this constraint is on; 0 if not a table constraint</entry> 
  -->
  <entry>这个约束所在的表；如果不是表约束则为 0</entry>
     </row>

     <row>
      <entry><structfield>contypid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The domain this constraint is on; 0 if not a domain constraint</entry> 
  -->
  <entry>这个约束所在的域；如果不是一个域约束则为 0</entry>
     </row>

     <row>
      <entry><structfield>conindid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The index supporting this constraint, if it's a unique, primary
       key, foreign key, or exclusion constraint; else 0</entry> 
   -->
   <entry>如果是唯一、主键、外键或排除约束，则为支持这个约束的索引；否则为0</entry>
     </row>

     <row>
      <entry><structfield>confrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <!-- 
  <entry>If a foreign key, the referenced table; else 0</entry> 
  -->
  <entry>如果是外键，则为参考的表；否则为 0</entry>
     </row>

     <row>
      <entry><structfield>confupdtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <!-- 
  <entry>Foreign key update action code:
            <literal>a</> = no action,
            <literal>r</> = restrict,
            <literal>c</> = cascade,
            <literal>n</> = set null,
            <literal>d</> = set default
          </entry> 
-->
<entry>外键更新操作代码:
            <literal>a</> = 无动作,
            <literal>r</> = 限制,
            <literal>c</> = 级联,
            <literal>n</> = 设置为空,
            <literal>d</> = 设置为缺省
          </entry>
     </row>

     <row>
      <entry><structfield>confdeltype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <!-- 
  <entry>Foreign key deletion action code:
            <literal>a</> = no action,
            <literal>r</> = restrict,
            <literal>c</> = cascade,
            <literal>n</> = set null,
            <literal>d</> = set default
          </entry> 
-->
<entry>外键删除操作代码:
            <literal>a</> = 无动作,
            <literal>r</> = 限制,
            <literal>c</> = 级联,
            <literal>n</> = 设置为空,
            <literal>d</> = 设置为缺省
          </entry>
     </row>

     <row>
      <entry><structfield>confmatchtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <!-- 
  <entry>Foreign key match type:
            <literal>f</> = full,
            <literal>p</> = partial,
            <literal>s</> = simple
          </entry> 
-->
<entry>外键匹配类型:
            <literal>f</> = 全部,
            <literal>p</> = 部分,
            <literal>s</> = 简单的
          </entry>
     </row>

     <row>
      <entry><structfield>conislocal</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   This constraint is defined locally for the relation.  Note that a
       constraint can be locally defined and inherited simultaneously. 
   -->
   这个约束是为关系本地定义的。请注意，约束可以本地定义和同时继承。
      </entry>
     </row>

     <row>
      <entry><structfield>coninhcount</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   The number of direct inheritance ancestors this constraint has.
       A constraint with
       a nonzero number of ancestors cannot be dropped nor renamed.
   -->
   这个约束直接继承祖先的数量。一个拥有非零祖先的约束不能被删除或重命名。
      </entry>
     </row>

     <row>
      <entry><structfield>connoinherit</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   This constraint is defined locally for the relation.  It is a
       non-inheritable constraint. 
   -->
   这个约束是为关系本地定义的。它是一个非继承的约束。
      </entry>
     </row>

     <row>
      <entry><structfield>conkey</structfield></entry>
      <entry><type>int2[]</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</></entry>
      <!-- 
  <entry>If a table constraint (including foreign keys, but not constraint
       triggers), list of the constrained columns</entry> 
   -->
   <entry>如果是表约束（包含外键，但是不包含约束触发器），则是约束字段的列表</entry>
     </row>

     <row>
      <entry><structfield>confkey</structfield></entry>
      <entry><type>int2[]</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</></entry>
      <!-- 
  <entry>If a foreign key, list of the referenced columns</entry> 
  -->
  <entry>如果是一个外键，是参考的字段的列表</entry>
     </row>

     <row>
      <entry><structfield>conpfeqop</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</></entry>
      <!-- 
  <entry>If a foreign key, list of the equality operators for PK = FK comparisons</entry> 
  -->
  <entry>如果是一个外键，是PK = FK比较的相等操作符的列表</entry>
     </row>

     <row>
      <entry><structfield>conppeqop</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</></entry>
      <!-- 
  <entry>If a foreign key, list of the equality operators for PK = PK comparisons</entry> 
  -->
  <entry>如果是一个外键，是PK = PK比较的相等操作符的列表</entry>
     </row>

     <row>
      <entry><structfield>conffeqop</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</></entry>
      <!-- 
  <entry>If a foreign key, list of the equality operators for FK = FK comparisons</entry> 
  -->
  <entry>如果是一个外键，是FK = FK比较的相等操作符的列表</entry>
     </row>

     <row>
      <entry><structfield>conexclop</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</></entry>
      <!-- 
  <entry>If an exclusion constraint, list of the per-column exclusion operators</entry> 
  -->
  <entry>如果是一个排除约束，是每个字段排除操作符的列表</entry>
     </row>

     <row>
      <entry><structfield>conbin</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <!-- 
  <entry>If a check constraint, an internal representation of the expression</entry> 
  -->
  <entry>如果是一个检查约束，那就是其表达式的内部形式</entry>
     </row>

     <row>
      <entry><structfield>consrc</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <!-- 
  <entry>If a check constraint, a human-readable representation of the expression</entry> 
  -->
  <entry>如果是检查约束，则是表达式的人类可读形式</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   In the case of an exclusion constraint, <structfield>conkey</structfield>
   is only useful for constraint elements that are simple column references.
   For other cases, a zero appears in <structfield>conkey</structfield>
   and the associated index must be consulted to discover the expression
   that is constrained.  (<structfield>conkey</structfield> thus has the
   same contents as <structname>pg_index</>.<structfield>indkey</> for the
   index.)
  </para>
-->
<para>
在排除约束的情况下，<structfield>conkey</structfield>是简单列引用的唯一有用约束元素。
对于其他情况下，<structfield>conkey</structfield>出现零和必须查阅相关索引以发现受约束的表达式。
（<structfield>conkey</structfield>因此有和索引的<structname>pg_index</>.<structfield>indkey</>相同的内容）。
</para>

  <note>
   <!--
<para>
    <structfield>consrc</structfield> is not updated when referenced objects
    change; for example, it won't track renaming of columns.  Rather than
    relying on this field, it's best to use <function>pg_get_constraintdef()</>
    to extract the definition of a check constraint.
   </para>
-->
<para>
<structfield>consrc</structfield>在被引用的对象改变之后不会被更新，它不会跟踪字段的名字修改。
与其依赖这个字段，最好还是使用<function>pg_get_constraintdef()</>来抽取一个检查约束的定义。
</para>
  </note>

  <note>
   <!--
<para>
    <literal>pg_class.relchecks</literal> needs to agree with the
    number of check-constraint entries found in this table for each
    relation.
   </para>
-->
<para>
<literal>pg_class.relchecks</literal>需要和在此表上为每个关系找到的检查约束的数目一致。
</para>
  </note>

 </sect1>

 <sect1 id="catalog-pg-collation">
  <title><structname>pg_collation</structname></title>

  <indexterm zone="catalog-pg-collation">
   <primary>pg_collation</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_collation</structname> describes the
   available collations, which are essentially mappings from an SQL
   name to operating system locale categories.
   See <xref linkend="collation"> for more information.
  </para>
-->
<para>
<structname>pg_collation</structname>表描述可用的排序规则，本质上从一个SQL名字映射到操作系统本地类别。
参阅<xref linkend="collation">获取详细信息。
</para>

  <table>
   <!-- 
   <title><structname>pg_collation</> Columns</title> 
   -->
   <title><structname>pg_collation</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <!-- 
  <entry>Row identifier (hidden attribute; must be explicitly selected)</entry> 
  -->
  <entry>行标识符(隐藏属性; 必须明确选择)</entry>
     </row>

     <row>
      <entry><structfield>collname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <!-- 
  <entry>Collation name (unique per namespace and encoding)</entry> 
  -->
  <entry>排序规则名 (每个名字空间和编码唯一)</entry>
     </row>

     <row>
      <entry><structfield>collnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   The OID of the namespace that contains this collation 
   -->
   包含这个排序规则的名字空间的OID
      </entry>
     </row>

     <row>
      <entry><structfield>collowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Owner of the collation</entry> 
  -->
  <entry>排序规则的所有者</entry>
     </row>

     <row>
      <entry><structfield>collencoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <!-- 
  <entry>Encoding in which the collation is applicable, or -1 if it
       works for any encoding</entry> 
   -->
   <entry>排序规则可用的编码，如果适用于任意编码为-1</entry>
     </row>

     <row>
      <entry><structfield>collcollate</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <!-- 
  <entry><symbol>LC_COLLATE</> for this collation object</entry> 
  -->
  <entry>这个排序规则对象的<symbol>LC_COLLATE</></entry>
     </row>

     <row>
      <entry><structfield>collctype</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <!-- 
  <entry><symbol>LC_CTYPE</> for this collation object</entry> 
  -->
  <entry>这个排序规则对象的<symbol>LC_CTYPE</></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   Note that the unique key on this catalog is (<structfield>collname</>,
   <structfield>collencoding</>, <structfield>collnamespace</>) not just
   (<structfield>collname</>, <structfield>collnamespace</>).
   <productname>PostgreSQL</productname> generally ignores all
   collations that do not have <structfield>collencoding</> equal to
   either the current database's encoding or -1, and creation of new entries
   with the same name as an entry with <structfield>collencoding</> = -1
   is forbidden.  Therefore it is sufficient to use a qualified SQL name
   (<replaceable>schema</>.<replaceable>name</>) to identify a collation,
   even though this is not unique according to the catalog definition.
   The reason for defining the catalog this way is that
   <application>initdb</> fills it in at cluster initialization time with
   entries for all locales available on the system, so it must be able to
   hold entries for all encodings that might ever be used in the cluster.
  </para>
-->
<para>
请注意这个表中的主键是(<structfield>collname</>, <structfield>collencoding</>, 
<structfield>collnamespace</>)不只是(<structfield>collname</>, <structfield>collnamespace</>)。
<productname>PostgreSQL</productname>通常忽略所有的<structfield>collencoding</>
不等于当前数据库编码或-1的排序规则，并且和<structfield>collencoding</> = -1
里的条目有相同名字的新条目的创建是被禁止的。因此，使用一个受限制的SQL名字
(<replaceable>schema</>.<replaceable>name</>)足够去定义一个排序规则，即使根据表的定义这不是唯一的。
这种方式定义表的原因是<application>initdb</>在集群初始化时用所有在系统上可用的区域设置的条目填充了它，
所以必须能够保持所有可能在集群中用的到编码的条目。
</para>

  <!--
<para>
   In the <literal>template0</> database, it could be useful to create
   collations whose encoding does not match the database encoding,
   since they could match the encodings of databases later cloned from
   <literal>template0</>.  This would currently have to be done manually.
  </para>
-->
<para>
在<literal>template0</>数据库中，创建编码不匹配数据库编码的排序规则可能是有用的，
因为他们可以匹配稍后从<literal>template0</>复制来的数据库编码。目前这些必须手动完成。
</para>
 </sect1>

 <sect1 id="catalog-pg-conversion">
  <title><structname>pg_conversion</structname></title>

  <indexterm zone="catalog-pg-conversion">
   <primary>pg_conversion</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_conversion</structname> describes
   encoding conversion procedures.  See <xref linkend="sql-createconversion">
   for more information.
  </para>
-->
<para>
<structname>pg_conversion</structname>描述编码转换信息。参阅
<xref linkend="sql-createconversion">获取更多信息。
</para>

  <table>
   <!-- 
   <title><structname>pg_conversion</> Columns</title> 
   -->
   <title><structname>pg_conversion</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <!-- 
  <entry>Row identifier (hidden attribute; must be explicitly selected)</entry> 
  -->
  <entry>行标识符(隐藏属性; 必须明确选择)</entry>
     </row>

     <row>
      <entry><structfield>conname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <!-- 
  <entry>Conversion name (unique within a namespace)</entry> 
  -->
  <entry>转换名字(在一个名字空间里是唯一的)</entry>
     </row>

     <row>
      <entry><structfield>connamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   The OID of the namespace that contains this conversion 
   -->
   包含这个转换的名字空间的 OID
      </entry>
     </row>

     <row>
      <entry><structfield>conowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Owner of the conversion</entry>
  -->
  <entry>编码转换的属主</entry>
     </row>

     <row>
      <entry><structfield>conforencoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <!-- 
  <entry>Source encoding ID</entry> 
  -->
  <entry>源编码 ID</entry>
     </row>

     <row>
      <entry><structfield>contoencoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <!-- 
  <entry>Destination encoding ID</entry>
  -->
  <entry>目的编码 ID</entry>
     </row>

     <row>
      <entry><structfield>conproc</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Conversion procedure</entry> 
  -->
  <entry>转换过程</entry>
     </row>

     <row>
      <entry><structfield>condefault</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>True if this is the default conversion</entry> 
  -->
  <entry>如果这是缺省转换则为真</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="catalog-pg-database">
  <title><structname>pg_database</structname></title>

  <indexterm zone="catalog-pg-database">
   <primary>pg_database</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_database</structname> stores information about
   the available databases.  Databases are created with the <xref
   linkend="sql-createdatabase"> command.
   Consult <xref linkend="managing-databases"> for details about the meaning
   of some of the parameters.
  </para>
-->
<para>
<structname>pg_database</structname>表存储关于可用数据库的信息。数据库是用
<xref linkend="sql-createdatabase">创建的。参考<xref linkend="managing-databases">
获取一些参数的详细含义。
</para>

  <!--
<para>
   Unlike most system catalogs, <structname>pg_database</structname>
   is shared across all databases of a cluster: there is only one
   copy of <structname>pg_database</structname> per cluster, not
   one per database.
  </para>
-->
<para>
和大多数系统表不同，<structname>pg_database</structname>是在一个集群里的所有数据库共享的：
每个集群只有一份<structname>pg_database</structname>拷贝，而不是每个数据库一份。
</para>

  <table>
   <!-- 
   <title><structname>pg_database</> Columns</title> 
   -->
   <title><structname>pg_database</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <!-- 
  <entry>Row identifier (hidden attribute; must be explicitly selected)</entry> 
  -->
  <entry>行标识符(隐藏属性; 必须明确选择)</entry>
     </row>

     <row>
      <entry><structfield>datname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <!-- 
  <entry>Database name</entry> 
  -->
  <entry>数据库名字</entry>
     </row>

     <row>
      <entry><structfield>datdba</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Owner of the database, usually the user who created it</entry> 
  -->
  <entry>数据库所有人，通常为其创建者</entry>
     </row>

     <row>
      <entry><structfield>encoding</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <!-- 
  <entry>Character encoding for this database
          (<function>pg_encoding_to_char()</function> can translate
           this number to the encoding name)</entry> 
-->
<entry>数据库的字符编码方式(<function>pg_encoding_to_char()</function>
能够将这个数字转换为相应的编码名称)</entry>
     </row>

     <row>
      <entry><structfield>datcollate</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <!-- 
  <entry>LC_COLLATE for this database</entry>
  -->
  <entry>这个数据库的LC_COLLATE</entry>
     </row>

     <row>
      <entry><structfield>datctype</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <!-- 
  <entry>LC_CTYPE for this database</entry> 
  -->
  <entry>这个数据库的LC_CTYPE</entry>
     </row>

     <row>
      <entry><structfield>datistemplate</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   If true then this database can be used in the
       <literal>TEMPLATE</literal> clause of <command>CREATE
       DATABASE</command> to create a new database as a clone of
       this one 
   -->
   如果为真则此数据库可以用于<command>CREATE DATABASE</command>的
   <literal>TEMPLATE</literal>子句，把新数据库创建为此数据库的克隆。
      </entry>
     </row>

     <row>
      <entry><structfield>datallowconn</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   If false then no one can connect to this database.  This is
       used to protect the <literal>template0</> database from being altered. 
   -->
   如果为假则没有人可以连接到这个数据库。这个字段用于保护<literal>template0</>数据库不被更改。
      </entry>
     </row>

     <row>
      <entry><structfield>datconnlimit</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Sets maximum number of concurrent connections that can be made
       to this database.  -1 means no limit. 
   -->
   设置该数据库上允许的最大并发连接数，-1 表示无限制。
      </entry>
     </row>

     <row>
      <entry><structfield>datlastsysoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Last system OID in the database; useful
       particularly to <application>pg_dump</application> 
   -->
   数据库里最后一个系统 OID ；对<application>pg_dump</application>特别有用。
      </entry>
     </row>

     <row>
      <entry><structfield>datfrozenxid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   All transaction IDs before this one have been replaced with a permanent
       (<quote>frozen</>) transaction ID in this database.  This is used to
       track whether the database needs to be vacuumed in order to prevent
       transaction ID wraparound or to allow <literal>pg_clog</> to be shrunk.
       It is the minimum of the per-table
       <structname>pg_class</>.<structfield>relfrozenxid</> values. 
   -->
   该数据库中中所有在这个之前的事务 ID 已经被一个固定的(<quote>frozen</>)
   事务 ID 替换。这用于跟踪该数据库是否需要为了防止事务 ID 重叠或者允许收缩
   <literal>pg_clog</>而进行清理。它是针对每个表的<structname>pg_class</>.<structfield>relfrozenxid</>
   中的最小值。
      </entry>
     </row>

     <row>
      <entry><structfield>datminmxid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   All multitransaction IDs before this one have been replaced with a
       transaction ID in this database.  This is used to
       track whether the database needs to be vacuumed in order to prevent
       transaction ID wraparound or to allow <literal>pg_clog</> to be shrunk.
       It is the minimum of the per-table
       <structname>pg_class</>.<structfield>relminmxid</> values. 
   -->
   该数据库中中所有在这个之前的多事务 ID 已经被一个事务 ID 替换。
   这用于跟踪该数据库是否需要为了防止事务 ID 重叠或者允许收缩
   <literal>pg_clog</>而进行清理。它是针对每个表的<structname>pg_class</>.<structfield>relfrozenxid</>
   中的最小值。
      </entry>
     </row>

     <row>
      <entry><structfield>dattablespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   The default tablespace for the database.
       Within this database, all tables for which
       <structname>pg_class</>.<structfield>reltablespace</> is zero
       will be stored in this tablespace; in particular, all the non-shared
       system catalogs will be there. 
   -->
   该数据库的缺省表空间。在这个数据库里，所有<structname>pg_class</>.<structfield>reltablespace</>
   为零的表都将保存在这个表空间里；特别要指出的是，所有非共享的系统表也都存放在这里。
      </entry>
     </row>

     <row>
      <entry><structfield>datacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Access privileges; see
       <xref linkend="sql-grant"> and
       <xref linkend="sql-revoke">
       for details 
   -->
   访问权限，参阅<xref linkend="sql-grant">和<xref linkend="sql-revoke">获取详细信息。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-db-role-setting">
  <title><structname>pg_db_role_setting</structname></title>

  <indexterm zone="catalog-pg-db-role-setting">
   <primary>pg_db_role_setting</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_db_role_setting</structname> records the default
   values that have been set for run-time configuration variables,
   for each role and database combination.
  </para>
-->
<para>
<structname>pg_db_role_setting</structname>记录已经为运行时配置变量设置的缺省值，
为每个角色和数据库的组合。
</para>

  <!--
<para>
   Unlike most system catalogs, <structname>pg_db_role_setting</structname>
   is shared across all databases of a cluster: there is only one
   copy of <structname>pg_db_role_setting</structname> per cluster, not
   one per database.
  </para>
-->
<para>
不像大多数系统表，<structname>pg_db_role_setting</structname>在一个集群中的所有数据库中共享：
这只是每个集群<structname>pg_db_role_setting</structname>的一个复制，不是每个数据库。
</para>

  <table>
   <!-- 
   <title><structname>pg_db_role_setting</> Columns</title> 
   -->
   <title><structname>pg_db_role_setting</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>setdatabase</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The OID of the database the setting is applicable to, or zero if not database-specific</entry> 
  -->
  <entry>设置适用于的数据库的OID,如果不是特定于数据库的则为0</entry>
     </row>

     <row>
      <entry><structfield>setrole</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The OID of the role the setting is applicable to, or zero if not role-specific</entry>
  -->
  <entry>设置适用于的角色的OID,如果不是特定于角色的则为0</entry>
     </row>

     <row>
      <entry><structfield>setconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <!-- 
  <entry>Defaults for run-time configuration variables</entry> 
  -->
  <entry>默认为运行时配置变量</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-default-acl">
  <title><structname>pg_default_acl</structname></title>

  <indexterm zone="catalog-pg-default-acl">
   <primary>pg_default_acl</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_default_acl</> stores initial
   privileges to be assigned to newly created objects.
  </para>
-->
<para>
<structname>pg_default_acl</>表存储分配给新创建对象的初始化权限。
</para>

  <table>
   <!-- 
   <title><structname>pg_default_acl</> Columns</title> 
   -->
   <title><structname>pg_default_acl</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <!-- 
  <entry>Row identifier (hidden attribute; must be explicitly selected)</entry> 
  -->
  <entry>行标识符(隐藏属性;必须明确选择)</entry>
     </row>

     <row>
      <entry><structfield>defaclrole</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The OID of the role associated with this entry</entry>
  -->
  <entry>与该条目相关的角色的OID</entry>
     </row>

     <row>
      <entry><structfield>defaclnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The OID of the namespace associated with this entry,
       or 0 if none</entry> 
   -->
   <entry>与这个条目相关的名字空间的OID，如果没有则为0</entry>
     </row>

     <row>
      <entry><structfield>defaclobjtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Type of object this entry is for:
       <literal>r</> = relation (table, view),
       <literal>S</> = sequence,
       <literal>f</> = function,
       <literal>T</> = type
   -->
   这个条目的对象的类型：
   <literal>r</> = 关系（表，视图）,
       <literal>S</> = 序列,
       <literal>f</> = 函数,
       <literal>T</> = 类型
      </entry>
     </row>

     <row>
      <entry><structfield>defaclacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Access privileges that this type of object should have on creation 
   -->
   这种类型的对象在创建时应该有的访问权限
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   A <structname>pg_default_acl</> entry shows the initial privileges to
   be assigned to an object belonging to the indicated user.  There are
   currently two types of entry: <quote>global</> entries with
   <structfield>defaclnamespace</> = 0, and <quote>per-schema</> entries
   that reference a particular schema.  If a global entry is present then
   it <emphasis>overrides</> the normal hard-wired default privileges
   for the object type.  A per-schema entry, if present, represents privileges
   to be <emphasis>added to</> the global or hard-wired default privileges.
  </para>
-->
<para>
<structname>pg_default_acl</>条目显示了分配给属于指定用户的对象的初始权限。
当前有两种条目类型：<structfield>defaclnamespace</> = 0的<quote>全局</>条目，
和引用一个特定模式的<quote>每模式</>条目。如果当前是全局条目，
那么它为每个对象类型<emphasis>重写</>正常硬链接的缺省权限。
如果当前是每模式条目，表示权限被<emphasis>添加到</>全局或硬链接的缺省权限。
</para>

  <!--
<para>
   Note that when an ACL entry in another catalog is null, it is taken
   to represent the hard-wired default privileges for its object,
   <emphasis>not</> whatever might be in <structname>pg_default_acl</>
   at the moment.  <structname>pg_default_acl</> is only consulted during
   object creation.
  </para>
-->
<para>
请注意，当一个ACL条目在另一个表中为空时，用来为它的对象表示硬链接的缺省权限，
<emphasis>不是</>此刻可能在<structname>pg_default_acl</>中的东西。
<structname>pg_default_acl</>只在对象创建时访问。
</para>

 </sect1>


 <sect1 id="catalog-pg-depend">
  <title><structname>pg_depend</structname></title>

  <indexterm zone="catalog-pg-depend">
   <primary>pg_depend</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_depend</structname> records the dependency
   relationships between database objects.  This information allows
   <command>DROP</> commands to find which other objects must be dropped
   by <command>DROP CASCADE</> or prevent dropping in the <command>DROP
   RESTRICT</> case.
  </para>
-->
<para>
<structname>pg_depend</structname>表记录数据库对象之间的依赖关系。
这个信息允许<command>DROP</>命令找出哪些其它对象必须由<command>DROP CASCADE</>删除，
或者是在<command>DROP RESTRICT</>的情况下避免删除。
</para>

  <!--
<para>
   See also <link linkend="catalog-pg-shdepend"><structname>pg_shdepend</structname></link>,
   which performs a similar function for dependencies involving objects
   that are shared across a database cluster.
  </para>
-->
<para>
这个表的功能类似<link linkend="catalog-pg-shdepend"><structname>pg_shdepend</structname></link>，
用于记录那些在数据库集群之间共享的对象之间的依赖性关系。
</para>

  <table>
   <!-- 
   <title><structname>pg_depend</> Columns</title> 
   -->
   <title><structname>pg_depend</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>classid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The OID of the system catalog the dependent object is in</entry> 
  -->
  <entry>有倚赖对象所在系统表的 OID</entry>
     </row>

     <row>
      <entry><structfield>objid</structfield></entry>
      <entry><type>oid</type></entry>
      <!-- 
  <entry>any OID column</entry>
      <entry>The OID of the specific dependent object</entry> 
  -->
  <entry>任意 OID 属性</entry>
      <entry>指定的依赖对象的 OID</entry>
     </row>

     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   For a table column, this is the column number (the
       <structfield>objid</> and <structfield>classid</> refer to the
       table itself).  For all other object types, this column is
       zero. 
   -->
   对于表字段，这个是该属性的字段数(<structfield>objid</>和<structfield>classid</>
   引用表本身)。对于所有其它对象类型，目前这个字段是零。
      </entry>
     </row>

     <row>
      <entry><structfield>refclassid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The OID of the system catalog the referenced object is in</entry> 
  -->
  <entry>被引用对象所在的系统表的 OID</entry>
     </row>

     <row>
      <entry><structfield>refobjid</structfield></entry>
      <entry><type>oid</type></entry>
      <!-- 
  <entry>any OID column</entry>
      <entry>The OID of the specific referenced object</entry>
  -->
  <entry>任意 OID 属性</entry>
      <entry>指定的被引用对象的 OID</entry>
     </row>

     <row>
      <entry><structfield>refobjsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   For a table column, this is the column number (the
       <structfield>refobjid</> and <structfield>refclassid</> refer
       to the table itself).  For all other object types, this column
       is zero. 
   -->
   对于表字段，这个是该字段的字段号(<structfield>refobjid</>和<structfield>refclassid</>
   引用表本身)。对于所有其它对象类型，目前这个字段是零。
      </entry>
     </row>

     <row>
      <entry><structfield>deptype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   A code defining the specific semantics of this dependency relationship; see text 
   -->
   一个定义这个依赖关系特定语义的代码。见下文。
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>


<para>
<!-- 
   In all cases, a <structname>pg_depend</structname> entry indicates that the
   referenced object cannot be dropped without also dropping the dependent
   object.  However, there are several subflavors identified by
   <structfield>deptype</>:
  -->
在所有情况下，一个<structname>pg_depend</structname>记录表示被引用的对象不能在有依赖的对象被删除前删除。
不过，这里还有几种由<structfield>deptype</>定义的情况：
  <variablelist>
    <varlistentry>
     <term><symbol>DEPENDENCY_NORMAL</> (<literal>n</>)</term>
     <listitem>
  <!--
  <para>
       A normal relationship between separately-created objects.  The
       dependent object can be dropped without affecting the
       referenced object.  The referenced object can only be dropped
       by specifying <literal>CASCADE</>, in which case the dependent
       object is dropped, too.  Example: a table column has a normal
       dependency on its data type.
      </para>
-->
<para>
独立创建的对象之间的一般关系。有倚赖的对象可以在不影响被引用对象的情况下删除。
被引用对象只有在声明了<literal>CASCADE</>的情况下删除，这时有依赖的对象也被删除。
例子：一个表字段对其数据类型有一般依赖关系。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_AUTO</> (<literal>a</>)</term>
     <listitem>
      <!--
<para>
       The dependent object can be dropped separately from the
       referenced object, and should be automatically dropped
       (regardless of <literal>RESTRICT</> or <literal>CASCADE</>
       mode) if the referenced object is dropped.  Example: a named
       constraint on a table is made autodependent on the table, so
       that it will go away if the table is dropped.
      </para>
-->
<para>
有依赖对象可以和被引用对象分别删除，并且如果删除了被引用对象则应该被自动删除
(不管是<literal>RESTRICT</>或<literal>CASCADE</>模式)。例子：
一个表上面的命名约束是在该表上的自动依赖关系，因此如果删除了表，它也会被删除。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_INTERNAL</> (<literal>i</>)</term>
     <listitem>
      <!--
<para>
       The dependent object was created as part of creation of the
       referenced object, and is really just a part of its internal
       implementation.  A <command>DROP</> of the dependent object
       will be disallowed outright (we'll tell the user to issue a
       <command>DROP</> against the referenced object, instead).  A
       <command>DROP</> of the referenced object will be propagated
       through to drop the dependent object whether
       <command>CASCADE</> is specified or not.  Example: a trigger
       that's created to enforce a foreign-key constraint is made
       internally dependent on the constraint's
       <structname>pg_constraint</> entry.
      </para>
-->
<para>
有依赖的对象是作为被引用对象的一部分创建的，实际上只是它的内部实现的一部分。
<command>DROP</>有依赖对象是不能直接允许的(将告诉用户发出一条删除被引用对象的<command>DROP</>)。
一个对被引用对象的<command>DROP</>将传播到有依赖对象，不管是否声明了<command>CASCADE</>。
例子：一个创建来强制外键约束的触发器在该约束的<structname>pg_constraint</>记录上是标记为内部依赖的。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_EXTENSION</> (<literal>e</>)</term>
     <listitem>
      <!--
<para>
       The dependent object is a member of the <firstterm>extension</> that is
       the referenced object (see
       <link linkend="catalog-pg-extension"><structname>pg_extension</structname></link>).
       The dependent object can be dropped only via
       <command>DROP EXTENSION</> on the referenced object.  Functionally
       this dependency type acts the same as an internal dependency, but
       it's kept separate for clarity and to simplify <application>pg_dump</>.
      </para>
-->
<para>
依赖对象是被依赖对象<firstterm>extension</>的一个成员（参阅
<link linkend="catalog-pg-extension"><structname>pg_extension</structname></link>）。
依赖对象只可以通过在被依赖对象上<command>DROP EXTENSION</>删除。
函数上这个依赖类型和内部依赖一样动作，但是它为了清晰和简化<application>pg_dump</>保持分开。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>DEPENDENCY_PIN</> (<literal>p</>)</term>
     <listitem>
      <!--
<para>
       There is no dependent object; this type of entry is a signal
       that the system itself depends on the referenced object, and so
       that object must never be deleted.  Entries of this type are
       created only by <command>initdb</command>.  The columns for the
       dependent object contain zeroes.
      </para>
-->
<para>
没有有依赖对象；这种类型的记录标志着系统本身依赖于被引用对象，因此这个对象决不能被删除。
这种类型的记录只有在<command>initdb</command>的时候创建。有依赖对象的字段里是零。
</para>
     </listitem>
    </varlistentry>
   </variablelist>

   <!-- 
   Other dependency flavors might be needed in future. 
   -->
   将来可能还会有其它依赖的风格。
  </para>

 </sect1>


 <sect1 id="catalog-pg-description">
  <title><structname>pg_description</structname></title>

  <indexterm zone="catalog-pg-description">
   <primary>pg_description</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_description</> stores optional descriptions
   (comments) for each database object.  Descriptions can be manipulated
   with the <xref linkend="sql-comment"> command and viewed with
   <application>psql</application>'s <literal>\d</literal> commands.
   Descriptions of many built-in system objects are provided in the initial
   contents of <structname>pg_description</structname>.
  </para>
-->
<para>
<structname>pg_description</>表可以给每个数据库对象存储一个可选的描述(注释)。
你可以用<xref linkend="sql-comment">命令操作这些描述，并且可以用<application>psql</application>
的<literal>\d</literal>命令查看。许多内置的系统对象的描述提供了
<structname>pg_description</structname>的初始内容。
</para>

  <!--
<para>
   See also <link linkend="catalog-pg-shdescription"><structname>pg_shdescription</structname></link>,
   which performs a similar function for descriptions involving objects that
   are shared across a database cluster.
  </para>
-->
<para>
<link linkend="catalog-pg-shdescription"><structname>pg_shdescription</structname></link>
提供了类似的功能，它记录了整个集群范围内共享对象的注释。
</para>

  <table>
   <!-- 
   <title><structname>pg_description</> Columns</title> 
   -->
   <title><structname>pg_description</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
       <!-- 
   <entry>any OID column</entry>
       <entry>The OID of the object this description pertains to</entry> 
  -->
  <entry>任意 oid 属性</entry>
  <entry>这条描述所描述的对象的 OID</entry>
     </row>

     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The OID of the system catalog this object appears in</entry> 
  -->
  <entry>这个对象出现的系统表的 OID</entry>
     </row>

     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   For a comment on a table column, this is the column number (the
       <structfield>objoid</> and <structfield>classoid</> refer to
       the table itself).  For all other object types, this column is
       zero.
   -->
   对于一个表字段的注释，它是字段号(<structfield>objoid</>和<structfield>classoid</>
   指向表自身)。对于其它对象类型，它是零。
      </entry>
     </row>

     <row>
      <entry><structfield>description</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <!-- 
  <entry>Arbitrary text that serves as the description of this object</entry> 
  -->
  <entry>作为对该对象的描述的任意文本</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-enum">
  <title><structname>pg_enum</structname></title>

  <indexterm zone="catalog-pg-enum">
   <primary>pg_enum</primary>
  </indexterm>

  <!--
<para>
   The <structname>pg_enum</structname> catalog contains entries
   showing the values and labels for each enum type. The
   internal representation of a given enum value is actually the OID
   of its associated row in <structname>pg_enum</structname>.
  </para>
-->
<para>
<structname>pg_enum</structname>表包含显示每个枚举类型值和标签的记录。
给定枚举类型的内部表示实际上是<structname>pg_enum</structname>里面相关行的OID。
</para>

  <table>
   <!-- 
   <title><structname>pg_enum</> Columns</title> 
   -->
   <title><structname>pg_enum</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <!-- 
  <entry>Row identifier (hidden attribute; must be explicitly selected)</entry> 
  -->
  <entry>行标识符(隐藏属性; 必须明确选择)</entry>
     </row>

     <row>
      <entry><structfield>enumtypid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The OID of the <structname>pg_type</> entry owning this enum value</entry>
  -->
  <entry>拥有这个枚举值的<structname>pg_type</>记录的OID</entry>
     </row>

     <row>
      <entry><structfield>enumsortorder</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <!-- 
  <entry>The sort position of this enum value within its enum type</entry> 
  -->
  <entry>这个枚举值在它的枚举类型中的排序位置</entry>
     </row>

     <row>
      <entry><structfield>enumlabel</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <!-- 
  <entry>The textual label for this enum value</entry>
  -->
  <entry>这个枚举值的文本标签</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   The OIDs for <structname>pg_enum</structname> rows follow a special
   rule: even-numbered OIDs are guaranteed to be ordered in the same way
   as the sort ordering of their enum type.  That is, if two even OIDs
   belong to the same enum type, the smaller OID must have the smaller
   <structfield>enumsortorder</structfield> value.  Odd-numbered OID values
   need bear no relationship to the sort order.  This rule allows the
   enum comparison routines to avoid catalog lookups in many common cases.
   The routines that create and alter enum types attempt to assign even
   OIDs to enum values whenever possible.
  </para>
-->
<para>
<structname>pg_enum</structname>行的OID跟着一个特殊规则：偶数的OID保证用和它们的枚举类型一样的排序顺序排序。
也就是，如果两个偶数OID属于相同的枚举类型，那么较小的OID必须有较小<structfield>enumsortorder</structfield>值。
奇数OID需要毫无关系的排序顺序。这个规则允许枚举比较例程在许多常见情况下避开目录查找。
创建和修改枚举类型的例程只要可能就尝试分配偶数OID给枚举值。
</para>

  <!--
<para>
   When an enum type is created, its members are assigned sort-order
   positions 1..<replaceable>n</>.  But members added later might be given
   negative or fractional values of <structfield>enumsortorder</structfield>.
   The only requirement on these values is that they be correctly
   ordered and unique within each enum type.
  </para>
-->
<para>
当创建了一个枚举类型时，它的成员赋予了排序顺序位置 1..<replaceable>n</>。
但是随后添加的成员可能会分配<structfield>enumsortorder</structfield>的负值或分数值。
对这些值的唯一要求是它们要正确的排序和在每个枚举类型中唯一。
</para>
 </sect1>


 <sect1 id="catalog-pg-extension">
  <title><structname>pg_extension</structname></title>

  <indexterm zone="catalog-pg-extension">
   <primary>pg_extension</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_extension</structname> stores information
   about the installed extensions.  See <xref linkend="extend-extensions">
   for details about extensions.
  </para>
-->
<para>
<structname>pg_extension</structname>表存储了关于已安装的扩展的信息。
参阅<xref linkend="extend-extensions">获取有关扩展的详细信息。
</para>

  <table>
   <!-- 
   <title><structname>pg_extension</> Columns</title> 
   -->
   <title><structname>pg_extension</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <!-- 
  <entry>Row identifier (hidden attribute; must be explicitly selected)</entry> 
  -->
  <entry>行标识符(隐藏属性; 必须明确选择)</entry>
     </row>

     <row>
      <entry><structfield>extname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <!-- 
  <entry>Name of the extension</entry> 
  -->
  <entry>扩展名</entry>
     </row>

     <row>
      <entry><structfield>extowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Owner of the extension</entry> 
  -->
  <entry>扩展的所有者</entry>
     </row>

     <row>
      <entry><structfield>extnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Schema containing the extension's exported objects</entry> 
  -->
  <entry>包含扩展的输出对象的模式</entry>
     </row>

     <row>
      <entry><structfield>extrelocatable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>True if extension can be relocated to another schema</entry> 
  -->
  <entry>如果扩展可以重新加载到另一个模式则为真</entry>
     </row>

     <row>
      <entry><structfield>extversion</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <!-- 
  <entry>Version name for the extension</entry> 
  -->
  <entry>扩展的版本名</entry>
     </row>

     <row>
      <entry><structfield>extconfig</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Array of <type>regclass</> OIDs for the extension's configuration
       table(s), or <literal>NULL</> if none</entry> 
   -->
   <entry>扩展的配置表的<type>regclass</> OID 的数组，如果没有则为<literal>NULL</></entry>
     </row>

     <row>
      <entry><structfield>extcondition</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <!-- 
  <entry>Array of <literal>WHERE</>-clause filter conditions for the
       extension's configuration table(s), or <literal>NULL</> if none</entry> 
   -->
   <entry>扩展的配置表的<literal>WHERE</>子句过滤条件的数组，如果没有则为<literal>NULL</></entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   Note that unlike most catalogs with a <quote>namespace</> column,
   <structfield>extnamespace</structfield> is not meant to imply
   that the extension belongs to that schema.  Extension names are never
   schema-qualified.  Rather, <structfield>extnamespace</structfield>
   indicates the schema that contains most or all of the extension's
   objects.  If <structfield>extrelocatable</structfield> is true, then
   this schema must in fact contain all schema-qualifiable objects
   belonging to the extension.
  </para>
-->
<para>
请注意，不同于大多数有<quote>namespace</>字段的表，<structfield>extnamespace</structfield>
并不意味着扩展属于哪个模式。扩展名从不模式限定。<structfield>extnamespace</structfield>
表明模式包含大多数或所有的扩展的对象。如果<structfield>extrelocatable</structfield>为真，
那么这个模式必须实际上包含所有属于该扩展的模式限定的对象。
</para>
 </sect1>


 <sect1 id="catalog-pg-foreign-data-wrapper">
  <title><structname>pg_foreign_data_wrapper</structname></title>

  <indexterm zone="catalog-pg-foreign-data-wrapper">
   <primary>pg_foreign_data_wrapper</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_foreign_data_wrapper</structname> stores
   foreign-data wrapper definitions.  A foreign-data wrapper is the
   mechanism by which external data, residing on foreign servers, is
   accessed.
  </para>
-->
<para>
<structname>pg_foreign_data_wrapper</structname>表存储外部数据封装器定义。
一个外部数据封装器是在外部服务器上驻留外部数据的机制，是可以访问的。
</para>

  <table>
   <!-- 
   <title><structname>pg_foreign_data_wrapper</> Columns</title> 
   -->
   <title><structname>pg_foreign_data_wrapper</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <!-- 
  <entry>Row identifier (hidden attribute; must be explicitly selected)</entry> 
  -->
  <entry>行标识符(隐藏属性; 必须明确选择)</entry>
     </row>

     <row>
      <entry><structfield>fdwname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <!-- 
  <entry>Name of the foreign-data wrapper</entry> 
  -->
  <entry>外部数据封装器名</entry>
     </row>

     <row>
      <entry><structfield>fdwowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Owner of the foreign-data wrapper</entry> 
  -->
  <entry>外部数据封装器的所有者</entry>
     </row>

     <row>
      <entry><structfield>fdwhandler</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   References a handler function that is responsible for
       supplying execution routines for the foreign-data wrapper.
       Zero if no handler is provided 
   -->
   引用一个负责为外部数据封装器提供扩展例程的处理函数。如果没有提供处理函数则为零
      </entry>
     </row>

     <row>
      <entry><structfield>fdwvalidator</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   References a validator function that is responsible for
       checking the validity of the options given to the
       foreign-data wrapper, as well as options for foreign servers and user
       mappings using the foreign-data wrapper.  Zero if no validator
       is provided 
   -->
   引用一个验证器函数，这个验证器函数负责验证给予外部数据封装器的选项、
   外部服务器选项和使用外部数据封装器的用户映射的有效性。
   如果没有提供验证器函数则为零。
      </entry>
     </row>

     <row>
      <entry><structfield>fdwacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Access privileges; see
       <xref linkend="sql-grant"> and
       <xref linkend="sql-revoke">
       for details 
   -->
   访问权限；参阅<xref linkend="sql-grant">和<xref linkend="sql-revoke">获取详细信息。
      </entry>
     </row>

     <row>
      <entry><structfield>fdwoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Foreign-data wrapper specific options, as <quote>keyword=value</> strings 
   -->
   外部数据封装器指定选项，使用<quote>keyword=value</>格式的字符串
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-foreign-server">
  <title><structname>pg_foreign_server</structname></title>

  <indexterm zone="catalog-pg-foreign-server">
   <primary>pg_foreign_server</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_foreign_server</structname> stores
   foreign server definitions.  A foreign server describes a source
   of external data, such as a remote server.  Foreign
   servers are accessed via foreign-data wrappers.
  </para>
-->
<para>
<structname>pg_foreign_server</structname>表存储外部服务器定义。
一个外部服务器描述了一个外部数据源，例如一个远程服务器。
外部服务器通过外部数据封装器访问。
</para>

  <table>
   <!-- 
   <title><structname>pg_foreign_server</> Columns</title> 
   -->
   <title><structname>pg_foreign_server</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <!-- 
  <entry>Row identifier (hidden attribute; must be explicitly selected)</entry> 
  -->
  <entry>行标识符(隐藏属性; 必须明确选择)</entry>
     </row>

     <row>
      <entry><structfield>srvname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <!-- 
  <entry>Name of the foreign server</entry>
  -->
  <entry>外部服务器名</entry>
     </row>

     <row>
      <entry><structfield>srvowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Owner of the foreign server</entry> 
  -->
  <entry>外部服务器的所有者</entry>
     </row>

     <row>
      <entry><structfield>srvfdw</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-foreign-data-wrapper"><structname>pg_foreign_data_wrapper</structname></link>.oid</literal></entry>
      <!-- 
  <entry>OID of the foreign-data wrapper of this foreign server</entry>
  -->
  <entry>这个外部服务器的外部数据封装器的OID</entry>
     </row>

     <row>
      <entry><structfield>srvtype</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <!-- 
  <entry>Type of the server (optional)</entry> 
  -->
  <entry>服务器的类型（可选）</entry>
     </row>

     <row>
      <entry><structfield>srvversion</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <!-- 
  <entry>Version of the server (optional)</entry> 
  -->
  <entry>服务器的版本（可选）</entry>
     </row>

     <row>
      <entry><structfield>srvacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Access privileges; see
       <xref linkend="sql-grant"> and
       <xref linkend="sql-revoke">
       for details 
   -->
   访问权限；参阅<xref linkend="sql-grant">和<xref linkend="sql-revoke">获取详细信息。
      </entry>
     </row>

     <row>
      <entry><structfield>srvoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Foreign server specific options, as <quote>keyword=value</> strings
   -->
   外部服务器指定选项，使用<quote>keyword=value</>格式的字符串。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-foreign-table">
  <title><structname>pg_foreign_table</structname></title>

  <indexterm zone="catalog-pg-foreign-table">
   <primary>pg_foreign_table</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_foreign_table</structname> contains
   auxiliary information about foreign tables.  A foreign table is
   primarily represented by a <structname>pg_class</structname> entry,
   just like a regular table.  Its <structname>pg_foreign_table</structname>
   entry contains the information that is pertinent only to foreign tables
   and not any other kind of relation.
  </para>
-->
<para>
<structname>pg_foreign_table</structname>表包含关于外表的辅助信息。
一个外表首先通过一个<structname>pg_class</structname>记录表现，就像一个普通表。
它的<structname>pg_foreign_table</structname>记录包含只和外表相关的信息，没有任何其他类型的关系。
</para>

  <table>
   <!-- 
   <title><structname>pg_foreign_table</> Columns</title> 
   -->
   <title><structname>pg_foreign_table</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>ftrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <!-- 
  <entry>OID of the <structname>pg_class</> entry for this foreign table</entry> 
  -->
  <entry>这个外表的<structname>pg_class</>记录的OID</entry>
     </row>

     <row>
      <entry><structfield>ftserver</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-foreign-server"><structname>pg_foreign_server</structname></link>.oid</literal></entry>
      <!-- 
  <entry>OID of the foreign server for this foreign table</entry> 
  -->
  <entry>这个外表的外部服务器的OID</entry>
     </row>

     <row>
      <entry><structfield>ftoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Foreign table options, as <quote>keyword=value</> strings 
   -->
   外表选项，使用<quote>keyword=value</>格式的字符串
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-index">
  <title><structname>pg_index</structname></title>

  <indexterm zone="catalog-pg-index">
   <primary>pg_index</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_index</structname> contains part of the information
   about indexes.  The rest is mostly in
   <structname>pg_class</structname>.
  </para>
-->
<para>
<structname>pg_index</structname>包含关于索引的一部分信息。其它的信息大多数在<structname>pg_class</structname>。
</para>

  <table>
   <!-- 
   <title><structname>pg_index</> Columns</title>
   -->
   <title><structname>pg_index</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>indexrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The OID of the <structname>pg_class</> entry for this index</entry> 
  -->
  <entry>这个索引在<structname>pg_class</>里的记录的 OID</entry>
     </row>

     <row>
      <entry><structfield>indrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The OID of the <structname>pg_class</> entry for the table this index is for</entry> 
  -->
  <entry>使用这个索引的表在<structname>pg_class</>里的记录的 OID</entry>
     </row>

     <row>
      <entry><structfield>indnatts</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <!-- 
  <entry>The number of columns in the index (duplicates
      <literal>pg_class.relnatts</literal>)</entry> 
  -->
  <entry>索引中的字段数目(复制的<literal>pg_class.relnatts</literal>)</entry>
     </row>

     <row>
      <entry><structfield>indisunique</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>If true, this is a unique index</entry> 
  -->
  <entry>如果为真，这是个唯一索引</entry>
     </row>

     <row>
      <entry><structfield>indisprimary</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>If true, this index represents the primary key of the table
      (<structfield>indisunique</> should always be true when this is true)</entry> 
  -->
  <entry>如果为真，该索引代表该表的主键。这个字段为真的时候<structfield>indisunique</>应该总是为真。</entry>
     </row>

     <row>
      <entry><structfield>indisexclusion</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>If true, this index supports an exclusion constraint</entry> 
  -->
  <entry>如果为真，那么这个索引支持一个排除约束</entry>
     </row>

     <row>
      <entry><structfield>indimmediate</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>If true, the uniqueness check is enforced immediately on
       insertion
       (irrelevant if <structfield>indisunique</> is not true)</entry> 
   -->
   <entry>如果为真，立即强制对插入进行唯一性检查(如果<structfield>indisunique</>不为真则是不相关的)</entry>
     </row>

     <row>
      <entry><structfield>indisclustered</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>If true, the table was last clustered on this index</entry> 
  -->
  <entry>如果为真，那么该表最后在这个索引上建了簇。</entry>
     </row>

     <row>
      <entry><structfield>indisvalid</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   If true, the index is currently valid for queries.  False means the
       index is possibly incomplete: it must still be modified by
       <command>INSERT</>/<command>UPDATE</> operations, but it cannot safely
       be used for queries. If it is unique, the uniqueness property is not
       guaranteed true either.
   -->
   如果为真，那么该索引可以用于查询。如果为假，那么该索引可能不完整：
   仍然必须在<command>INSERT</>/<command>UPDATE</>操作时进行更新，不过不能安全的用于查询。
   如果是唯一索引，那么唯一属性也不保证为真。
      </entry>
     </row>

     <row>
      <entry><structfield>indcheckxmin</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   If true, queries must not use the index until the <structfield>xmin</>
       of this <structname>pg_index</> row is below their <symbol>TransactionXmin</symbol>
       event horizon, because the table may contain broken HOT chains with
       incompatible rows that they can see 
   -->
   如果为真，查询必须不是使用索引，知道这个<structname>pg_index</>行的<structfield>xmin</>
   低于它们的<symbol>TransactionXmin</symbol>事件地平线，因为该表可能包含他们能看到的不兼容的行的断热链。
      </entry>
     </row>

     <row>
      <entry><structfield>indisready</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   If true, the index is currently ready for inserts.  False means the
       index must be ignored by <command>INSERT</>/<command>UPDATE</>
       operations.
   -->
   如果为真，该索引目前已准备好插入。如果为假，那么该索引必须通过<command>INSERT</>/<command>UPDATE</>
   操作忽略。
      </entry>
     </row>

     <row>
      <entry><structfield>indislive</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   If false, the index is in process of being dropped, and should be
       ignored for all purposes (including HOT-safety decisions) 
   -->
   如果为假，那么该索引正在被删除，并且应该被所有目的所忽略（包括热安全决策）
      </entry>
     </row>

     <row>
      <entry><structfield>indkey</structfield></entry>
      <entry><type>int2vector</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <entry>
       <!-- 
   This is an array of <structfield>indnatts</structfield> values that
       indicate which table columns this index indexes.  For example a value
       of <literal>1 3</literal> would mean that the first and the third table
       columns make up the index key.  A zero in this array indicates that the
       corresponding index attribute is an expression over the table columns,
       rather than a simple column reference. 
   -->
   这是一个包含<structfield>indnatts</structfield>值的数组，这些数组值表示这个索引所建立的表字段。
   比如一个值为<literal>1 3</literal>的意思是第一个字段和第三个字段组成这个索引键字。
   这个数组里的零表明对应的索引属性是在这个表字段上的一个表达式，而不是一个简单的字段引用。
      </entry>
     </row>

     <row>
      <entry><structfield>indcollation</structfield></entry>
      <entry><type>oidvector</type></entry>
      <entry><literal><link linkend="catalog-pg-collation"><structname>pg_collation</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   For each column in the index key, this contains the OID of the
       collation to use for the index. 
   -->
   对于每个在这个索引键字中的字段，这个字段包含用于这个索引的排序规则的OID。
      </entry>
     </row>

     <row>
      <entry><structfield>indclass</structfield></entry>
      <entry><type>oidvector</type></entry>
      <entry><literal><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   For each column in the index key, this contains the OID of
       the operator class to use.  See
       <link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link> for details. 
   -->
   对于索引键字里面的每个字段，这个字段都包含一个指向所使用的操作符类的 OID ，
   参阅<link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>获取细节。
      </entry>
     </row>

     <row>
      <entry><structfield>indoption</structfield></entry>
      <entry><type>int2vector</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   This is an array of <structfield>indnatts</structfield> values that
       store per-column flag bits.  The meaning of the bits is defined by
       the index's access method.
   -->
   这是<structfield>indnatts</structfield>值的一个数组，存储每个字段标志位。
   这个标志位的含义是通过索引的访问方式定义的。
      </entry>
     </row>

     <row>
      <entry><structfield>indexprs</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Expression trees (in <function>nodeToString()</function>
       representation) for index attributes that are not simple column
       references.  This is a list with one element for each zero
       entry in <structfield>indkey</>.  Null if all index attributes
       are simple references. 
   -->
   表达式树(以<function>nodeToString()</function>形式表现)用于那些非简单字段引用的索引属性。
   它是一个列表，在<structfield>indkey</>里面的每个零条目一个元素。
   如果所有索引属性都是简单的引用，则为空。
      </entry>
     </row>

     <row>
      <entry><structfield>indpred</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Expression tree (in <function>nodeToString()</function>
       representation) for partial index predicate.  Null if not a
       partial index. 
   -->
   部分索引断言的表达式树(以<function>nodeToString()</function>的形式表现)。
   如果不是部分索引，则是空字符串。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-inherits">
  <title><structname>pg_inherits</structname></title>

  <indexterm zone="catalog-pg-inherits">
   <primary>pg_inherits</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_inherits</> records information about
   table inheritance hierarchies.  There is one entry for each direct
   child table in the database.  (Indirect inheritance can be determined
   by following chains of entries.)
  </para>
-->
<para>
<structname>pg_inherits</>记录关于表继承层次的信息。数据库里每个直接的子系表都有一条记录。
间接的继承可以通过追溯记录链来判断。
</para>

  <table>
  <!-- 
  <title><structname>pg_inherits</> Columns</title> 
  -->
   <title><structname>pg_inherits</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>inhrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   The OID of the child table 
   -->
   子表的 OID
      </entry>
     </row>

     <row>
      <entry><structfield>inhparent</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   The OID of the parent table 
   -->
   父表的OID
      </entry>
     </row>

     <row>
      <entry><structfield>inhseqno</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   If there is more than one direct parent for a child table (multiple
       inheritance), this number tells the order in which the
       inherited columns are to be arranged.  The count starts at 1. 
   -->
   如果一个子表存在多个直系父表(多重继承)，这个数字表明此继承字段的排列顺序。
   计数从 1 开始。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-language">
  <title><structname>pg_language</structname></title>

  <indexterm zone="catalog-pg-language">
   <primary>pg_language</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_language</structname> registers
   languages in which you can write functions or stored procedures.
   See <xref linkend="sql-createlanguage">
   and <xref linkend="xplang"> for more information about language handlers.
  </para>
-->
<para>
<structname>pg_language</structname>登记编程语言，你可以用这些语言或接口写函数或者存储过程。
参阅<xref linkend="sql-createlanguage">和<xref linkend="xplang">获取更多关于语言处理器的信息。
</para>

  <table>
   <!-- 
   <title><structname>pg_language</> Columns</title>
   -->
   <title><structname>pg_language</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <!-- 
  <entry>Row identifier (hidden attribute; must be explicitly selected)</entry> 
  -->
  <entry>行标识符(隐藏属性;必须明确选择)</entry>
     </row>

     <row>
      <entry><structfield>lanname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <!-- 
  <entry>Name of the language</entry> 
  -->
  <entry>语言的名字</entry>
     </row>

     <row>
      <entry><structfield>lanowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Owner of the language</entry>
  -->
  <entry>语言的所有者</entry>
     </row>

     <row>
      <entry><structfield>lanispl</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   This is false for internal languages (such as
       <acronym>SQL</acronym>) and true for user-defined languages.
       Currently, <application>pg_dump</application> still uses this
       to determine which languages need to be dumped, but this might be
       replaced by a different mechanism in the future. 
   -->
   对于内部语言而言是假(比如<acronym>SQL</acronym>)，对于用户定义的语言则是真。
   目前，<application>pg_dump</application>仍然使用这个东西判断哪种语言需要转储，
   但是这些可能在将来被其它机制取代。
      </entry>
     </row>

     <row>
      <entry><structfield>lanpltrusted</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   True if this is a trusted language, which means that it is believed
       not to grant access to anything outside the normal SQL execution
       environment.  Only superusers can create functions in untrusted
       languages. 
   -->
   如果这是可信语言则为真，意味着系统相信它不会被授予任何正常 SQL 执行环境之外的权限。
   只有超级用户可以用不可信的语言创建函数。
      </entry>
     </row>

     <row>
      <entry><structfield>lanplcallfoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   For noninternal languages this references the language
       handler, which is a special function that is responsible for
       executing all functions that are written in the particular
       language 
   -->
   对于非内部语言，这是指向该语言处理器的引用，语言处理器是一个特殊函数，
   负责执行以某种语言写的所有函数。
      </entry>
     </row>

     <row>
      <entry><structfield>laninline</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   This references a function that is responsible for executing
       <quote>inline</> anonymous code blocks
       (<xref linkend="sql-do"> blocks).
       Zero if inline blocks are not supported. 
   -->
   这个字段引用一个负责执行<quote>inline</>匿名代码块的函数（<xref linkend="sql-do">块）。
   如果不支持内联块则为零。
      </entry>
     </row>

     <row>
      <entry><structfield>lanvalidator</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   This references a language validator function that is responsible
       for checking the syntax and validity of new functions when they
       are created.  Zero if no validator is provided.
   -->
   这个字段引用一个语言校验器函数，它负责检查新创建的函数的语法和有效性。
   如果没有提供校验器，则为零。
      </entry>
     </row>

     <row>
      <entry><structfield>lanacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Access privileges; see
       <xref linkend="sql-grant"> and
       <xref linkend="sql-revoke">
       for details 
   -->
   访问权限，参阅<xref linkend="sql-grant">和<xref linkend="sql-revoke">获取细节。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-largeobject">
  <title><structname>pg_largeobject</structname></title>

  <indexterm zone="catalog-pg-largeobject">
   <primary>pg_largeobject</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_largeobject</structname> holds the data making up
   <quote>large objects</quote>.  A large object is identified by an OID
   assigned when it is created.  Each large object is broken into
   segments or <quote>pages</> small enough to be conveniently stored as rows
   in <structname>pg_largeobject</structname>.
   The amount of data per page is defined to be <symbol>LOBLKSIZE</> (which is currently
   <literal>BLCKSZ/4</>, or typically 2 kB).
  </para>
-->
<para>
<structname>pg_largeobject</structname>表保存那些标记着<quote>大对象</quote>的数据。
一个大对象是使用其创建时分配的 OID 标识的。每个大对象都分解成足够小的小段或者
<quote>页面</>以便以行的形式存储在<structname>pg_largeobject</structname>里。
每页的数据定义为<symbol>LOBLKSIZE</>(目前是<literal>BLCKSZ/4</>或者通常是 2K 字节)。
</para>

  <!--
<para>
   Prior to <productname>PostgreSQL</> 9.0, there was no permission structure
   associated with large objects.  As a result,
   <structname>pg_largeobject</structname> was publicly readable and could be
   used to obtain the OIDs (and contents) of all large objects in the system.
   This is no longer the case; use
   <link linkend="catalog-pg-largeobject-metadata"><structname>pg_largeobject_metadata</></link>
   to obtain a list of large object OIDs.
  </para>
-->
<para>
<productname>PostgreSQL</> 9.0之前，没有许可结构与大对象相关。因此，<structname>pg_largeobject</structname>
公开可读并且可以用来包含系统中所有大对象的OID（和内容）。现在不再是这样了；
使用<link linkend="catalog-pg-largeobject-metadata"><structname>pg_largeobject_metadata</></link>
获取大对象OID的列表。
</para>

  <table>
   <!-- 
   <title><structname>pg_largeobject</> Columns</title> 
   -->
   <title><structname>pg_largeobject</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>loid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-largeobject-metadata"><structname>pg_largeobject_metadata</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Identifier of the large object that includes this page</entry> 
  -->
  <entry>包含本页的大对象的标识符</entry>
     </row>

     <row>
      <entry><structfield>pageno</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <!-- 
  <entry>Page number of this page within its large object
      (counting from zero)</entry>
  -->
  <entry>本页在其大对象数据中的页码从零开始计算</entry>
     </row>

     <row>
      <entry><structfield>data</structfield></entry>
      <entry><type>bytea</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Actual data stored in the large object.
       This will never be more than <symbol>LOBLKSIZE</> bytes and might be less.
   -->
   存储在大对象中的实际数据。这些数据绝不会超过<symbol>LOBLKSIZE</>字节，而且可能更少。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   Each row of <structname>pg_largeobject</structname> holds data
   for one page of a large object, beginning at
   byte offset (<literal>pageno * LOBLKSIZE</>) within the object.  The implementation
   allows sparse storage: pages might be missing, and might be shorter than
   <literal>LOBLKSIZE</> bytes even if they are not the last page of the object.
   Missing regions within a large object read as zeroes.
  </para>
-->
<para>
<structname>pg_largeobject</structname>的每一行保存一个大对象的一个页面，
从该对象内部的字节偏移(<literal>pageno * LOBLKSIZE</>)开始。这种实现允许松散的存储：
页面可以丢失，而且可以比<literal>LOBLKSIZE</>字节少(即使它们不是对象的最后一页)。
大对象内丢失的部分读做零。
</para>

 </sect1>

 <sect1 id="catalog-pg-largeobject-metadata">
  <title><structname>pg_largeobject_metadata</structname></title>

  <indexterm zone="catalog-pg-largeobject-metadata">
   <primary>pg_largeobject_metadata</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_largeobject_metadata</structname>
   holds metadata associated with large objects.  The actual large object
   data is stored in
   <link linkend="catalog-pg-largeobject"><structname>pg_largeobject</></link>.
  </para>
-->
<para>
<structname>pg_largeobject_metadata</structname>表存储与大数据相关的元数据。实际的大对象数据存储在
<link linkend="catalog-pg-largeobject"><structname>pg_largeobject</></link>里。
</para>

  <table>
   <!-- 
   <title><structname>pg_largeobject_metadata</> Columns</title> 
   -->
   <title><structname>pg_largeobject_metadata</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <!-- 
  <entry>Row identifier (hidden attribute; must be explicitly selected)</entry> 
  -->
  <entry>行标识符(隐藏属性; 必须明确选择)</entry>
     </row>

     <row>
      <entry><structfield>lomowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Owner of the large object</entry> 
  -->
  <entry>大对象的所有者</entry>
     </row>

     <row>
      <entry><structfield>lomacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Access privileges; see
       <xref linkend="sql-grant"> and
       <xref linkend="sql-revoke">
       for details 
   -->
   访问权限；参阅<xref linkend="sql-grant">和<xref linkend="sql-revoke">获取详细信息。
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-namespace">
  <title><structname>pg_namespace</structname></title>

  <indexterm zone="catalog-pg-namespace">
   <primary>pg_namespace</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_namespace</> stores namespaces.
   A namespace is the structure underlying SQL schemas: each namespace
   can have a separate collection of relations, types, etc. without name
   conflicts.
  </para>
-->
<para>
<structname>pg_namespace</>存储名字空间。名字空间是 SQL 模式下层的结构：每个名字空间有独立的关系，
类型等集合但并不会相互冲突。
</para>

  <table>
   <!-- 
   <title><structname>pg_namespace</> Columns</title> 
   -->
   <title><structname>pg_namespace</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <!-- 
  <entry>Row identifier (hidden attribute; must be explicitly selected)</entry> 
  -->
  <entry>行标识符(隐藏属性; 必须明确选择)</entry>
     </row>

     <row>
      <entry><structfield>nspname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <!-- 
  <entry>Name of the namespace</entry> 
  -->
  <entry>名字空间的名字</entry>
     </row>

     <row>
      <entry><structfield>nspowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Owner of the namespace</entry> 
  -->
  <entry>名字空间的所有者</entry>
     </row>

     <row>
      <entry><structfield>nspacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Access privileges; see
       <xref linkend="sql-grant"> and
       <xref linkend="sql-revoke">
       for details 
   -->
   访问权限；参阅<xref linkend="sql-grant">和<xref linkend="sql-revoke">获取细节。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-opclass">
  <title><structname>pg_opclass</structname></title>

  <indexterm zone="catalog-pg-opclass">
   <primary>pg_opclass</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_opclass</structname> defines
   index access method operator classes.  Each operator class defines
   semantics for index columns of a particular data type and a particular
   index access method.  An operator class essentially specifies that a
   particular operator family is applicable to a particular indexable column
   data type.  The set of operators from the family that are actually usable
   with the indexed column are whichever ones accept the column's data type
   as their left-hand input.
  </para>
-->
<para>
<structname>pg_opclass</structname>定义索引访问方法操作符类。
每个操作符类为一种特定数据类型和一种特定索引访问方法定义索引字段的语义。
一个操作符类本质上指定一个特定的操作符族适用于一个特定的可索引的字段数据类型。
索引的字段实际可用的族中的操作符集是接受字段的数据类型作为它们的左边的输入的那个。
</para>

  <!--
<para>
   Operator classes are described at length in <xref linkend="xindex">.
  </para>
-->
<para>
操作符类在<xref linkend="xindex">里有比较详细的描述。
</para>

  <table>
   <!-- 
   <title><structname>pg_opclass</> Columns</title>
   -->
   <title><structname>pg_opclass</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <!-- 
  <entry>Row identifier (hidden attribute; must be explicitly selected)</entry>
  -->
  <entry>行标识符(隐藏属性;必须明确选择)</entry>
     </row>

     <row>
      <entry><structfield>opcmethod</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-am"><structname>pg_am</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Index access method operator class is for</entry> 
  -->
  <entry>操作符类所服务的索引访问方法</entry>
     </row>

     <row>
      <entry><structfield>opcname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <!-- 
  <entry>Name of this operator class</entry>
  -->
  <entry>这个操作符类的名字</entry>
     </row>

     <row>
      <entry><structfield>opcnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Namespace of this operator class</entry> 
  -->
  <entry>这个操作符类的名字空间</entry>
     </row>

     <row>
      <entry><structfield>opcowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Owner of the operator class</entry>
  -->
  <entry>操作符类属主</entry>
     </row>

     <row>
      <entry><structfield>opcfamily</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opfamily"><structname>pg_opfamily</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Operator family containing the operator class</entry>
  -->
  <entry>包含该操作符类的操作符族</entry>
     </row>

     <row>
      <entry><structfield>opcintype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Data type that the operator class indexes</entry>
  -->
  <entry>操作符类索引的数据类型</entry>
     </row>

     <row>
      <entry><structfield>opcdefault</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>True if this operator class is the default for <structfield>opcintype</></entry> 
  -->
  <entry>如果操作符类是<structfield>opcintype</>的缺省，则为真</entry>
     </row>

     <row>
      <entry><structfield>opckeytype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Type of data stored in index, or zero if same as <structfield>opcintype</></entry> 
  -->
  <entry>索引数据的类型，如果和<structfield>opcintype</>相同则为零</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   An operator class's <structfield>opcmethod</> must match the
   <structname>opfmethod</> of its containing operator family.
   Also, there must be no more than one <structname>pg_opclass</structname>
   row having <structname>opcdefault</> true for any given combination of
   <structname>opcmethod</> and <structname>opcintype</>.
  </para>
-->
<para>
一个操作符类的<structfield>opcmethod</>必须匹配包含它的操作符族的 <structname>opfmethod</>。
同样，对于任意给定的<structname>opcmethod</>和<structname>opcintype</>的组合，
不能有超过一个<structname>pg_opclass</structname>行有<structname>opcdefault</>为真。
</para>

 </sect1>


 <sect1 id="catalog-pg-operator">
  <title><structname>pg_operator</structname></title>

  <indexterm zone="catalog-pg-operator">
   <primary>pg_operator</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_operator</> stores information about operators.
   See <xref linkend="sql-createoperator">
   and <xref linkend="xoper"> for more information.
  </para>
-->
<para>
<structname>pg_operator</>存储有关操作符的信息。参阅 CREATE OPERATOR 和 节33.12 获取这些操作符参数的细节。
</para>

  <table>
   <!-- 
   <title><structname>pg_operator</> Columns</title> 
   -->
   <title><structname>pg_operator</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <!-- 
  <entry>Row identifier (hidden attribute; must be explicitly selected)</entry>
  -->
  <entry>行标识符(隐藏属性;必须明确选择)</entry>
     </row>

     <row>
      <entry><structfield>oprname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <!-- 
  <entry>Name of the operator</entry> 
  -->
  <entry>操作符的名字</entry>
     </row>

     <row>
      <entry><structfield>oprnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   The OID of the namespace that contains this operator
   -->
   包含此操作符的名字空间的 OID
      </entry>
     </row>

     <row>
      <entry><structfield>oprowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Owner of the operator</entry> 
  -->
  <entry>操作符所有者</entry>
     </row>

     <row>
      <entry><structfield>oprkind</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   <literal>b</> = infix (<quote>both</quote>), <literal>l</> = prefix
       (<quote>left</quote>), <literal>r</> = postfix (<quote>right</quote>) 
   -->
   <literal>b</> = infix = 中缀(<quote>两边</quote>)， <literal>l</> = 前缀(<quote>左边</quote>)，
   <literal>r</> = 后缀(<quote>右边</quote>)
      </entry>
     </row>

     <row>
      <entry><structfield>oprcanmerge</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>This operator supports merge joins</entry> 
  -->
  <entry>这个操作符支持合并连接</entry>
     </row>

     <row>
      <entry><structfield>oprcanhash</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>This operator supports hash joins</entry> 
  -->
  <entry>这个操作符支持 Hash 连接</entry>
     </row>

     <row>
      <entry><structfield>oprleft</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Type of the left operand</entry> 
  -->
  <entry>左操作数的类型</entry>
     </row>

     <row>
      <entry><structfield>oprright</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Type of the right operand</entry> 
  -->
  <entry>右操作数的类型</entry>
     </row>

     <row>
      <entry><structfield>oprresult</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Type of the result</entry> 
  -->
  <entry>结果类型</entry>
     </row>

     <row>
      <entry><structfield>oprcom</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Commutator of this operator, if any</entry> 
  -->
  <entry>此操作符的交换符，如果存在的话</entry>
     </row>

     <row>
      <entry><structfield>oprnegate</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Negator of this operator, if any</entry> 
  -->
  <entry>此操作符的反转器，如果存在的话</entry>
     </row>

     <row>
      <entry><structfield>oprcode</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Function that implements this operator</entry>
  -->
  <entry>实现这个操作符的函数</entry>
     </row>

     <row>
      <entry><structfield>oprrest</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Restriction selectivity estimation function for this operator</entry> 
  -->
  <entry>此操作符的约束选择性计算函数</entry>
     </row>

     <row>
      <entry><structfield>oprjoin</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Join selectivity estimation function for this operator</entry> 
  -->
  <entry>此操作符的连接选择性计算函数</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   Unused column contain zeroes. For example, <structfield>oprleft</structfield>
   is zero for a prefix operator.
  </para>
-->
<para>
未用的字段包含零。比如，<structfield>oprleft</structfield>对于前缀操作符而言是零。
</para>

 </sect1>


 <sect1 id="catalog-pg-opfamily">
  <title><structname>pg_opfamily</structname></title>

  <indexterm zone="catalog-pg-opfamily">
   <primary>pg_opfamily</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_opfamily</structname> defines operator families.
   Each operator family is a collection of operators and associated
   support routines that implement the semantics specified for a particular
   index access method.  Furthermore, the operators in a family are all
   <quote>compatible</>, in a way that is specified by the access method.
   The operator family concept allows cross-data-type operators to be used
   with indexes and to be reasoned about using knowledge of access method
   semantics.
  </para>
-->
<para>
<structname>pg_opfamily</structname>表定义操作符族。每个操作符族是一个操作符和相关支持例程的集合，
其中的例程实现为一个特定的索引访问方式指定的语义。另外，族中的操作符都是<quote>兼容的</>，
通过由访问方式指定的方法。操作符族的概念允许交叉数据类型操作符和索引一起使用，
并且合理的使用访问方式的语义的知识。
</para>

  <!--
<para>
   Operator families are described at length in <xref linkend="xindex">.
  </para>
-->
<para>
操作符族在<xref linkend="xindex">里面描述。
</para>

  <table>
   <!-- 
   <title><structname>pg_opfamily</> Columns</title> 
   -->
   <title><structname>pg_opfamily</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>

     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <!-- 
  <entry>Row identifier (hidden attribute; must be explicitly selected)</entry> 
  -->
  <entry>行标识符(隐藏属性; 必须明确选择)</entry>
     </row>

     <row>
      <entry><structfield>opfmethod</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-am"><structname>pg_am</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Index access method operator family is for</entry> 
  -->
  <entry>操作符族使用的索引方法</entry>
     </row>

     <row>
      <entry><structfield>opfname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <!-- 
  <entry>Name of this operator family</entry> 
  -->
  <entry>这个操作符族的名字</entry>
     </row>

     <row>
      <entry><structfield>opfnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Namespace of this operator family</entry> 
  -->
  <entry>这个操作符的名字空间</entry>
     </row>

     <row>
      <entry><structfield>opfowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Owner of the operator family</entry> 
  -->
  <entry>操作符族的所有者</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   The majority of the information defining an operator family is not in its
   <structname>pg_opfamily</structname> row, but in the associated rows in
   <link linkend="catalog-pg-amop"><structname>pg_amop</structname></link>,
   <link linkend="catalog-pg-amproc"><structname>pg_amproc</structname></link>,
   and
   <link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>.
  </para>
-->
<para>
定义一个操作符族的大多数信息不在它的<structname>pg_opfamily</structname>行里面，
而是在相关的行<link linkend="catalog-pg-amop"><structname>pg_amop</structname></link>，
<link linkend="catalog-pg-amproc"><structname>pg_amproc</structname></link>和
<link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>里。
</para>

 </sect1>


 <sect1 id="catalog-pg-pltemplate">
  <title><structname>pg_pltemplate</structname></title>

  <indexterm zone="catalog-pg-pltemplate">
   <primary>pg_pltemplate</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_pltemplate</structname> stores
   <quote>template</> information for procedural languages.
   A template for a language allows the language to be created in a
   particular database by a simple <command>CREATE LANGUAGE</> command,
   with no need to specify implementation details.
  </para>
-->
<para>
<structname>pg_pltemplate</structname>表为过程语言存储<quote>模板</>信息。
一个语言的模板允许该语言可以在某个数据库里使用简单的<command>CREATE LANGUAGE</>命令创建，
而不需要声明实现细节。
</para>

  <!--
<para>
   Unlike most system catalogs, <structname>pg_pltemplate</structname>
   is shared across all databases of a cluster: there is only one
   copy of <structname>pg_pltemplate</structname> per cluster, not
   one per database.  This allows the information to be accessible in
   each database as it is needed.
  </para>
-->
<para>
和许多系统表不一样，<structname>pg_pltemplate</structname>是在集群里的所有数据库之间共享的：
每个集群只有一个<structname>pg_pltemplate</structname>的拷贝，而不是每个数据库一个。
这样就允许这些信息在需要时每个数据库都可以访问。
</para>

  <table>
   <!-- 
   <title><structname>pg_pltemplate</> Columns</title> 
   -->
   <title><structname>pg_pltemplate</> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>tmplname</structfield></entry>
      <entry><type>name</type></entry>
      <!-- 
  <entry>Name of the language this template is for</entry> 
  -->
  <entry>这个模板所应用的语言的名字</entry>
     </row>

     <row>
      <entry><structfield>tmpltrusted</structfield></entry>
      <entry><type>boolean</type></entry>
      <!-- 
  <entry>True if language is considered trusted</entry> 
  -->
  <entry>如果语言被认为是可信的，则为真</entry>
     </row>

     <row>
      <entry><structfield>tmpldbacreate</structfield></entry>
      <entry><type>boolean</type></entry>
      <!-- 
  <entry>True if language may be created by a database owner</entry>
  -->
  <entry>如果语言可以通过数据库所有者创建则为真</entry>
     </row>

     <row>
      <entry><structfield>tmplhandler</structfield></entry>
      <entry><type>text</type></entry>
      <!-- 
  <entry>Name of call handler function</entry> 
  -->
  <entry>调用处理器函数的名字</entry>
     </row>

     <row>
      <entry><structfield>tmplinline</structfield></entry>
      <entry><type>text</type></entry>
      <!-- 
  <entry>Name of anonymous-block handler function, or null if none</entry> 
  -->
  <entry>匿名块处理器函数的名字，如果没有则为null</entry>
     </row>

     <row>
      <entry><structfield>tmplvalidator</structfield></entry>
      <entry><type>text</type></entry>
      <!-- 
  <entry>Name of validator function, or null if none</entry> 
  -->
  <entry>校验函数的名字，如果没有则为 NULL</entry>
     </row>

     <row>
      <entry><structfield>tmpllibrary</structfield></entry>
      <entry><type>text</type></entry>
      <!-- 
  <entry>Path of shared library that implements language</entry> 
  -->
  <entry>实现语言的共享库的路径</entry>
     </row>

     <row>
      <entry><structfield>tmplacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <!-- 
  <entry>Access privileges for template (not actually used)</entry> 
  -->
  <entry>模板的访问权限(未使用)</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   There are not currently any commands that manipulate procedural language
   templates; to change the built-in information, a superuser must modify
   the table using ordinary <command>INSERT</command>, <command>DELETE</command>,
   or <command>UPDATE</command> commands.
  </para>
-->
<para>
目前还没有任何命令可以用于操作过程语言模板；要修改内置的信息，
超级用户必须使用普通的<command>INSERT</command>, <command>DELETE</command>, <command>UPDATE</command>命令修改该表。
</para>

  <note>
   <!--
<para>
    It is likely that <structname>pg_pltemplate</> will be removed in some
    future release of <productname>PostgreSQL</productname>, in favor of
    keeping this knowledge about procedural languages in their respective
    extension installation scripts.
   </para>
-->
<para>
很有可能在将来的<productname>PostgreSQL</productname>版本中删除<structname>pg_pltemplate</>，
为了支持过程语言的信息保持在它们各自的扩展安装脚本中。
</para>
  </note>

 </sect1>


 <sect1 id="catalog-pg-proc">
  <title><structname>pg_proc</structname></title>

  <indexterm zone="catalog-pg-proc">
   <primary>pg_proc</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_proc</> stores information about functions (or procedures).
   See <xref linkend="sql-createfunction">
   and <xref linkend="xfunc"> for more information.
  </para>
-->
<para>
<structname>pg_proc</>表存储关于函数(或过程)的信息。参阅<xref linkend="sql-createfunction">
和<xref linkend="xfunc">获取更多信息。
</para>

  <!--
<para>
   The table contains data for aggregate functions as well as plain functions.
   If <structfield>proisagg</structfield> is true, there should be a matching
   row in <structfield>pg_aggregate</structfield>.
  </para>
-->
<para>
该表包含聚集函数和普通函数的数据。如果<structfield>proisagg</structfield>为真，
那么在<structfield>pg_aggregate</structfield>里应该有一个匹配行。
</para>

  <table>
   <!-- 
   <title><structname>pg_proc</> Columns</title> 
   -->
   <title><structname>pg_proc</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <!-- 
  <entry>Row identifier (hidden attribute; must be explicitly selected)</entry> 
  -->
  <entry>行标识符(隐藏属性;必须明确选择)</entry>
     </row>

     <row>
      <entry><structfield>proname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <!-- 
  <entry>Name of the function</entry>
  -->
  <entry>函数名字</entry>
     </row>

     <row>
      <entry><structfield>pronamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   The OID of the namespace that contains this function 
   -->
   包含该函数名字空间的 OID
      </entry>
     </row>

     <row>
      <entry><structfield>proowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Owner of the function</entry> 
  -->
  <entry>函数的所有者</entry>
     </row>

     <row>
      <entry><structfield>prolang</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-language"><structname>pg_language</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Implementation language or call interface of this function</entry> 
  -->
  <entry>这个函数的实现语言或调用接口</entry>
     </row>

     <row>
      <entry><structfield>procost</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <!-- 
  <entry>Estimated execution cost (in units of
       <xref linkend="guc-cpu-operator-cost">); if <structfield>proretset</>,
       this is cost per row returned</entry>
   -->
   <entry>估计执行成本(以<xref linkend="guc-cpu-operator-cost">为单位);如果<structfield>proretset</>,
       这是每一行返回的成本</entry>
     </row>

     <row>
      <entry><structfield>prorows</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <!-- 
  <entry>Estimated number of result rows (zero if not <structfield>proretset</>)</entry> 
  -->
  <entry>估计的结果行数(如果非<structfield>proretset</>则为零)</entry>
     </row>

     <row>
      <entry><structfield>provariadic</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Data type of the variadic array parameter's elements,
       or zero if the function does not have a variadic parameter</entry> 
   -->
   <entry>可变数组参数的元素的数据类型，如果函数没有可变参数则为零</entry>
     </row>

     <row>
      <entry><structfield>protransform</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Calls to this function can be simplified by this other function
       (see <xref linkend="xfunc-transform-functions">)</entry>
   -->
   <entry>调用这个函数可以简化其他函数(参阅<xref linkend="xfunc-transform-functions">)</entry>
     </row>

     <row>
      <entry><structfield>proisagg</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>Function is an aggregate function</entry> 
  -->
  <entry>函数是聚集函数</entry>
     </row>

     <row>
      <entry><structfield>proiswindow</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>Function is a window function</entry> 
  -->
  <entry>函数是窗口函数</entry>
     </row>

     <row>
      <entry><structfield>prosecdef</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>Function is a security definer (i.e., a <quote>setuid</>
      function)</entry> 
  -->
  <entry>函数是一个安全定义器(也就是一个<quote>setuid</>函数)</entry>
     </row>

     <row>
      <entry><structfield>proleakproof</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   The function has no side effects.  No information about the
       arguments is conveyed except via the return value.  Any function
       that might throw an error depending on the values of its arguments
       is not leak-proof. 
   -->
   该函数没有副作用。没有关于该参数的信息传递，除非通过返回值。
   任何函数都有可能抛出一个错误，取决于它的参数值是不加密的。
      </entry>
     </row>

     <row>
      <entry><structfield>proisstrict</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Function returns null if any call argument is null.  In that
       case the function won't actually be called at all.  Functions
       that are not <quote>strict</quote> must be prepared to handle
       null inputs. 
   -->
   如果任何调用参数是空，那么函数返回空。这时函数实际上连调用都不调用。
   不是<quote>strict</quote>的函数必须准备处理空输入。
      </entry>
     </row>

     <row>
      <entry><structfield>proretset</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
     <!-- 
 <entry>Function returns a set (i.e., multiple values of the specified
      data type)</entry> 
  -->
   <entry>函数返回一个集合(也就是说，指定数据类型的多个数值)</entry>
     </row>

     <row>
      <entry><structfield>provolatile</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   <structfield>provolatile</structfield> tells whether the function's
       result depends only on its input arguments, or is affected by outside
       factors.
       It is <literal>i</literal> for <quote>immutable</> functions,
       which always deliver the same result for the same inputs.
       It is <literal>s</literal> for <quote>stable</> functions,
       whose results (for fixed inputs) do not change within a scan.
       It is <literal>v</literal> for <quote>volatile</> functions,
       whose results might change at any time.  (Use <literal>v</literal> also
       for functions with side-effects, so that calls to them cannot get
       optimized away.) 
   -->
   告诉该函数的结果是否只依赖于它的输入参数，或者还会被外接因素影响。
   对于<quote>不可变的</>(immutable)函数它是 <literal>i</literal>，
   这样的函数对于相同的输入总是产生相同的结果。对于<quote>稳定的</>(stable)
   函数它是<literal>s</literal>，(对于固定输入)其结果在一次扫描里不变。
   对于<quote>易变</>(volatile)函数它是<literal>v</literal>，其结果可能在任何时候变化。
   <literal>v</literal>也用于那些有副作用的函数，因此调用它们无法得到优化。
      </entry>
     </row>

     <row>
      <entry><structfield>pronargs</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <!-- 
  <entry>Number of input arguments</entry>
  -->
  <entry>参数数目</entry>
     </row>

     <row>
      <entry><structfield>pronargdefaults</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <!-- 
  <entry>Number of arguments that have defaults</entry> 
  -->
  <entry>有缺省值的参数的数量</entry>
     </row>

     <row>
      <entry><structfield>prorettype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Data type of the return value</entry> 
  -->
  <entry>返回值的数据类型</entry>
     </row>

     <row>
      <entry><structfield>proargtypes</structfield></entry>
      <entry><type>oidvector</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   An array with the data types of the function arguments.  This includes
       only input arguments (including <literal>INOUT</literal> and
       <literal>VARIADIC</> arguments), and thus represents
       the call signature of the function. 
   -->
   一个存放函数参数的数据类型的数组。数组里只包括输入参数(包括<literal>INOUT</literal>和
   <literal>VARIADIC</>参数)，因此代表该函数的调用签名(接口)。
      </entry>
     </row>

     <row>
      <entry><structfield>proallargtypes</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   An array with the data types of the function arguments.  This includes
       all arguments (including <literal>OUT</literal> and
       <literal>INOUT</literal> arguments); however, if all the
       arguments are <literal>IN</literal> arguments, this field will be null.
       Note that subscripting is 1-based, whereas for historical reasons
       <structfield>proargtypes</> is subscripted from 0. 
   -->
   一个包含函数参数的数据类型的数组。数组里包括所有参数的类型(包括<literal>OUT</literal>
   和<literal>INOUT</literal>参数)；不过，如果所有参数都是<literal>IN</literal>参数，
   那么这个字段就会是空。请注意数组下标是以 1 为起点的，而因为历史原因，
   <structfield>proargtypes</>的下标起点为 0 。
      </entry>
     </row>

     <row>
      <entry><structfield>proargmodes</structfield></entry>
      <entry><type>char[]</type></entry>
      <entry></entry>
      <entry>
        <!-- 
An array with the modes of the function arguments, encoded as
        <literal>i</literal> for <literal>IN</> arguments,
        <literal>o</literal> for <literal>OUT</> arguments,
        <literal>b</literal> for <literal>INOUT</> arguments,
        <literal>v</literal> for <literal>VARIADIC</> arguments,
        <literal>t</literal> for <literal>TABLE</> arguments.
        If all the arguments are <literal>IN</literal> arguments,
        this field will be null.
        Note that subscripts correspond to positions of
        <structfield>proallargtypes</> not <structfield>proargtypes</>. 
-->
一个保存函数参数模式的数组，编码如下：<literal>i</literal>表示<literal>IN</>参数，
<literal>o</literal>表示<literal>OUT</>参数，<literal>b</literal>表示<literal>INOUT</>参数，
<literal>v</literal>表示<literal>VARIADIC</>参数，<literal>t</literal>表示<literal>TABLE</>参数。
如果所有参数都是<literal>IN</literal>参数，那么这个字段为空。请注意，
下标对应的是<structfield>proallargtypes</>的位置，而不是<structfield>proargtypes</>。
      </entry>
     </row>

     <row>
      <entry><structfield>proargnames</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
        <!-- 
An array with the names of the function arguments.
        Arguments without a name are set to empty strings in the array.
        If none of the arguments have a name, this field will be null.
        Note that subscripts correspond to positions of
        <structfield>proallargtypes</> not <structfield>proargtypes</>. 
-->
一个保存函数参数的名字的数组。没有名字的参数在数组里设置为空字符串。
如果没有一个参数有名字，这个字段将是空。请注意，此数组的下标对应
<structfield>proallargtypes</>而不是<structfield>proargtypes</>。
      </entry>
     </row>

     <row>
      <entry><structfield>proargdefaults</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Expression trees (in <function>nodeToString()</function> representation)
       for default values.  This is a list with
       <structfield>pronargdefaults</> elements, corresponding to the last
       <replaceable>N</> <emphasis>input</> arguments (i.e., the last
       <replaceable>N</> <structfield>proargtypes</> positions).
       If none of the arguments have defaults, this field will be null. 
   -->
   缺省值的表达式树（用<function>nodeToString()</function>表示）。
   是和<structfield>pronargdefaults</>参数一起列出的，对应最后<replaceable>N</>个<emphasis>输入</>
   参数（也就是，最后<replaceable>N</>个<structfield>proargtypes</>位置）。
   如果没有有缺省的参数，那么这个字段为null。
      </entry>
     </row>

     <row>
      <entry><structfield>prosrc</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   This tells the function handler how to invoke the function.  It
       might be the actual source code of the function for interpreted
       languages, a link symbol, a file name, or just about anything
       else, depending on the implementation language/call convention. 
   -->
   这个字段告诉函数处理器如何调用该函数。它实际上对于解释语言来说就是函数的源程序，
   或者一个链接符号，一个文件名，或者是任何其它的东西，具体取决于语言/调用习惯的实现。
      </entry>
     </row>

     <row>
      <entry><structfield>probin</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Additional information about how to invoke the function.
       Again, the interpretation is language-specific. 
   -->
   关于如何调用该函数的附加信息。同样，其含义也是和语言相关的。
      </entry>
     </row>

     <row>
      <entry><structfield>proconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <!-- 
  <entry>Function's local settings for run-time configuration variables</entry> 
  -->
  <entry>函数的运行时配置变量的本地设置</entry>
     </row>

     <row>
      <entry><structfield>proacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Access privileges; see
       <xref linkend="sql-grant"> and
       <xref linkend="sql-revoke">
       for details 
   -->
   访问权限；参阅<xref linkend="sql-grant">和<xref linkend="sql-revoke">获取细节。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   For compiled functions, both built-in and dynamically loaded,
   <structfield>prosrc</structfield> contains the function's C-language
   name (link symbol).  For all other currently-known language types,
   <structfield>prosrc</structfield> contains the function's source
   text.  <structfield>probin</structfield> is unused except for
   dynamically-loaded C functions, for which it gives the name of the
   shared library file containing the function.
  </para>
-->
<para>
对于内置和动态加载得编译函数，<structfield>prosrc</structfield>包含函数的 C 语言名字(链接符号)。
对于所有其它当前已知的语言类型，<structfield>prosrc</structfield>包含该函数的源文本。
<structfield>probin</structfield>除了用于动态加载的 C 函数之外没有其它用途，
这个时候它给出包含给函数的共享库的文件名。
</para>

 </sect1>

 <sect1 id="catalog-pg-range">
  <title><structname>pg_range</structname></title>

  <indexterm zone="catalog-pg-range">
   <primary>pg_range</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_range</structname> stores information about
   range types.  This is in addition to the types' entries in
   <link linkend="catalog-pg-type"><structname>pg_type</structname></link>.
  </para>
-->
<para>
<structname>pg_range</structname>存储关于范围类型的信息。除了
<link linkend="catalog-pg-type"><structname>pg_type</structname></link>里类型的记录。
</para>

  <table>
   <!-- 
   <title><structname>pg_range</> Columns</title> 
   -->
   <title><structname>pg_range</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>rngtypid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <!-- 
  <entry>OID of the range type</entry> 
  -->
  <entry>范围类型的OID</entry>
     </row>

     <row>
      <entry><structfield>rngsubtype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <!-- 
  <entry>OID of the element type (subtype) of this range type</entry>
  -->
  <entry>这个范围类型的元素类型（子类型）的OID</entry>
     </row>

     <row>
      <entry><structfield>rngcollation</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-collation"><structname>pg_collation</structname></link>.oid</literal></entry>
      <!-- 
  <entry>OID of the collation used for range comparisons, or 0 if none</entry> 
  -->
  <entry>用于范围比较的排序规则的OID，如果没有则为零</entry>
     </row>

     <row>
      <entry><structfield>rngsubopc</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-opclass"><structname>pg_opclass</structname></link>.oid</literal></entry>
      <!-- 
  <entry>OID of the subtype's operator class used for range comparisons</entry> 
  -->
  <entry>用于范围比较的子类型的操作符类的OID</entry>
     </row>

     <row>
      <entry><structfield>rngcanonical</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry>OID of the function to convert a range value into canonical form,
      or 0 if none</entry> 
  -->
  <entry>转换范围类型为规范格式的函数的OID，如果没有则为0。</entry>
     </row>

     <row>
      <entry><structfield>rngsubdiff</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry>OID of the function to return the difference between two element
      values as <type>double precision</type>, or 0 if none</entry> 
  -->
  <entry>返回两个<type>double precision</type>元素值的不同的函数的OID，如果没有则为0。</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   <structfield>rngsubopc</> (plus <structfield>rngcollation</>, if the
   element type is collatable) determines the sort ordering used by the range
   type.  <structfield>rngcanonical</> is used when the element type is
   discrete.  <structfield>rngsubdiff</> is optional but should be supplied to
   improve performance of GiST indexes on the range type.
  </para>
-->
<para>
<structfield>rngsubopc</>（如果元素类型是可排序的则加上<structfield>rngcollation</>）
决定用于范围类型的排序顺序。当元素类型是离散的时使用<structfield>rngcanonical</>。
<structfield>rngsubdiff</>是可选的，但是应该应用于提高范围类型上的GiST索引的性能。
</para>

 </sect1>

 <sect1 id="catalog-pg-rewrite">
  <title><structname>pg_rewrite</structname></title>

  <indexterm zone="catalog-pg-rewrite">
   <primary>pg_rewrite</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_rewrite</structname> stores rewrite rules for tables and views.
  </para>
-->
<para>
<structname>pg_rewrite</structname>存储为表和视图定义的重写规则。
</para>

  <table>
   <!-- 
   <title><structname>pg_rewrite</> Columns</title> 
   -->
   <title><structname>pg_rewrite</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <!-- 
  <entry>Row identifier (hidden attribute; must be explicitly selected)</entry> 
  -->
  <entry>行标识符(隐藏属性; 必须明确选择)</entry>
     </row>

     <row>
      <entry><structfield>rulename</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <!-- 
  <entry>Rule name</entry> 
  -->
  <entry>规则名称</entry>
     </row>

     <row>
      <entry><structfield>ev_class</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The table this rule is for</entry> 
  -->
  <entry>使用这条规则的表名称</entry>
     </row>

     <row>
      <entry><structfield>ev_attr</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <!-- 
  <entry>The column this rule is for (currently, always -1 to
      indicate the whole table)</entry> 
  -->
  <entry>这条规则适用的字段(目前总是为-1，表示整个表)</entry>
     </row>

     <row>
      <entry><structfield>ev_type</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Event type that the rule is for: 1 = <command>SELECT</>, 2 =
       <command>UPDATE</>, 3 = <command>INSERT</>, 4 =
       <command>DELETE</> 
   -->
   规则适用的事件类型：1 = <command>SELECT</>, 2 =
       <command>UPDATE</>, 3 = <command>INSERT</>, 4 =
       <command>DELETE</> 
      </entry>
     </row>

     <row>
      <entry><structfield>ev_enabled</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Controls in which <xref linkend="guc-session-replication-role"> modes
       the rule fires.
       <literal>O</> = rule fires in <quote>origin</> and <quote>local</> modes,
       <literal>D</> = rule is disabled,
       <literal>R</> = rule fires in <quote>replica</> mode,
       <literal>A</> = rule fires always. 
   -->
   控制规则在哪个<xref linkend="guc-session-replication-role">模块触发。
   <literal>O</> = 规则 <quote>origin</> 和 <quote>local</> 模块触发,
       <literal>D</> = 规则被禁用,
       <literal>R</> = 规则在 <quote>replica</> 模块触发,
       <literal>A</> = 规则总是触发。
      </entry>
     </row>

     <row>
      <entry><structfield>is_instead</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!--
  <entry>True if the rule is an <literal>INSTEAD</literal> rule</entry>
  -->
  <entry>如果该规则是<literal>INSTEAD</literal>规则，那么为真</entry>
     </row>

     <row>
      <entry><structfield>ev_qual</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Expression tree (in the form of a
       <function>nodeToString()</function> representation) for the
       rule's qualifying condition 
   -->
   规则的资格条件的表达式树(以<function>nodeToString()</function>形式存在)
      </entry>
     </row>

     <row>
      <entry><structfield>ev_action</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Query tree (in the form of a
       <function>nodeToString()</function> representation) for the
       rule's action 
   -->
   规则动作的查询树(以<function>nodeToString()</function>形式存在)
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
   <!--
<para>
    <literal>pg_class.relhasrules</literal>
    must be true if a table has any rules in this catalog.
   </para>
-->
<para>
如果一个表在这个系统表里有任何规则存在，那么<literal>pg_class.relhasrules</literal>必须为真。
</para>
  </note>

 </sect1>


 <sect1 id="catalog-pg-seclabel">
  <title><structname>pg_seclabel</structname></title>

  <indexterm zone="catalog-pg-seclabel">
   <primary>pg_seclabel</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_seclabel</structname> stores security
   labels on database objects.  Security labels can be manipulated
   with the <xref linkend="sql-security-label"> command.  For an easier
   way to view security labels, see <xref linkend="view-pg-seclabels">.
  </para>
-->
<para>
<structname>pg_seclabel</structname>表存储数据对象上的安全标签。
安全标签可以和<xref linkend="sql-security-label">命令一起操作。
查看安全标签的简单些的方法请参阅<xref linkend="view-pg-seclabels">。
</para>

  <!--
<para>
   See also <link linkend="catalog-pg-shseclabel"><structname>pg_shseclabel</structname></link>,
   which performs a similar function for security labels of database objects
   that are shared across a database cluster.
  </para>
-->
<para>
<link linkend="catalog-pg-shseclabel"><structname>pg_shseclabel</structname></link>表的作用类似，
只是它是用于在一个数据库集群内共享的数据库对象的安全标签上的。
</para>

  <table>
   <!-- 
   <title><structname>pg_seclabel</structname> Columns</title> 
   -->
   <title><structname>pg_seclabel</structname> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <!-- 
  <entry>any OID column</entry>
      <entry>The OID of the object this security label pertains to</entry> 
  -->
  <entry>任意OID属性</entry>
      <entry>这个安全标签所属的对象的OID</entry>
     </row>

     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The OID of the system catalog this object appears in</entry> 
  -->
  <entry>出现这个对象的系统目录的OID</entry>
     </row>

     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   For a security label on a table column, this is the column number (the
       <structfield>objoid</> and <structfield>classoid</> refer to
       the table itself).  For all other object types, this column is
       zero. 
   -->
   对于一个在表字段上的安全标签，这是字段号（<structfield>objoid</>和<structfield>classoid</>
   参考表本身）。对于所有其他对象类型，这个字段是零。
      </entry>
     </row>

     <row>
      <entry><structfield>provider</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <!-- 
  <entry>The label provider associated with this label.</entry> 
  -->
  <entry>与这个标签相关的标签提供程序。</entry>
     </row>

     <row>
      <entry><structfield>label</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <!-- 
  <entry>The security label applied to this object.</entry>
  -->
  <entry>应用于这个对象的安全标签。</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-shdepend">
  <title><structname>pg_shdepend</structname></title>

  <indexterm zone="catalog-pg-shdepend">
   <primary>pg_shdepend</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_shdepend</structname> records the
   dependency relationships between database objects and shared objects,
   such as roles.  This information allows
   <productname>PostgreSQL</productname> to ensure that those objects are
   unreferenced before attempting to delete them.
  </para>
-->
<para>
<structname>pg_shdepend</structname>记录数据库对象和共享对象(比如角色)之间的依赖性关系。
这些信息允许<productname>PostgreSQL</productname>保证在企图删除这些对象之前，
这些对象是没有被引用的。
</para>

  <!--
<para>
   See also <link linkend="catalog-pg-depend"><structname>pg_depend</structname></link>,
   which performs a similar function for dependencies involving objects
   within a single database.
  </para>
-->
<para>
<link linkend="catalog-pg-depend"><structname>pg_depend</structname></link>表的作用类似，
只是它是用于在一个数据库内部的对象的依赖性关系的。
</para>

  <!--
<para>
   Unlike most system catalogs, <structname>pg_shdepend</structname>
   is shared across all databases of a cluster: there is only one
   copy of <structname>pg_shdepend</structname> per cluster, not
   one per database.
  </para>
-->
<para>
和其它大多数系统表不同，<structname>pg_shdepend</structname>是在集群里面所有的数据库之间共享的：
每个数据库集群只有一个<structname>pg_shdepend</structname>，而不是每个数据库一个。
</para>

  <table>
   <!-- 
   <title><structname>pg_shdepend</> Columns</title> 
   -->
   <title><structname>pg_shdepend</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>dbid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The OID of the database the dependent object is in,
       or zero for a shared object</entry> 
   -->
   <entry>依赖对象所在的数据库的 OID ，如果是共享对象，则为零</entry>
     </row>

     <row>
      <entry><structfield>classid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The OID of the system catalog the dependent object is in</entry> 
  -->
  <entry>依赖对象所在的系统表的 OID</entry>
     </row>

     <row>
      <entry><structfield>objid</structfield></entry>
      <entry><type>oid</type></entry>
      <!-- 
  <entry>any OID column</entry>
      <entry>The OID of the specific dependent object</entry> 
  -->
  <entry>任意 oid 属性</entry>
      <entry>指定的依赖对象的 OID</entry>
     </row>

     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   For a table column, this is the column number (the
       <structfield>objid</> and <structfield>classid</> refer to the
       table itself).  For all other object types, this column is zero. 
   -->
   对于一个表字段，这是字段号（<structfield>objid</>和<structfield>classid</>
   参考表本身）。对于所有其他对象类型，这个字段为零。
      </entry>
     </row>

     <row>
      <entry><structfield>refclassid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The OID of the system catalog the referenced object is in
       (must be a shared catalog)</entry> 
   -->
   <entry>被引用对象所在的系统表的 OID(必须是一个共享表)</entry>
     </row>

     <row>
      <entry><structfield>refobjid</structfield></entry>
      <entry><type>oid</type></entry>
      <!-- 
  <entry>any OID column</entry>
      <entry>The OID of the specific referenced object</entry>
  -->
  <entry>任意 oid 属性</entry>
      <entry>指定的被引用对象的 OID</entry>
     </row>

     <row>
      <entry><structfield>deptype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   A code defining the specific semantics of this dependency relationship; see text 
   -->
   一段代码，定义了这个依赖性关系的特定语义；参阅下文。
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  
<para>
<!-- 
   In all cases, a <structname>pg_shdepend</structname> entry indicates that
   the referenced object cannot be dropped without also dropping the dependent
   object.  However, there are several subflavors identified by
   <structfield>deptype</>:
-->
在任何情况下，一条<structname>pg_shdepend</structname>
记录就表明这个被引用的对象不能在未删除依赖对象的前提下删除。
不过，<structfield>deptype</>同时还标出了几种不同的子风格：

   <variablelist>
    <varlistentry>
     <term><symbol>SHARED_DEPENDENCY_OWNER</> (<literal>o</>)</term>
     <listitem>
<!--
      <para>
       The referenced object (which must be a role) is the owner of the
       dependent object.
      </para>
-->
<para>
被引用的对象(必须是一个角色)是依赖对象的所有者。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SHARED_DEPENDENCY_ACL</> (<literal>a</>)</term>
     <listitem>
      <!--
<para>
       The referenced object (which must be a role) is mentioned in the
       ACL (access control list, i.e., privileges list) of the
       dependent object.  (A <symbol>SHARED_DEPENDENCY_ACL</> entry is
       not made for the owner of the object, since the owner will have
       a <symbol>SHARED_DEPENDENCY_OWNER</> entry anyway.)
      </para>
-->
<para>
被引用的对象(必须是一个角色)在依赖对象的 ACL(访问控制列表，也就是权限列表)里提到。
<symbol>SHARED_DEPENDENCY_ACL</>不会在对象的所有者头上添加的，因为所有者会有一个
<symbol>SHARED_DEPENDENCY_OWNER</>记录。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><symbol>SHARED_DEPENDENCY_PIN</> (<literal>p</>)</term>
     <listitem>
      <!--
<para>
       There is no dependent object; this type of entry is a signal
       that the system itself depends on the referenced object, and so
       that object must never be deleted.  Entries of this type are
       created only by <command>initdb</command>.  The columns for the
       dependent object contain zeroes.
      </para>
-->
<para>
没有依赖对象；这类记录标识系统自身依赖于该被依赖对象，因此这样的对象绝对不能被删除。
这种类型的记录只是由<command>initdb</command>创建。这样的依赖对象的字段都是零。
</para>
     </listitem>
    </varlistentry>
   </variablelist>

<!-- 
   Other dependency flavors might be needed in future.  Note in particular
   that the current definition only supports roles as referenced objects. 
 -->
 其它依赖性的风格可能在将来会出现。请注意，目前的定义只是支持把角色当作被引用对象。
  </para>

 </sect1>

 <sect1 id="catalog-pg-shdescription">
  <title><structname>pg_shdescription</structname></title>

  <indexterm zone="catalog-pg-shdescription">
   <primary>pg_shdescription</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_shdescription</structname> stores optional
   descriptions (comments) for shared database objects.  Descriptions can be
   manipulated with the <xref linkend="sql-comment"> command and viewed with
   <application>psql</application>'s <literal>\d</literal> commands.
  </para>
-->
<para>
<structname>pg_shdescription</structname>为共享数据库对象存储可选的注释。
可以使用<xref linkend="sql-comment">命令操作注释的内容，使用
<application>psql</application>的<literal>\d</literal>命令查看注释内容。
</para>

  <!--
<para>
   See also <link linkend="catalog-pg-description"><structname>pg_description</structname></link>,
   which performs a similar function for descriptions involving objects
   within a single database.
  </para>
-->
<para>
<link linkend="catalog-pg-description"><structname>pg_description</structname></link>提供了类似的功能，
它记录了单个数据库中对象的注释。
</para>

  <!--
<para>
   Unlike most system catalogs, <structname>pg_shdescription</structname>
   is shared across all databases of a cluster: there is only one
   copy of <structname>pg_shdescription</structname> per cluster, not
   one per database.
  </para>
-->
<para>
不同于大多数系统表，<structname>pg_shdescription</structname>是在集群里面所有的数据库之间共享的：
每个数据库集群只有一个<structname>pg_shdescription</structname>，而不是每个数据库一个。
</para>

  <table>
   <!-- 
   <title><structname>pg_shdescription</> Columns</title> 
   -->
   <title><structname>pg_shdescription</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <!-- 
  <entry>any OID column</entry>
      <entry>The OID of the object this description pertains to</entry>
  -->
  <entry>任意 oid 属性</entry>
      <entry>这条描述所描述的对象的 OID</entry>
     </row>

     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The OID of the system catalog this object appears in</entry> 
  -->
  <entry>这个对象出现的系统表的 OID</entry>
     </row>

     <row>
      <entry><structfield>description</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <!-- 
  <entry>Arbitrary text that serves as the description of this object</entry> 
  -->
  <entry>作为对该对象的描述的任意文本</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="catalog-pg-shseclabel">
  <title><structname>pg_shseclabel</structname></title>

  <indexterm zone="catalog-pg-shseclabel">
   <primary>pg_shseclabel</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_shseclabel</structname> stores security
   labels on shared database objects.  Security labels can be manipulated
   with the <xref linkend="sql-security-label"> command.  For an easier
   way to view security labels, see <xref linkend="view-pg-seclabels">.
  </para>
-->
<para>
<structname>pg_shseclabel</structname>表存储在共享数据库对象上的安全标签。
安全标签可以用<xref linkend="sql-security-label">命令操作。
查看安全标签的简单点的方法，请参阅<xref linkend="view-pg-seclabels">。
</para>

  <!--
<para>
   See also <link linkend="catalog-pg-seclabel"><structname>pg_seclabel</structname></link>,
   which performs a similar function for security labels involving objects
   within a single database.
  </para>
-->
<para>
<link linkend="catalog-pg-seclabel"><structname>pg_seclabel</structname></link>表的作用类似，
只是它是用于在单个数据库内部的对象的安全标签的。
</para>

  <!--
<para>
   Unlike most system catalogs, <structname>pg_shseclabel</structname>
   is shared across all databases of a cluster: there is only one
   copy of <structname>pg_shseclabel</structname> per cluster, not
   one per database.
  </para>
-->
<para>
不同于大多数的系统表，<structname>pg_shseclabel</structname>在一个集群中的所有数据库中共享：
每个数据库集群只有一个<structname>pg_shseclabel</structname>，而不是每个数据库一个。
</para>

  <table>
   <!-- 
   <title><structname>pg_shseclabel</structname> Columns</title> 
   -->
   <title><structname>pg_shseclabel</structname> 字段</title>
   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <!-- 
  <entry>any OID column</entry>
      <entry>The OID of the object this security label pertains to</entry> 
  -->
  <entry>任意OID属性</entry>
      <entry>这个安全标签所属的对象的OID</entry>
     </row>
     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The OID of the system catalog this object appears in</entry> 
  -->
  <entry>出现这个对象的系统表的OID</entry>
     </row>
     <row>
      <entry><structfield>provider</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <!-- 
  <entry>The label provider associated with this label.</entry> 
  -->
  <entry>与这个标签相关的标签提供程序。</entry>
     </row>
     <row>
      <entry><structfield>label</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <!-- 
  <entry>The security label applied to this object.</entry> 
  -->
  <entry>应用于这个对象的安全标签。</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="catalog-pg-statistic">
  <title><structname>pg_statistic</structname></title>

  <indexterm zone="catalog-pg-statistic">
   <primary>pg_statistic</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_statistic</structname> stores
   statistical data about the contents of the database.  Entries are
   created by <xref linkend="sql-analyze">
   and subsequently used by the query planner.  Note that all the
   statistical data is inherently approximate, even assuming that it
   is up-to-date.
  </para>
-->
<para>
<structname>pg_statistic</structname>表存储有关该数据库内容的统计数据。
记录是由<xref linkend="sql-analyze">创建的，并且随后被查询规划器使用。
请注意所有统计信息天生都是近似的数值，即使假设它是最新的也如此。
</para>

  <!--
<para>
   Normally there is one entry, with <structfield>stainherit</> =
   <literal>false</>, for each table column that has been analyzed.
   If the table has inheritance children, a second entry with
   <structfield>stainherit</> = <literal>true</> is also created.  This row
   represents the column's statistics over the inheritance tree, i.e.,
   statistics for the data you'd see with
   <literal>SELECT <replaceable>column</> FROM <replaceable>table</>*</literal>,
   whereas the <structfield>stainherit</> = <literal>false</> row represents
   the results of
   <literal>SELECT <replaceable>column</> FROM ONLY <replaceable>table</></literal>.
  </para>
-->
<para>
通常这里对于每个被分析了的表字段有一条<structfield>stainherit</> = <literal>false</>的记录。
如果该表有继承的子代，那么也会创建一条带有<structfield>stainherit</> = <literal>true</>的记录。
这个行表示字段在继承树上的状态，也就是，对于这个数据的状态，你应该看到
<literal>SELECT <replaceable>column</> FROM <replaceable>table</>*</literal>，
而<structfield>stainherit</> = <literal>false</>行的结果为
<literal>SELECT <replaceable>column</> FROM ONLY <replaceable>table</></literal>。
</para>

  <!--
<para>
   <structname>pg_statistic</structname> also stores statistical data about
   the values of index expressions.  These are described as if they were
   actual data columns; in particular, <structfield>starelid</structfield>
   references the index.  No entry is made for an ordinary non-expression
   index column, however, since it would be redundant with the entry
   for the underlying table column.  Currently, entries for index expressions
   always have <structfield>stainherit</> = <literal>false</>.
  </para>
-->
<para>
<structname>pg_statistic</structname>还存储有关索引表达式数值的统计数据。
这些是把他们当作实际的数据字段来描述的；特别是，<structfield>starelid</structfield>引用索引。
不过，普通的非表达式索引字段没有记录，因为会和下层的表字段记录冗余。
当前，索引表达式的记录总是有<structfield>stainherit</> = <literal>false</>。
</para>

  <!--
<para>
   Since different kinds of statistics might be appropriate for different
   kinds of data, <structname>pg_statistic</structname> is designed not
   to assume very much about what sort of statistics it stores.  Only
   extremely general statistics (such as nullness) are given dedicated
   columns in <structname>pg_statistic</structname>.  Everything else
   is stored in <quote>slots</quote>, which are groups of associated columns
   whose content is identified by a code number in one of the slot's columns.
   For more information see
   <filename>src/include/catalog/pg_statistic.h</filename>.
  </para>
-->
<para>
因为不同类型的统计信息适用于不同类型的数据，<structname>pg_statistic</structname>
被设计成不太在意自己存储的是什么类型的统计。只有极为常用的统计信息(比如 NULL 的含量)
才在<structname>pg_statistic</structname>里给予专用的字段。其它所有东西都存储在
<quote>槽位</quote>中，而槽位是一组相关的字段，它们的内容用槽位中的一个字段的代码号码表示。
更详细的信息请参阅<filename>src/include/catalog/pg_statistic.h</filename>。
</para>

  <!--
<para>
   <structname>pg_statistic</structname> should not be readable by the
   public, since even statistical information about a table's contents
   might be considered sensitive.  (Example: minimum and maximum values
   of a salary column might be quite interesting.)
   <link linkend="view-pg-stats"><structname>pg_stats</structname></link>
   is a publicly readable view on
   <structname>pg_statistic</structname> that only exposes information
   about those tables that are readable by the current user.
  </para>
-->
<para>
<structname>pg_statistic</structname>不应该是公众可读的，因为即使是表内容的统计信息也应该认为是敏感的。
例子：薪水字段的最大最小值肯定是相当让人感兴趣的。<link linkend="view-pg-stats"><structname>pg_stats</structname></link>
是一个在<structname>pg_statistic</structname>上的全局可读的视图，它只显示那些表对于当前用户可读的信息。
</para>

  <table>
   <!-- 
   <title><structname>pg_statistic</> Columns</title> 
   -->
   <title><structname>pg_statistic</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>starelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The table or index that the described column belongs to</entry> 
  -->
  <entry>所描述的字段所属的表或者索引</entry>
     </row>

     <row>
      <entry><structfield>staattnum</structfield></entry>
      <entry><type>int2</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <!-- 
  <entry>The number of the described column</entry> 
  -->
  <entry>所描述的字段的个数</entry>
     </row>

     <row>
      <entry><structfield>stainherit</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>If true, the stats include inheritance child columns, not just the
       values in the specified relation</entry> 
   -->
   <entry>如果为真，那么统计数据包含继承子字段，不只是指定关系中的值。</entry>
     </row>

     <row>
      <entry><structfield>stanullfrac</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <!-- 
  <entry>The fraction of the column's entries that are null</entry>
  -->
  <entry>该字段中为 NULL 的记录的比率</entry>
     </row>

     <row>
      <entry><structfield>stawidth</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <!-- 
  <entry>The average stored width, in bytes, of nonnull entries</entry> 
  -->
  <entry>非 NULL 记录的平均存储宽度，以字节计</entry>
     </row>

     <row>
      <entry><structfield>stadistinct</structfield></entry>
      <entry><type>float4</type></entry>
      <entry></entry>
      <entry>
  <!-- 
  The number of distinct nonnull data values in the column.
      A value greater than zero is the actual number of distinct values.
      A value less than zero is the negative of a multiplier for the number
      of rows in the table; for example, a column in which values appear about
      twice on the average could be represented by
      <structfield>stadistinct</> = -0.5.
      A zero value means the number of distinct values is unknown. 
  -->
  字段里唯一的非 NULL 数据值的数目。一个大于零的数值是独立数值的实际数目。
  一个小于零的数值是表中行数的乘数的负数(比如，一个字段的数值平均出现概率为两次，
  那么可以表示为<structfield>stadistinct</> = -0.5)。零值表示独立数值的数目未知。
      </entry>
     </row>

     <row>
      <entry><structfield>stakind<replaceable>N</></structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   A code number indicating the kind of statistics stored in the
       <replaceable>N</>th <quote>slot</quote> of the
       <structname>pg_statistic</structname> row. 
   -->
   一个编码，表示这种类型的统计存储在<structname>pg_statistic</structname>
   行的第<replaceable>N</>个<quote>槽位</quote>。
      </entry>
     </row>

     <row>
      <entry><structfield>staop<replaceable>N</></structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-operator"><structname>pg_operator</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   An operator used to derive the statistics stored in the
       <replaceable>N</>th <quote>slot</quote>.  For example, a
       histogram slot would show the <literal>&lt;</literal> operator
       that defines the sort order of the data. 
   -->
   一个用于生成这些存储在第<replaceable>N</>个<quote>槽位</quote>的统计信息的操作符。
   比如，一个柱面图槽位会显示<literal>&lt;</literal>操作符，该操作符定义了该数据的排序顺序。
      </entry>
     </row>

     <row>
      <entry><structfield>stanumbers<replaceable>N</></structfield></entry>
      <entry><type>float4[]</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Numerical statistics of the appropriate kind for the
       <replaceable>N</>th <quote>slot</quote>, or null if the slot
       kind does not involve numerical values 
   -->
   第<replaceable>N</>个<quote>槽位</quote>的相关类型的数值统计，
   如果该槽位和数值没有关系，那么就是 NULL 。
      </entry>
     </row>

     <row>
      <entry><structfield>stavalues<replaceable>N</></structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Column data values of the appropriate kind for the
       <replaceable>N</>th <quote>slot</quote>, or null if the slot
       kind does not store any data values.  Each array's element
       values are actually of the specific column's data type, or a related
       type such as an array's element type, so there is no way to define
       these columns' type more specifically than <type>anyarray</>.
-->
第<replaceable>N</>个<quote>槽位</quote>相关类型的字段数据值，
如果该槽位类型不存储任何数据值那么就是 NULL 。
每个数组的元素值实际上都是指定字段的数据类型，或相关类型如一个数组的元素类型，
因此，除了把这些字段的类型定义成<type>anyarray</>之外，没有更好的办法。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-tablespace">
  <title><structname>pg_tablespace</structname></title>

  <indexterm zone="catalog-pg-tablespace">
   <primary>pg_tablespace</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_tablespace</structname> stores information
   about the available tablespaces.  Tables can be placed in particular
   tablespaces to aid administration of disk layout.
  </para>
-->
<para>
<structname>pg_tablespace</structname>存储有关可用的表空间的信息。
表可以放置在特定的表空间里，以帮助管理磁盘布局。
</para>

  <!--
<para>
   Unlike most system catalogs, <structname>pg_tablespace</structname>
   is shared across all databases of a cluster: there is only one
   copy of <structname>pg_tablespace</structname> per cluster, not
   one per database.
  </para>
-->
<para>
与大多数系统表不同，<structname>pg_tablespace</structname>在一个集群中的所有数据库之间共享：
每个集群只有一份<structname>pg_tablespace</structname>的拷贝，而不是每个数据库一个。
</para>

  <table>
   <!-- 
   <title><structname>pg_tablespace</> Columns</title> 
   -->
   <title><structname>pg_tablespace</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <!-- 
  <entry>Row identifier (hidden attribute; must be explicitly selected)</entry>
  -->
  <entry>行标识符(隐藏属性; 必须明确指定)</entry>
     </row>

     <row>
      <entry><structfield>spcname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <!-- 
  <entry>Tablespace name</entry> 
  -->
  <entry>表空间名字</entry>
     </row>

     <row>
      <entry><structfield>spcowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Owner of the tablespace, usually the user who created it</entry> 
  -->
  <entry>表空间的所有者，通常是创建它的人</entry>
     </row>

     <row>
      <entry><structfield>spcacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Access privileges; see
       <xref linkend="sql-grant"> and
       <xref linkend="sql-revoke">
       for details 
   -->
   访问权限；参阅<xref linkend="sql-grant">和<xref linkend="sql-revoke">获取细节。
      </entry>
     </row>

     <row>
      <entry><structfield>spcoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Tablespace-level options, as <quote>keyword=value</> strings
   -->
   表空间级选项，使用<quote>keyword=value</>格式的字符串
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-trigger">
  <title><structname>pg_trigger</structname></title>

  <indexterm zone="catalog-pg-trigger">
   <primary>pg_trigger</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_trigger</structname> stores triggers on tables
   and views.
   See <xref linkend="sql-createtrigger">
   for more information.
  </para>
-->
<para>
<structname>pg_trigger</structname>存储表和视图上面的触发器。
参阅<xref linkend="sql-createtrigger">获取更多信息。
</para>

  <table>
   <!-- 
   <title><structname>pg_trigger</> Columns</title>
   -->
   <title><structname>pg_trigger</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <!-- 
  <entry>Row identifier (hidden attribute; must be explicitly selected)</entry> 
  -->
  <entry>行标识符(隐藏属性;必须明确选择)</entry>
     </row>

     <row>
      <entry><structfield>tgrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The table this trigger is on</entry> 
  -->
  <entry>这个触发器所在的表</entry>
     </row>

     <row>
      <entry><structfield>tgname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <!-- 
  <entry>Trigger name (must be unique among triggers of same table)</entry> 
  -->
  <entry>触发器名称(在同一表的所有触发器中必须唯一)</entry>
     </row>

     <row>
      <entry><structfield>tgfoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The function to be called</entry> 
  -->
  <entry>要调用的函数</entry>
     </row>

     <row>
      <entry><structfield>tgtype</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <!-- 
  <entry>Bit mask identifying trigger firing conditions</entry> 
  -->
  <entry>标识触发器条件的位掩码</entry>
     </row>

     <row>
      <entry><structfield>tgenabled</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Controls in which <xref linkend="guc-session-replication-role"> modes
       the trigger fires.
       <literal>O</> = trigger fires in <quote>origin</> and <quote>local</> modes,
       <literal>D</> = trigger is disabled,
       <literal>R</> = trigger fires in <quote>replica</> mode,
       <literal>A</> = trigger fires always. 
   -->
   在<xref linkend="guc-session-replication-role">模块里控制触发器的触发。
   <literal>O</> = 触发器在<quote>origin</>和<quote>local</>模块里触发，
       <literal>D</> = 禁用触发器，
       <literal>R</> = 触发器在<quote>replica</>模块里触发，
       <literal>A</> = 触发器总是触发。
      </entry>
     </row>

     <row>
      <entry><structfield>tgisinternal</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>True if trigger is internally generated (usually, to enforce
       the constraint identified by <structfield>tgconstraint</>)</entry>
   -->
   <entry>如果触发器是内部产生的则为真(通常，强制约束由
   <structfield>tgconstraint</>指定)</entry>

     </row>

     <row>
      <entry><structfield>tgconstrrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The table referenced by a referential integrity constraint</entry> 
  -->
  <entry>一个参照完整性约束引用的表</entry>
     </row>

     <row>
      <entry><structfield>tgconstrindid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The index supporting a unique, primary key, or referential integrity constraint</entry> 
  -->
  <entry>索引支持唯一、主键或参照完整性约束</entry>
     </row>

     <row>
      <entry><structfield>tgconstraint</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-constraint"><structname>pg_constraint</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The <structname>pg_constraint</> entry associated with the trigger, if any</entry> 
  -->
  <entry><structname>pg_constraint</>条目与触发器相关，如果有</entry>
     </row>

     <row>
      <entry><structfield>tgdeferrable</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>True if constraint trigger is deferrable</entry> 
  -->
  <entry>如果约束触发器可推迟则为真</entry>
     </row>

     <row>
      <entry><structfield>tginitdeferred</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>True if constraint trigger is initially deferred</entry> 
  -->
  <entry>如果约束触发器是初始可推迟则为真</entry>
     </row>

     <row>
      <entry><structfield>tgnargs</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <!-- 
  <entry>Number of argument strings passed to trigger function</entry> 
  -->
  <entry>传递给触发器函数的参数字符串个数</entry>
     </row>

     <row>
      <entry><structfield>tgattr</structfield></entry>
      <entry><type>int2vector</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attnum</literal></entry>
      <!-- 
  <entry>Column numbers, if trigger is column-specific; otherwise an
       empty array</entry> 
   -->
   <entry>如果触发器是指定字段的则为字段号；否则为空数组</entry>
     </row>

     <row>
      <entry><structfield>tgargs</structfield></entry>
      <entry><type>bytea</type></entry>
      <entry></entry>
      <!-- 
  <entry>Argument strings to pass to trigger, each NULL-terminated</entry>
  -->
  <entry>传递给触发器的参数字符串，每个都是用 NULL 结尾</entry>
     </row>

     <row>
      <entry><structfield>tgqual</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <!-- 
  <entry>Expression tree (in <function>nodeToString()</function>
       representation) for the trigger's <literal>WHEN</> condition, or null
       if none</entry> 
   -->
   <entry>触发器的<literal>WHEN</>条件的表达式树(用<function>nodeToString()</function>表示)，
   如果没有则为空</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   Currently, column-specific triggering is supported only for
   <literal>UPDATE</> events, and so <structfield>tgattr</> is relevant
   only for that event type.  <structfield>tgtype</structfield> might
   contain bits for other event types as well, but those are presumed
   to be table-wide regardless of what is in <structfield>tgattr</>.
  </para>
-->
<para>
当前，指定字段的触发只支持<literal>UPDATE</>事件，因此<structfield>tgattr</>只和事件类型相关。
<structfield>tgtype</structfield>可能包含一些其他事件类型，
但是假定那些是在表范围的，不管<structfield>tgattr</>里有什么。
</para>

  <note>
   <!--
<para>
    When <structfield>tgconstraint</> is nonzero,
    <structfield>tgconstrrelid</>, <structfield>tgconstrindid</>,
    <structfield>tgdeferrable</>, and <structfield>tginitdeferred</> are
    largely redundant with the referenced <structname>pg_constraint</> entry.
    However, it is possible for a non-deferrable trigger to be associated
    with a deferrable constraint: foreign key constraints can have some
    deferrable and some non-deferrable triggers.
   </para>
-->
<para>
当<structfield>tgconstraint</>非零时，<structfield>tgconstrrelid</>, <structfield>tgconstrindid</>,
 <structfield>tgdeferrable</>, 和 <structfield>tginitdeferred</>与引用的<structname>pg_constraint</>
条目在很大程度上是冗余的。然而，不可延缓的触发器与可延缓的约束关联是可能的：
外键约束可以有一些可延缓和不可延缓的触发器。
</para>
  </note>

  <note>
   <!--
<para>
    <literal>pg_class.relhastriggers</literal>
    must be true if a relation has any triggers in this catalog.
   </para>
-->
<para>
如果一个关系有任何触发器在这个表里，则<literal>pg_class.relhastriggers</literal>必须为真。
</para>
  </note>

 </sect1>


 <sect1 id="catalog-pg-ts-config">
  <title><structname>pg_ts_config</structname></title>

  <indexterm zone="catalog-pg-ts-config">
   <primary>pg_ts_config</primary>
  </indexterm>

  <!--
<para>
   The <structname>pg_ts_config</structname> catalog contains entries
   representing text search configurations.  A configuration specifies
   a particular text search parser and a list of dictionaries to use
   for each of the parser's output token types.  The parser is shown
   in the <structname>pg_ts_config</structname> entry, but the
   token-to-dictionary mapping is defined by subsidiary entries in <link
   linkend="catalog-pg-ts-config-map"><structname>pg_ts_config_map</structname></link>.
  </para>
-->
<para>
<structname>pg_ts_config</structname>表包含表示文本搜索配置的记录。
一个配置指定一个特定的文本搜索解析器和一个为了每个解析器的输出类型使用的字典的列表。
解析器在<structname>pg_ts_config</structname>记录中显示，但是字典映射的标记是由
<link linkend="catalog-pg-ts-config-map"><structname>pg_ts_config_map</structname></link>
里面的辅助记录定义的。
</para>

  <!--
<para>
   <productname>PostgreSQL</productname>'s text search features are
   described at length in <xref linkend="textsearch">.
  </para>
-->
<para>
<productname>PostgreSQL</productname>的文本搜索功能在<xref linkend="textsearch">里面描述。
</para>

  <table>
   <!-- 
   <title><structname>pg_ts_config</> Columns</title> 
   -->
   <title><structname>pg_ts_config</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <!-- 
  <entry>Row identifier (hidden attribute; must be explicitly selected)</entry> 
  -->
  <entry>行标识符(隐藏属性; 必须明确选择)</entry>
     </row>

     <row>
      <entry><structfield>cfgname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <!-- 
  <entry>Text search configuration name</entry>
  -->
  <entry>文本搜索配置名</entry>
     </row>

     <row>
      <entry><structfield>cfgnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   The OID of the namespace that contains this configuration 
   -->
   包含这个配置的名字空间的OID
      </entry>
     </row>

     <row>
      <entry><structfield>cfgowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Owner of the configuration</entry> 
  -->
  <entry>配置的所有者</entry>
     </row>

     <row>
      <entry><structfield>cfgparser</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-ts-parser"><structname>pg_ts_parser</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The OID of the text search parser for this configuration</entry> 
  -->
  <entry>这个配置的文本搜索解析器的OID</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-ts-config-map">
  <title><structname>pg_ts_config_map</structname></title>

  <indexterm zone="catalog-pg-ts-config-map">
   <primary>pg_ts_config_map</primary>
  </indexterm>

  <!--
<para>
   The <structname>pg_ts_config_map</structname> catalog contains entries
   showing which text search dictionaries should be consulted, and in
   what order, for each output token type of each text search configuration's
   parser.
  </para>
-->
<para>
<structname>pg_ts_config_map</structname>表包含为每个文本搜索配置的解析器的每个输出符号类型，
显示哪个文本搜索字典应该被咨询、以什么顺序搜索的记录。
</para>

  <!--
<para>
   <productname>PostgreSQL</productname>'s text search features are
   described at length in <xref linkend="textsearch">.
  </para>
-->
<para>
<productname>PostgreSQL</productname>的文本搜索功能在<xref linkend="textsearch">里描述。
</para>

  <table>
   <!-- 
   <title><structname>pg_ts_config_map</> Columns</title> 
   -->
   <title><structname>pg_ts_config_map</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>mapcfg</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-ts-config"><structname>pg_ts_config</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The OID of the <structname>pg_ts_config</> entry owning this map entry</entry> 
  -->
  <entry>拥有这个映射记录的<structname>pg_ts_config</>记录的OID</entry>
     </row>

     <row>
      <entry><structfield>maptokentype</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <!-- 
  <entry>A token type emitted by the configuration's parser</entry> 
  -->
  <entry>由配置的解析器发出的一个符号类型</entry>
     </row>

     <row>
      <entry><structfield>mapseqno</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <!-- 
  <entry>Order in which to consult this entry (lower
       <structfield>mapseqno</>s first)</entry> 
   -->
   <entry>以什么顺序咨询这个记录 (低<structfield>mapseqno</>为先)</entry>
     </row>

     <row>
      <entry><structfield>mapdict</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-ts-dict"><structname>pg_ts_dict</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The OID of the text search dictionary to consult</entry> 
  -->
  <entry>要咨询的文本搜索字典的OID</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-ts-dict">
  <title><structname>pg_ts_dict</structname></title>

  <indexterm zone="catalog-pg-ts-dict">
   <primary>pg_ts_dict</primary>
  </indexterm>

  <!--
<para>
   The <structname>pg_ts_dict</structname> catalog contains entries
   defining text search dictionaries.  A dictionary depends on a text
   search template, which specifies all the implementation functions
   needed; the dictionary itself provides values for the user-settable
   parameters supported by the template.  This division of labor allows
   dictionaries to be created by unprivileged users.  The parameters
   are specified by a text string <structfield>dictinitoption</>,
   whose format and meaning vary depending on the template.
  </para>
-->
<para>
<structname>pg_ts_dict</structname>表包含定义文本搜索字典的记录。
字典取决于文本搜索模板，该模板声明所有需要的实现函数；
字典本身提供模板支持的用户可设置的参数的值。这种分工允许字典通过非权限用户创建。
参数由文本字符串<structfield>dictinitoption</>指定，参数的格式和意义取决于模板。
</para>

  <!--
<para>
   <productname>PostgreSQL</productname>'s text search features are
   described at length in <xref linkend="textsearch">.
  </para>
-->
<para>
<productname>PostgreSQL</productname>的文本搜索功能在<xref linkend="textsearch">里描述。
</para>

  <table>
   <!-- 
   <title><structname>pg_ts_dict</> Columns</title> 
   -->
   <title><structname>pg_ts_dict</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名子</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <!-- 
  <entry>Row identifier (hidden attribute; must be explicitly selected)</entry> 
  -->
  <entry>行标识符(隐藏属性; 必须明确选择)</entry>
     </row>

     <row>
      <entry><structfield>dictname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <!-- 
  <entry>Text search dictionary name</entry> 
  -->
  <entry>文本搜索字典名</entry>
     </row>

     <row>
      <entry><structfield>dictnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   The OID of the namespace that contains this dictionary 
   -->
   包含这个字段的名字空间的OID
      </entry>
     </row>

     <row>
      <entry><structfield>dictowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Owner of the dictionary</entry> 
  -->
  <entry>字典的所有者</entry>
     </row>

     <row>
      <entry><structfield>dicttemplate</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-ts-template"><structname>pg_ts_template</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The OID of the text search template for this dictionary</entry>
  -->
  <entry>这个字典的文本搜索模板的OID</entry>
     </row>

     <row>
      <entry><structfield>dictinitoption</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <!-- 
  <entry>Initialization option string for the template</entry> 
  -->
  <entry>该模板的初始化选项字符串</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-ts-parser">
  <title><structname>pg_ts_parser</structname></title>

  <indexterm zone="catalog-pg-ts-parser">
   <primary>pg_ts_parser</primary>
  </indexterm>

  <!--
<para>
   The <structname>pg_ts_parser</structname> catalog contains entries
   defining text search parsers.  A parser is responsible for splitting
   input text into lexemes and assigning a token type to each lexeme.
   Since a parser must be implemented by C-language-level functions,
   creation of new parsers is restricted to database superusers.
  </para>
-->
<para>
<structname>pg_ts_parser</structname>表包含定义文本解析器的记录。
解析器负责分裂输入文本为词位，并且为每个词位分配标记类型。
因为解析器必须通过C语言级别的函数实现，所以新解析器的创建局限于数据库超级用户。
</para>

  <!--
<para>
   <productname>PostgreSQL</productname>'s text search features are
   described at length in <xref linkend="textsearch">.
  </para>
-->
<para>
<productname>PostgreSQL</productname>的文本搜索功能在<xref linkend="textsearch">里描述。
</para>

  <table>
   <!-- 
   <title><structname>pg_ts_parser</> Columns</title> 
   -->
   <title><structname>pg_ts_parser</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <!-- 
  <entry>Row identifier (hidden attribute; must be explicitly selected)</entry> 
  -->
  <entry>行标识符(隐藏属性;必须明确选择)</entry>
     </row>

     <row>
      <entry><structfield>prsname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <!-- 
  <entry>Text search parser name</entry> 
  -->
  <entry>文本搜索解析器名</entry>
     </row>

     <row>
      <entry><structfield>prsnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   The OID of the namespace that contains this parser 
   -->
   包含这个解析器的名字空间的OID
      </entry>
     </row>

     <row>
      <entry><structfield>prsstart</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry>OID of the parser's startup function</entry> 
  -->
  <entry>解析器的启动函数的OID</entry>
     </row>

     <row>
      <entry><structfield>prstoken</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry>OID of the parser's next-token function</entry>
  -->
  <entry>解析器的下一个标记函数的OID</entry>
     </row>

     <row>
      <entry><structfield>prsend</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry>OID of the parser's shutdown function</entry> 
  -->
  <entry>解析器的关闭函数的OID</entry>
     </row>

     <row>
      <entry><structfield>prsheadline</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry>OID of the parser's headline function</entry> 
  -->
  <entry>解析器的标题函数的OID</entry>
     </row>

     <row>
      <entry><structfield>prslextype</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry>OID of the parser's lextype function</entry> 
  -->
  <entry>解析器的lextype函数的OID</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-ts-template">
  <title><structname>pg_ts_template</structname></title>

  <indexterm zone="catalog-pg-ts-template">
   <primary>pg_ts_template</primary>
  </indexterm>

  <!--
<para>
   The <structname>pg_ts_template</structname> catalog contains entries
   defining text search templates.  A template is the implementation
   skeleton for a class of text search dictionaries.
   Since a template must be implemented by C-language-level functions,
   creation of new templates is restricted to database superusers.
  </para>
-->
<para>
<structname>pg_ts_template</structname>表包含定义文本搜索模板的记录。
模板是文本搜索字典的类的实现框架。因为模板必须通过C语言级别的函数实现，
索引新模板的创建局限于数据库超级用户。
</para>

  <!--
<para>
   <productname>PostgreSQL</productname>'s text search features are
   described at length in <xref linkend="textsearch">.
  </para>
-->
<para>
<productname>PostgreSQL</productname>的文本搜索功能在<xref linkend="textsearch">里描述。
</para>

  <table>
   <!-- 
   <title><structname>pg_ts_template</> Columns</title> 
   -->
   <title><structname>pg_ts_template</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <!-- 
  <entry>Row identifier (hidden attribute; must be explicitly selected)</entry> 
  -->
  <entry>行标识符(隐藏属性；必须明确选择)</entry>
     </row>

     <row>
      <entry><structfield>tmplname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <!-- 
  <entry>Text search template name</entry> 
  -->
  <entry>文本搜索模板名</entry>
     </row>

     <row>
      <entry><structfield>tmplnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   The OID of the namespace that contains this template 
   -->
   包含这个模板的名字空间的OID
      </entry>
     </row>

     <row>
      <entry><structfield>tmplinit</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry>OID of the template's initialization function</entry>
  -->
  <entry>模板的初始化函数的OID</entry>
     </row>

     <row>
      <entry><structfield>tmpllexize</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry>OID of the template's lexize function</entry> 
  -->
  <entry>模板的lexize函数的OID</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="catalog-pg-type">
  <title><structname>pg_type</structname></title>

  <indexterm zone="catalog-pg-type">
   <primary>pg_type</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_type</structname> stores information about data
   types.  Base types and enum types (scalar types) are created with
   <xref linkend="sql-createtype">, and
   domains with
   <xref linkend="sql-createdomain">.
   A composite type is automatically created for each table in the database, to
   represent the row structure of the table.  It is also possible to create
   composite types with <command>CREATE TYPE AS</command>.
  </para>
-->
<para>
<structname>pg_type</structname>存储有关数据类型的信息。基本类型和枚举类型(标量类型)是用
<xref linkend="sql-createtype">创建的，域是使用<xref linkend="sql-createdomain">创建的。
同时还为数据库中每个表自动创建一个复合类型，以表示该表的行结构。还可以用
<command>CREATE TYPE AS</command>创建复合类型。
</para>

  <table>
   <!-- 
   <title><structname>pg_type</> Columns</title> 
   -->
   <title><structname>pg_type</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <!-- 
  <entry>Row identifier (hidden attribute; must be explicitly selected)</entry> 
  -->
  <entry>行标识符(隐藏属性；必须明确选择)</entry>
     </row>

     <row>
      <entry><structfield>typname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <!-- 
  <entry>Data type name</entry> 
  -->
  <entry>数据类型名</entry>
     </row>

     <row>
      <entry><structfield>typnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   The OID of the namespace that contains this type 
   -->
   包含这个类型的名字空间的OID
      </entry>
     </row>

     <row>
      <entry><structfield>typowner</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Owner of the type</entry> 
  -->
  <entry>该类型的所有者</entry>
     </row>

     <row>
      <entry><structfield>typlen</structfield></entry>
      <entry><type>int2</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   For a fixed-size type, <structfield>typlen</structfield> is the number
       of bytes in the internal representation of the type.  But for a
       variable-length type, <structfield>typlen</structfield> is negative.
       -1 indicates a <quote>varlena</> type (one that has a length word),
       -2 indicates a null-terminated C string. 
   -->
   对于定长类型是该类型内部表现形式的字节数目。对于变长类型是负数。
   -1 表示一种<quote>变长</>类型(有长度字属性的数据)，
   -2 表示这是一个 NULL 结尾的 C 字符串。
      </entry>
     </row>

     <row>
      <entry><structfield>typbyval</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   <structfield>typbyval</structfield> determines whether internal
       routines pass a value of this type by value or by reference.
       <structfield>typbyval</structfield> had better be false if
       <structfield>typlen</structfield> is not 1, 2, or 4 (or 8 on machines
       where Datum is 8 bytes).
       Variable-length types are always passed by reference. Note that
       <structfield>typbyval</structfield> can be false even if the
       length would allow pass-by-value. 
   -->
   判断内部过程传递这个类型的数值时是通过传值还是传引用。
   如果该类型不是 1, 2, 4, 8 字节长将只能按引用传递，因此 typbyval 最好是假。
   即使可以传值，typbyval 也可以为假。
      </entry>
     </row>

     <row>
      <entry><structfield>typtype</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   <structfield>typtype</structfield> is
       <literal>b</literal> for a base type,
       <literal>c</literal> for a composite type (e.g., a table's row type),
       <literal>d</literal> for a domain,
       <literal>e</literal> for an enum type,
       <literal>p</literal> for a pseudo-type, or
       <literal>r</literal> for a range type.
       See also <structfield>typrelid</structfield> and
       <structfield>typbasetype</structfield>.
   -->
   对于基础类型是<literal>b</literal>，对于复合类型是<literal>c</literal>
   (比如，一个表的行类型)。对于域类型是<literal>d</literal>，对于枚举类型是<literal>e</literal>，
   对于伪类型是<literal>p</literal>，对于范围类型是<literal>r</literal>。
   又见<structfield>typrelid</structfield>和<structfield>typbasetype</structfield>。
      </entry>
     </row>

     <row>
      <entry><structfield>typcategory</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   <structfield>typcategory</structfield> is an arbitrary classification
       of data types that is used by the parser to determine which implicit
       casts should be <quote>preferred</>.
       See <xref linkend="catalog-typcategory-table">.
   -->
   <structfield>typcategory</structfield>是数据类型的任意分类，
   该数据类型被触发器用来决定哪种隐式转换应该是<quote>首选</>。
   参阅<xref linkend="catalog-typcategory-table">。
      </entry>
     </row>

     <row>
      <entry><structfield>typispreferred</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   True if the type is a preferred cast target within its
       <structfield>typcategory</structfield> 
   -->
   如果类型在它的<structfield>typcategory</structfield> 里是首选转换目标则为真。
      </entry>
     </row>

     <row>
      <entry><structfield>typisdefined</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   True if the type is defined, false if this is a placeholder
       entry for a not-yet-defined type.  When
       <structfield>typisdefined</structfield> is false, nothing
       except the type name, namespace, and OID can be relied on. 
   -->
   如果定义了类型则为真，如果是一种尚未定义的类型的占位符则为假。如果为假，
   那么除了该类型名称，名字空间，和 OID 之外没有可靠的信息。
      </entry>
     </row>

     <row>
      <entry><structfield>typdelim</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Character that separates two values of this type when parsing
       array input.  Note that the delimiter is associated with the array
       element data type, not the array data type.
   -->
   当分析数组输入时，分隔两个此类型数值的字符。请注意该分隔符是与数组元素数据类型相关联的，
   而不是和数组数据类型关联。
      </entry>
     </row>

     <row>
      <entry><structfield>typrelid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   If this is a composite type (see
       <structfield>typtype</structfield>), then this column points to
       the <structname>pg_class</structname> entry that defines the
       corresponding table.  (For a free-standing composite type, the
       <structname>pg_class</structname> entry doesn't really represent
       a table, but it is needed anyway for the type's
       <structname>pg_attribute</structname> entries to link to.)
       Zero for non-composite types. 
   -->
   如果是复合类型(见<structfield>typtype</structfield>)那么这个字段指向<structname>pg_class</structname>
   中定义该表的行。对于自由存在的复合类型，<structname>pg_class</structname>记录并不表示一个表，
   但是总需要它来查找该类型连接的<structname>pg_attribute</structname>记录。对于非复合类型为零。
      </entry>
     </row>

     <row>
      <entry><structfield>typelem</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   If <structfield>typelem</structfield> is not 0 then it
       identifies another row in <structname>pg_type</structname>.
       The current type can then be subscripted like an array yielding
       values of type <structfield>typelem</structfield>.  A
       <quote>true</quote> array type is variable length
       (<structfield>typlen</structfield> = -1),
       but some fixed-length (<structfield>typlen</structfield> &gt; 0) types
       also have nonzero <structfield>typelem</structfield>, for example
       <type>name</type> and <type>point</type>.
       If a fixed-length type has a <structfield>typelem</structfield> then
       its internal representation must be some number of values of the
       <structfield>typelem</structfield> data type with no other data.
       Variable-length array types have a header defined by the array
       subroutines. 
   -->
   如果不为 0 ，那么它标识<structname>pg_type</structname>里面的另外一行。
   当前类型可以像一个数组产生类型为<structfield>typelem</structfield>的值一样当做下标。
   一个<quote>真正的</quote>数组类型是变长的(<structfield>typlen</structfield> = -1)，
   但是一些定长的(<structfield>typlen</structfield> &gt; 0)类型也拥有非零的<structfield>typelem</structfield>
   (比如<type>name</type>和<type>point</type>)。如果一个定长类型拥有一个<structfield>typelem</structfield>，
   那么他的内部形式必须是<structfield>typelem</structfield>数据类型的某个数目的个数值，
   不能有其它数据。变长数组类型有一个该数组子过程定义的头(文件)。
      </entry>
     </row>

     <row>
      <entry><structfield>typarray</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   If <structfield>typarray</structfield> is not 0 then it
       identifies another row in <structname>pg_type</structname>, which
       is the <quote>true</quote> array type having this type as element
   -->
   如果<structfield>typarray</structfield>非零，那么它在<structname>pg_type</structname>
   里定义另外一行，该行是将这个类型作为元素的<quote>真正的</quote>数组类型。
      </entry>
     </row>

     <row>
      <entry><structfield>typinput</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Input conversion function (text format)</entry> 
  -->
  <entry>输入转换函数(文本格式)</entry>
     </row>

     <row>
      <entry><structfield>typoutput</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Output conversion function (text format)</entry> 
  -->
  <entry>输出转换函数(文本格式)</entry>
     </row>

     <row>
      <entry><structfield>typreceive</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Input conversion function (binary format), or 0 if none</entry> 
  -->
  <entry>输入转换函数(二进制格式)，如果没有则为 0</entry>
     </row>

     <row>
      <entry><structfield>typsend</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Output conversion function (binary format), or 0 if none</entry> 
  -->
  <entry>输出转换函数(二进制格式)，如果没有则为 0</entry>
     </row>

     <row>
      <entry><structfield>typmodin</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Type modifier input function, or 0 if type does not support modifiers</entry> 
  -->
  <entry>类型修饰符输入函数，如果类型不支持修饰符则为0</entry>
     </row>

     <row>
      <entry><structfield>typmodout</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Type modifier output function, or 0 to use the standard format</entry> 
  -->
  <entry>类型修饰符输出函数，如果使用标准格式则为0</entry>
     </row>

     <row>
      <entry><structfield>typanalyze</structfield></entry>
      <entry><type>regproc</type></entry>
      <entry><literal><link linkend="catalog-pg-proc"><structname>pg_proc</structname></link>.oid</literal></entry>
      <!-- 
  <entry>Custom <command>ANALYZE</command> function, or 0 to use the standard function</entry> 
  -->
  <entry>自定义的<command>ANALYZE</command>函数，如果使用标准函数，则为 0</entry>
     </row>

     <row>
      <entry><structfield>typalign</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry><!--
<para>

       <structfield>typalign</structfield> is the alignment required
       when storing a value of this type.  It applies to storage on
       disk as well as most representations of the value inside
       <productname>PostgreSQL</>.
       When multiple values are stored consecutively, such
       as in the representation of a complete row on disk, padding is
       inserted before a datum of this type so that it begins on the
       specified boundary.  The alignment reference is the beginning
       of the first datum in the sequence.
      </para>
-->
<para>
当存储此类型的数值时要求的对齐性质。它应用于磁盘存储以及该值在<productname>PostgreSQL</>
内部的大多数形式。如果数值是连续存放的，比如在磁盘上以完全的裸数据的形式存放时，
那么先在此类型的数据前填充空白，这样它就可以按照要求的界限存储。对齐引用是该序列中第一个数据的开头。
</para>

      
<para>
       <!-- 
   Possible values are: 
   -->
   可能的值有：
       <itemizedlist>
        <listitem>
<!--
         <para><literal>c</> = <type>char</type> alignment, i.e., no alignment needed.</para>
-->
<para>
<literal>c</> = <type>char</type>对齐，也就是不需要对齐。
</para>
        </listitem>
        <listitem>
         <!--
<para><literal>s</> = <type>short</type> alignment (2 bytes on most machines).</para>
-->
<para>
<literal>s</> = <type>short</type>对齐(在大多数机器上是 2 字节)
</para>
        </listitem>
        <listitem>
         <!--
<para><literal>i</> = <type>int</type> alignment (4 bytes on most machines).</para>
-->
<para>
<literal>i</> = <type>int</type>对齐(在大多数机器上是 4 字节)
</para>
        </listitem>
        <listitem>
         <!--
<para><literal>d</> = <type>double</type> alignment (8 bytes on many machines, but by no means all).</para>
-->
<para>
<literal>d</> = <type>double</type>对齐(在大多数机器上是 8 字节，但不一定是全部)
</para>
        </listitem>
       </itemizedlist>
      </para><note>
       <!--
<para>
        For types used in system tables, it is critical that the size
        and alignment defined in <structname>pg_type</structname>
        agree with the way that the compiler will lay out the column in
        a structure representing a table row.
       </para>
-->
<para>
对于在系统表里使用的类型，在<structname>pg_type</structname>
里定义的尺寸和对齐必须和编译器在一个表示表的一行的结构里的布局一样。
</para>
      </note></entry>
     </row>

     <row>
      <entry><structfield>typstorage</structfield></entry>
      <entry><type>char</type></entry>
      <entry></entry>
      <entry>
<para>
<!-- 
       <structfield>typstorage</structfield> tells for varlena
       types (those with <structfield>typlen</structfield> = -1) if
       the type is prepared for toasting and what the default strategy
       for attributes of this type should be.
       Possible values are 
   -->
   告诉一个变长类型(那些有<structfield>typlen</structfield> = -1的)
   说该类型是否准备好应付非常规值，以及对这种类型的属性的缺省策略是什么。可能的值有
       <itemizedlist>
        <listitem>
<!--
         <para><literal>p</>: Value must always be stored plain.</para>
-->
<para>
<literal>p</>:数值总是以简单方式存储
</para>
        </listitem>
        <listitem>
         <!--
<para>
          <literal>e</>: Value can be stored in a <quote>secondary</quote>
          relation (if relation has one, see
          <literal>pg_class.reltoastrelid</literal>).
         </para>
-->
<para>
<literal>e</>: 数值可以存储在一个<quote>次要</quote>关系中(如果该关系有这么一个，
参阅<literal>pg_class.reltoastrelid</literal>)
</para>
        </listitem>
        <listitem>
         <!--
<para><literal>m</>: Value can be stored compressed inline.</para>
-->
<para>
<literal>m</>: 数值可以以内联的压缩方式存储
</para>
        </listitem>
        <listitem>
         <!--
<para><literal>x</>: Value can be stored compressed inline or stored in <quote>secondary</quote> storage.</para>
-->
<para>
<literal>x</>: 数值可以以内联的压缩方式或者在<quote>次要</quote>表里存储。
</para>
        </listitem>
       </itemizedlist>
       <!-- 
   Note that <literal>m</> columns can also be moved out to secondary
       storage, but only as a last resort (<literal>e</> and <literal>x</> columns are
       moved first). 
   -->
   请注意<literal>m</>域也可以移到从属表里存储，但只是最后的解决方法
   (<literal>e</>和<literal>x</>域先移走)。
      </para></entry>
     </row>

     <row>
      <entry><structfield>typnotnull</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry><!--
<para>
       <structfield>typnotnull</structfield> represents a not-null
       constraint on a type.  Used for domains only.
      </para>
-->
<para>
代表在某类型上的一个 NOTNULL 约束。目前只用于域。
</para></entry>
     </row>

     <row>
      <entry><structfield>typbasetype</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-type"><structname>pg_type</structname></link>.oid</literal></entry>
      <entry><!--
<para>
       If this is a domain (see <structfield>typtype</structfield>), then
       <structfield>typbasetype</structfield> identifies the type that this
       one is based on.  Zero if this type is not a domain.
      </para>
-->
<para>
如果这是一个域(参阅<structfield>typtype</structfield>)，
那么标识作为这个类型的基础的类型。如果不是域则为零。
</para></entry>
     </row>

     <row>
      <entry><structfield>typtypmod</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry><!--
<para>
       Domains use <structfield>typtypmod</structfield> to record the <literal>typmod</>
       to be applied to their base type (-1 if base type does not use a
       <literal>typmod</>).  -1 if this type is not a domain.
      </para>
-->
<para>
域使用<structfield>typtypmod</structfield>记录要作用到它们的基础类型上的<literal>typmod</>
(如果基础类型不使用<literal>typmod</>则为 -1)。如果这种类型不是域，那么为 -1 。
</para></entry>
     </row>

     <row>
      <entry><structfield>typndims</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry><!--
<para>
       <structfield>typndims</structfield> is the number of array dimensions
       for a domain over an array (that is, <structfield>typbasetype</> is
       an array type).
       Zero for types other than domains over array types.
       </para>
-->
<para>
如果是一个域数组，那么<structfield>typndims</structfield>是数组维数的数值(也就是说，
<structfield>typbasetype</>是一个数组类型）。非域非数组类型为零。

</para></entry>
     </row>

     <row>
      <entry><structfield>typcollation</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-collation"><structname>pg_collation</structname></link>.oid</literal></entry>
      <entry><!--
<para>
       <structfield>typcollation</structfield> specifies the collation
       of the type.  If the type does not support collations, this will
       be zero.  A base type that supports collations will have
       <symbol>DEFAULT_COLLATION_OID</symbol> here.  A domain over a
       collatable type can have some other collation OID, if one was
       specified for the domain.
      </para>
-->
<para>
指定类型的排序规则。如果类型不支持排序，则为0。一个支持排序的基础类型将有
<symbol>DEFAULT_COLLATION_OID</symbol>。一个可排序类型的域可以有一些其他排序OID，
如果为该域指定了一个的话。
</para></entry>
     </row>

     <row>
      <entry><structfield>typdefaultbin</structfield></entry>
      <entry><type>pg_node_tree</type></entry>
      <entry></entry>
      <entry><!--
<para>
       If <structfield>typdefaultbin</> is not null, it is the
       <function>nodeToString()</function>
       representation of a default expression for the type.  This is
       only used for domains.
      </para>
-->
<para>
如果为非 NULL ，那么它是该类型缺省表达式的<function>nodeToString()</function>表现形式。
目前这个字段只用于域。
</para></entry>
     </row>

     <row>
      <entry><structfield>typdefault</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry><!--
<para>
       <structfield>typdefault</> is null if the type has no associated
       default value. If <structfield>typdefaultbin</> is not null,
       <structfield>typdefault</> must contain a human-readable version of the
       default expression represented by <structfield>typdefaultbin</>.  If
       <structfield>typdefaultbin</> is null and <structfield>typdefault</> is
       not, then <structfield>typdefault</> is the external representation of
       the type's default value, which can be fed to the type's input
       converter to produce a constant.
      </para>
-->
<para>
如果某类型没有相关缺省值，那么<structfield>typdefault</>是 NULL 。如果<structfield>typdefaultbin</>
不是 NULL ，那么<structfield>typdefault</>必须包含一个<structfield>typdefaultbin</>
代表的缺省表达式的人类可读的版本。如果<structfield>typdefaultbin</>为 NULL 但<structfield>typdefault</>
不是，那么<structfield>typdefault</>是该类型缺省值的外部表现形式，
可以把它交给该类型的输入转换器生成一个常量。
</para></entry>
     </row>

     <row>
      <entry><structfield>typacl</structfield></entry>
      <entry><type>aclitem[]</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Access privileges; see
       <xref linkend="sql-grant"> and
       <xref linkend="sql-revoke">
       for details 
   -->
   访问权限；参阅<xref linkend="sql-grant">和<xref linkend="sql-revoke">获取细节。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   <xref linkend="catalog-typcategory-table"> lists the system-defined values
   of <structfield>typcategory</>.  Any future additions to this list will
   also be upper-case ASCII letters.  All other ASCII characters are reserved
   for user-defined categories.
  </para>
-->
<para>
<xref linkend="catalog-typcategory-table">列出了系统定义的<structfield>typcategory</>的值。
任何未来添加到这个列表的也是大写的ASCII字母。所有其他ASCII字符为用户定义的范畴保留。
</para>

  <table id="catalog-typcategory-table">
   <!-- 
   <title><structfield>typcategory</> Codes</title> 
   -->
   <title><structfield>typcategory</> 代码</title>

   <tgroup cols="2">
    <thead>
     <row>
      <!-- 
  <entry>Code</entry>
      <entry>Category</entry> 
  -->
  <entry>代码</entry>
      <entry>种类</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal>A</literal></entry>
      <!-- 
  <entry>Array types</entry> 
  -->
  <entry>数组类型</entry> 
     </row>
     <row>
      <entry><literal>B</literal></entry>
      <!-- 
  <entry>Boolean types</entry> 
  -->
  <entry>布尔类型</entry>
     </row>
     <row>
      <entry><literal>C</literal></entry>
      <!-- 
  <entry>Composite types</entry> 
  -->
  <entry>复合类型</entry>
     </row>
     <row>
      <entry><literal>D</literal></entry>
      <!-- 
  <entry>Date/time types</entry> 
  -->
  <entry>日期/时间类型</entry>
     </row>
     <row>
      <entry><literal>E</literal></entry>
      <!-- 
  <entry>Enum types</entry> 
  -->
  <entry>枚举类型</entry>
     </row>
     <row>
      <entry><literal>G</literal></entry>
      <!-- 
  <entry>Geometric types</entry> 
  -->
  <entry>几何类型</entry>
     </row>
     <row>
      <entry><literal>I</literal></entry>
      <!-- 
  <entry>Network address types</entry> 
  -->
  <entry>网络地址类型</entry>
     </row>
     <row>
      <entry><literal>N</literal></entry>
      <!-- 
  <entry>Numeric types</entry> 
  -->
  <entry>数值类型</entry>
     </row>
     <row>
      <entry><literal>P</literal></entry>
      <!-- 
  <entry>Pseudo-types</entry>
  -->
  <entry>伪类型</entry>
     </row>
     <row>
      <entry><literal>R</literal></entry>
      <!-- 
  <entry>Range types</entry> 
  -->
  <entry>范围类型</entry>
     </row>
     <row>
      <entry><literal>S</literal></entry>
      <!-- 
  <entry>String types</entry> 
  -->
  <entry>字符串类型</entry>
     </row>
     <row>
      <entry><literal>T</literal></entry>
      <!-- 
  <entry>Timespan types</entry> 
  -->
  <entry>时间间隔类型</entry>
     </row>
     <row>
      <entry><literal>U</literal></entry>
      <!-- 
  <entry>User-defined types</entry> 
  -->
  <entry>用户定义类型</entry>
     </row>
     <row>
      <entry><literal>V</literal></entry>
      <!-- 
  <entry>Bit-string types</entry> 
  -->
  <entry>位串类型</entry>
     </row>
     <row>
      <entry><literal>X</literal></entry>
      <!-- 
  <entry><type>unknown</> type</entry> 
  -->
  <entry><type>未知</> 类型</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>


 <sect1 id="catalog-pg-user-mapping">
  <title><structname>pg_user_mapping</structname></title>

  <indexterm zone="catalog-pg-user-mapping">
   <primary>pg_user_mapping</primary>
  </indexterm>

  <!--
<para>
   The catalog <structname>pg_user_mapping</structname> stores
   the mappings from local user to remote.  Access to this catalog is
   restricted from normal users, use the view
   <link linkend="view-pg-user-mappings"><structname>pg_user_mappings</structname></link>
   instead.
  </para>
-->
<para>
<structname>pg_user_mapping</structname>表存储从本地用户到远程的映射。
普通用户访问这个表是受到限制的，使用视图访问
<link linkend="view-pg-user-mappings"><structname>pg_user_mappings</structname></link>。
</para>

  <table>
  <!-- 
  <title><structname>pg_user_mapping</> Columns</title> 
  -->
   <title><structname>pg_user_mapping</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry></entry>
      <!-- 
  <entry>Row identifier (hidden attribute; must be explicitly selected)</entry> 
  -->
  <entry>行标识符(隐藏属性；必须明确选择)</entry>
     </row>

     <row>
      <entry><structfield>umuser</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <!-- 
  <entry>OID of the local role being mapped, 0 if the user mapping is public</entry> 
  -->
  <entry>被映射的本地用户的OID，如果用户映射是公共的则为0</entry>
     </row>

     <row>
      <entry><structfield>umserver</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-foreign-server"><structname>pg_foreign_server</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   The OID of the foreign server that contains this mapping 
   -->
   包含这个映射的外部服务器的OID
      </entry>
     </row>

     <row>
      <entry><structfield>umoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   User mapping specific options, as <quote>keyword=value</> strings 
   -->
   用户映射指定选项，使用<quote>keyword=value</>格式的字符串
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="views-overview">
  <!-- 
  <title>System Views</title> 
  -->
  <title>系统视图</title>

  <!--
<para>
   In addition to the system catalogs, <productname>PostgreSQL</productname>
   provides a number of built-in views.  Some system views provide convenient
   access to some commonly used queries on the system catalogs.  Other views
   provide access to internal server state.
  </para>
-->
<para>
除了系统表之外，<productname>PostgreSQL</productname>还提供了一系列内置的视图。
系统视图提供了查询系统表的一些便利的访问方法。
其它一些视图提供了访问内部服务器状态的方法。
</para>

  <!--
<para>
   The information schema (<xref linkend="information-schema">) provides
   an alternative set of views which overlap the functionality of the system
   views.  Since the information schema is SQL-standard whereas the views
   described here are <productname>PostgreSQL</productname>-specific,
   it's usually better to use the information schema if it provides all
   the information you need.
  </para>
-->
<para>
信息模式(<xref linkend="information-schema">)提供了另外一套视图，
它的功能覆盖了系统视图的功能。因为信息模式是 SQL 标准，
而这里描述的视图是<productname>PostgreSQL</productname>特有的，
所以最好用信息模式来获取自己需要的所有信息。
</para>

  <!--
<para>
   <xref linkend="view-table"> lists the system views described here.
   More detailed documentation of each view follows below.
   There are some additional views that provide access to the results of
   the statistics collector; they are described in <xref
   linkend="monitoring-stats-views-table">.
  </para>
-->
<para>
<xref linkend="view-table">列出了这里描述的所有系统视图。下面是每个视图更详细的信息。
有些视图提供了对统计收集器的结果的访问；他们在<xref linkend="monitoring-stats-views-table">里列出。
</para>

  <!--
<para>
   Except where noted, all the views described here are read-only.
  </para>
-->
<para>
除了特别声明的，这里描述的所有视图都是只读的。
</para>

  <table id="view-table">
   <!-- 
   <title>System Views</title> 
   -->
   <title>系统视图</title>

   <tgroup cols="2">
    <thead>
     <row>
      <!-- 
  <entry>View Name</entry>
      <entry>Purpose</entry>
  -->
  <entry>视图名</entry>
      <entry>用途</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><link linkend="view-pg-available-extensions"><structname>pg_available_extensions</structname></link></entry>
      <!-- 
  <entry>available extensions</entry> 
  -->
  <entry>可用的扩展</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-available-extension-versions"><structname>pg_available_extension_versions</structname></link></entry>
      <!-- 
  <entry>available versions of extensions</entry> 
  -->
  <entry>可用扩展的版本</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-cursors"><structname>pg_cursors</structname></link></entry>
      <!-- 
  <entry>open cursors</entry> 
  -->
  <entry>打开的游标</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-group"><structname>pg_group</structname></link></entry>
      <!-- 
  <entry>groups of database users</entry> 
  -->
  <entry>数据库用户的组</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-indexes"><structname>pg_indexes</structname></link></entry>
      <!-- 
  <entry>indexes</entry>
  -->
  <entry>索引</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-locks"><structname>pg_locks</structname></link></entry>
      <!-- 
  <entry>currently held locks</entry> 
  -->
  <entry>当前持有的锁</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-matviews"><structname>pg_matviews</structname></link></entry>
      <!-- 
  <entry>materialized views</entry> 
  -->
  <entry>物化视图</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-prepared-statements"><structname>pg_prepared_statements</structname></link></entry>
      <!-- 
  <entry>prepared statements</entry> 
  -->
  <entry>预备语句</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-prepared-xacts"><structname>pg_prepared_xacts</structname></link></entry>
      <!-- 
  <entry>prepared transactions</entry> 
  -->
  <entry>预备事务</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-roles"><structname>pg_roles</structname></link></entry>
      <!-- 
  <entry>database roles</entry> 
  -->
  <entry>数据库角色</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-rules"><structname>pg_rules</structname></link></entry>
      <!--
  <entry>rules</entry>
  -->
  <entry>规则</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-seclabels"><structname>pg_seclabels</structname></link></entry>
      <!-- 
  <entry>security labels</entry> 
  -->
  <entry>安全标签</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-settings"><structname>pg_settings</structname></link></entry>
      <!-- 
  <entry>parameter settings</entry> 
  -->
  <entry>参数设置</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-shadow"><structname>pg_shadow</structname></link></entry>
      <!-- 
  <entry>database users</entry> 
  -->
  <entry>数据库用户</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-stats"><structname>pg_stats</structname></link></entry>
      <!-- 
  <entry>planner statistics</entry> 
  -->
  <entry>规划器统计</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-tables"><structname>pg_tables</structname></link></entry>
      <!-- 
  <entry>tables</entry>
  -->
  <entry>表</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-timezone-abbrevs"><structname>pg_timezone_abbrevs</structname></link></entry>
      <!-- 
  <entry>time zone abbreviations</entry>
  -->
  <entry>时区缩写</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-timezone-names"><structname>pg_timezone_names</structname></link></entry>
      <!-- 
  <entry>time zone names</entry> 
  -->
  <entry>时区名</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-user"><structname>pg_user</structname></link></entry>
      <!-- 
  <entry>database users</entry>
  -->
  <entry>数据库用户</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-user-mappings"><structname>pg_user_mappings</structname></link></entry>
      <!-- 
  <entry>user mappings</entry> 
  -->
  <entry>用户映射</entry>
     </row>

     <row>
      <entry><link linkend="view-pg-views"><structname>pg_views</structname></link></entry>
      <!-- 
  <entry>views</entry> 
  -->
  <entry>视图</entry>
     </row>

    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="view-pg-available-extensions">
  <title><structname>pg_available_extensions</structname></title>

  <indexterm zone="view-pg-available-extensions">
   <primary>pg_available_extensions</primary>
  </indexterm>

  <!--
<para>
   The <structname>pg_available_extensions</structname> view lists the
   extensions that are available for installation.
   See also the
   <link linkend="catalog-pg-extension"><structname>pg_extension</structname></link>
   catalog, which shows the extensions currently installed.
  </para>
-->
<para>
<structname>pg_available_extensions</structname>视图列出了可用于安装的扩展。
又见<link linkend="catalog-pg-extension"><structname>pg_extension</structname></link>表，
显示了当前安装了的扩展。
</para>

  <table>
   <!-- 
   <title><structname>pg_available_extensions</> Columns</title> 
   -->
   <title><structname>pg_available_extensions</> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>name</type></entry>
      <!-- 
  <entry>Extension name</entry> 
  -->
  <entry>扩展名</entry>
     </row>

     <row>
      <entry><structfield>default_version</structfield></entry>
      <entry><type>text</type></entry>
      <!-- 
  <entry>Name of default version, or <literal>NULL</literal> if none is
       specified</entry>
   -->
   <entry>缺省版本的名字，如果没有指定则为<literal>NULL</literal></entry>
     </row>

     <row>
      <entry><structfield>installed_version</structfield></entry>
      <entry><type>text</type></entry>
      <!-- 
  <entry>Currently installed version of the extension,
       or <literal>NULL</literal> if not installed</entry> 
   -->
   <entry>扩展当前安装版本，如果没有安装任何版本则为<literal>NULL</literal></entry>
     </row>

     <row>
      <entry><structfield>comment</structfield></entry>
      <entry><type>text</type></entry>
      <!-- 
  <entry>Comment string from the extension's control file</entry> 
  -->
  <entry>扩展的控制文件中的评论字符串</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   The <structname>pg_available_extensions</structname> view is read only.
  </para>
-->
<para>
<structname>pg_available_extensions</structname>视图是只读的。
</para>
 </sect1>

 <sect1 id="view-pg-available-extension-versions">
  <title><structname>pg_available_extension_versions</structname></title>

  <indexterm zone="view-pg-available-extension-versions">
   <primary>pg_available_extension_versions</primary>
  </indexterm>

  <!--
<para>
   The <structname>pg_available_extension_versions</structname> view lists the
   specific extension versions that are available for installation.
   See also the <link
   linkend="catalog-pg-extension"><structname>pg_extension</structname></link>
   catalog, which shows the extensions currently installed.
  </para>
-->
<para>
<structname>pg_available_extension_versions</structname>视图列出了可用于安装的指定扩展版本。
又见<link linkend="catalog-pg-extension"><structname>pg_extension</structname></link>表，
显示了当前安装了的扩展。
</para>

  <table>
   <!-- 
   <title><structname>pg_available_extension_versions</> Columns</title> 
   -->
   <title><structname>pg_available_extension_versions</> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>name</type></entry>
      <!-- 
  <entry>Extension name</entry> 
  -->
  <entry>扩展名</entry>
     </row>

     <row>
      <entry><structfield>version</structfield></entry>
      <entry><type>text</type></entry>
      <!-- 
  <entry>Version name</entry> 
  -->
  <entry>版本名</entry>
     </row>

     <row>
      <entry><structfield>installed</structfield></entry>
      <entry><type>bool</type></entry>
      <!-- 
  <entry>True if this version of this extension is currently
       installed</entry> 
   -->
   <entry>如果这个扩展的这个版本是当前已经安装了的则为真</entry>
     </row>

     <row>
      <entry><structfield>superuser</structfield></entry>
      <entry><type>bool</type></entry>
      <!-- 
  <entry>True if only superusers are allowed to install this extension</entry> 
  -->
  <entry>如果只允许超级用户安装这个扩展则为真</entry>
     </row>

     <row>
      <entry><structfield>relocatable</structfield></entry>
      <entry><type>bool</type></entry>
      <!-- 
  <entry>True if extension can be relocated to another schema</entry> 
  -->
  <entry>如果扩展可以重新加载到另一个模式则为真</entry>
     </row>

     <row>
      <entry><structfield>schema</structfield></entry>
      <entry><type>name</type></entry>
      <!-- 
  <entry>Name of the schema that the extension must be installed into,
       or <literal>NULL</literal> if partially or fully relocatable</entry> 
   -->
   <entry>扩展必须安装到的模式名，如果部分或全部可重新定位则为<literal>NULL</literal></entry>
     </row>

     <row>
      <entry><structfield>requires</structfield></entry>
      <entry><type>name[]</type></entry>
      <!-- 
  <entry>Names of prerequisite extensions,
       or <literal>NULL</literal> if none</entry>
   -->
   <entry>先决条件扩展的名字，如果没有则为<literal>NULL</literal></entry>
     </row>

     <row>
      <entry><structfield>comment</structfield></entry>
      <entry><type>text</type></entry>
      <!-- 
  <entry>Comment string from the extension's control file</entry> 
  -->
  <entry>扩展的控制文件中的评论字符串</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   The <structname>pg_available_extension_versions</structname> view is read
   only.
  </para>
-->
<para>
<structname>pg_available_extension_versions</structname>是只读的。
</para>
 </sect1>

 <sect1 id="view-pg-cursors">
  <title><structname>pg_cursors</structname></title>

  <indexterm zone="view-pg-cursors">
   <primary>pg_cursors</primary>
  </indexterm>

  
<para>
<!-- 
   The <structname>pg_cursors</structname> view lists the cursors that
   are currently available. Cursors can be defined in several ways:
   -->
   <structname>pg_cursors</structname>列出了当前可用的游标。游标可以用几种不同的方法定义：
   <itemizedlist>
    <listitem>
<!--
     <para>
      via the <xref linkend="sql-declare">
      statement in SQL
     </para>
-->
<para>
通过<xref linkend="sql-declare">语句
</para>
    </listitem>

    <listitem>
     <!--
<para>
      via the Bind message in the frontend/backend protocol, as
      described in <xref linkend="protocol-flow-ext-query">
     </para>
-->
<para>
在前/后端协议中通过 Bind 信息，具体在<xref linkend="protocol-flow-ext-query">中描述。
</para>
    </listitem>

    <listitem>
     <!--
<para>
      via the Server Programming Interface (SPI), as described in
      <xref linkend="spi-interface">
     </para>
-->
<para>
通过服务器编程接口(SPI)，具体在<xref linkend="spi-interface">中描述。
</para>
    </listitem>
   </itemizedlist>

<!-- 
   The <structname>pg_cursors</structname> view displays cursors
   created by any of these means. Cursors only exist for the duration
   of the transaction that defines them, unless they have been
   declared <literal>WITH HOLD</literal>. Therefore non-holdable
   cursors are only present in the view until the end of their
   creating transaction. 
-->
<structname>pg_cursors</structname>显示上述所有方法创建的游标。
除非被声明为<literal>WITH HOLD</literal>，游标仅存在于定义它们的事务的生命期中。
因此非持久游标仅能够在视图中存在到创建该游标的事务结束时为止。

   <note>
    <!--
<para>
     Cursors are used internally to implement some of the components
     of <productname>PostgreSQL</>, such as procedural languages.
     Therefore, the <structname>pg_cursors</> view might include cursors
     that have not been explicitly created by the user.
    </para>
-->
<para>
因为游标用于在<productname>PostgreSQL</>内部实现一些比如过程语言之类的组件。
因此<structname>pg_cursors</>可能包含并非由用户明确创建的游标。
</para>
   </note>
  </para>

  <table>
   <!-- 
   <title><structname>pg_cursors</> Columns</title> 
   -->
   <title><structname>pg_cursors</> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <!-- 
  <entry>The name of the cursor</entry> 
  -->
  <entry>游标名</entry>
     </row>

     <row>
      <entry><structfield>statement</structfield></entry>
      <entry><type>text</type></entry>
      <!-- 
  <entry>The verbatim query string submitted to declare this cursor</entry> 
  -->
  <entry>声明该游标的查询字符串</entry>
     </row>

     <row>
      <entry><structfield>is_holdable</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>
       <!-- 
   <literal>true</literal> if the cursor is holdable (that is, it
       can be accessed after the transaction that declared the cursor
       has committed); <literal>false</literal> otherwise 
   -->
   如果该游标是持久的(也就是在声明该游标的事务结束后仍然可以访问该游标)则为<literal>true</literal> ；
   否则为<literal>false</literal>
       </entry>
     </row>

     <row>
      <entry><structfield>is_binary</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>
       <!-- 
   <literal>true</literal> if the cursor was declared
       <literal>BINARY</literal>; <literal>false</literal>
       otherwise 
   -->
   如果该游标被声明为<literal>BINARY</literal>则为<literal>true</literal>；
   否则为<literal>false</literal>
       </entry>
     </row>

     <row>
      <entry><structfield>is_scrollable</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>
       <!-- 
   <literal>true</> if the cursor is scrollable (that is, it
       allows rows to be retrieved in a nonsequential manner);
       <literal>false</literal> otherwise 
   -->
   如果该游标可以滚动(也就是允许以不连续的方式检索)则为<literal>true</>；
   否则为<literal>false</literal>
       </entry>
     </row>

     <row>
      <entry><structfield>creation_time</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <!-- 
  <entry>The time at which the cursor was declared</entry> 
  -->
  <entry>声明该游标的时间戳</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   The <structname>pg_cursors</structname> view is read only.
  </para>
-->
<para>
<structname>pg_cursors</structname>视图是只读的。
</para>

 </sect1>

 <sect1 id="view-pg-group">
  <title><structname>pg_group</structname></title>

  <indexterm zone="view-pg-group">
   <primary>pg_group</primary>
  </indexterm>

  <!--
<para>
   The view <structname>pg_group</structname> exists for backwards
   compatibility: it emulates a catalog that existed in
   <productname>PostgreSQL</productname> before version 8.1.
   It shows the names and members of all roles that are marked as not
   <structfield>rolcanlogin</>, which is an approximation to the set
   of roles that are being used as groups.
  </para>
-->
<para>
<structname>pg_group</structname>的存在是为了向下兼容：它模拟一个存在于<productname>PostgreSQL</productname>
版本 8.1 之前的系统表。它显示所有标记为不是<structfield>rolcanlogin</>的角色的名字和成员，
这就是近似于用做组的那些角色的集合了。
</para>

  <table>
   <!-- 
   <title><structname>pg_group</> Columns</title> 
   -->
   <title><structname>pg_group</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>groname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <!-- 
  <entry>Name of the group</entry> 
  -->
  <entry>组的名字</entry>
     </row>

     <row>
      <entry><structfield>grosysid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <!-- 
  <entry>ID of this group</entry> 
  -->
  <entry>组的 ID</entry>
     </row>

     <row>
      <entry><structfield>grolist</structfield></entry>
      <entry><type>oid[]</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <!-- 
  <entry>An array containing the IDs of the roles in this group</entry> 
  -->
  <entry>一个数组，包含这个组里面所有角色的 ID</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-indexes">
  <title><structname>pg_indexes</structname></title>

  <indexterm zone="view-pg-indexes">
   <primary>pg_indexes</primary>
  </indexterm>

  <!--
<para>
   The view <structname>pg_indexes</structname> provides access to
   useful information about each index in the database.
  </para>
-->
<para>
<structname>pg_indexes</structname>提供对数据库中每个索引的有用信息的访问。
</para>

  <table>
   <!-- 
   <title><structname>pg_indexes</> Columns</title> 
   -->
   <title><structname>pg_indexes</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <!-- 
  <entry>Name of schema containing table and index</entry> 
  -->
  <entry>包含表和索引的模式的名字</entry>
     </row>
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <!-- 
  <entry>Name of table the index is for</entry>
  -->
  <entry>此索引所服务的表的名字</entry>
     </row>
     <row>
      <entry><structfield>indexname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <!-- 
  <entry>Name of index</entry> 
  -->
  <entry>索引的名字</entry>
     </row>
     <row>
      <entry><structfield>tablespace</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.spcname</literal></entry>
      <!-- 
  <entry>Name of tablespace containing index (null if default for database)</entry> 
  -->
  <entry>包含索引的表空间名字(如果是数据库缺省，则为 NULL)</entry>
     </row>
     <row>
      <entry><structfield>indexdef</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <!-- 
  <entry>Index definition (a reconstructed <command>CREATE INDEX</command>
      command)</entry> 
  -->
  <entry>索引定义(一个重建的<command>CREATE INDEX</command>命令)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-locks">
  <title><structname>pg_locks</structname></title>

  <indexterm zone="view-pg-locks">
   <primary>pg_locks</primary>
  </indexterm>

  <!--
<para>
   The view <structname>pg_locks</structname> provides access to
   information about the locks held by open transactions within the
   database server.  See <xref linkend="mvcc"> for more discussion
   of locking.
  </para>
-->
<para>
<structname>pg_locks</structname>提供有关在数据库服务器中由打开的事务持有的锁的信息。
参阅<xref linkend="mvcc">获取有关锁的更多的讨论。
</para>

  <!--
<para>
   <structname>pg_locks</structname> contains one row per active lockable
   object, requested lock mode, and relevant transaction.  Thus, the same
   lockable object might
   appear many times, if multiple transactions are holding or waiting
   for locks on it.  However, an object that currently has no locks on it
   will not appear at all.
  </para>
-->
<para>
<structname>pg_locks</structname>对每个活跃的可锁定对象、请求的锁模式、
以及相关的事务保存一行。因此，如果多个事务持有或者等待对同一个对象的锁，
那么同一个可锁定的对象可能出现多次。不过，一个目前没有锁在其上的对象将肯定不会出现。
</para>

  <!--
<para>
   There are several distinct types of lockable objects:
   whole relations (e.g., tables), individual pages of relations,
   individual tuples of relations,
   transaction IDs (both virtual and permanent IDs),
   and general database objects (identified by class OID and object OID,
   in the same way as in <structname>pg_description</structname> or
   <structname>pg_depend</structname>).  Also, the right to extend a
   relation is represented as a separate lockable object.
   Also, <quote>advisory</> locks can be taken on numbers that have
   user-defined meanings.
  </para>
-->
<para>
有好几种不同的可锁定对象：一个关系(也就是一个表)、关系中独立页面、
关系中独立的行、一个事务 ID（虚拟和永久ID）、以及一般的数据库对象
(用类别 OID 和对象 OID 标识，表示方法和<structname>pg_description</structname>
或<structname>pg_depend</structname>一样)还有，扩展一个关系的权限也是用一种独立的可锁定对象表示的。
另外，<quote>advisory</>锁可以用在有用户定义的含义的数据上。
</para>

  <table>
   <!-- 
   <title><structname>pg_locks</> Columns</title> 
   -->
   <title><structname>pg_locks</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>locktype</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Type of the lockable object:
       <literal>relation</>,
       <literal>extend</>,
       <literal>page</>,
       <literal>tuple</>,
       <literal>transactionid</>,
       <literal>virtualxid</>,
       <literal>object</>,
       <literal>userlock</>, or
       <literal>advisory</> 
   -->
   可锁定对象的类型：
       <literal>relation</>,
       <literal>extend</>,
       <literal>page</>,
       <literal>tuple</>,
       <literal>transactionid</>,
       <literal>virtualxid</>,
       <literal>object</>,
       <literal>userlock</>, 或
       <literal>advisory</>
      </entry>
     </row>
     <row>
      <entry><structfield>database</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   OID of the database in which the lock target exists, or
       zero if the target is a shared object, or
       null if the target is a transaction ID 
   -->
   目标所在的数据库的 OID ，如果目标是共享对象，那么就是零，
   如果目标是一个事务 ID ，就是 null 。
      </entry>
     </row>
     <row>
      <entry><structfield>relation</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   OID of the relation targeted by the lock, or null if the target is not
       a relation or part of a relation 
   -->
   关系的 OID ，如果目标不是关系，也不是关系的一部分，则为 null
      </entry>
     </row>
     <row>
      <entry><structfield>page</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>
       <!-- Page number targeted by the lock within the relation,
       or null if the target is not a relation page or tuple
-->
关系内部的页面编号，如果目标不是行页不是关系页，则为null
      </entry>
     </row>
     <row>
      <entry><structfield>tuple</structfield></entry>
      <entry><type>smallint</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Tuple number targeted by the lock within the page,
       or null if the target is not a tuple 
   -->
   页面里面的行编号，如果目标不是行，则为 null
      </entry>
     </row>
     <row>
      <entry><structfield>virtualxid</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Virtual ID of the transaction targeted by the lock,
       or null if the target is not a virtual transaction ID 
   -->
   事务的虚拟 ID ，如果目标不是虚拟事务 ID ，就是 null
      </entry>
     </row>
     <row>
      <entry><structfield>transactionid</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   ID of the transaction targeted by the lock,
       or null if the target is not a transaction ID 
   -->
   事务的 ID ，如果目标不是事务 ID ，就是 null
      </entry>
     </row>
     <row>
      <entry><structfield>classid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   OID of the system catalog containing the lock target, or null if the
       target is not a general database object 
   -->
   包含该目标的系统表的 OID ，如果目标不是普通数据库对象，则为 null
      </entry>
     </row>
     <row>
      <entry><structfield>objid</structfield></entry>
      <entry><type>oid</type></entry>
      <!-- 
  <entry>any OID column</entry> 
  -->
  <entry>任意OID属性</entry>
      <entry>
       <!-- 
   OID of the lock target within its system catalog, or null if the
       target is not a general database object 
   -->
   目标在其系统表内的 OID ，如果目标不是普通数据库对象，则为 null
      </entry>
     </row>
     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>smallint</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Column number targeted by the lock (the
       <structfield>classid</> and <structfield>objid</> refer to the
       table itself),
       or zero if the target is some other general database object,
       or null if the target is not a general database object 
   -->
   字段编号(<structfield>classid</>和<structfield>objid</>指向表自身)。
   如果目标是其它普通数据库对象，这个字段是零。如果这个目标不是普通数据库对象，则为 null
      </entry>
     </row>
     <row>
      <entry><structfield>virtualtransaction</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Virtual ID of the transaction that is holding or awaiting this lock 
   -->
   持有此锁或者在等待此锁的事务的虚拟 ID 
      </entry>
     </row>
     <row>
      <entry><structfield>pid</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Process ID of the server process holding or awaiting this
       lock, or null if the lock is held by a prepared transaction
   -->
   持有或者等待这个锁的服务器进程的进程 ID 。如果锁是被一个预备事务持有的，那么为 null
      </entry>
     </row>
     <row>
      <entry><structfield>mode</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <!-- 
  <entry>Name of the lock mode held or desired by this process (see <xref
      linkend="locking-tables"> and <xref linkend="xact-serializable">)</entry> 
  -->
  <entry>这个进程持有的或者是期望的锁模式(参阅<xref
      linkend="locking-tables"> 和 <xref linkend="xact-serializable">)</entry>
     </row>
     <row>
      <entry><structfield>granted</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry></entry>
      <!-- 
  <entry>True if lock is held, false if lock is awaited</entry> 
  -->
  <entry>如果持有锁，为真，如果等待锁，为假</entry>
     </row>
     <row>
      <entry><structfield>fastpath</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry></entry>
      <!-- 
  <entry>True if lock was taken via fast path, false if taken via main
       lock table</entry> 
   -->
   <entry>如果锁通过快速路径获得为真，如果通过主锁表获得为假</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   <structfield>granted</structfield> is true in a row representing a lock
   held by the indicated transaction.  False indicates that this transaction is
   currently waiting to acquire this lock, which implies that some other
   transaction is holding a conflicting lock mode on the same lockable object.
   The waiting transaction will sleep until the other lock is released (or a
   deadlock situation is detected). A single transaction can be waiting to
   acquire at most one lock at a time.
  </para>
-->
<para>
<structfield>granted</structfield>为真时表明指定事务持有一个锁。为假则表明该事务当前等待使用这个锁，
这就暗示着某个其它的事务正在同样的可锁定对象上持有冲突的锁模式。等待的会话将一直睡眠，
直到另外一个锁释放(或者侦测到一个死锁条件)。一个事务一次最多等待一个锁。
</para>

  <!--
<para>
   Every transaction holds an exclusive lock on its virtual transaction ID for
   its entire duration.  If a permanent ID is assigned to the transaction
   (which normally happens only if the transaction changes the state of the
   database), it also holds an exclusive lock on its permanent transaction ID
   until it ends.  When one transaction finds it necessary to wait specifically
   for another transaction, it does so by attempting to acquire share lock on
   the other transaction ID (either virtual or permanent ID depending on the
   situation). That will succeed only when the other transaction
   terminates and releases its locks.
  </para>
-->
<para>
每个事务都在它持续的时间里在他自己的虚拟事务 ID 上持有一个排他锁。如果给事务赋予一个永久ID
（通常只在事务改变数据库的状态时发生），那么它也在它的永久事务ID上持有一个排它锁，直到它结束。
如果一个事务认为它必须等待另外一个事务，它会以企图在另外一个事务 ID 上获取共享锁的方式实现之
（虚拟的或永久的ID取决于情景）。这个锁只有在另外一个事务终止并且释放它的锁的前提下才能成功。
</para>

  <!--
<para>
   Although tuples are a lockable type of object,
   information about row-level locks is stored on disk, not in memory,
   and therefore row-level locks normally do not appear in this view.
   If a transaction is waiting for a
   row-level lock, it will usually appear in the view as waiting for the
   permanent transaction ID of the current holder of that row lock.
  </para>
-->
<para>
尽管行是一种可以锁定的对象，但是有关行级别锁的信息是存储在磁盘上的，而不是在内存里，
因此，行级别的锁通常不会出现在这个视图里。如果一个事务在等待一个行级别的锁，
那么它通常会在这个视图里以等待当前持有该行锁的永久事务 ID 的方式出现。
</para>

  <!--
<para>
   Advisory locks can be acquired on keys consisting of either a single
   <type>bigint</type> value or two integer values.
   A <type>bigint</type> key is displayed with its
   high-order half in the <structfield>classid</> column, its low-order half
   in the <structfield>objid</> column, and <structfield>objsubid</> equal
   to 1. The original <type>bigint</type> value can be reassembled with the
   expression <literal>(classid::bigint &lt;&lt; 32) |
   objid::bigint</literal>. Integer keys are displayed with the
   first key in the
   <structfield>classid</> column, the second key in the <structfield>objid</>
   column, and <structfield>objsubid</> equal to 2.  The actual meaning of
   the keys is up to the user.  Advisory locks are local to each database,
   so the <structfield>database</> column is meaningful for an advisory lock.
  </para>
-->
<para>
建议锁可以在由单独一个<type>bigint</type>值或两个integer值组成的键上获得。
一个 <type>bigint</type>键的高/低位部分分别在<structfield>classid</>和 <structfield>objid</>
字段中显示，并且<structfield>objsubid</>等于 1 。原先的<type>bigint</type>值可以通过
表达式<literal>(classid::bigint &lt;&lt; 32) | objid::bigint</literal>重新组装。
integer 组成的键前半部分在<structfield>classid</>字段中显示、后半部分在<structfield>objid</>
字段中显示，并且<structfield>objsubid</>等于 2 。键的实际含义取决于用户的定义。
建议锁是针对单个数据库的，因此<structfield>database</>字段对于建议锁就显得很有意义了。
</para>

  <!--
<para>
   <structname>pg_locks</structname> provides a global view of all locks
   in the database cluster, not only those relevant to the current database.
   Although its <structfield>relation</structfield> column can be joined
   against <structname>pg_class</>.<structfield>oid</> to identify locked
   relations, this will only work correctly for relations in the current
   database (those for which the <structfield>database</structfield> column
   is either the current database's OID or zero).
  </para>
-->
<para>
<structname>pg_locks</structname>提供了一个数据库集群里的所有的锁的全局视图，
而不仅仅那些和当前数据库相关的。尽管它的<structfield>relation</structfield>
字段可以和<structname>pg_class</>.<structfield>oid</>连接起来以标识被锁住的关系，
但是这个方法目前只能对在当前数据库里的关系有用(那些<structfield>database</structfield>
字段是当前数据库的 OID 或者零的数据库)。
</para>

  <!--
<para>
   The <structfield>pid</structfield> column can be joined to the
   <structfield>pid</structfield> column of the
   <structname>pg_stat_activity</structname> view to get more
   information on the session holding or waiting to hold each lock.
   Also, if you are using prepared transactions, the
   <structfield>transaction</> column can be joined to the
   <structfield>transaction</structfield> column of the
   <structname>pg_prepared_xacts</structname> view to get more
   information on prepared transactions that hold locks.
   (A prepared transaction can never be waiting for a lock,
   but it continues to hold the locks it acquired while running.)
  </para>
-->
<para>
<structfield>pid</structfield>字段可以可以和<structname>pg_stat_activity</structname>
视图的<structfield>pid</structfield>字段连接起来获取持有或者等待持有每个锁的会话的更多信息。
同样，如果你使用预备事务，可以把<structfield>transaction</>字段和<structname>pg_prepared_xacts</structname>
视图的<structfield>transaction</structfield>字段连接起来获取持有锁的那个预备事务的更多信息。
一个预备事务不能等待任何锁，但是在运行的时候，它继续持有它已经请求到的锁。
</para>

  <!--
<para>
   The <structname>pg_locks</structname> view displays data from both the
   regular lock manager and the predicate lock manager, which are
   separate systems; in addition, the regular lock manager subdivides its
   locks into regular and <firstterm>fast-path</> locks.
   This data is not guaranteed to be entirely consistent.
   When the view is queried,
   data on fast-path locks (with <structfield>fastpath</> = <literal>true</>)
   is gathered from each backend one at a time, without freezing the state of
   the entire lock manager, so it is possible for locks to be taken or
   released while information is gathered.  Note, however, that these locks are
   known not to conflict with any other lock currently in place.  After
   all backends have been queried for fast-path locks, the remainder of the
   regular lock manager is locked as a unit, and a consistent snapshot of all
   remaining locks is collected as an atomic action.  After unlocking the
   regular lock manager, the predicate lock manager is similarly locked and all
   predicate locks are collected as an atomic action.  Thus, with the exception
   of fast-path locks, each lock manager will deliver a consistent set of
   results, but as we do not lock both lock managers simultaneously, it is
   possible for locks to be taken or released after we interrogate the regular
   lock manager and before we interrogate the predicate lock manager.
  </para>
-->
<para>
<structname>pg_locks</structname>显示独立系统的普通锁管理器和谓词锁管理器的数据；
另外，普通锁管理器细分它的锁为普通和<firstterm>fast-path</>锁。这个数据不保证是完全一致的。
当请求视图时，fast-path锁的数据（<structfield>fastpath</> = <literal>true</>）
从每个后端一次收集，在整个锁管器中没有冻结状态，所以当收集信息时，可以获取锁或释放锁。
不过，要注意的是，这些锁不和任意其他当前锁发生冲突。在所有后端已经查询fast-path锁之后，
剩余的普通锁管理器作为一个单元，并且一个所有剩余锁的一致的快照作为原子动作收集。
在解锁普通锁管理器之后，谓词锁管理器同样的锁住，并且所有谓词锁作为一个原子动作收集。
因此，除了fast-path锁，每个锁管理器将给出一致的结果集，但是因为我们不同时锁住锁管理器，
锁可能在我们访问普通锁管理器之后、访问谓词锁管理器之前获取或释放。
</para>

  <!--
<para>
   Locking the regular and/or predicate lock manager could have some
   impact on database performance if this view is very frequently accessed.
   The locks are held only for the minimum amount of time necessary to
   obtain data from the lock managers, but this does not completely eliminate
   the possibility of a performance impact.
  </para>
-->
<para>
如果这个视图访问的非常频繁，那么锁住普通和/或谓词锁管理器可能会对数据库性能有些影响。
锁只持有从锁管理器获取数据所需要的最小的时间，但是这并不能完全消除性能影响的可能性。
</para>

 </sect1>

 <sect1 id="view-pg-matviews">
  <title><structname>pg_matviews</structname></title>

  <indexterm zone="view-pg-matviews">
   <primary>pg_matviews</primary>
  </indexterm>

  <indexterm zone="view-pg-matviews">
   <primary>materialized views</primary>
  </indexterm>

  <!--
<para>
   The view <structname>pg_matviews</structname> provides access to
   useful information about each materialized view in the database.
  </para>
-->
<para>
<structname>pg_matviews</structname>视图提供了访问关于每个物化视图在数据库中的有用信息的接口。
</para>

  <table>
   <!-- 
   <title><structname>pg_matviews</> Columns</title> 
   -->
   <title><structname>pg_matviews</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <!-- 
  <entry>Name of schema containing materialized view</entry> 
  -->
  <entry>包含物化视图的模式名</entry>
     </row>
     <row>
      <entry><structfield>matviewname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <!-- 
  <entry>Name of materialized view</entry> 
  -->
  <entry>物化视图的名字</entry>
     </row>
     <row>
      <entry><structfield>matviewowner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <!-- 
  <entry>Name of materialized view's owner</entry> 
  -->
  <entry>物化视图的所有者的名字</entry>
     </row>
     <row>
      <entry><structfield>tablespace</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.spcname</literal></entry>
      <!-- 
  <entry>Name of tablespace containing materialized view (null if default for database)</entry> 
  -->
  <entry>包含物化视图的名字空间的名字（如果对于数据库是缺省的则为null）</entry>
     </row>
     <row>
      <entry><structfield>hasindexes</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry></entry>
      <!-- 
  <entry>True if materialized view has (or recently had) any indexes</entry> 
  -->
  <entry>如果物化视图有（或最近有）任何索引则为真</entry>
     </row>
     <row>
      <entry><structfield>ispopulated</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry></entry>
      <!-- 
  <entry>True if materialized view is currently populated</entry> 
  -->
  <entry>如果物化视图当前填充了则为真</entry>
     </row>
     <row>
      <entry><structfield>definition</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <!-- 
  <entry>Materialized view definition (a reconstructed <command>SELECT</command> query)</entry> 
  -->
  <entry>物化视图定义（一个重新构造的<command>SELECT</command>查询）</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-prepared-statements">
  <title><structname>pg_prepared_statements</structname></title>

  <indexterm zone="view-pg-prepared-statements">
   <primary>pg_prepared_statements</primary>
  </indexterm>

  <!--
<para>
   The <structname>pg_prepared_statements</structname> view displays
   all the prepared statements that are available in the current
   session. See <xref linkend="sql-prepare"> for more information about prepared
   statements.
  </para>
-->
<para>
<structname>pg_prepared_statements</structname>显示所有当前会话中可用的预备语句。
参见<xref linkend="sql-prepare">获取关于预备语句的更多信息。
</para>

  <!--
<para>
   <structname>pg_prepared_statements</structname> contains one row
   for each prepared statement. Rows are added to the view when a new
   prepared statement is created and removed when a prepared statement
   is released (for example, via the <xref linkend="sql-deallocate"> command).
  </para>
-->
<para>
每个预备语句在<structname>pg_prepared_statements</structname>中都有对应的一条记录。
当一条新的预备语句创建后该视图中就会新增一条记录，同样，
当一条预备语句被释放后(比如通过<xref linkend="sql-deallocate">命令)，相应的记录也会被删除。
</para>

  <table>
   <!-- 
   <title><structname>pg_prepared_statements</> Columns</title> 
   -->
   <title><structname>pg_prepared_statements</> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <entry>
       <!-- 
   The identifier of the prepared statement 
   -->
   预备语句的标识符
      </entry>
     </row>
     <row>
      <entry><structfield>statement</structfield></entry>
      <entry><type>text</type></entry>
      <entry>
       <!-- 
   The query string submitted by the client to create this
       prepared statement. For prepared statements created via SQL,
       this is the <command>PREPARE</command> statement submitted by
       the client. For prepared statements created via the
       frontend/backend protocol, this is the text of the prepared
       statement itself. 
   -->
   创建该预备语句的查询字符串。对于从 SQL 创建的预备语句而言是客户端提交的
   <command>PREPARE</command>语句。对于通过前/后端协议创建的预备语句而言是预备语句自身的文本。
      </entry>
     </row>
     <row>
      <entry><structfield>prepare_time</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <entry>
       <!-- 
   The time at which the prepared statement was created 
   -->
   创建该预备语句的时间戳
      </entry>
     </row>
     <row>
      <entry><structfield>parameter_types</structfield></entry>
      <entry><type>regtype[]</type></entry>
      <entry>
       <!-- 
   The expected parameter types for the prepared statement in the
       form of an array of <type>regtype</type>. The OID corresponding
       to an element of this array can be obtained by casting the
       <type>regtype</type> value to <type>oid</type>.
   -->
   该预备语句期望的参数类型，以<type>regtype</type>类型的数组格式出现。
   与该数组元素相对应的 OID 可以通过把<type>regtype</type>值转换为<type>oid</type>值得到。
      </entry>
     </row>
     <row>
      <entry><structfield>from_sql</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry>
       <!-- 
   <literal>true</literal> if the prepared statement was created
       via the <command>PREPARE</command> SQL statement;
       <literal>false</literal> if the statement was prepared via the
       frontend/backend protocol 
   -->
   如果该预备语句是通过<command>PREPARE</command>语句创建的则为<literal>true</literal>；
   如果是通过前/后端协议创建的则为<literal>false</literal>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   The <structname>pg_prepared_statements</structname> view is read only.
  </para>
-->
<para>
<structname>pg_prepared_statements</structname>视图是只读的。
</para>
 </sect1>

 <sect1 id="view-pg-prepared-xacts">
  <title><structname>pg_prepared_xacts</structname></title>

  <indexterm zone="view-pg-prepared-xacts">
   <primary>pg_prepared_xacts</primary>
  </indexterm>

  <!--
<para>
   The view <structname>pg_prepared_xacts</structname> displays
   information about transactions that are currently prepared for two-phase
   commit (see <xref linkend="sql-prepare-transaction"> for details).
  </para>
-->
<para>
<structname>pg_prepared_xacts</structname>显示那些当前准备好进行两阶段提交的事务的信息
(参阅<xref linkend="sql-prepare-transaction">获取细节)。
</para>

  <!--
<para>
   <structname>pg_prepared_xacts</structname> contains one row per prepared
   transaction.  An entry is removed when the transaction is committed or
   rolled back.
  </para>
-->
<para>
<structname>pg_prepared_xacts</structname>为每个预备事务包含一行。如果事务提交或者回滚，
则删除该条记录。
</para>

  <table>
   <!-- 
   <title><structname>pg_prepared_xacts</> Columns</title> 
   -->
   <title><structname>pg_prepared_xacts</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>transaction</structfield></entry>
      <entry><type>xid</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Numeric transaction identifier of the prepared transaction 
   -->
   预备事务的数字事务标识
      </entry>
     </row>
     <row>
      <entry><structfield>gid</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Global transaction identifier that was assigned to the transaction 
   -->
   赋予该事务的全局事务标识
      </entry>
     </row>
     <row>
      <entry><structfield>prepared</structfield></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Time at which the transaction was prepared for commit 
   -->
   事务准备好提交的时间
      </entry>
     </row>
     <row>
      <entry><structfield>owner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <entry>
       <!-- 
   Name of the user that executed the transaction 
   -->
   执行该事务的用户的名字
      </entry>
     </row>
     <row>
      <entry><structfield>database</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-database"><structname>pg_database</structname></link>.datname</literal></entry>
      <entry>
       <!-- 
   Name of the database in which the transaction was executed 
   -->
   执行该事务所在的数据库名
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   When the <structname>pg_prepared_xacts</structname> view is accessed, the
   internal transaction manager data structures are momentarily locked, and
   a copy is made for the view to display.  This ensures that the
   view produces a consistent set of results, while not blocking
   normal operations longer than necessary.  Nonetheless
   there could be some impact on database performance if this view is
   frequently accessed.
  </para>
-->
<para>
在访问<structname>pg_prepared_xacts</structname>视图的时候，内部事务管理器数据结构被暂时锁住，
并且为显示视图制作了一份拷贝。这样就保证了视图生成一个一致的结果集，
而不会阻塞正常的操作太长时间。当然，即便这么做，如果过于频繁地访问这个视图，
肯定也会对数据库性能造成一定的影响。
</para>

 </sect1>

 <sect1 id="view-pg-roles">
  <title><structname>pg_roles</structname></title>

  <indexterm zone="view-pg-roles">
   <primary>pg_roles</primary>
  </indexterm>

  <!--
<para>
   The view <structname>pg_roles</structname> provides access to
   information about database roles.  This is simply a publicly
   readable view of
   <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>
   that blanks out the password field.
  </para>
-->
<para>
<structname>pg_roles</structname>提供访问数据库角色有关信息的接口。
它只是一个<link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>
表的公开可读部分的视图，把口令字段用空白填充了。
</para>

  <!--
<para>
   This view explicitly exposes the OID column of the underlying table,
   since that is needed to do joins to other catalogs.
  </para>
-->
<para>
该视图明确的显示了底层表的 OID 字段，可以用于与其它表连接。
</para>

  <table>
   <!-- 
   <title><structname>pg_roles</> Columns</title> 
   -->
   <title><structname>pg_roles</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>rolname</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <!-- 
  <entry>Role name</entry> 
  -->
  <entry>角色名</entry>
     </row>

     <row>
      <entry><structfield>rolsuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>Role has superuser privileges</entry> 
  -->
  <entry>有超级用户权限的角色</entry>
     </row>

     <row>
      <entry><structfield>rolinherit</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>Role automatically inherits privileges of roles it is a
       member of</entry> 
   -->
   <entry>自动继承属主角色权限的角色</entry>
     </row>

     <row>
      <entry><structfield>rolcreaterole</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>Role can create more roles</entry> 
  -->
  <entry>可以创建更多角色的角色</entry>
     </row>

     <row>
      <entry><structfield>rolcreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>Role can create databases</entry> 
  -->
  <entry>可以创建数据库的角色</entry>
     </row>

     <row>
      <entry><structfield>rolcatupdate</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Role can update system catalogs directly.  (Even a superuser cannot do
       this unless this column is true)
   -->
   可以直接更新系统表的角色。除非这个字段为真，否则超级用户也不能干这个事情。
      </entry>
     </row>

     <row>
      <entry><structfield>rolcanlogin</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Role can log in. That is, this role can be given as the initial
       session authorization identifier 
   -->
   可以登录的角色，也就是说，这个角色可以给予初始化会话认证的标识符。
      </entry>
     </row>

     <row>
      <entry><structfield>rolreplication</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
      <!-- 
  Role is a replication role. That is, this role can initiate streaming
       replication (see <xref linkend="streaming-replication">) and set/unset
       the system backup mode using <function>pg_start_backup</> and
       <function>pg_stop_backup</> 
   -->
   复制的角色。也就是说，这个角色可以初始化流复制(参阅<xref linkend="streaming-replication">)
   和使用<function>pg_start_backup</>和<function>pg_stop_backup</>设置/重设系统备份模式。
      </entry>
     </row>

     <row>
      <entry><structfield>rolconnlimit</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   For roles that can log in, this sets maximum number of concurrent
       connections this role can make.  -1 means no limit. 
   -->
   对于可以登录的角色，这儿限制了该角色允许发起的最大并发连接数。 -1 表示无限制。
      </entry>
     </row>

     <row>
      <entry><structfield>rolpassword</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <!-- 
  <entry>Not the password (always reads as <literal>********</>)</entry> 
  -->
  <entry>不是口令(总是 <literal>********</>)</entry> 
     </row>

     <row>
      <entry><structfield>rolvaliduntil</structfield></entry>
      <entry><type>timestamptz</type></entry>
      <entry></entry>
      <!-- 
  <entry>Password expiry time (only used for password authentication);
       null if no expiration</entry> 
   -->
   <entry>口令失效日期(只用于口令认证)；如果没有失效期，为 NULL</entry>
     </row>

     <row>
      <entry><structfield>rolconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <!-- 
  <entry>Role-specific defaults for run-time configuration variables</entry>
  -->
  <entry>运行时配置变量的用户指定的缺省</entry>
     </row>

     <row>
      <entry><structfield>oid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <!-- 
  <entry>ID of role</entry> 
  -->
  <entry>角色的 ID</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-rules">
  <title><structname>pg_rules</structname></title>

  <indexterm zone="view-pg-rules">
   <primary>pg_rules</primary>
  </indexterm>

  <!--
<para>
   The view <structname>pg_rules</structname> provides access to
   useful information about query rewrite rules.
  </para>
-->
<para>
<structname>pg_rules</structname>提供对查询重写规则的有用信息访问的接口。
</para>

  <table>
   <!-- 
   <title><structname>pg_rules</> Columns</title> 
   -->
   <title><structname>pg_rules</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <!-- 
  <entry>Name of schema containing table</entry> 
  -->
  <entry>包含表的模式的名字</entry>
     </row>
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <!-- 
  <entry>Name of table the rule is for</entry> 
  -->
  <entry>规则作用的表的名字</entry>
     </row>
     <row>
      <entry><structfield>rulename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-rewrite"><structname>pg_rewrite</structname></link>.rulename</literal></entry>
      <!-- 
  <entry>Name of rule</entry> 
  -->
  <entry>规则的名字</entry>
     </row>
     <row>
      <entry><structfield>definition</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <!-- 
  <entry>Rule definition (a reconstructed creation command)</entry> 
  -->
  <entry>规则定义(一个重新构造的创建命令)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   The <structname>pg_rules</> view excludes the <literal>ON SELECT</> rules
   of views and materialized views; those can be seen in
   <structname>pg_views</> and <structname>pg_matviews</>.
  </para>
-->
<para>
<structname>pg_rules</>视图排除了视图和物化视图的<literal>ON SELECT</>规则；
就是那些可以在<structname>pg_views</>和<structname>pg_matviews</>里看到的。
</para>

 </sect1>

 <sect1 id="view-pg-seclabels">
  <title><structname>pg_seclabels</structname></title>

  <indexterm zone="view-pg-seclabels">
   <primary>pg_seclabels</primary>
  </indexterm>

  <!--
<para>
   The view <structname>pg_seclabels</structname> provides information about
   security labels.  It as an easier-to-query version of the
   <link linkend="catalog-pg-seclabel"><structname>pg_seclabel</></> catalog.
  </para>
-->
<para>
<structname>pg_seclabels</structname>提供关于安全标签的信息。它是一个
<link linkend="catalog-pg-seclabel"><structname>pg_seclabel</></>表容易查询的版本。
</para>

  <table>
   <!-- 
   <title><structname>pg_seclabels</> Columns</title> 
   -->
   <title><structname>pg_seclabels</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>objoid</structfield></entry>
      <entry><type>oid</type></entry>
      <!-- 
  <entry>any OID column</entry>
      <entry>The OID of the object this security label pertains to</entry>
  -->
  <entry>任意OID属性</entry>
      <entry>这个安全标签指向的对象的OID</entry>
     </row>
     <row>
      <entry><structfield>classoid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.oid</literal></entry>
      <!-- 
  <entry>The OID of the system catalog this object appears in</entry> 
  -->
  <entry>这个对象出现的系统表的OID</entry>
     </row>
     <row>
      <entry><structfield>objsubid</structfield></entry>
      <entry><type>int4</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   For a security label on a table column, this is the column number (the
       <structfield>objoid</> and <structfield>classoid</> refer to
       the table itself).  For all other object types, this column is
       zero. 
   -->
   对于一个在表字段上的安全标签，是字段编号（引用表本身的<structfield>objoid</>
   和<structfield>classoid</>）。对于所有其他对象类型，这个字段为零。
      </entry>
     </row>
     <row>
      <entry><structfield>objtype</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
         <!-- 
 The type of object to which this label applies, as text. 
 -->
 这个标签出现的对象的类型，文本格式。
      </entry>
     </row>
     <row>
      <entry><structfield>objnamespace</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   The OID of the namespace for this object, if applicable;
       otherwise NULL. 
   -->
   这个对象的名字空间的OID，如果适用；否则为NULL。
      </entry>
     </row>
     <row>
      <entry><structfield>objname</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   The name of the object to which this label applies, as text. 
   -->
   这个标签适用的对象的名字，文本格式。
      </entry>
     </row>
     <row>
      <entry><structfield>provider</structfield></entry>
      <entry><type>text</type></entry>
      <entry><literal><link linkend="catalog-pg-seclabel"><structname>pg_seclabel</structname></link>.provider</literal></entry>
      <!-- 
  <entry>The label provider associated with this label.</entry> 
  -->
  <entry>与这个标签相关的标签提供者。</entry>
     </row>
     <row>
      <entry><structfield>label</structfield></entry>
      <entry><type>text</type></entry>
      <entry><literal><link linkend="catalog-pg-seclabel"><structname>pg_seclabel</structname></link>.label</literal></entry>
      <!-- 
  <entry>The security label applied to this object.</entry> 
  -->
  <entry>适用于这个对象的安全标签。</entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>

 <sect1 id="view-pg-settings">
  <title><structname>pg_settings</structname></title>

  <indexterm zone="view-pg-settings">
   <primary>pg_settings</primary>
  </indexterm>

  <!--
<para>
   The view <structname>pg_settings</structname> provides access to
   run-time parameters of the server.  It is essentially an alternative
   interface to the <xref linkend="sql-show">
   and <xref linkend="sql-set"> commands.
   It also provides access to some facts about each parameter that are
   not directly available from <command>SHOW</>, such as minimum and
   maximum values.
  </para>
-->
<para>
<structname>pg_settings</structname>提供了对服务器运行时参数的访问。
它实际上是<xref linkend="sql-show">和<xref linkend="sql-set">命令的另外一个接口。
它还提供一些用<command>SHOW</>不能直接获取的参数的访问，比如最大和最小值。
</para>

  <table>
   <!-- 
   <title><structname>pg_settings</> Columns</title>
   -->
   <title><structname>pg_settings</> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <!-- 
  <entry>Run-time configuration parameter name</entry> 
  -->
  <entry>运行时配置参数名</entry>
     </row>
     <row>
      <entry><structfield>setting</structfield></entry>
      <entry><type>text</type></entry>
      <!-- 
  <entry>Current value of the parameter</entry> 
  -->
  <entry>参数的当前值</entry>
     </row>
     <row>
      <entry><structfield>unit</structfield></entry>
      <entry><type>text</type></entry>
      <!-- 
  <entry>Implicit unit of the parameter</entry> 
  -->
  <entry>参数的隐含单元</entry>
     </row>
     <row>
      <entry><structfield>category</structfield></entry>
      <entry><type>text</type></entry>
      <!-- 
  <entry>Logical group of the parameter</entry> 
  -->
  <entry>参数的逻辑组</entry>
     </row>
     <row>
      <entry><structfield>short_desc</structfield></entry>
      <entry><type>text</type></entry>
      <!-- 
  <entry>A brief description of the parameter</entry> 
  -->
  <entry>参数的一个简短的描述</entry>
     </row>
     <row>
      <entry><structfield>extra_desc</structfield></entry>
      <entry><type>text</type></entry>
      <!-- 
  <entry>Additional, more detailed, description of the parameter</entry> 
  -->
  <entry>有关参数的额外的，更详细的描述</entry>
     </row>
     <row>
      <entry><structfield>context</structfield></entry>
      <entry><type>text</type></entry>
      <!-- 
  <entry>Context required to set the parameter's value (see below)</entry> 
  -->
  <entry>设置这个参数的值要求的环境（见下文）</entry>
     </row>
     <row>
      <entry><structfield>vartype</structfield></entry>
      <entry><type>text</type></entry>
      <!-- 
  <entry>Parameter type (<literal>bool</>, <literal>enum</>,
       <literal>integer</>, <literal>real</>, or <literal>string</>)
      </entry> 
  -->
  <entry>参数类型(<literal>bool</>, <literal>enum</>,
       <literal>integer</>, <literal>real</>, <literal>string</>)
      </entry>
     </row>
     <row>
      <entry><structfield>source</structfield></entry>
      <entry><type>text</type></entry>
      <!-- 
  <entry>Source of the current parameter value</entry> 
  -->
  <entry>当前参数值的来源</entry>
     </row>
     <row>
      <entry><structfield>min_val</structfield></entry>
      <entry><type>text</type></entry>
      <!-- 
  <entry>Minimum allowed value of the parameter (null for non-numeric
      values)</entry> 
  -->
  <entry>该参数允许的最小值(非数字值为 null)</entry>
     </row>
     <row>
      <entry><structfield>max_val</structfield></entry>
      <entry><type>text</type></entry>
      <!-- 
  <entry>Maximum allowed value of the parameter (null for non-numeric
      values)</entry>
  -->
  <entry>这个参数允许的最大的数值(非数字值为 null)</entry>
     </row>
     <row>
      <entry><structfield>enumvals</structfield></entry>
      <entry><type>text[]</type></entry>
      <!-- 
  <entry>Allowed values of an enum parameter (null for non-enum
      values)</entry>
  -->
  <entry>枚举参数允许的值（非枚举值为null）</entry>
     </row>
     <row>
      <entry><structfield>boot_val</structfield></entry>
      <entry><type>text</type></entry>
      <!-- 
  <entry>Parameter value assumed at server startup if the parameter is
      not otherwise set</entry> 
  -->
  <entry>如果参数没有设置则为服务器启动时假设的参数值</entry>
     </row>
     <row>
      <entry><structfield>reset_val</structfield></entry>
      <entry><type>text</type></entry>
      <!-- 
  <entry>Value that <command>RESET</command> would reset the parameter to
      in the current session</entry>
  -->
  <entry><command>RESET</command>在当前会话中将重设的参数值</entry>
     </row>
     <row>
      <entry><structfield>sourcefile</structfield></entry>
      <entry><type>text</type></entry>
      <!-- 
  <entry>Configuration file the current value was set in (null for
      values set from sources other than configuration files, or when
      examined by a non-superuser);
      helpful when using <literal>include</> directives in configuration files</entry>
  -->
  <entry>设置当前值的配置文件（从源码而不是配置文件设置值或当通过非超级用户检查时为null）；
  当在配置文件中使用<literal>include</>指令时是有帮助的。</entry>
     </row>
     <row>
      <entry><structfield>sourceline</structfield></entry>
      <entry><type>integer</type></entry>
      <!-- 
  <entry>Line number within the configuration file the current value was
      set at (null for values set from sources other than configuration files,
      or when examined by a non-superuser)
      </entry> 
  -->
  <entry>设置当前值的配置文件中的行编码
  （从源码而不是配置文件设置值或当通过非超级用户检查时为null）
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   There are several possible values of <structfield>context</structfield>.
   In order of decreasing difficulty of changing the setting, they are:
  </para>
-->
<para>
有几个<structfield>context</structfield>的可能值。以减少困难的改变设置的顺序，它们是：
</para>

  <variablelist>
   <varlistentry>
    <term><literal>internal</literal></term>
    <listitem>
     <!--
<para>
      These settings cannot be changed directly; they reflect internally
      determined values.  Some of them may be adjustable by rebuilding the
      server with different configuration options, or by changing options
      supplied to <command>initdb</command>.
     </para>
-->
<para>
不能直接更改这些设置；它们反映了内部确定的值。其中的一些可以通过用不同的配置选项重建服务器，
或通过改变提供给<command>initdb</command>的选项来更改。
</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>postmaster</literal></term>
    <listitem>
     <!--
<para>
      These settings can only be applied when the server starts, so any change
      requires restarting the server.  Values for these settings are typically
      stored in the <filename>postgresql.conf</filename> file, or passed on
      the command line when starting the server.  Of course, settings with any
      of the lower <structfield>context</structfield> types can also be
      set at server start time.
     </para>
-->
<para>
这些选项只在服务器启动时使用，所以任何改变都需要重启服务器。这些设置的值通常存储在
<filename>postgresql.conf</filename>文件中，或当服务器启动时传递给命令行。
当然，带有任何低<structfield>context</structfield>类型的设置也可以在服务器启动时设置。
</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>sighup</literal></term>
    <listitem>
     <!--
<para>
      Changes to these settings can be made in
      <filename>postgresql.conf</filename> without restarting the server.
      Send a <systemitem>SIGHUP</systemitem> signal to the postmaster to
      cause it to re-read <filename>postgresql.conf</filename> and apply
      the changes.  The postmaster will also forward the
      <systemitem>SIGHUP</systemitem> signal to its child processes so that
      they all pick up the new value.
     </para>
-->
<para>
这些设置可以在<filename>postgresql.conf</filename>中改变而不用重启服务器。
发送一个<systemitem>SIGHUP</systemitem>信号到主进程使其重读<filename>postgresql.conf</filename>
并应用改变。主进程也将<systemitem>SIGHUP</systemitem>信号传递给它的子进程，
这样它们所有都使用新值。
</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>backend</literal></term>
    <listitem>
     <!--
<para>
      Changes to these settings can be made in
      <filename>postgresql.conf</filename> without restarting the server;
      they can also be set for a particular session in the connection request
      packet (for example, via <application>libpq</>'s <literal>PGOPTIONS</>
      environment variable).  However, these settings never change in a
      session after it is started.  If you change them in
      <filename>postgresql.conf</filename>, send a
      <systemitem>SIGHUP</systemitem> signal to the postmaster to cause it to
      re-read <filename>postgresql.conf</filename>.  The new values will only
      affect subsequently-launched sessions.
     </para>
-->
<para>
这些设置可以在<filename>postgresql.conf</filename>中改变而不用重启服务器；
它们也可以在连接需求包中为特定的会话设置（例如，通过<application>libpq</>的
<literal>PGOPTIONS</>环境变量）。不过，这些设置在会话启动后永远不会改变。
如果你在<filename>postgresql.conf</filename>中改变了它们，那么发送一个<systemitem>SIGHUP</systemitem>
信号到主进程使其重读<filename>postgresql.conf</filename>。新值将只影响随后加载的会话。
</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>superuser</literal></term>
    <listitem>
     <!--
<para>
      These settings can be set from <filename>postgresql.conf</filename>,
      or within a session via the <command>SET</> command; but only superusers
      can change them via <command>SET</>.  Changes in
      <filename>postgresql.conf</filename> will affect existing sessions
      only if no session-local value has been established with <command>SET</>.
     </para>
-->
<para>
这些值可以在<filename>postgresql.conf</filename>中设置，或在一个会话中通过<command>SET</>
命令设置；但是只有超级用户可以通过<command>SET</>改变它们。在<filename>postgresql.conf</filename>
中改变它们将只在没有会话本地值是使用<command>SET</>建立的时影响现有会话。
</para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><literal>user</literal></term>
    <listitem>
     <!--
<para>
      These settings can be set from <filename>postgresql.conf</filename>,
      or within a session via the <command>SET</> command.  Any user is
      allowed to change his session-local value.  Changes in
      <filename>postgresql.conf</filename> will affect existing sessions
      only if no session-local value has been established with <command>SET</>.
     </para>
-->
<para>
这些值可以在<filename>postgresql.conf</filename>中设置，或在一个会话中通过<command>SET</>
命令设置。允许任何用户改变他们的会话本地值。<filename>postgresql.conf</filename>
中的改变将只在没有会话本地值是使用<command>SET</>建立的时影响现有会话。
</para>
    </listitem>
   </varlistentry>
  </variablelist>

  <!--
<para>
   See <xref linkend="config-setting"> for more information about the various
   ways to change these parameters.
  </para>
-->
<para>
参阅<xref linkend="config-setting">获取更多关于改变这些参数的各种方式的信息。
</para>

  <!--
<para>
   The <structname>pg_settings</structname> view cannot be inserted into or
   deleted from, but it can be updated.  An <command>UPDATE</command> applied
   to a row of <structname>pg_settings</structname> is equivalent to executing
   the <xref linkend="sql-set"> command on that named
   parameter. The change only affects the value used by the current
   session. If an <command>UPDATE</command> is issued within a transaction
   that is later aborted, the effects of the <command>UPDATE</command> command
   disappear when the transaction is rolled back. Once the surrounding
   transaction is committed, the effects will persist until the end of the
   session, unless overridden by another <command>UPDATE</command> or
   <command>SET</command>.
  </para>
-->
<para>
不能对<structname>pg_settings</structname>视图进行插入或者删除，但是可以更新。
对<structname>pg_settings</structname>中的一行进行 <command>UPDATE</command>
等效于在该命名参数上执行<xref linkend="sql-set">命令。这个修改只影响当前会话使用的数值。
如果在一个最后退出的事务中发出了<command>UPDATE</command> 命令，那么<command>UPDATE</command>
命令的效果将在事务回滚之后消失。一旦包围它的事务提交，这个效果将固化，直到会话结束，
除非由其它的<command>UPDATE</command>或<command>SET</command>命令覆盖。
</para>

 </sect1>

 <sect1 id="view-pg-shadow">
  <title><structname>pg_shadow</structname></title>

  <indexterm zone="view-pg-shadow">
   <primary>pg_shadow</primary>
  </indexterm>

  <!--
<para>
   The view <structname>pg_shadow</structname> exists for backwards
   compatibility: it emulates a catalog that existed in
   <productname>PostgreSQL</productname> before version 8.1.
   It shows properties of all roles that are marked as
   <structfield>rolcanlogin</> in
   <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.
  </para>
-->
<para>
<structname>pg_shadow</structname>存在是为了向下兼容：它模拟了一个<productname>PostgreSQL</productname>
版本 8.1 之前的系统表。它显示了所有在<link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>
中标记了<structfield>rolcanlogin</>的角色的属性。
</para>

  <!--
<para>
   The name stems from the fact that this table
   should not be readable by the public since it contains passwords.
   <link linkend="view-pg-user"><structname>pg_user</structname></link>
   is a publicly readable view on
   <structname>pg_shadow</structname> that blanks out the password field.
  </para>
-->
<para>
这个系统表的名字来自于该表不能被公众可读，因为它包含口令。
<link linkend="view-pg-user"><structname>pg_user</structname></link>是一个在
<structname>pg_shadow</structname>上公开可读的视图，只是把口令域填成了空白。
</para>

  <table>
   <!-- 
   <title><structname>pg_shadow</> Columns</title> 
   -->
   <title><structname>pg_shadow</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>usename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <!-- 
  <entry>User name</entry> 
  -->
  <entry>用户名</entry>
     </row>

     <row>
      <entry><structfield>usesysid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <!-- 
  <entry>ID of this user</entry> 
  -->
  <entry>用户的 ID</entry>
     </row>

     <row>
      <entry><structfield>usecreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>User can create databases</entry> 
  -->
  <entry>用户可以创建数据库</entry>
     </row>

     <row>
      <entry><structfield>usesuper</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>User is a superuser</entry> 
  -->
  <entry>用户是超级用户</entry>
     </row>

     <row>
      <entry><structfield>usecatupd</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   User can update system catalogs.  (Even a superuser cannot do
       this unless this column is true.) 
   -->
   用户可以更新系统表。即使超级用户，如果这个字段不是真，也不能更新系统表。
      </entry>
     </row>

     <row>
      <entry><structfield>userepl</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   User can initiate streaming replication and put the system in and
       out of backup mode. 
   -->
   用户可以初始化流复制和使系统处于或不处于备份模式。
      </entry>
     </row>

     <row>
      <entry><structfield>passwd</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <!-- 
  <entry>Password (possibly encrypted); null if none.  See
      <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>
      for details of how encrypted passwords are stored.</entry> 
  -->
  <entry>口令(可能是加密的)；如果没有则为null。参阅
  <link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>
  获取加密的口令是如何存储的信息。</entry>
     </row>

     <row>
      <entry><structfield>valuntil</structfield></entry>
      <entry><type>abstime</type></entry>
      <entry></entry>
      <!-- 
  <entry>Password expiry time (only used for password authentication)</entry> 
  -->
  <entry>口令失效的时间(只用于口令认证)</entry>
     </row>

     <row>
      <entry><structfield>useconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <!-- 
  <entry>Session defaults for run-time configuration variables</entry> 
  -->
  <entry>运行时配置变量的会话缺省</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-stats">
  <title><structname>pg_stats</structname></title>

  <indexterm zone="view-pg-stats">
   <primary>pg_stats</primary>
  </indexterm>

  <!--
<para>
   The view <structname>pg_stats</structname> provides access to
   the information stored in the <link
   linkend="catalog-pg-statistic"><structname>pg_statistic</structname></link>
   catalog.  This view allows access only to rows of
   <structname>pg_statistic</structname> that correspond to tables the
   user has permission to read, and therefore it is safe to allow public
   read access to this view.
  </para>
-->
<para>
<structname>pg_stats</structname>提供对存储在
<link linkend="catalog-pg-statistic"><structname>pg_statistic</structname></link>表里面的信息的访问。
这个视图允许只访问那些在<structname>pg_statistic</structname>里面对应用户有权限读取的表的数据行，
因此可以安全地允许公众访问这个视图。
</para>

  <!--
<para>
   <structname>pg_stats</structname> is also designed to present the
   information in a more readable format than the underlying catalog
   &mdash; at the cost that its schema must be extended whenever new slot types
   are defined for <structname>pg_statistic</structname>.
  </para>
-->
<para>
<structname>pg_stats</structname>也设计成把信息以一种更易读的方式出现的形式，
它比下层的系统表更容易阅读，代价就是如果在<structname>pg_statistic</structname>
里定义了新的数据槽位，那么必须扩展它的视图定义。
</para>

  <table>
   <!-- 
   <title><structname>pg_stats</> Columns</title> 
   -->
   <title><structname>pg_stats</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <!-- 
  <entry>Name of schema containing table</entry>
  -->
  <entry>包含此表的模式名字</entry>
     </row>

     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <!-- 
  <entry>Name of table</entry> 
  -->
  <entry>表的名字</entry>
     </row>

     <row>
      <entry><structfield>attname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-attribute"><structname>pg_attribute</structname></link>.attname</literal></entry>
      <!-- 
  <entry>Name of the column described by this row</entry> 
  -->
  <entry>这一行描述的字段的名字</entry>
     </row>

     <row>
      <entry><structfield>inherited</structfield></entry>
      <entry><type>bool</type></entry>
      <entry></entry>
      <!-- 
  <entry>If true, this row includes inheritance child columns, not just the
       values in the specified table</entry> 
   -->
   <entry>如果为真，那么这行包含继承的子字段，不只是指定表的值。</entry>
     </row>

     <row>
      <entry><structfield>null_frac</structfield></entry>
      <entry><type>real</type></entry>
      <entry></entry>
      <!-- 
  <entry>Fraction of column entries that are null</entry> 
  -->
  <entry>记录中字段为空的百分比</entry>
     </row>

     <row>
      <entry><structfield>avg_width</structfield></entry>
      <entry><type>integer</type></entry>
      <entry></entry>
      <!-- 
  <entry>Average width in bytes of column's entries</entry> 
  -->
  <entry>字段记录以字节记的平均宽度</entry>
     </row>

     <row>
      <entry><structfield>n_distinct</structfield></entry>
      <entry><type>real</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   If greater than zero, the estimated number of distinct values in the
       column.  If less than zero, the negative of the number of distinct
       values divided by the number of rows.  (The negated form is used when
       <command>ANALYZE</> believes that the number of distinct values is
       likely to increase as the table grows; the positive form is used when
       the column seems to have a fixed number of possible values.)  For
       example, -1 indicates a unique column in which the number of distinct
       values is the same as the number of rows. 
   -->
   如果大于零，就是在字段中独立数值的估计数目。如果小于零，
   就是独立数值的数目被行数除的负数。用负数形式是因为<command>ANALYZE</>
   认为独立数值的数目是随着表增长而增长；
   正数的形式用于在字段看上去好像有固定的可能值数目的情况下。比如，
   -1 表示一个唯一字段，独立数值的个数和行数相同。
      </entry>
     </row>

     <row>
      <entry><structfield>most_common_vals</structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   A list of the most common values in the column. (Null if
       no values seem to be more common than any others.) 
   -->
   一个字段里最常用数值的列表。如果看上去没有啥数值比其它更常见，则为 null
      </entry>
     </row>

     <row>
      <entry><structfield>most_common_freqs</structfield></entry>
      <entry><type>real[]</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   A list of the frequencies of the most common values,
       i.e., number of occurrences of each divided by total number of rows.
       (Null when <structfield>most_common_vals</structfield> is.) 
   -->
   一个最常用数值的频率的列表，也就是说，每个出现的次数除以行数。
   如果<structfield>most_common_vals</structfield>是 null ，则为 null。
      </entry>
     </row>

     <row>
      <entry><structfield>histogram_bounds</structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   A list of values that divide the column's values into groups of
       approximately equal population.  The values in
       <structfield>most_common_vals</>, if present, are omitted from this
       histogram calculation.  (This column is null if the column data type
       does not have a <literal>&lt;</> operator or if the
       <structfield>most_common_vals</> list accounts for the entire
       population.) 
   -->
   一个数值的列表，它把字段的数值分成几组大致相同热门的组。
   如果在<structfield>most_common_vals</>里有数值，则在这个饼图的计算中省略。
   如果字段数据类型没有<literal>&lt;</>操作符或者<structfield>most_common_vals</>
   列表代表了整个分布性，则这个字段为 null。
      </entry>
     </row>

     <row>
      <entry><structfield>correlation</structfield></entry>
      <entry><type>real</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   Statistical correlation between physical row ordering and
       logical ordering of the column values.  This ranges from -1 to +1.
       When the value is near -1 or +1, an index scan on the column will
       be estimated to be cheaper than when it is near zero, due to reduction
       of random access to the disk.  (This column is null if the column data
       type does not have a <literal>&lt;</> operator.) 
   -->
   统计与字段值的物理行序和逻辑行序有关。它的范围从 -1 到 +1 。
   在数值接近 -1 或者 +1 的时候，在字段上的索引扫描将被认为比它接近零的时候开销更少，
   因为减少了对磁盘的随机访问。如果字段数据类型没有<literal>&lt;</>操作符，那么这个字段为null。
      </entry>
     </row>

     <row>
      <entry><structfield>most_common_elems</structfield></entry>
      <entry><type>anyarray</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   A list of non-null element values most often appearing within values of
       the column. (Null for scalar types.) 
   -->
   经常在字段值中出现的非空元素值的列表。（标量类型为空。）
      </entry>
     </row>

     <row>
      <entry><structfield>most_common_elem_freqs</structfield></entry>
      <entry><type>real[]</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   A list of the frequencies of the most common element values, i.e., the
       fraction of rows containing at least one instance of the given value.
       Two or three additional values follow the per-element frequencies;
       these are the minimum and maximum of the preceding per-element
       frequencies, and optionally the frequency of null elements.
       (Null when <structfield>most_common_elems</structfield> is.) 
   -->
   最常见元素值的频率列表，也就是，至少包含一个给定值的实例的行的分数。
   每个元素频率跟着两到三个附加的值；它们是在每个元素频率之前的最小和最大值，
   还有可选择的null元素的频率。（当<structfield>most_common_elems</structfield>
   为null时，为null）
      </entry>
     </row>

     <row>
      <entry><structfield>elem_count_histogram</structfield></entry>
      <entry><type>real[]</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   A histogram of the counts of distinct non-null element values within the
       values of the column, followed by the average number of distinct
       non-null elements.  (Null for scalar types.) 
   -->
   该字段中值的不同非空元素值的统计直方图，跟着不同非空元素的平均值。（标量类型为空。）
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <!--
<para>
   The maximum number of entries in the array fields can be controlled on a
   column-by-column basis using the <command>ALTER TABLE SET STATISTICS</>
   command, or globally by setting the
   <xref linkend="guc-default-statistics-target"> run-time parameter.
  </para>
-->
<para>
在数组里的元素的最大数目可以用<command>ALTER TABLE SET STATISTICS</>命令一个一个字段地控制，
或者通过设置运行时参数<xref linkend="guc-default-statistics-target">全局地设置。
</para>

 </sect1>

 <sect1 id="view-pg-tables">
  <title><structname>pg_tables</structname></title>

  <indexterm zone="view-pg-tables">
   <primary>pg_tables</primary>
  </indexterm>

  <!--
<para>
   The view <structname>pg_tables</structname> provides access to
   useful information about each table in the database.
  </para>
-->
<para>
<structname>pg_tables</structname>提供了对有关数据库中每个表的有用信息地访问。
</para>

  <table>
   <!-- 
   <title><structname>pg_tables</> Columns</title> 
   -->
   <title><structname>pg_tables</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <!-- 
  <entry>Name of schema containing table</entry> 
  -->
  <entry>包含表的模式名字</entry>
     </row>
     <row>
      <entry><structfield>tablename</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <!-- 
  <entry>Name of table</entry> 
  -->
  <entry>表的名字</entry>
     </row>
     <row>
      <entry><structfield>tableowner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <!-- 
  <entry>Name of table's owner</entry> 
  -->
  <entry>表的所有者的名字</entry>
     </row>
     <row>
      <entry><structfield>tablespace</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-tablespace"><structname>pg_tablespace</structname></link>.spcname</literal></entry>
      <!-- 
  <entry>Name of tablespace containing table (null if default for database)</entry> 
  -->
  <entry>包含表的表空间名字(如果是数据库缺省，则为 null)</entry>
     </row>
     <row>
      <entry><structfield>hasindexes</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relhasindex</literal></entry>
      <!-- 
  <entry>True if table has (or recently had) any indexes</entry> 
  -->
  <entry>如果表拥有(或者最近拥有)任何索引，则为真</entry>
     </row>
     <row>
      <entry><structfield>hasrules</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relhasrules</literal></entry>
      <!-- 
  <entry>True if table has (or once had) rules</entry>
  -->
  <entry>如果表有（或曾静有）规则，则为真</entry>
     </row>
     <row>
      <entry><structfield>hastriggers</structfield></entry>
      <entry><type>boolean</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relhastriggers</literal></entry>
      <!-- 
  <entry>True if table has (or once had) triggers</entry> 
  -->
  <entry>如果表有（或曾静有）触发器，则为真</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-timezone-abbrevs">
  <title><structname>pg_timezone_abbrevs</structname></title>

  <indexterm zone="view-pg-timezone-abbrevs">
   <primary>pg_timezone_abbrevs</primary>
  </indexterm>

  <!--
<para>
   The view <structname>pg_timezone_abbrevs</structname> provides a list
   of time zone abbreviations that are currently recognized by the datetime
   input routines.  The contents of this view change when the
   <xref linkend="guc-timezone-abbreviations"> run-time parameter is modified.
  </para>
-->
<para>
<structname>pg_timezone_abbrevs</structname>提供了输入例程能够识别的所有时区缩写。
当运行时参数<xref linkend="guc-timezone-abbreviations">发生改变的时候，该视图的内容也会发生改变。
</para>

  <table>
   <!-- 
   <title><structname>pg_timezone_abbrevs</> Columns</title>
   -->
   <title><structname>pg_timezone_abbrevs</> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>Description</entry>
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>abbrev</structfield></entry>
      <entry><type>text</type></entry>
      <!-- 
  <entry>Time zone abbreviation</entry> 
  -->
  <entry>时区缩写</entry>
     </row>
     <row>
      <entry><structfield>utc_offset</structfield></entry>
      <entry><type>interval</type></entry>
      <!-- 
  <entry>Offset from UTC (positive means east of Greenwich)</entry> 
  -->
  <entry>相对于 UTC 的偏移量</entry>
     </row>
     <row>
      <entry><structfield>is_dst</structfield></entry>
      <entry><type>boolean</type></entry>
      <!-- 
  <entry>True if this is a daylight-savings abbreviation</entry> 
  -->
  <entry>如果这是一个夏时制时区缩写则为真</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-timezone-names">
  <title><structname>pg_timezone_names</structname></title>

  <indexterm zone="view-pg-timezone-names">
   <primary>pg_timezone_names</primary>
  </indexterm>

  <!--
<para>
   The view <structname>pg_timezone_names</structname> provides a list
   of time zone names that are recognized by <command>SET TIMEZONE</>,
   along with their associated abbreviations, UTC offsets,
   and daylight-savings status.  (Technically,
   <productname>PostgreSQL</productname> uses <acronym>UT1</> rather
   than UTC because leap seconds are not handled.)
   Unlike the abbreviations shown in <link
   linkend="view-pg-timezone-abbrevs"><structname>pg_timezone_abbrevs</structname></link>, many of these names imply a set of daylight-savings transition
   date rules.  Therefore, the associated information changes across local DST
   boundaries.  The displayed information is computed based on the current
   value of <function>CURRENT_TIMESTAMP</>.
  </para>
-->
<para>
<structname>pg_timezone_names</structname>显示了所有能够被<command>SET TIMEZONE</>
识别的时区名及其缩写、UTC 偏移量、是否夏时制。（学术上，<productname>PostgreSQL</productname>
使用<acronym>UT1</>而不是UTC，因为它不处理闺秒。）不同于在
<link linkend="view-pg-timezone-abbrevs"><structname>pg_timezone_abbrevs</structname></link>
中显示的缩写，许多这些名字都隐含着夏令时转换规则。因此，在跨越夏令时边界时相关信息会发生变化。
显示的信息给予当前的<function>CURRENT_TIMESTAMP</>值进行计算。
</para>

  <table>
   <!-- 
   <title><structname>pg_timezone_names</> Columns</title> 
   -->
   <title><structname>pg_timezone_names</> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>name</structfield></entry>
      <entry><type>text</type></entry>
      <!-- 
  <entry>Time zone name</entry> 
  -->
  <entry>时区名</entry>
     </row>
     <row>
      <entry><structfield>abbrev</structfield></entry>
      <entry><type>text</type></entry>
      <!-- 
  <entry>Time zone abbreviation</entry>
  -->
  <entry>时区缩写</entry>
     </row>
     <row>
      <entry><structfield>utc_offset</structfield></entry>
      <entry><type>interval</type></entry>
      <!-- 
  <entry>Offset from UTC (positive means east of Greenwich)</entry> 
  -->
  <entry>相对于 UTC 的偏移量（正数为东格林威治）</entry>
     </row>
     <row>
      <entry><structfield>is_dst</structfield></entry>
      <entry><type>boolean</type></entry>
      <!-- 
  <entry>True if currently observing daylight savings</entry> 
  -->
  <entry>如果当前正处于夏令时范围则为真</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-user">
  <title><structname>pg_user</structname></title>

  <indexterm zone="view-pg-user">
   <primary>pg_user</primary>
  </indexterm>

  <!--
<para>
   The view <structname>pg_user</structname> provides access to
   information about database users.  This is simply a publicly
   readable view of
   <link linkend="view-pg-shadow"><structname>pg_shadow</structname></link>
   that blanks out the password field.
  </para>
-->
<para>
<structname>pg_user</structname>提供了对数据库用户的相关信息的访问。
这个视图只是一个<link linkend="view-pg-shadow"><structname>pg_shadow</structname></link>
的公众可读的部分的视图化，它把口令域给刷掉了。
</para>

  <table>
   <!-- 
   <title><structname>pg_user</> Columns</title> 
   -->
   <title><structname>pg_user</> 字段</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>usename</structfield></entry>
      <entry><type>name</type></entry>
      <!-- 
  <entry>User name</entry> 
  -->
  <entry>用户名</entry>
     </row>

     <row>
      <entry><structfield>usesysid</structfield></entry>
      <entry><type>oid</type></entry>
      <!-- 
  <entry>ID of this user</entry> 
  -->
  <entry>用户 ID</entry>
     </row>

     <row>
      <entry><structfield>usecreatedb</structfield></entry>
      <entry><type>bool</type></entry>
      <!-- 
  <entry>User can create databases</entry> 
  -->
  <entry>用户可以创建数据库</entry>
     </row>

     <row>
      <entry><structfield>usesuper</structfield></entry>
      <entry><type>bool</type></entry>
      <!-- 
  <entry>User is a superuser</entry> 
  -->
  <entry>用户是一个超级用户</entry>
     </row>

     <row>
      <entry><structfield>usecatupd</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>
       <!-- 
   User can update system catalogs.  (Even a superuser cannot do
       this unless this column is true.)
   -->
   用户可以更新系统表。即使超级用户也不能这么干，除非这个字段为真。
      </entry>
     </row>

     <row>
      <entry><structfield>userepl</structfield></entry>
      <entry><type>bool</type></entry>
      <entry>
       <!-- 
   User can initiate streaming replication and put the system in and
       out of backup mode. 
   -->
   用户可以初始化流复制并且使系统处于或离开备份模式。
      </entry>
     </row>

     <row>
      <entry><structfield>passwd</structfield></entry>
      <entry><type>text</type></entry>
      <!-- 
  <entry>Not the password (always reads as <literal>********</>)</entry> 
  -->
  <entry>不是口令(总是为 <literal>********</>)</entry>
     </row>

     <row>
      <entry><structfield>valuntil</structfield></entry>
      <entry><type>abstime</type></entry>
      <!-- 
  <entry>Password expiry time (only used for password authentication)</entry> 
  -->
  <entry>口令失效的时间(只用于口令认证)</entry>
     </row>

     <row>
      <entry><structfield>useconfig</structfield></entry>
      <entry><type>text[]</type></entry>
      <!-- 
  <entry>Session defaults for run-time configuration variables</entry> 
  -->
  <entry>运行时配置参数的会话缺省</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

 <sect1 id="view-pg-user-mappings">
  <title><structname>pg_user_mappings</structname></title>

  <indexterm zone="view-pg-user-mappings">
   <primary>pg_user_mappings</primary>
  </indexterm>

  <!--
<para>
   The view <structname>pg_user_mappings</structname> provides access
   to information about user mappings.  This is essentially a publicly
   readable view of
   <link linkend="catalog-pg-user-mapping"><structname>pg_user_mapping</structname></link>
   that leaves out the options field if the user has no rights to use
   it.
  </para>
-->
<para>
<structname>pg_user_mappings</structname>提供访问关于用户映射的信息的接口。
这个视图只是一个<link linkend="catalog-pg-user-mapping"><structname>pg_user_mapping</structname></link>
的公众可读的部分的视图化，如果用户无权使用它则空着选项字段。
</para>

  <table>
   <!-- 
   <title><structname>pg_user_mappings</> Columns</title>
   -->
   <title><structname>pg_user_mappings</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>umid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-user-mapping"><structname>pg_user_mapping</structname></link>.oid</literal></entry>
      <!-- 
  <entry>OID of the user mapping</entry> 
  -->
  <entry>用户映射的OID</entry>
     </row>

     <row>
      <entry><structfield>srvid</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-foreign-server"><structname>pg_foreign_server</structname></link>.oid</literal></entry>
      <entry>
       <!-- 
   The OID of the foreign server that contains this mapping 
   -->
   包含这个映射的外部服务器的OID
      </entry>
     </row>

     <row>
      <entry><structfield>srvname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-foreign-server"><structname>pg_foreign_server</structname></link>.srvname</literal></entry>
      <entry>
       <!-- 
   Name of the foreign server 
   -->
   外部服务器的名字
      </entry>
     </row>

     <row>
      <entry><structfield>umuser</structfield></entry>
      <entry><type>oid</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.oid</literal></entry>
      <!-- 
  <entry>OID of the local role being mapped, 0 if the user mapping is public</entry> 
  -->
  <entry>被映射的本地角色的OID，如果用户映射是公共的则为0</entry>
     </row>

     <row>
      <entry><structfield>usename</structfield></entry>
      <entry><type>name</type></entry>
      <entry></entry>
      <!-- 
  <entry>Name of the local user to be mapped</entry> 
  -->
  <entry>被映射的本地用户的名字</entry>
     </row>

     <row>
      <entry><structfield>umoptions</structfield></entry>
      <entry><type>text[]</type></entry>
      <entry></entry>
      <entry>
       <!-- 
   User mapping specific options, as <quote>keyword=value</>
       strings, if the current user is the owner of the foreign
       server, else null 
   -->
   如果当前用户是外部服务器的所有者，则为用户映射指定选项，
   使用<quote>keyword=value</>字符串，否则为null
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect1>


 <sect1 id="view-pg-views">
  <title><structname>pg_views</structname></title>

  <indexterm zone="view-pg-views">
   <primary>pg_views</primary>
  </indexterm>

  <!--
<para>
   The view <structname>pg_views</structname> provides access to
   useful information about each view in the database.
  </para>
-->
<para>
<structname>pg_views</structname>提供了对数据库里每个视图的有用信息的访问途径。
</para>

  <table>
   <!-- 
   <title><structname>pg_views</> Columns</title> 
   -->
   <title><structname>pg_views</> 字段</title>

   <tgroup cols="4">
    <thead>
     <row>
      <!-- 
  <entry>Name</entry>
      <entry>Type</entry>
      <entry>References</entry>
      <entry>Description</entry> 
  -->
  <entry>名字</entry>
      <entry>类型</entry>
      <entry>引用</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><structfield>schemaname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-namespace"><structname>pg_namespace</structname></link>.nspname</literal></entry>
      <!-- 
  <entry>Name of schema containing view</entry> 
  -->
  <entry>包含此视图的模式名字</entry>
     </row>
     <row>
      <entry><structfield>viewname</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-class"><structname>pg_class</structname></link>.relname</literal></entry>
      <!-- 
  <entry>Name of view</entry> 
  -->
  <entry>视图的名字</entry>
     </row>
     <row>
      <entry><structfield>viewowner</structfield></entry>
      <entry><type>name</type></entry>
      <entry><literal><link linkend="catalog-pg-authid"><structname>pg_authid</structname></link>.rolname</literal></entry>
      <!-- 
  <entry>Name of view's owner</entry> 
  -->
  <entry>视图的所有者的名字</entry>
     </row>
     <row>
      <entry><structfield>definition</structfield></entry>
      <entry><type>text</type></entry>
      <entry></entry>
      <!-- 
  <entry>View definition (a reconstructed <command>SELECT</command> query)</entry> 
  -->
  <entry>视图定义(一个重建的<command>SELECT</command>查询)</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect1>

</chapter>
