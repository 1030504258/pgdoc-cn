<!--
doc/src/sgml/ref/cluster.sgml
PostgreSQL documentation
-->

<refentry id="SQL-CLUSTER">
 <refmeta>
  <refentrytitle>CLUSTER</refentrytitle>
  <manvolnum>7</manvolnum>
  <!--
<refmiscinfo>SQL - Language Statements</refmiscinfo>
-->
<refmiscinfo>SQL - 语句</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CLUSTER</refname>
  <!--
<refpurpose>cluster a table according to an index</refpurpose>
-->
<refpurpose>
根据一个索引对某个表盘簇化排序
</refpurpose>
 </refnamediv>

 <indexterm zone="sql-cluster">
  <primary>CLUSTER</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
CLUSTER [VERBOSE] <replaceable class="PARAMETER">table_name</replaceable> [ USING <replaceable class="PARAMETER">index_name</replaceable> ]
CLUSTER [VERBOSE]
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <!--
<title>Description</title>
-->
<title>描述</title>

  <!--
<para>
   <command>CLUSTER</command> instructs <productname>PostgreSQL</productname>
   to cluster the table specified
   by <replaceable class="parameter">table_name</replaceable>
   based on the index specified by
   <replaceable class="parameter">index_name</replaceable>. The index must
   already have been defined on
   <replaceable class="parameter">table_name</replaceable>.
  </para>
-->
<para>
<command>CLUSTER</command>指示<productname>PostgreSQL</productname>基于索引<replaceable class="parameter">index_name</replaceable>的内容对表<replaceable class="parameter">table_name</replaceable>进行存储盘簇化排序。
索引必须已经在表<replaceable class="parameter">table_name</replaceable>上定义过的索引。 
</para>

  <!--
<para>
   When a table is clustered, it is physically reordered
   based on the index information. Clustering is a one-time operation:
   when the table is subsequently updated, the changes are
   not clustered.  That is, no attempt is made to store new or
   updated rows according to their index order.  (If one wishes, one can
   periodically recluster by issuing the command again.  Also, setting
   the table's <literal>FILLFACTOR</literal> storage parameter to less than
   100% can aid in preserving cluster ordering during updates, since updated
   rows are kept on the same page if enough space is available there.)
  </para>
-->
<para>
当对一个表盘簇化排序后，该表的物理存储将基于索引顺序排序。盘簇化是一次性操作：当表将来被更新之后，更改的内容不会被盘簇化排序。
也就是说，系统不会试图按照索引顺序对更新过的记录重新盘簇化排序。
（如果用户想要这个效果，可以通过周期性地手工执行该命令的方法重新盘簇化排序。
并且，设置表的<literal>FILLFACTOR</literal>存储参数为小于100%可以帮助盘簇化排序在更新时排序，因为若有足够的空间可用，更新的行可以保存在相同的页面位置。） 
</para>

  <!--
<para>
   When a table is clustered, <productname>PostgreSQL</productname>
   remembers which index it was clustered by.  The form
   <command>CLUSTER <replaceable class="parameter">table_name</replaceable></command>
   reclusters the table using the same index as before.  You can also
   use the <literal>CLUSTER</literal> or <literal>SET WITHOUT CLUSTER</literal>
   forms of <xref linkend="SQL-ALTERTABLE"> to set the index to be used for
   future cluster operations, or to clear any previous setting.
  </para>
-->
<para>
在对一个表盘簇化排序之后，<productname>PostgreSQL</productname>会记忆使用了哪个索引上进行了盘簇化排序。
<command>CLUSTER <replaceable class="parameter">table_name</replaceable></command>的形式在表以前进行盘簇化排序的同一个索引上重新盘簇化排序。
也可以用<literal>CLUSTER</literal> 或<literal>SET WITHOUT CLUSTER</literal>形式来设置用于进行盘簇化排序的索引，或清除任何之前的设置。 
</para>

  <!--
<para>
   <command>CLUSTER</command> without any parameter reclusters all the
   previously-clustered tables in the current database that the calling user
   owns, or all such tables if called by a superuser.  This
   form of <command>CLUSTER</command> cannot be executed inside a transaction
   block.
  </para>
-->
<para>
不含参数的<command>CLUSTER</command>会将当前用户所拥有的当前数据库中的所有先前进行盘簇化排序的表重新处理，或者如果是超级用户使用这个命令时，则对所有进行过盘簇化排序表重新处理。
这种形式的<command>CLUSTER</command>不能在一个事务里面调用。 
</para>

  <!--
<para>
   When a table is being clustered, an <literal>ACCESS
   EXCLUSIVE</literal> lock is acquired on it. This prevents any other
   database operations (both reads and writes) from operating on the
   table until the <command>CLUSTER</command> is finished.
  </para>
-->
<para>
在对一个表进行盘簇化排序的时候，会在其上请求一个<literal>ACCESS EXCLUSIVE</literal>锁。这样就避免了在<command>CLUSTER</command>完成之前执行任何其它的数据库操作(包括读写)。 
</para>
 </refsect1>

 <refsect1>
  <!--
<title>Parameters</title>
-->
<title>参数</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="PARAMETER">table_name</replaceable></term>
    <listitem>
     <!--
<para>
      The name (possibly schema-qualified) of a table.
     </para>
-->
<para>
表的名称（可以有模式修饰）。 
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="PARAMETER">index_name</replaceable></term>
    <listitem>
     <!--
<para>
      The name of an index.
     </para>
-->
<para>
一个索引名称。 
</para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>VERBOSE</literal></term>
    <listitem>
     <!--
<para>
      Prints a progress report as each table is clustered.
     </para>
-->
<para>
当每一个表进行盘簇化排序时打印一个处理情况报告。 
</para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <!--
<title>Notes</title>
-->
<title>注意</title>

   <!--
<para>
    In cases where you are accessing single rows randomly
    within a table, the actual order of the data in the
    table is unimportant. However, if you tend to access some
    data more than others, and there is an index that groups
    them together, you will benefit from using <command>CLUSTER</command>.
    If you are requesting a range of indexed values from a table, or a
    single indexed value that has multiple rows that match,
    <command>CLUSTER</command> will help because once the index identifies the
    table page for the first row that matches, all other rows
    that match are probably already on the same table page,
    and so you save disk accesses and speed up the query.
   </para>
-->
<para>
如果你只是随机的访问表中的行，那么表中数据的实际存储顺序是无关紧要的。
但是，如果对某些特定数据的访问较多，而且有一个索引将这些数据分组，那么使用<command>CLUSTER</command>会非常有益处。
如果从一个表中请求一定索引范围的值，或者是一个索引值对应多行，<command>CLUSTER</command>也会有助于应用，因为如果索引标识出第一匹配行所在的存储页，所有其它行也可能已经在同一个存储页里了，这样便节省了磁盘访问的时间，加速了查询。 
</para>

   <!--
<para>
    <command>CLUSTER</> can re-sort the table using either an index scan
    on the specified index, or (if the index is a b-tree) a sequential
    scan followed by sorting.  It will attempt to choose the method that
    will be faster, based on planner cost parameters and available statistical
    information.
   </para>
-->
<para>
<command>CLUSTER</>在盘簇化排序的处理过程中，可以按一个索引顺序，也可以按一个排序后的顺序扫描内容。
它会基于查询规划器的成本参数和表的统计信息选择一个相对较快的方法。
</para>

   <!--
<para>
    When an index scan is used, a temporary copy of the table is created that
    contains the table data in the index order.  Temporary copies of each
    index on the table are created as well.  Therefore, you need free space on
    disk at least equal to the sum of the table size and the index sizes.
   </para>
-->
<para>
<command>CLUSTER</>在盘簇化排序的处理过程中，系统先创建一个按照索引顺序建立的表的临时拷贝。同时也建立表上的每个索引的临时拷贝。
因此，需要磁盘上有足够的剩余空间，至少是表大小和索引大小的和。 
</para>

   <!--
<para>
    When a sequential scan and sort is used, a temporary sort file is
    also created, so that the peak temporary space requirement is as much
    as double the table size, plus the index sizes.  This method is often
    faster than the index scan method, but if the disk space requirement is
    intolerable, you can disable this choice by temporarily setting <xref
    linkend="guc-enable-sort"> to <literal>off</>.
   </para>
-->
<para>
当使用顺序扫描和排序操作时，系统会创建临时排序文件，这样极端情况下，磁盘空间会需要至少约2倍的表大小和索引大小。
这个方法一般比使用索引的方法要快一点，但如果对磁盘空间的要求不可接受，可以临时设置<xref linkend="guc-enable-sort"> 为 <literal>off</>来禁用这个选择。
</para>

   <!--
<para>
    It is advisable to set <xref linkend="guc-maintenance-work-mem"> to
    a reasonably large value (but not more than the amount of RAM you can
    dedicate to the <command>CLUSTER</> operation) before clustering.
   </para>
-->
<para>
建议在执行盘簇化排序前，将<xref linkend="guc-maintenance-work-mem">参数设置为一个合理的较大数值（但不要超过可以保留给<command>CLUSTER</>使用的内存大小）。
</para>

   <!--
<para>
    Because the planner records statistics about the ordering of
    tables, it is advisable to run <xref linkend="sql-analyze">
    on the newly clustered table.
    Otherwise, the planner might make poor choices of query plans.
   </para>
-->
<para>
因为规划器记录着有关表的排序的统计，所以建议在最近盘簇化排序后的表上运行<xref linkend="sql-analyze">。否则，规划器可能会选择很差劲的查询规划。 
</para>

   <!--
<para>
    Because <command>CLUSTER</command> remembers which indexes are clustered,
    one can cluster the tables one wants clustered manually the first time,
    then set up a periodic maintenance script that executes
    <command>CLUSTER</> without any parameters, so that the desired tables
    are periodically reclustered.
   </para>
-->
<para>
因为<command>CLUSTER</command>记录着哪些索引用于过盘簇化排序，所以用户可以第一次手工指定表使用指定索引进行盘簇化排序，以后设置一个周期化执行的维护脚本，只需执行不带参数的<command>CLUSTER</>命令，即可实现对想要周期性盘簇化排序的表进行自动更新。
 </para>

 </refsect1>

 <refsect1>
  <!--
<title>Examples</title>
-->
<title>例子</title>

  <!--
<para>
   Cluster the table <literal>employees</literal> on the basis of
   its index <literal>employees_ind</literal>:
<programlisting>
CLUSTER employees USING employees_ind;
</programlisting>
  </para>
-->
<para>
按照索引<literal>employees_ind</literal>的顺序对<literal>employees</literal>表进行盘簇化排序：
<programlisting>
CLUSTER employees USING employees_ind;
</programlisting>
</para>

  <!--
<para>
   Cluster the <literal>employees</literal> table using the same
   index that was used before:
<programlisting>
CLUSTER employees;
</programlisting>
  </para>
-->
<para>
使用以前用过的同一个索引对<literal>employees</literal>表进行盘簇化排序： 
<programlisting>
CLUSTER employees;
</programlisting>
</para>

  <!--
<para>
   Cluster all tables in the database that have previously been clustered:
<programlisting>
CLUSTER;
</programlisting></para>
-->
<para>
对以前盘簇化排序过的所有表进行重新盘簇化排序： 
<programlisting>
CLUSTER;
</programlisting>
</para>
 </refsect1>

 <refsect1>
  <!--
<title>Compatibility</title>
-->
<title>兼容性</title>

  <!--
<para>
   There is no <command>CLUSTER</command> statement in the SQL standard.
  </para>
-->
<para>
SQL标准里没有<command>CLUSTER</command>语句。 
</para>

  <!--
<para>
   The syntax
<synopsis>
CLUSTER <replaceable class="PARAMETER">index_name</replaceable> ON <replaceable class="PARAMETER">table_name</replaceable>
</synopsis>
  is also supported for compatibility with pre-8.3 <productname>PostgreSQL</>
  versions.
  </para>
-->
<para>
<synopsis> CLUSTER <replaceable class="PARAMETER">index_name</replaceable> ON <replaceable class="PARAMETER">table_name</replaceable></synopsis>的语法也兼容<productname>PostgreSQL</> 8.3之前的版本
</para>
 </refsect1>

 <refsect1>
  <!--
<title>See Also</title>
-->
<title>参见</title>

  <simplelist type="inline">
   <member><xref linkend="app-clusterdb"></member>
  </simplelist>
 </refsect1>
</refentry>
