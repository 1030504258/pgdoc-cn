<!-- doc/src/sgml/spgist.sgml -->

<chapter id="SPGiST">
<title>SP-GiST索引</title>

   <indexterm>
    <primary>index</primary>
    <secondary>SP-GiST</secondary>
   </indexterm>

<sect1 id="spgist-intro">
 <title>简介</title>

 <para>
  <acronym>SP-GiST</acronym>是空间划分<acronym>GiST</acronym>（Space-partitioned GiST）的简称。<acronym>SP-GiST</acronym>支持划分搜索树，它们可用于开发许多各种不同的非平衡数据结构，例如四叉树、k-d树和单词查找树。这些结构的共同特征是它们反复地将搜索空间划分成大小不需要相等的分区。匹配这些划分规则的搜索将会很快。
 </para>

 <para>
  这些常用的数据结构最初是为在内存中使用而设计的。在主存中，它们通常被设计为一组由指针链接的动态分配的结点。这对直接在磁盘上存储并不合适，因为这些指针链可能很长并且需要太多次的磁盘访问。相反，基于磁盘的数据结构应该具有高扇出来最小化 I/O。<acronym>SP-GiST</acronym>所提出的挑战是将搜索树结点映射到磁盘页面，这样即使是一次搜索会穿过很多结点，它也只需要访问很少的几个磁盘页面。
 </para>

 <para>
  和<acronym>GiST</acronym>一样，<acronym>SP-GiST</acronym>也打算允许带有合适访问方法的自定义数据类型的开发，这种开发只需由该数据类型的领域专家参与，而不需要数据库专家的参与。
 </para>

 <para>
  这里的一些信息是来自于普渡大学的 SP-GiST 索引项目<ulink url="http://www.cs.purdue.edu/spgist/">web site</ulink>。<productname>PostgreSQL</productname>中的<acronym>SP-GiST</acronym>实现主要由 Teodor Sigaev 和 Oleg Bartunov 维护，在他们的
  <!-- URL will be changed -->
  <ulink url="http://www.sai.msu.su/~megera/wiki/spgist_dev">网站</ulink>上有更多信息。
 </para>

</sect1>

<sect1 id="spgist-builtin-opclasses">
 <title>内建操作符类</title>

 <para>
  <xref linkend="spgist-builtin-opclasses-table">中展示了<productname>PostgreSQL</>
  核心发布所包括的<acronym>SP-GiST</acronym>操作符类。
 </para>

  <table id="spgist-builtin-opclasses-table">
   <title>内建 <acronym>SP-GiST</acronym> 操作符类</title>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>名称</entry>
      <entry>索引数据类型</entry>
      <entry>可索引操作符</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><literal>kd_point_ops</></entry>
      <entry><type>point</></entry>
      <entry>
       <literal>&lt;&lt;</>
       <literal>&lt;@</>
       <literal>&lt;^</>
       <literal>&gt;&gt;</>
       <literal>&gt;^</>
       <literal>~=</>
      </entry>
     </row>
     <row>
      <entry><literal>quad_point_ops</></entry>
      <entry><type>point</></entry>
      <entry>
       <literal>&lt;&lt;</>
       <literal>&lt;@</>
       <literal>&lt;^</>
       <literal>&gt;&gt;</>
       <literal>&gt;^</>
       <literal>~=</>
      </entry>
     </row>
     <row>
      <entry><literal>range_ops</></entry>
      <entry>任何范围类型</entry>
      <entry>
       <literal>&amp;&amp;</>
       <literal>&amp;&lt;</>
       <literal>&amp;&gt;</>
       <literal>-|-</>
       <literal>&lt;&lt;</>
       <literal>&lt;@</>
       <literal>=</>
       <literal>&gt;&gt;</>
       <literal>@&gt;</>
      </entry>
     </row>
     <row>
      <entry><literal>text_ops</></entry>
      <entry><type>text</></entry>
      <entry>
       <literal>&lt;</>
       <literal>&lt;=</>
       <literal>=</>
       <literal>&gt;</>
       <literal>&gt;=</>
       <literal>~&lt;=~</>
       <literal>~&lt;~</>
       <literal>~&gt;=~</>
       <literal>~&gt;~</>
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 <para>
  在用于类型<type>point</>的两种操作符类中，<literal>quad_point_ops</>
  是默认值。<literal>kd_point_ops</>支持相同的操作符，但是使用一种不同的
  索引数据结构，在某些应用中它可以提供更好的性能。
 </para>

</sect1>

<sect1 id="spgist-extensibility">
 <title>可扩展性</title>

 <para>
  <acronym>SP-GiST</acronym>提供了一个高抽象层次的接口，要求访问方法开发者实现与一个给定数据类型相关的几种方法。<acronym>SP-GiST</acronym>核心负责高效的磁盘映射和搜索树结构。它也会处理并发和日志。
 </para>

 <para>
  <acronym>SP-GiST</acronym>树的叶子元组包含与被索引列数据类型相同的值。在根层的叶子元组总是包含原始的被索引数据值，但是在较下层的叶子元组可能只含有一个压缩后的表示，例如一个后缀。在这种情况下，操作符类支持函数必须能够使用从内部元组计算出来的信息重构出原始的值，这些内部元组指的是在到达叶子层的过程中穿过的元组。
 </para>

 <para>
  内部元组更加复杂，因为它们是搜索树的分支点。每一个内部元组包含一个或者更多个<firstterm>结点</>，结点表示一个具有相似叶子值的组。一个结点包含一个向下的链接，这个链接可以导向另一个较下层的内部元组，或者是由位于同一索引页面的叶子元组组成的一个短列表。每一个结点还有一个<firstterm>标签</>来描述它，例如，在一个 radix 树中结点标签可以是串值的下一个字符。可选择地，一个内部元组可以有一个<firstterm>前缀</>值来描述它所有的成员。在一个 radix 树中前缀可以是所表示的串的公共前缀。前缀值并不一定非要是一个真正的前缀，它可以是操作符类需要的任何数据。例如，在一个四叉树中它可以存储用于划分四个象限的中心点。一个四叉树的内部元组则可以包含对应于围绕该中心点的象限的四个结点。
 </para>

 <para>
  某些树算法要求当前元组所在层（或深度）的知识，因此<acronym>SP-GiST</acronym>核心为操作符类提供了机会以便在沿着树下降时管理层计数。当需要重组被表示的值时，这也可以为增量地重构过程提供支持。
 </para>

 <note>
  <para>
   <acronym>SP-GiST</acronym>核心代码会关注空项。尽管<acronym>SP-GiST</acronym>索引确实可以存储被索引列中的空值，但这对索引操作符类代码是隐藏的：不会有空索引项或搜索条件会被传递给操作符类方法（我们假定<acronym>SP-GiST</acronym>操作符是严格的并且因此无法成功处理空值）。因此这里不会进一步讨论空值。
  </para>
 </note>

 <para>
  一个<acronym>SP-GiST</acronym>的索引操作符类必须提供五个用户定义的方法。所有五个方法都接受两个<type>内部</>参数，其中第一个是一个指针，它指向一个包含用于支持方法的值的 C 结构。而第二个参数也是一个指针，它指向将放置输出值的 C 结构。其中四个函数只返回<type>void</>，因为它们的所有结果都出现在输出结构中。但是<function>leaf_consistent</>会额外返回一个<type>boolean</>结果。这些方法不能修改它们的输入结构的任何域。在所有情况下，调用用户定义的方法之前输出结构都被初始化为零。
 </para>

 <para>
  五个用户定义的方法是：
 </para>

 <variablelist>
    <varlistentry>
     <term><function>config</></term>
     <listitem>
      <para>
       返回关于索引实现的静态信息，包括前缀的数据类型的OID以及结点标签数据类型。
      </para>
     <para>
      这个函数的<acronym>SQL</>声明必须看起来像这样：
<programlisting>
CREATE FUNCTION my_config(internal, internal) RETURNS void ...
</programlisting>
      第一个参数是一个指向<structname>spgConfigIn</> C 结构的指针，包含该函数的输入数据。第二个参数是一个指向<structname>spgConfigOut</> C 结构的指针，函数必须将结果数据填充在其中。
<programlisting>
typedef struct spgConfigIn
{
    Oid         attType;        /* 要被索引的数据类型 */
} spgConfigIn;

typedef struct spgConfigOut
{
    Oid         prefixType;     /* 内部元组前缀的数据类型 */
    Oid         labelType;      /* 内部元组结点标签的数据类型 */
    bool        canReturnData;  /* 操作符类能重构原始数据 */
    bool        longValuesOK;   /* 操作符类能处理值 &gt; 1 页 */
} spgConfigOut;
</programlisting>

      为了支持多态的索引操作符类，<structfield>attType</>要被传入；对于普通固定数据类型的操作符类，它将总是取相同的值，因此可以被忽略。
     </para>

     <para>
      对于不使用前缀的操作符类，<structfield>prefixType</>可以被设置为<literal>VOIDOID</>。同样，对于不使用结点标签的操作符类，<structfield>labelType</>可以被设置为<literal>VOIDOID</>。如果操作符类能够重构出原来提供的被索引值，则<structfield>canReturnData</>应该被设置为真。只有当<structfield>attType</>是变长的并且操作符类能够将长值通过反复的添加后缀分段时，<structfield>longValuesOK</>才应当被设置为真（参见<xref linkend="spgist-limits">）。
     </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>choose</></term>
     <listitem>
      <para>
        为将一个新值插入到一个内部元组选择一种方法。
      </para>

     <para>
      该函数的<acronym>SQL</>声明必须看起来像这样：
<programlisting>
CREATE FUNCTION my_choose(internal, internal) RETURNS void ...
</programlisting>
      第一个参数是一个指向<structname>spgChooseIn</> C 结构的指针，包含该函数的输入数据。第二个参数是一个指向<structname>spgChooseOut</> C 结构的指针，函数必须将结果数据填充在其中。
<programlisting>
typedef struct spgChooseIn
{
    Datum       datum;          /* 要被索引的原始数据 */
    Datum       leafDatum;      /* 要被存储在叶子中的当前数据 */
    int         level;          /* 当前层（从零计数） */

    /* 来自当前内部元组的数据 */
    bool        allTheSame;     /* tuple is marked all-the-same? */
    bool        hasPrefix;      /* 元组有一个前缀？ */
    Datum       prefixDatum;    /* 如果有，前缀值 */
    int         nNodes;         /* 内部元组中的结点数目 */
    Datum      *nodeLabels;     /* 结点标签值（如果没有为 NULL） */
} spgChooseIn;

typedef enum spgChooseResultType
{
    spgMatchNode = 1,           /* 下降到现有结点 */
    spgAddNode,                 /* 向内部元组增加一个结点 */
    spgSplitTuple               /* 划分内部元组（修改它的前缀） */
} spgChooseResultType;

typedef struct spgChooseOut
{
    spgChooseResultType resultType;     /* 动作代码，见上文 */
    union
    {
        struct                  /* 用于spgMatchNode的结果 */
        {
            int         nodeN;      /* 下降到这个结点（索引从 0 开始） */
            int         levelAdd;   /* 这次匹配增加的层 */
            Datum       restDatum;  /* 新叶数据 */
        }           matchNode;
        struct                  /* 用于spgAddNode的结果 */
        {
            Datum       nodeLabel;  /* 新结点的标签 */
            int         nodeN;      /* 在哪里插入它（索引从 0 开始） */
        }           addNode;
        struct                  /* 用于spgSplitTuple的结果 */
        {
            /* 来自有一个结点的新内部元组的信息 */
            bool        prefixHasPrefix;    /* 元组能有前缀吗？ */
            Datum       prefixPrefixDatum;  /* 如果有，前缀值 */
            Datum       nodeLabel;          /* 结点的标签 */

            /* 来自放有所有旧结点的新下层内部元组的信息 */
            bool        postfixHasPrefix;   /* 元组能有前缀吗？ */
            Datum       postfixPrefixDatum; /* 如果有，前缀值 */
        }           splitTuple;
    }           result;
} spgChooseOut;
</programlisting>

       <structfield>datum</>是将被插入到索引中的原始数据。<structfield>leafDatum</>最初和<structfield>datum</>一样，但是如果<function>choose</function>或<function>picksplit</function>改变了它，那么位于较低层的<structfield>leafDatum</>值就会有所改变。当插入搜索到达一个叶子页，<structfield>leafDatum</>的当前值就会被存储在新创建的叶子元组中。<structfield>level</>是当前内部元组的层次，根层是 0 。如果当前内部元组被标记为包含多个等价节点（见<xref linkend="spgist-all-the-same">），<structfield>allTheSame</>为真。如果当前内部元组有一个前缀，<structfield>hasPrefix</>为真，如果这样，<structfield>prefixDatum</>为前缀值。<structfield>nNodes</>是包含在内部元组中子结点的数量，并且<structfield>nodeLabels</>是这些子结点的标签值的数组，如果没有标签则为 NULL。
      </para>

      <para>
       The <function>choose</function>函数能决定新值是匹配一个现有子结点，或是必须增加一个新的子节点，亦或是新值和元组的前缀不一致并且因此该内部元组必须被分裂来创建限制性更低的前缀。
      </para>

      <para>
       如果新值匹配一个现有的子结点，将<structfield>resultType</>设置为<literal>spgMatchNode</>。将<structfield>nodeN</>设置为该结点在结点数组中的索引（从零开始）。将<structfield>levelAdd</>设置为传到该结点导致的<structfield>level</>增加，或者在操作符类不使用层数时将它置为零。如果操作符类没有把数据从一层修改到下一层，将<structfield>restDatum</>设置为等于<structfield>datum</>，否则将它设置为在下一层用作<structfield>leafDatum</>的被修改后的值。
      </para>

      <para>
       如果必须增加一个新的子结点，将<structfield>resultType</>设置为<literal>spgAddNode</>。将<structfield>nodeLabel</>设置为在新结点中使用的标签，并将<structfield>nodeN</>设置为插入该结点的位置在结点数组中的索引（从零开始）。在结点被增加之后，<function>choose</function>函数将被再次调用并使用修改后的内部元组，那时将会导致一个<literal>spgMatchNode</>结果。
      </para>

      <para>
       如果新值和元组的前缀不一致，将<structfield>resultType</>设置为<literal>spgSplitTuple</>。这个动作将所有现有的结点移动到一个新的下层内部元组，并且将现有的内部元组用一个新元组替换，该元组只有一个结点链接到那个新的下层内部元组。将<structfield>prefixHasPrefix</>设置为指示新的上层元组是否具有一个前缀，并且在如果有前缀时设置<structfield>prefixPrefixDatum</>为前缀值。这个新的前缀值必须比原来的值要足够宽松以便能够接受将被索引的新值，并且它不能比原来的前缀长。将<structfield>nodeLabel</>设置为要用于指向新下层内部元组的结点的标签。将<structfield>postfixHasPrefix</>设置为指示新下层内部元组是否具有一个前缀，并且如果有前缀则设置<structfield>postfixPrefixDatum</>为前缀值。这两个前缀和额外的标签的组合必须和原来的前缀具有相同的含义，因为我们没有机会修改被移动到新下层元组的结点标签，也没有机会改变任何子索引项。在结点被分裂后，<function>choose</function>函数将被再次调用并使用替换内部元组。该次调用通常会导致一个<literal>spgAddNode</>结果，因为有可能在分裂步骤中增加的节点标签不能匹配新值；那么这样会有第三次调用最终返回<literal>spgMatchNode</>并且允许插入下降到叶子层。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>picksplit</></term>
     <listitem>
      <para>
       决定如何在一组叶子元组上创建一个新的内部元组。
      </para>

      <para>
        该函数的<acronym>SQL</>声明必须看起来像这样：
<programlisting>
CREATE FUNCTION my_picksplit(internal, internal) RETURNS void ...
</programlisting>
      第一个参数是一个指向<structname>spgPickSplitIn</> C 结构的指针，包含该函数的输入数据。第二个参数是一个指向<structname>spgPickSplitOut</> C 结构的指针，函数必须将结果数据填充在其中。
<programlisting>
typedef struct spgPickSplitIn
{
    int         nTuples;        /* 叶子元组的数量 */
    Datum      *datums;         /* 它们的数据（长度为 nTuples 的数组） */
    int         level;          /* 当前层次（从零开始计） */
} spgPickSplitIn;

typedef struct spgPickSplitOut
{
    bool        hasPrefix;      /* 新内部元组应该有一个前缀吗？ */
    Datum       prefixDatum;    /* 如果有，前缀值 */

    int         nNodes;         /* 新内部元组的结点数 */
    Datum      *nodeLabels;     /* 它们的标签（没有标签则为NULL） */

    int        *mapTuplesToNodes;   /* 每一个叶子元组的结点索引 */
    Datum      *leafTupleDatums;    /* 存储在每一个新叶子元组中的数据 */
} spgPickSplitOut;
</programlisting>

       <structfield>nTuples</>是所提供的叶子元组的数量。
       <structfield>datums</>是它们的数据值的数组。
       <structfield>level</>是所有叶子元组共有的当前层次，它将成为新内部元组的层次。
      </para>

      <para>
       将<structfield>hasPrefix</>设置为指示新内部元组是否应该有前缀，并且如果有前缀则将<structfield>prefixDatum</>设置成前缀值。将<structfield>nNodes</>设置为新内部元组将包含的结点数目，并且将<structfield>nodeLabels</>设置为它们的标签值的数组（如果结点不要求标签，将<structfield>nodeLabels</>设置为 NULL，详见<xref linkend="spgist-null-labels">）。将<structfield>mapTuplesToNodes</>设置为一个数组，该数组告诉每一个叶子元组应该被赋予的结点的索引（从零开始）。将<structfield>leafTupleDatums</>设置为由将要被存储在新叶子元组中的值构成的一个数组（如果操作符类不将数据从一层修改到下一层，这些值将和输入的<structfield>datums</>相同）。注意<function>picksplit</>函数负责为<structfield>nodeLabels</>、<structfield>mapTuplesToNodes</>和<structfield>leafTupleDatums</>数组进行 palloc。
      </para>

      <para>
       如果提供了多于一个叶子元组，<function>picksplit</>被寄望于将它们分类到多余一个结点中；否则不可能将叶子元组划分到多个页面，这也是这个操作的终极目的。因此，如果<function>picksplit</>函数结束时把所有叶子元组放在同一个结点中，核心SP-GiST代码将覆盖该决定，并且生成一个内部元组，将叶子元组随机分配到多个不同标签的结点。这样一个元组被标记为<literal>allTheSame</>来表示发生了这种情况。<function>choose</>和<function>inner_consistent</>函数必须对这样的内部元组采取合适的处理。详见<xref linkend="spgist-all-the-same">。
      </para>

      <para>
       <function>picksplit</>只能在一种情况下被应用在单独一个叶子元组上，这种情况是<function>config</>函数将<structfield>longValuesOK</>设置为真并且提供了一个长于一页的输入。在这种情况中，该操作的要点是剥离一个前缀并且产生一个新的、较短的叶子数据值。这种调用将被重复直到产生一个足够短能够放入到一页的叶子数据。详见<xref linkend="spgist-limits">。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>inner_consistent</></term>
     <listitem>
      <para>
       在树搜索过程中返回一组要追求的结点（分支）。
      </para>

      <para>
       该函数的<acronym>SQL</>声明必须看起来像这样：
<programlisting>
CREATE FUNCTION my_inner_consistent(internal, internal) RETURNS void ...
</programlisting>
      第一个参数是一个指向<structname>spgInnerConsistentIn</> C 结构的指针，包含该函数的输入数据。第二个参数是一个指向<structname>spgInnerConsistentOut</> C 结构的指针，函数必须将结果数据填充在其中。

<programlisting>
typedef struct spgInnerConsistentIn
{
    ScanKey     scankeys;       /* 操作符和比较值的数组 */
    int         nkeys;          /* 数组的长度 */

    Datum       reconstructedValue;     /* 在父结点中的重构值 */
    int         level;          /* 当前层次（从零开始计） */
    bool        returnData;     /* 是否必须返回原始数据？ */

    /* 来自当前内元组的数据 */
    bool        allTheSame;     /* 元组被标记为完全相同？ */
    bool        hasPrefix;      /* 元组有前缀？ */
    Datum       prefixDatum;    /* 如果有，前缀值 */
    int         nNodes;         /* 内元组中的结点数 */
    Datum      *nodeLabels;     /* 结点标签值（没有就是 NULL） */
} spgInnerConsistentIn;

typedef struct spgInnerConsistentOut
{
    int         nNodes;         /* 要被访问的子结点数 */
    int        *nodeNumbers;    /* 它们在结点数组中的索引 */
    int        *levelAdds;      /* 为每个子结点要增加的层数 */
    Datum      *reconstructedValues;    /* 相关的重构值 */
} spgInnerConsistentOut;
</programlisting>

       长度为<structfield>nkeys</>的数组<structfield>scankeys</>描述了
       索引搜索条件。这些条件用 AND 组合 &mdash; 只对满足所有条件的索引
       项感兴趣（注意，<structfield>nkeys</> = 0 表示所有索引项满足该查
       询）。通常一致函数只关心每个数组项的<structfield>sk_strategy</>和
       <structfield>sk_argument</>，它们分别给出了可索引操作符和比较值。
       特别要说明的是，没有必要去检查<structfield>sk_flags</>来看比较值
       是否为 NULL，因为 SP-GiST 的核心代码会过滤这样的条件。
       <structfield>reconstructedValue</>是用于父元组的重构值，在根层时
       或者如果<function>inner_consistent</>函数没有在父层提供一个值时，
       它为<literal>(Datum) 0</>。<structfield>level</>是当前内元组层次，
       根层是 0。如果这个查询要求重构的数据，<structfield>returnData</>是
       <literal>true</>。如果<function>config</>断言
       <structfield>canReturnData</>，<structfield>returnData</>只会是
       <literal>true</>。如果当前的内元组被标记为<quote>完全一样</>，
       那么<structfield>allTheSame</>为真。在这种情况下，所有的结点都具有
       相同的标签（如果有），而且它们要么全部匹配该查询，要么一个都不匹配查
       询（见<xref linkend="spgist-all-the-same">）。如果当前内元组包含一个
       前缀，则<structfield>hasPrefix</>为真。如果这样，
       <structfield>prefixDatum</>就是该前缀的值。<structfield>nNodes</>
       是包含在内元组中的子结点的数量，<structfield>nodeLabels</>是它们的
       标签值的数组。当然如果结点没有标签，这个数组就为 NULL。
      </para>

      <para>
       <structfield>nNodes</>必须被设置为搜索需要访问的子结点数，并且
       <structfield>nodeNumbers</>必须被设置为子结点索引的数组。如果
       操作符类跟踪层次，把<structfield>levelAdds</>设置成一个数组，其中
       说明了在下降到要被访问的每一个结点时需要增加的层数（通常这些增量对
       于所有结点都是相同的，但是并不一定如此，所以需要使用一个数组）。如
       果需要值重构，将<structfield>reconstructedValues</>设置成要被访问
       的每一个子结点的重构值数组。否则让
       <structfield>reconstructedValues</>为 NULL。注意
       <function>inner_consistent</>函数负责为
       <structfield>nodeNumbers</>、<structfield>levelAdds</> 和
       <structfield>reconstructedValues</>数组分配空间。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><function>leaf_consistent</></term>
     <listitem>
      <para>
       如果一个叶子元组满足一个查询则返回真。
      </para>

      <para>
       该函数的<acronym>SQL</>声明必须看起来像这样：
<programlisting>
CREATE FUNCTION my_leaf_consistent(internal, internal) RETURNS bool ...
</programlisting>
      第一个参数是一个指向<structname>spgLeafConsistentIn</> C 结构的指针，包含该函数的输入数据。第二个参数是一个指向<structname>spgLeafConsistentOut</> C 结构的指针，函数必须将结果数据填充在其中。
<programlisting>
typedef struct spgLeafConsistentIn
{
    ScanKey     scankeys;       /* 操作符和比较值的数组 */
    int         nkeys;          /* 数组的长度 */

    Datum       reconstructedValue;     /* 在父结点中的重构值 */
    int         level;          /* 当前层次（从零开始计） */
    bool        returnData;     /* 是否必须返回原始数据？ */

    Datum       leafDatum;      /* 叶子元组中的数据 */
} spgLeafConsistentIn;

typedef struct spgLeafConsistentOut
{
    Datum       leafValue;      /* 重构的原始数据，如果有 */
    bool        recheck;        /* 如果操作符必须被重新检查则设为真 */
} spgLeafConsistentOut;
</programlisting>

       The array <structfield>scankeys</>, of length <structfield>nkeys</>,
       describes the index search condition(s).  These conditions are
       combined with AND &mdash; only index entries that satisfy all of
       them satisfy the query.  (Note that <structfield>nkeys</> = 0 implies
       that all index entries satisfy the query.)  Usually the consistent
       function only cares about the <structfield>sk_strategy</> and
       <structfield>sk_argument</> fields of each array entry, which
       respectively give the indexable operator and comparison value.
       In particular it is not necessary to check <structfield>sk_flags</> to
       see if the comparison value is NULL, because the SP-GiST core code
       will filter out such conditions.
       <structfield>reconstructedValue</> is the value reconstructed for the
       parent tuple; it is <literal>(Datum) 0</> at the root level or if the
       <function>inner_consistent</> function did not provide a value at the
       parent level.
       <structfield>level</> is the current leaf tuple's level, starting at
       zero for the root level.
       <structfield>returnData</> is <literal>true</> if reconstructed data is
       required for this query; this will only be so if the
       <function>config</> function asserted <structfield>canReturnData</>.
       <structfield>leafDatum</> is the key value stored in the current
       leaf tuple.
      </para>

      <para>
       The function must return <literal>true</> if the leaf tuple matches the
       query, or <literal>false</> if not.  In the <literal>true</> case,
       if <structfield>returnData</> is <literal>true</> then
       <structfield>leafValue</> must be set to the value originally supplied
       to be indexed for this leaf tuple.  Also,
       <structfield>recheck</> may be set to <literal>true</> if the match
       is uncertain and so the operator(s) must be re-applied to the actual
       heap tuple to verify the match.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

  <para>
   所有的 SP-GiST 支持方法通常都在一个短期存在的内存上下文中被调用，即在处理完每一个元组后<varname>CurrentMemoryContext</>将被重置。因此并不需要操心 pfree 你 palloc 的任何东西（<function>config</>方法是一个特例：它应该避免泄漏内存。但是通常<function>config</>方法只需要为传出的参数结构赋常数值）。
  </para>

  <para>
   如果被索引的列是一种可排序的数据类型，索引的排序规则将被使用标准的<function>PG_GET_COLLATION()</>机制传递给所有的支持方法。
  </para>

</sect1>

<sect1 id="spgist-implementation">
 <title>实现</title>

  <para>
   这一节覆盖了实现细节以及<acronym>SP-GiST</acronym>操作符类的实现者需要知道的有用的技巧。
  </para>

 <sect2 id="spgist-limits">
  <title>SP-GiST 限制</title>

  <para>
   单独的叶子节点和内部节点必须能适合一个单一的索引页面（默认为 8KB）。因此，当索引值是一种变长数据类型时（长值只能由如 radix 树的方法所支持），树的每一层包含的前缀都足够短以适合一个页面，并且最终的叶子层包括的后缀也足够短以适合一个页面。如果操作符类准备好做这种事情，它应该将<structfield>longValuesOK</>设置为 TRUE。否则，<acronym>SP-GiST</acronym>核心将拒绝任何要索引超过一个所以页面长度的值的请求。
  </para>

  <para>
   Likewise, it is the operator class's responsibility that inner tuples
   do not grow too large to fit on an index page; this limits the number
   of child nodes that can be used in one inner tuple, as well as the
   maximum size of a prefix value.
  </para>

  <para>
   Another limitation is that when an inner tuple's node points to a set
   of leaf tuples, those tuples must all be in the same index page.
   (This is a design decision to reduce seeking and save space in the
   links that chain such tuples together.)  If the set of leaf tuples
   grows too large for a page, a split is performed and an intermediate
   inner tuple is inserted.  For this to fix the problem, the new inner
   tuple <emphasis>must</> divide the set of leaf values into more than one
   node group.  If the operator class's <function>picksplit</> function
   fails to do that, the <acronym>SP-GiST</acronym> core resorts to
   extraordinary measures described in <xref linkend="spgist-all-the-same">.
  </para>
 </sect2>

 <sect2 id="spgist-null-labels">
  <title>SP-GiST Without Node Labels</title>

  <para>
   Some tree algorithms use a fixed set of nodes for each inner tuple;
   for example, in a quad-tree there are always exactly four nodes
   corresponding to the four quadrants around the inner tuple's centroid
   point.  In such a case the code typically works with the nodes by
   number, and there is no need for explicit node labels.  To suppress
   node labels (and thereby save some space), the <function>picksplit</>
   function can return NULL for the <structfield>nodeLabels</> array.
   This will in turn result in <structfield>nodeLabels</> being NULL during
   subsequent calls to <function>choose</> and <function>inner_consistent</>.
   In principle, node labels could be used for some inner tuples and omitted
   for others in the same index.
  </para>

  <para>
   When working with an inner tuple having unlabeled nodes, it is an error
   for <function>choose</> to return <literal>spgAddNode</>, since the set
   of nodes is supposed to be fixed in such cases.  Also, there is no
   provision for generating an unlabeled node in <literal>spgSplitTuple</>
   actions, since it is expected that an <literal>spgAddNode</> action will
   be needed as well.
  </para>
 </sect2>

 <sect2 id="spgist-all-the-same">
  <title><quote>All-the-same</> Inner Tuples</title>

  <para>
   The <acronym>SP-GiST</acronym> core can override the results of the
   operator class's <function>picksplit</> function when
   <function>picksplit</> fails to divide the supplied leaf values into
   at least two node categories.  When this happens, the new inner tuple
   is created with multiple nodes that each have the same label (if any)
   that <function>picksplit</> gave to the one node it did use, and the
   leaf values are divided at random among these equivalent nodes.
   The <literal>allTheSame</> flag is set on the inner tuple to warn the
   <function>choose</> and <function>inner_consistent</> functions that the
   tuple does not have the node set that they might otherwise expect.
  </para>

  <para>
   When dealing with an <literal>allTheSame</> tuple, a <function>choose</>
   result of <literal>spgMatchNode</> is interpreted to mean that the new
   value can be assigned to any of the equivalent nodes; the core code will
   ignore the supplied  <structfield>nodeN</> value and descend into one
   of the nodes at random (so as to keep the tree balanced).  It is an
   error for <function>choose</> to return <literal>spgAddNode</>, since
   that would make the nodes not all equivalent; the
   <literal>spgSplitTuple</> action must be used if the value to be inserted
   doesn't match the existing nodes.
  </para>

  <para>
   When dealing with an <literal>allTheSame</> tuple, the
   <function>inner_consistent</> function should return either all or none
   of the nodes as targets for continuing the index search, since they are
   all equivalent.  This may or may not require any special-case code,
   depending on how much the <function>inner_consistent</> function normally
   assumes about the meaning of the nodes.
  </para>
 </sect2>

</sect1>

<sect1 id="spgist-examples">
 <title>例子</title>

 <para>
  The <productname>PostgreSQL</productname> source distribution includes
  several examples of index operator classes for
  <acronym>SP-GiST</acronym>.  The core system currently provides radix
  trees over text columns and two types of trees over points: quad-tree and
  k-d tree.  Look into <filename>src/backend/access/spgist/</> to see the
  code.
 </para>

</sect1>

</chapter>
