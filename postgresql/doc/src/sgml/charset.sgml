<!-- doc/src/sgml/charset.sgml -->

<chapter id="charset">
<!--
 <title>Localization</title>
 -->
 <title>区域</title> 


<para>
   <!--
  This chapter describes the available localization features from the
  point of view of the administrator.
  <productname>PostgreSQL</productname> supports two localization
  facilities:
  -->
  本章从管理员的角度描述可用的区域特性。<productname>PostgreSQL</productname>
  支持2种区域设置：

   <itemizedlist>
    <listitem>
     <para>
   <!--
      Using the locale features of the operating system to provide
      locale-specific collation order, number formatting, translated
      messages, and other aspects.
      This is covered in <xref linkend="locale"> and
      <xref linkend="collation">.
  -->
  利用操作系统的区域(locale)特性，提供区域特定的排序顺序、数值格式、本地消息和其它方面的支持。
  这些都位于<xref linkend="locale">和<xref linkend="collation">中。
     </para>

    </listitem>

    <listitem>
     <!--
<para>
      Providing a number of different character sets to support storing text
      in all kinds of languages, and providing character set translation
      between client and server.
      This is covered in <xref linkend="multibyte">.
     </para>
-->
<para>
    提供多种不同的字符集以支持存储各种语言的文本、
并且提供客户端和服务器端之间的字符集转换。
这些位于<xref linkend="multibyte">中。
</para>
    </listitem>
   </itemizedlist>
  </para>


 <sect1 id="locale">
 <!--
  <title>Locale Support</title>
  -->
  <title>区域支持</title>

  <indexterm zone="locale"><primary>locale</></>

  <!--
<para>
   <firstterm>Locale</> support refers to an application respecting
   cultural preferences regarding alphabets, sorting, number
   formatting, etc.  <productname>PostgreSQL</> uses the standard ISO
   C and <acronym>POSIX</acronym> locale facilities provided by the server operating
   system.  For additional information refer to the documentation of your
   system.
  </para>
-->
<para>
  <firstterm>区域</>支持指的是应用中考虑字母、排序、数值格式化等与文化相关的问题。
  <productname>PostgreSQL</>使用服务器操作系统提供的标准ISO C 和<acronym>POSIX</acronym>区域机制。
  更多的信息请参考你的系统文档。
</para>

  <sect2>
  <!--
   <title>Overview</title>
   -->
    <title>概述</title>

   
<para>
    <!--
    Locale support is automatically initialized when a database
    cluster is created using <command>initdb</command>.
    <command>initdb</command> will initialize the database cluster
    with the locale setting of its execution environment by default,
    so if your system is already set to use the locale that you want
    in your database cluster then there is nothing else you need to
    do.  If you want to use a different locale (or you are not sure
    which locale your system is set to), you can instruct
    <command>initdb</command> exactly which locale to use by
    specifying the <option>&#045;-locale</option> option. For example:
-->
区域支持是在使用<command>initdb</command>创建一个数据库集群的时候自动初始化的。
缺省时，<command>initdb</command>将会按照它的执行环境的区域设置初始化数据库集群；
因此如果你的系统已经设置为你的数据库集群想要的区域，那么你就没有什么可干的了。
如果你想使用其它的区域(或者你还不知道你的系统设置的区域是什么)，
那么你可以用<option>--locale</option>命令行选项告诉<command>initdb</command>你需要的区域究竟是哪个。
比如：

<screen>
initdb --locale=sv_SE
</screen>
   </para>


   <!--
<para>
    This example for Unix systems sets the locale to Swedish
    (<literal>sv</>) as spoken
    in Sweden (<literal>SE</>).  Other possibilities might include
    <literal>en_US</> (U.S. English) and <literal>fr_CA</> (French
    Canadian).  If more than one character set can be used for a
    locale then the specifications can take the form
    <replaceable>language_territory.codeset</>.  For example,
    <literal>fr_BE.UTF-8</> represents the French language (fr) as
    spoken in Belgium (BE), with a <acronym>UTF-8</> character set
    encoding.
   </para>
-->
<para>
   Unix系统下的这个例子就把区域设置为说瑞典语(<literal>sv</>)，并且在瑞典地区(<literal>SE</>)。
   其它的可能性是<literal>en_US</>(美国英语)和<literal>fr_CA</>(加拿大法语)等等。
   如果有多于一种的字符集可以用于同一个区域，那么声明看起来会像<replaceable>language_territory.codeset</>。
   比如，<literal>fr_BE.UTF-8</>表示为在比利时(BE)地区使用的法语(fr)，并且使用<acronym>UTF-8</>字符集编码。
   
</para>

   <!--
<para>
    What locales are available on your
    system under what names depends on what was provided by the operating
    system vendor and what was installed.  On most Unix systems, the command
    <literal>locale -a</> will provide a list of available locales.
    Windows uses more verbose locale names, such as <literal>German_Germany</>
    or <literal>Swedish_Sweden.1252</>, but the principles are the same.
   </para>
-->
<para>
   你的系统里有哪些可用的区域设置，它们的名字是什么，
   这些信息都取决于你的操作系统提供商提供了什么以及你安装了什么东西。
   在大多数系统上，命令<literal>locale -a</>将提供所有可用区域的一个列表。
   Windows使用更详细的区域名称，比如<literal>German_Germany</>或者<literal>Swedish_Sweden.1252</>，
   但是原则是一样的。
</para>

   
<para>
    <!--
    Occasionally it is useful to mix rules from several locales, e.g.,
    use English collation rules but Spanish messages.  To support that, a
    set of locale subcategories exist that control only certain
    aspects of the localization rules:
    -->
有时候，把几种区域规则混合起来也很有用，比如，
使用英语排序规则而用西班牙语消息。为了支持这些，
我们有一套区域子范畴用于控制区域规则的某一方面： 


    <informaltable>
     <tgroup cols="2">
      <tbody>
       <row>
        <entry><envar>LC_COLLATE</></>
<!--
        <entry>String sort order</>
-->
<entry>字符串排序顺序</>
       </row>
       <row>
        <entry><envar>LC_CTYPE</></>
<!--
        <entry>Character classification (What is a letter? Its upper-case equivalent?)</>
-->
<entry>字符分类(什么是字母?是否区分大小写?)</>
       </row>
       <row>
        <entry><envar>LC_MESSAGES</></>
<!--
        <entry>Language of messages</>
-->
<entry>消息的语言</>
       </row>
       <row>
        <entry><envar>LC_MONETARY</></>
<!--
        <entry>Formatting of currency amounts</>
-->
<entry>货币金额的格式</>
       </row>
       <row>
        <entry><envar>LC_NUMERIC</></>
<!--
        <entry>Formatting of numbers</>
-->
<entry>数值格式</>
       </row>
       <row>
        <entry><envar>LC_TIME</></>
<!--
        <entry>Formatting of dates and times</>
-->
<entry>日期和时间格式</>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
    <!--
    The category names translate into names of
    <command>initdb</command> options to override the locale choice
    for a specific category.  For instance, to set the locale to
    French Canadian, but use U.S. rules for formatting currency, use
    <literal>initdb &#045;-locale=fr_CA &#045;-lc-monetary=en_US</literal>.
-->
 这些范畴名转换成<command>initdb</command>选项的名字以覆盖某个特定范畴的区域选择。
 比如，要把区域设置为加拿大法语，但使用美国的货币格式化规则，
 可以使用<literal>initdb --locale=fr_CA --lc-monetary=en_US</literal>。 
   </para>

   <!--
<para>
    If you want the system to behave as if it had no locale support,
    use the special locale name <literal>C</>, or equivalently
    <literal>POSIX</>.
   </para>
-->
<para>
    如果你想要你的系统表现得像没有区域支持一样，那么使用特殊的区域<literal>C</>或<literal>POSIX</>。
</para>

   <!--
<para>
    Some locale categories must have their values
    fixed when the database is created.  You can use different settings
    for different databases, but once a database is created, you cannot
    change them for that database anymore. <literal>LC_COLLATE</literal>
    and <literal>LC_CTYPE</literal> are these categories.  They affect
    the sort order of indexes, so they must be kept fixed, or indexes on
    text columns would become corrupt.
    (But you can alleviate this restriction using collations, as discussed
    in <xref linkend="collation">.)
    The default values for these
    categories are determined when <command>initdb</command> is run, and
    those values are used when new databases are created, unless
    specified otherwise in the <command>CREATE DATABASE</command> command.
   </para>
-->
<para>
   一些区域范畴的值必须在创建数据库时固定下来。
   您可以对不同的数据库使用不同的设置，但一旦创建一个数据库，你就再也不能更改它们了。
   <literal>LC_COLLATE</literal>和<literal>LC_CTYPE</literal>就是这样的范畴。 
   它们影响索引的排序顺序，因此它们必需保持固定，否则在文本字段上的索引将会崩溃。
  （但是你可以使用排序规则(collation)缓解这种限制，正如<xref linkend="collation">中讨论的）。
   当运行<command>initdb</command>时确定这些范畴的缺省值，
   这些值被用于创建新的数据库，除非在<command>CREATE DATABASE</command>命令中明确指定。
</para>

   <!--
<para>
    The other locale categories can be changed whenever desired
    by setting the server configuration parameters
    that have the same name as the locale categories (see <xref
    linkend="runtime-config-client-format"> for details).  The values
    that are chosen by <command>initdb</command> are actually only written
    into the configuration file <filename>postgresql.conf</filename> to
    serve as defaults when the server is started.  If you remove these
    assignments from <filename>postgresql.conf</filename> then the
    server will inherit the settings from its execution environment.
   </para>
-->
<para>
  其它区域范畴可以在服务器启动的时候根据需要设置
  服务器配置参数来改变(参阅<xref linkend="runtime-config-client-format">获取细节)。
  <command>initdb</command>选择的值实际上只是作为服务器启动时的缺省值写入
  <filename>postgresql.conf</filename>配置文件。
  如果你在<filename>postgresql.conf</filename>里面删除了这些设置，
  那么服务器将会继承来自运行环境的设置。 

</para>

   <!--
<para>
    Note that the locale behavior of the server is determined by the
    environment variables seen by the server, not by the environment
    of any client.  Therefore, be careful to configure the correct locale settings
    before starting the server.  A consequence of this is that if
    client and server are set up in different locales, messages might
    appear in different languages depending on where they originated.
   </para>
-->
<para>
   请注意服务器的区域行为是由它看到的环境变量决定的，
   而不受客户端的环境影响。
   因此，我们要在启动服务器之前认真地设置好这些变量。
   这样带来的一种情况是如果客户端和服务器设置成不同的区域，
   那么消息可能以不同的语言呈现，这取决于消息的来源。
</para>

   <note>
    <!--
<para>
     When we speak of inheriting the locale from the execution
     environment, this means the following on most operating systems:
     For a given locale category, say the collation, the following
     environment variables are consulted in this order until one is
     found to be set: <envar>LC_ALL</envar>, <envar>LC_COLLATE</envar>
     (or the variable corresponding to the respective category),
     <envar>LANG</envar>.  If none of these environment variables are
     set then the locale defaults to <literal>C</literal>.
    </para>
-->
<para>
   在我们谈到从执行环境继承区域的时候，
   我们的意思是在大多数操作系统上的下列动作：
   对于一个给定的区域范畴，
   比如排序规则，按照下面的顺序评估这些环境变量，
   直到找到一个已设置的：<envar>LC_ALL</envar>, <envar>LC_COLLATE</envar>
   (或者对应于相应范畴的其他变量), <envar>LANG</envar>。
   如果这些环境变量一个都没有设置，那么区域缺省为<literal>C</literal>。
</para>

    <!--
<para>
     Some message localization libraries also look at the environment
     variable <envar>LANGUAGE</envar> which overrides all other locale
     settings for the purpose of setting the language of messages.  If
     in doubt, please refer to the documentation of your operating
     system, in particular the documentation about
     <application>gettext</>.
    </para>
-->
<para>
   一些消息本地化库也使用环境变量<envar>LANGUAGE</envar>，
   它覆盖所有其它用于设置语言信息的区域设置。
   如果有问题，请参考你的操作系统文档，
   特别是<application>gettext</>的文档以获取更多信息。
</para>
   </note>

   <!--
<para>
    To enable messages to be translated to the user's preferred language,
    <acronym>NLS</acronym> must have been selected at build time
    (<literal>configure &#045;-enable-nls</>).  All other locale support is
    built in automatically.
   </para>
-->
<para>
   要能够将消息翻译成用户选择的语言，编译时必需选择<acronym>NLS</acronym>选项(<literal>configure --enable-nls</>)。
   其它区域支持是自动包含的。
</para>
  </sect2>

  <sect2>
  <!--
   <title>Behavior</title>
   -->
    <title>行为</title>

   
<para>
    <!--
    The locale settings influence the following SQL features:
-->
    区域设置特别影响下面的 SQL 特性：

    <itemizedlist>
     <listitem>
      <para>
   <!--
       Sort order in queries using <literal>ORDER BY</> or the standard
       comparison operators on textual data
       <indexterm><primary>ORDER BY</><secondary>and locales</></indexterm>
   -->
   查询中使用<literal>ORDER BY</>或者对文本数据的标准比较操作符进行排序
   <indexterm><primary>ORDER BY</><secondary>和区域</></indexterm>
      </para>


     </listitem>

     <listitem>
      <!--
<para>
       The <function>upper</>, <function>lower</>, and <function>initcap</>
       functions
       <indexterm><primary>upper</><secondary>and locales</></indexterm>
       <indexterm><primary>lower</><secondary>and locales</></indexterm>
      </para>
-->
<para>
       <function>upper</>, <function>lower</>和<function>initcap</>函数
       <indexterm><primary>upper</><secondary>和区域</></indexterm>
       <indexterm><primary>lower</><secondary>和区域</></indexterm>
</para>
     </listitem>

     <listitem>
      <!--
<para>
       Pattern matching operators (<literal>LIKE</>, <literal>SIMILAR TO</>,
       and POSIX-style regular expressions); locales affect both case
       insensitive matching and the classification of characters by
       character-class regular expressions
       <indexterm><primary>LIKE</><secondary>and locales</></indexterm>
       <indexterm><primary>regular expressions</><secondary>and locales</></indexterm>
      </para>
-->
<para>
     模式匹配运算符(<literal>LIKE</>, <literal>SIMILAR TO</>,
     以及POSIX-风格的正则表达式)； 
 区域影响大小写不敏感的匹配和通过字符分类正则表达式的字符分类。
 <indexterm><primary>LIKE</><secondary>以及区域</></indexterm>
     <indexterm><primary>正则表达式</><secondary>以及区域</></indexterm>
</para>
     </listitem>

     <listitem>
      <!--
<para>
       The <function>to_char</> family of functions
       <indexterm><primary>to_char</><secondary>and locales</></indexterm>
      </para>
-->
<para>
    <function>to_char</>函数族
       <indexterm><primary>to_char</><secondary>and locales</></indexterm>
</para>
     </listitem>

     <listitem>
      <!--
<para>
       The ability to use indexes with <literal>LIKE</> clauses
      </para>
-->
<para>
   使用<literal>LIKE</>子句的索引能力
</para>
     </listitem>
    </itemizedlist>
   </para>

   <!--
<para>
    The drawback of using locales other than <literal>C</> or
    <literal>POSIX</> in <productname>PostgreSQL</> is its performance
    impact. It slows character handling and prevents ordinary indexes
    from being used by <literal>LIKE</>. For this reason use locales
    only if you actually need them.
   </para>
-->
<para>
  <productname>PostgreSQL</>里使用非<literal>C</>或者<literal>POSIX</>区域的缺点是性能影响。
  它降低了字符处理的速度并阻止了在<literal>LIKE</>类查询里面普通索引的使用。
  因此，应该只有在你实际上需要的时候才使用它。
</para>

   <!--
<para>
    As a workaround to allow <productname>PostgreSQL</> to use indexes
    with <literal>LIKE</> clauses under a non-C locale, several custom
    operator classes exist. These allow the creation of an index that
    performs a strict character-by-character comparison, ignoring
    locale comparison rules. Refer to <xref linkend="indexes-opclass">
    for more information.  Another approach is to create indexes using
    the <literal>C</> collation, as discussed in
    <xref linkend="collation">.
   </para>
-->
<para>
  为了允许<productname>PostgreSQL</>在非C区域下的<literal>LIKE</>子句中使用索引，
  有好几个自定义的操作符类可以用。
  这些操作符类允许创建一个严格地比较每个字符的索引，
  而忽略区域比较规则。请参考<xref linkend="indexes-opclass">获取更多信息。
  另外一个方法是使用<literal>C</> collation创建索引，正如<xref linkend="collation">
  中讨论的。
</para>
  </sect2>

  <sect2>
  <!--
   <title>Problems</title>
   -->
   <title>问题</title>

   <!--
<para>
    If locale support doesn't work according to the explanation above,
    check that the locale support in your operating system is
    correctly configured.  To check what locales are installed on your
    system, you can use the command <literal>locale -a</literal> if
    your operating system provides it.
   </para>
-->
<para>
  如果经过上面解释后区域支持仍然不能运转，
  那你就要检查一下操作系统的区域支持是否正确配置。
  要检查某个区域是否安装并且正常运转，
  你可以使用<literal>locale -a</literal>命令(如果你的系统提供了该命令)。
</para>

   <!--
<para>
    Check that <productname>PostgreSQL</> is actually using the locale
    that you think it is.  The <envar>LC_COLLATE</> and <envar>LC_CTYPE</>
    settings are determined when a database is created, and cannot be
    changed except by creating a new database.  Other locale
    settings including <envar>LC_MESSAGES</> and <envar>LC_MONETARY</>
    are initially determined by the environment the server is started
    in, but can be changed on-the-fly.  You can check the active locale
    settings using the <command>SHOW</> command.
   </para>
-->
<para>
   请检查核实<productname>PostgreSQL</>确实使用了你认为它该用的区域设置。
   <envar>LC_COLLATE</>和<envar>LC_CTYPE</>的设置都是在数据库创建时决定的，
   不能被改变除非创建新的数据库。其它的区域设置包括
   <envar>LC_MESSAGES</>和<envar>LC_MONETARY</>都是由服务器的启动环境决定的，
   但是可以在运行时修改。你可以用<command>SHOW</>命令检查数据库正在使用的区域设置。
</para>

   <!--
<para>
    The directory <filename>src/test/locale</> in the source
    distribution contains a test suite for
    <productname>PostgreSQL</>'s locale support.
   </para>
-->
<para>
  源码发布中的<filename>src/test/locale</>目录包含
  <productname>PostgreSQL</>的区域支持测试套件。
</para>

   <!--
<para>
    Client applications that handle server-side errors by parsing the
    text of the error message will obviously have problems when the
    server's messages are in a different language.  Authors of such
    applications are advised to make use of the error code scheme
    instead.
   </para>
-->
<para>
   那些通过解析错误消息文本处理服务器端错误的客户端应用很明显会有问题，
   因为服务器信息可能会以不同的语言表示。我们建议这类应用的开发人员改用错误代码机制。
</para>

   <!--
<para>
    Maintaining catalogs of message translations requires the on-going
    efforts of many volunteers that want to see
    <productname>PostgreSQL</> speak their preferred language well.
    If messages in your language are currently not available or not fully
    translated, your assistance would be appreciated.  If you want to
    help, refer to <xref linkend="nls"> or write to the developers'
    mailing list.
   </para>
-->
<para>
  维护消息翻译表需要许多志愿者的坚持不懈的努力，
  他们就是希望<productname>PostgreSQL</>以他们的语言说话的人。
  如果你的语言消息目前还不可用或者没有完全翻译完成，
  那么我们很欢迎你的协助。如果你想帮忙，
  那么请参考<xref linkend="nls">或者向开发者邮递列表发邮件。
</para>
  </sect2>
 </sect1>


 <sect1 id="collation">
 <!--
  <title>Collation Support</title>
  -->
  <title>排序规则支持</title>

  <indexterm zone="collation"><primary>collation</></>

  <!--
<para>
   The collation feature allows specifying the sort order and character
   classification behavior of data per-column, or even per-operation.
   This alleviates the restriction that the
   <symbol>LC_COLLATE</symbol> and <symbol>LC_CTYPE</symbol> settings
   of a database cannot be changed after its creation.
  </para>
-->
<para>
   排序规则特性允许为每一列数据指定排序顺序和字符分类行为，或者甚至为每个操作指定。
   这缓解了<symbol>LC_COLLATE</symbol>和<symbol>LC_CTYPE</symbol>在数据库被创建后不能被修改的限制。
</para>

  <sect2>
  <!--
   <title>Concepts</title>
   -->
   <title>概念</title>

   <!--
<para>
    Conceptually, every expression of a collatable data type has a
    collation.  (The built-in collatable data types are
    <type>text</type>, <type>varchar</type>, and <type>char</type>.
    User-defined base types can also be marked collatable, and of course
    a domain over a collatable data type is collatable.)  If the
    expression is a column reference, the collation of the expression is the
    defined collation of the column.  If the expression is a constant, the
    collation is the default collation of the data type of the
    constant.  The collation of a more complex expression is derived
    from the collations of its inputs, as described below.
   </para>
-->
<para>
   从概念上讲，collatable数据类型的每个表达式都有一个排序规则。
   （内置collatable数据类型有<type>text</type>, <type>varchar</type>以及<type>char</type>。 
   用户定义的基本类型，也可以标记为collatable，
   当然一个collatable数据类型的域也是collatable的）。
   如果表达式是一个列引用，该表达式的排序规则是就这个列的排序规则。
   如果表达式是一个常数，排序规则是常数数据类型的缺省排序规则。 
   一个更复杂表达式的排序规则从它的输入端排序规则推导，如下所述。
</para>

   <!--
<para>
    The collation of an expression can be the <quote>default</quote>
    collation, which means the locale settings defined for the
    database.  It is also possible for an expression's collation to be
    indeterminate.  In such cases, ordering operations and other
    operations that need to know the collation will fail.
   </para>
-->
<para>
   一个表达式的排序规则可以是<quote>缺省</quote>排序规则，
   这意味着为数据库的区域设置。它也可以用于表达式的排序规则是不确定的。
   在这种情况下，排序操作符以及其他需要知道排序规则的操作符会在执行时失败。 
</para>

   <!--
<para>
    When the database system has to perform an ordering or a character
    classification, it uses the collation of the input expression.  This
    happens, for example, with <literal>ORDER BY</literal> clauses
    and function or operator calls such as <literal>&lt;</literal>.
    The collation to apply for an <literal>ORDER BY</literal> clause
    is simply the collation of the sort key.  The collation to apply for a
    function or operator call is derived from the arguments, as described
    below.  In addition to comparison operators, collations are taken into
    account by functions that convert between lower and upper case
    letters, such as <function>lower</>, <function>upper</>, and
    <function>initcap</>; by pattern matching operators; and by
    <function>to_char</> and related functions.
   </para>
-->
<para>
   当数据库系统必须执行排序或字符分类时，它使用输入表达式的排序规则。
   这种情况发生，例如，使用<literal>ORDER BY</literal>子句
   以及函数或运算符调用比如<literal>&lt;</literal>。 
   应用到<literal>ORDER BY</literal>子句中的排序规则直接就是排序关键字的排序规则。
   应用到函数或操作符调用的排序规则要从参数上派生，
   如下文所述。除了比较操作符外，
   大小写字母转换函数，如<function>lower</>, <function>upper</>和
   <function>initcap</>；模式匹配运算符号；以及 
   <function>to_char</>及其相关函数都需要考虑排序规则。
</para>

   <!--
<para>
    For a function or operator call, the collation that is derived by
    examining the argument collations is used at run time for performing
    the specified operation.  If the result of the function or operator
    call is of a collatable data type, the collation is also used at parse
    time as the defined collation of the function or operator expression,
    in case there is a surrounding expression that requires knowledge of
    its collation.
   </para>
-->
<para>
   对于一个函数或运算符调用，
   通过检查用来在运行时执行指定操作的参数排序规则派生出该排序规则。
   如果函数或运算符调用结果是collatable数据类型，
   并且有需要知道该排序规则的外围表达式，
   排序规则也可用于在解析时作为函数或运算符表达式的定义的排序规则。
</para>

   
<para>
    <!--
    The <firstterm>collation derivation</firstterm> of an expression can be
    implicit or explicit.  This distinction affects how collations are
    combined when multiple different collations appear in an
    expression.  An explicit collation derivation occurs when a
    <literal>COLLATE</literal> clause is used; all other collation
    derivations are implicit.  When multiple collations need to be
    combined, for example in a function call, the following rules are
    used:
    -->
表达式的<firstterm>排序规则推导</firstterm>可以是
隐式或显式的。当多个不同的排序规则出现在表达式中，这种区别会影响排序规则如何组合， 
当使用<literal>COLLATE</literal>子句的时候，产生显式排序规则推导;所有其他排序规则 
推导是隐式的。当多个排序规则必须结合时，例如在一个函数调用中，使用下面的规则： 


    <orderedlist>
     <listitem>
      <para>
   <!--
       If any input expression has an explicit collation derivation, then
       all explicitly derived collations among the input expressions must be
       the same, otherwise an error is raised.  If any explicitly
       derived collation is present, that is the result of the
       collation combination.
   -->
   如果任何输入表达式有显式的排序规则推导，那么 
   输入表达式中所有显式派生的排序规则必须是一样的，
   否则将引发错误。如果有任何显式派生的排序规则，这即是排序规则组合的结果。
      </para>

     </listitem>

     <listitem>
      <!--
<para>
       Otherwise, all input expressions must have the same implicit
       collation derivation or the default collation.  If any non-default
       collation is present, that is the result of the collation combination.
       Otherwise, the result is the default collation.
      </para>
-->
<para>
     否则，所有输入表达式必须具有相同的隐式排序规则推导或者缺省排序规则。如果出现任何非缺省的
 排序规则，则是这就是排序组合的结果。否则，结果是缺省排序规则。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       If there are conflicting non-default implicit collations among the
       input expressions, then the combination is deemed to have indeterminate
       collation.  This is not an error condition unless the particular
       function being invoked requires knowledge of the collation it should
       apply.  If it does, an error will be raised at run-time.
      </para>
-->
<para>
     如果在输入的表达式之间非缺省的隐式排序规则有冲突，
 那么该组合视为不明确的排序规则。
 这不是一个错误情况，除非被调用的那个函数需要知道排序规则。
 如果是这样，在运行时将引发一个错误。
 
</para>
     </listitem>
    </orderedlist>
    <!--
    For example, consider this table definition:
-->
比如，考虑这个表定义：
<programlisting>
CREATE TABLE test1 (
    a text COLLATE "de_DE",
    b text COLLATE "es_ES",
    ...
);
</programlisting>
    <!--
    Then in
-->
然后
<programlisting>
SELECT a &lt; 'foo' FROM test1;
</programlisting>
    <!--
    the <literal>&lt;</literal> comparison is performed according to
    <literal>de_DE</literal> rules, because the expression combines an
    implicitly derived collation with the default collation.  But in
-->
按照<literal>de_DE</literal>规则，执行<literal>&lt;</literal>比较，因为表达式
组合隐式推导排序规则与缺省排序规则，但是

<programlisting>
SELECT a &lt; ('foo' COLLATE "fr_FR") FROM test1;
</programlisting>
    <!--
    the comparison is performed using <literal>fr_FR</literal> rules,
    because the explicit collation derivation overrides the implicit one.
    Furthermore, given
-->
使用<literal>fr_FR</literal>规则执行比较，因为显式排序规则覆盖了隐式的。
此外，
<programlisting>
SELECT a &lt; b FROM test1;
</programlisting>
    <!--
    the parser cannot determine which collation to apply, since the
    <structfield>a</> and <structfield>b</> columns have conflicting
    implicit collations.  Since the <literal>&lt;</literal> operator
    does need to know which collation to use, this will result in an
    error.  The error can be resolved by attaching an explicit collation
    specifier to either input expression, thus:
-->
解析器无法确定应该应用哪个排序规则，因为
<structfield>a</>列和<structfield>b</>列拥有冲突的隐式排序规则。
因为<literal>&lt;</literal>操作符确实需要知道所使用的排序规则，这将导致一个错误。
错误可以通过附加一个明确的排序规则说明符给输入表达式得以解决，如下：

<programlisting>
SELECT a &lt; b COLLATE "de_DE" FROM test1;
</programlisting>
    <!--
    or equivalently
-->
或者等效的，
<programlisting>
SELECT a COLLATE "de_DE" &lt; b FROM test1;
</programlisting>
    <!--
    On the other hand, the structurally similar case
-->
另一方面，结构上类似的情况
<programlisting>
SELECT a || b FROM test1;
</programlisting>
    <!--
    does not result in an error, because the <literal>||</> operator
    does not care about collations: its result is the same regardless
    of the collation.
-->
不会产生错误，因为<literal>||</>操作符并不关心排序规则：
不论什么排序规则结果都是一样的。
   </para>

   
<para>
   <!--
    The collation assigned to a function or operator's combined input
    expressions is also considered to apply to the function or operator's
    result, if the function or operator delivers a result of a collatable
    data type.  So, in
-->
如果函数或者操作符的结果还是collatable数据类型,
那么分配给函数或者操作符的组合的输入表达式的排序规则也会应用到函数或者操作符结果上。
因此，
<programlisting>
SELECT * FROM test1 ORDER BY a || 'foo';
</programlisting>
    <!--
    the ordering will be done according to <literal>de_DE</literal> rules.
    But this query:
-->
按照<literal>de_DE</literal>规则执行该排序。但是这个查询：
<programlisting>
SELECT * FROM test1 ORDER BY a || b;
</programlisting>
    <!--
results in an error, because even though the <literal>||</> operator
    doesn't need to know a collation, the <literal>ORDER BY</> clause does.
    As before, the conflict can be resolved with an explicit collation
    specifier:
-->
导致一个错误，因为即使<literal>||</>操作符不需要知道排序规则，而<literal>ORDER BY</>子句
确实需要。和前面一样，可以使用显式的排序规则说明符解决这个冲突。

<programlisting>
SELECT * FROM test1 ORDER BY a || b COLLATE "fr_FR";
</programlisting>
   </para>

  </sect2>

  <sect2>
  <!--
   <title>Managing Collations</title>
   -->
   <title>管理排序规则</title>
   
   <!--
<para>
    A collation is an SQL schema object that maps an SQL name to
    operating system locales.  In particular, it maps to a combination
    of <symbol>LC_COLLATE</symbol> and <symbol>LC_CTYPE</symbol>.  (As
    the name would suggest, the main purpose of a collation is to set
    <symbol>LC_COLLATE</symbol>, which controls the sort order.  But
    it is rarely necessary in practice to have an
    <symbol>LC_CTYPE</symbol> setting that is different from
    <symbol>LC_COLLATE</symbol>, so it is more convenient to collect
    these under one concept than to create another infrastructure for
    setting <symbol>LC_CTYPE</symbol> per expression.)  Also, a collation
    is tied to a character set encoding (see <xref linkend="multibyte">).
    The same collation name may exist for different encodings.
   </para>
-->
<para>
   排序规则是把SQL名称映射到操作系统区域的SQL模式对象。
   特别是，它映射到<symbol>LC_COLLATE</symbol>和<symbol>LC_CTYPE</symbol>的组合。  
   （顾名思义，排序规则的主要目的是设置<symbol>LC_COLLATE</symbol>， 
   它控制排序顺序。但在实际中很少需要一个和 
   <symbol>LC_COLLATE</symbol>不同的<symbol>LC_CTYPE</symbol>设置，  
   所以将它们合在一起，而不是为每个表达式另外创造一个设置
   <symbol>LC_CTYPE</symbol>的基础设施，更为方便）。
   另外，排序规则和字符集编码（参见<xref linkend="multibyte">）紧密关联。 
   对不同的编码可能存在同名的排序规则。
</para>

   <!--
<para>
    On all platforms, the collations named <literal>default</>,
    <literal>C</>, and <literal>POSIX</> are available.  Additional
    collations may be available depending on operating system support.
    The <literal>default</> collation selects the <symbol>LC_COLLATE</symbol>
    and <symbol>LC_CTYPE</symbol> values specified at database creation time.
    The <literal>C</> and <literal>POSIX</> collations both specify
    <quote>traditional C</> behavior, in which only the ASCII letters
    <quote><literal>A</></quote> through <quote><literal>Z</></quote>
    are treated as letters, and sorting is done strictly by character
    code byte values.
   </para>
-->
<para>
   在所有平台上，名称为<literal>default</>,
    <literal>C</>和<literal>POSIX</>排序规则都是可用的。其他可用的排序规则
   取决于操作系统支持。<literal>default</>排序规则选择在创建数据库时指定的<symbol>LC_COLLATE</symbol>
   和<symbol>LC_CTYPE</symbol>值。
   <literal>C</>和<literal>POSIX</>的排序规则都表现为<quote>传统 C</>的行为，
   即只有ASCII字母<quote><literal>A</></quote>到<quote><literal>Z</></quote> 
   被视为字母，并且严格按照字符的编码字节值进行排序。
</para>

   <!--
<para>
    If the operating system provides support for using multiple locales
    within a single program (<function>newlocale</> and related functions),
    then when a database cluster is initialized, <command>initdb</command>
    populates the system catalog <literal>pg_collation</literal> with
    collations based on all the locales it finds on the operating
    system at the time.  For example, the operating system might
    provide a locale named <literal>de_DE.utf8</literal>.
    <command>initdb</command> would then create a collation named
    <literal>de_DE.utf8</literal> for encoding <literal>UTF8</literal>
    that has both <symbol>LC_COLLATE</symbol> and
    <symbol>LC_CTYPE</symbol> set to <literal>de_DE.utf8</literal>.
    It will also create a collation with the <literal>.utf8</literal>
    tag stripped off the name.  So you could also use the collation
    under the name <literal>de_DE</literal>, which is less cumbersome
    to write and makes the name less encoding-dependent.  Note that,
    nevertheless, the initial set of collation names is
    platform-dependent.
   </para>
-->
<para>
    如果操作系统提供了在一个程序中使用多语言环境的支持
(<function>newlocale</>以及相关函数)，那么当一个数据库集群初始化的时候，
<command>initdb</command>使用基于当时在操作系统上发现的所有语言环境的排序规则
来填充系统表<literal>pg_collation</literal>。
例如，操作系统可能提供名为<literal>de_DE.utf8</literal>的区域。
那么，<command>initdb</command>就可能为编码<literal>UTF8</literal>创建命名为
<literal>de_DE.utf8</literal>的排序规则，它的<symbol>LC_COLLATE</symbol>和
<symbol>LC_CTYPE</symbol>都被设置为<literal>de_DE.utf8</literal>。
它还将创建名称中被剥离了<literal>.utf8</literal>标签的排序规则。
所以，你也可以使用<literal>de_DE</literal>名称的排序规则
，这方便于编写并且使得名称较少依赖于编码。然而，需要注意的是，
排序规则名称的初始设置是平台相关的。
</para>

   <!--
<para>
    In case a collation is needed that has different values for
    <symbol>LC_COLLATE</symbol> and <symbol>LC_CTYPE</symbol>, a new
    collation may be created using
    the <xref linkend="sql-createcollation"> command.  That command
    can also be used to create a new collation from an existing
    collation, which can be useful to be able to use
    operating-system-independent collation names in applications.
   </para>
-->
<para>
   在需要有不同的<symbol>LC_COLLATE</symbol>和<symbol>LC_CTYPE</symbol>
   值的排序规则的情况下，可以使用<xref linkend="sql-createcollation">  
   命令创建新的排序规则。
   该命令也可以从现有排序规则中创建一个新的，这可能是有用的，以便能够 
   在应用中使用操作系统无关的排序规则名称。
</para>

   <!--
<para>
    Within any particular database, only collations that use that
    database's encoding are of interest.  Other entries in
    <literal>pg_collation</literal> are ignored.  Thus, a stripped collation
    name such as <literal>de_DE</literal> can be considered unique
    within a given database even though it would not be unique globally.
    Use of the stripped collation names is recommended, since it will
    make one less thing you need to change if you decide to change to
    another database encoding.  Note however that the <literal>default</>,
    <literal>C</>, and <literal>POSIX</> collations can be used
    regardless of the database encoding.
   </para>
-->
<para>
   在任何特定的数据库中，只关心使用该数据库编码的排序规则。
   <literal>pg_collation</literal>中的其他项目会被忽略。因此，剥离了编码名的排序规则
   名称，如<literal>de_DE</literal>，在一个给定的数据库中也算是独一无二的，即使它不是全局唯一的。
   建议使用剥离过的排序规则名称，因为如果你以后决定改变到另一个数据库编码，可以少改变一样东西。
   但是请注意，无论是什么数据库编码，都可以使用<literal>default</>,
    <literal>C</>和<literal>POSIX</>排序规则。
</para>

   
<para>
   <!--
    <productname>PostgreSQL</productname> considers distinct collation
    objects to be incompatible even when they have identical properties.
    Thus for example,
-->
<productname>PostgreSQL</productname>认为不同排序规则 
对象是不兼容的，即使他们有相同的属性。 
例如：

<programlisting>
SELECT a COLLATE "C" &lt; b COLLATE "POSIX" FROM test1;
</programlisting>
<!--
    will draw an error even though the <literal>C</> and <literal>POSIX</>
    collations have identical behaviors.  Mixing stripped and non-stripped
    collation names is therefore not recommended.
-->
将引起一个错误，即使<literal>C</>和<literal>POSIX</>
排序规则具有完全相同的行为。因此不推荐混合剥离的和非剥离的排序规则名。

   </para>

  </sect2>
 </sect1>

 <sect1 id="multibyte">
 <!--
  <title>Character Set Support</title>
  -->
  <title>字符集支持</title>

  <indexterm zone="multibyte"><primary>character set</></>

  <!--
<para>
   The character set support in <productname>PostgreSQL</productname>
   allows you to store text in a variety of character sets (also called
   encodings), including
   single-byte character sets such as the ISO 8859 series and
   multiple-byte character sets such as <acronym>EUC</> (Extended Unix
   Code), UTF-8, and Mule internal code.  All supported character sets
   can be used transparently by clients, but a few are not supported
   for use within the server (that is, as a server-side encoding).
   The default character set is selected while
   initializing your <productname>PostgreSQL</productname> database
   cluster using <command>initdb</>.  It can be overridden when you
   create a database, so you can have multiple
   databases each with a different character set.
  </para>
-->
<para>
   <productname>PostgreSQL</productname>中的字符集支持可以让你以各种字符集存储文本（也称为编码），
   包含单字节字符集，比如ISO-8859系列和多字节字符集比如<acronym>EUC</>(扩展Unix编码)、
   UTF-8、Mule国际编码。
   所有字符集都可以被客户端透明地使用。
   但是有一些不支持在服务器上使用（即作为服务器端编码）。
   缺省的字符集是在使用<command>initdb</>初始化数据库集群的时候选择的。
   在你创建数据库的时候是可以覆盖这个缺省值的。因此，你可以有多个数据库，
   每个都有不同的字符集。
</para>

  <!--
<para>
   An important restriction, however, is that each database's character set
   must be compatible with the database's <envar>LC_CTYPE</> (character
   classification) and <envar>LC_COLLATE</> (string sort order) locale
   settings. For <literal>C</> or
   <literal>POSIX</> locale, any character set is allowed, but for other
   locales there is only one character set that will work correctly.
   (On Windows, however, UTF-8 encoding can be used with any locale.)
  </para>
-->
<para>
    但是，有一个重要的限制，每个数据库的字符集必须与该数据库的<envar>LC_CTYPE</>（字符类别）以及
<envar>LC_COLLATE</>（字符串排序顺序）区域设置相兼容。对于<literal>C</>或者
    <literal>POSIX</>区域，允许任何字符集，
   但对于其他区域只有一个字符集设置能正常工作。（不过在Windows上，UTF-8编码可用于任何区域）。
</para>

   <sect2 id="multibyte-charset-supported">
   <!--
    <title>Supported Character Sets</title>
-->
 <title>支持的字符集</title>

    <!--
<para>
     <xref linkend="charset-table"> shows the character sets available
     for use in <productname>PostgreSQL</productname>.
    </para>
-->
<para>
    <xref linkend="charset-table">显示了可以在<productname>PostgreSQL</productname>中使用的
字符集。
</para>

     <table id="charset-table">
 <!--
      <title><productname>PostgreSQL</productname> Character Sets</title>
  -->
   <title><productname>PostgreSQL</productname>字符集</title>
      <tgroup cols="6">
       <thead>
        <row>
<!--
         <entry>Name</entry>
         <entry>Description</entry>
         <entry>Language</entry>
         <entry>Server?</entry>
 -->
 <entry>名字</entry>
         <entry>描述</entry>
         <entry>语言</entry>
         <entry>服务端?</entry>
         <!--
          The Bytes/Char field is populated by looking at the values returned
          by pg_wchar_table.mblen function for each encoding.
         -->
 <!--
         <entry>Bytes/Char</entry>
         <entry>Aliases</entry>
 -->
 <entry>字节数/字符</entry>
         <entry>别名</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><literal>BIG5</literal></entry>
 <!--
         <entry>Big Five</entry>
 -->
 <entry>大五码</entry>
 <!--
         <entry>Traditional Chinese</entry>
 -->
 <entry>繁体中文</entry>
         <entry>No</entry>
         <entry>1-2</entry>
         <entry><literal>WIN950</>, <literal>Windows950</></entry>
        </row>
        <row>
         <entry><literal>EUC_CN</literal></entry>
 <!--
         <entry>Extended UNIX Code-CN</entry>
         <entry>Simplified Chinese</entry>
 -->
 <entry>扩展UNIX代码-CN</entry>
         <entry>简体中文</entry>
         <entry>Yes</entry>
         <entry>1-3</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>EUC_JP</literal></entry>
 <!--
         <entry>Extended UNIX Code-JP</entry>
         <entry>Japanese</entry>
 -->
 <entry>扩展UNIX代码-JP</entry>
         <entry>日文</entry>
         <entry>Yes</entry>
         <entry>1-3</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>EUC_JIS_2004</literal></entry>
 <!--
         <entry>Extended UNIX Code-JP, JIS X 0213</entry>
         <entry>Japanese</entry>
 -->
 <entry>扩展UNIX代码-JP, JIS X 0213</entry>
         <entry>日文</entry>
         <entry>Yes</entry>
         <entry>1-3</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>EUC_KR</literal></entry>
 <!--
         <entry>Extended UNIX Code-KR</entry>
         <entry>Korean</entry>
 -->
 <entry>扩展UNIX代码-KR</entry>
         <entry>韩文</entry>
         <entry>Yes</entry>
         <entry>1-3</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>EUC_TW</literal></entry>
 <!--
         <entry>Extended UNIX Code-TW</entry>
         <entry>Traditional Chinese, Taiwanese</entry>
 -->
 <entry>扩展UNIX代码-TW</entry>
         <entry>繁体中文，台湾</entry>
         <entry>Yes</entry>
         <entry>1-3</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>GB18030</literal></entry>
 <!--
         <entry>National Standard</entry>
         <entry>Chinese</entry>
 -->
 <entry>国标码</entry>
         <entry>中文</entry>
         <entry>No</entry>
         <entry>1-2</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>GBK</literal></entry>
 <!--
         <entry>Extended National Standard</entry>
         <entry>Simplified Chinese</entry>
 -->
 <entry>扩展国标码</entry>
         <entry>简体中文</entry>
         <entry>No</entry>
         <entry>1-2</entry>
         <entry><literal>WIN936</>, <literal>Windows936</></entry>
        </row>
        <row>
         <entry><literal>ISO_8859_5</literal></entry>
         <entry>ISO 8859-5, <acronym>ECMA</> 113</entry>
 <!--
         <entry>Latin/Cyrillic</entry>
 -->
  <entry>拉丁/西里尔语</entry>
         <entry>Yes</entry>
         <entry>1</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>ISO_8859_6</literal></entry>
         <entry>ISO 8859-6, <acronym>ECMA</> 114</entry>
 <!--
         <entry>Latin/Arabic</entry>
 -->
 <entry>拉丁/阿拉伯语</entry>
         <entry>Yes</entry>
         <entry>1</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>ISO_8859_7</literal></entry>
         <entry>ISO 8859-7, <acronym>ECMA</> 118</entry>
 <!--
         <entry>Latin/Greek</entry>
 -->
 <entry>拉丁/希腊语</entry>
         <entry>Yes</entry>
         <entry>1</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>ISO_8859_8</literal></entry>
         <entry>ISO 8859-8, <acronym>ECMA</> 121</entry>
 <!--
         <entry>Latin/Hebrew</entry>
 -->
  <entry>拉丁/希伯莱语</entry>
         <entry>Yes</entry>
         <entry>1</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>JOHAB</literal></entry>
         <entry><acronym>JOHAB</></entry>
 <!--
         <entry>Korean (Hangul)</entry>
 -->
 <entry>韩语</entry>
         <entry>No</entry>
         <entry>1-3</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>KOI8R</literal></entry>
         <entry><acronym>KOI</acronym>8-R</entry>
 <!--
         <entry>Cyrillic (Russian)</entry>
 -->
 <entry>西里尔语(俄国)</entry>
         <entry>Yes</entry>
         <entry>1</entry>
         <entry><literal>KOI8</></entry>
        </row>
        <row>
         <entry><literal>KOI8U</literal></entry>
         <entry><acronym>KOI</acronym>8-U</entry>
 <!--
         <entry>Cyrillic (Ukrainian)</entry>
 -->
 <entry>西里尔语(乌克兰)</entry>
         <entry>Yes</entry>
         <entry>1</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>LATIN1</literal></entry>
         <entry>ISO 8859-1, <acronym>ECMA</> 94</entry>
 <!--
         <entry>Western European</entry>
 -->
 <entry>西欧语</entry>
         <entry>Yes</entry>
         <entry>1</entry>
         <entry><literal>ISO88591</></entry>
        </row>
        <row>
         <entry><literal>LATIN2</literal></entry>
         <entry>ISO 8859-2, <acronym>ECMA</> 94</entry>
 <!--
         <entry>Central European</entry>
 -->
 <entry>中欧语</entry>
         <entry>Yes</entry>
         <entry>1</entry>
         <entry><literal>ISO88592</></entry>
        </row>
        <row>
         <entry><literal>LATIN3</literal></entry>
         <entry>ISO 8859-3, <acronym>ECMA</> 94</entry>
 <!--
         <entry>South European</entry>
 -->
 <entry>南欧语</entry>
         <entry>Yes</entry>
         <entry>1</entry>
         <entry><literal>ISO88593</></entry>
        </row>
        <row>
         <entry><literal>LATIN4</literal></entry>
         <entry>ISO 8859-4, <acronym>ECMA</> 94</entry>
 <!--
         <entry>North European</entry>
 -->
 <entry>北欧语</entry>
         <entry>Yes</entry>
         <entry>1</entry>
         <entry><literal>ISO88594</></entry>
        </row>
        <row>
         <entry><literal>LATIN5</literal></entry>
         <entry>ISO 8859-9, <acronym>ECMA</> 128</entry>
 <!--
         <entry>Turkish</entry>
 -->
 <entry>土耳其语</entry>
         <entry>Yes</entry>
         <entry>1</entry>
         <entry><literal>ISO88599</></entry>
        </row>
        <row>
         <entry><literal>LATIN6</literal></entry>
         <entry>ISO 8859-10, <acronym>ECMA</> 144</entry>
 <!--
         <entry>Nordic</entry>
 -->
 <entry>日耳曼语</entry>
         <entry>Yes</entry>
         <entry>1</entry>
         <entry><literal>ISO885910</></entry>
        </row>
        <row>
         <entry><literal>LATIN7</literal></entry>
         <entry>ISO 8859-13</entry>
 <!--
         <entry>Baltic</entry>
 -->
 <entry>波罗的海语</entry>
         <entry>Yes</entry>
         <entry>1</entry>
         <entry><literal>ISO885913</></entry>
        </row>
        <row>
         <entry><literal>LATIN8</literal></entry>
         <entry>ISO 8859-14</entry>
 <!--
         <entry>Celtic</entry>
 -->
 <entry>凯尔特语</entry>
         <entry>Yes</entry>
         <entry>1</entry>
         <entry><literal>ISO885914</></entry>
        </row>
        <row>
         <entry><literal>LATIN9</literal></entry>
         <entry>ISO 8859-15</entry>
 <!--
         <entry>LATIN1 with Euro and accents</entry>
 -->
 <entry>带有欧洲语系和语调的LATIN1</entry>
         <entry>Yes</entry>
         <entry>1</entry>
         <entry><literal>ISO885915</></entry>
        </row>
        <row>
         <entry><literal>LATIN10</literal></entry>
         <entry>ISO 8859-16, <acronym>ASRO</> SR 14111</entry>
 <!--
         <entry>Romanian</entry>
 -->
 <entry>罗马尼亚语</entry>
         <entry>Yes</entry>
         <entry>1</entry>
         <entry><literal>ISO885916</></entry>
        </row>
        <row>
         <entry><literal>MULE_INTERNAL</literal></entry>
         <entry>Mule internal code</entry>
 <!--
         <entry>Multilingual Emacs</entry>
 -->
 <entry>多语种Emacs</entry>
         <entry>Yes</entry>
         <entry>1-4</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>SJIS</literal></entry>
         <entry>Shift JIS</entry>
 <!--
         <entry>Japanese</entry>
 -->
 <entry>日语</entry>
         <entry>No</entry>
         <entry>1-2</entry>
         <entry><literal>Mskanji</>, <literal>ShiftJIS</>, <literal>WIN932</>, <literal>Windows932</></entry>
        </row>
        <row>
         <entry><literal>SHIFT_JIS_2004</literal></entry>
         <entry>Shift JIS, JIS X 0213</entry> 
 <!--
         <entry>Japanese</entry>
 -->
 <entry>日语</entry>
         <entry>No</entry>
         <entry>1-2</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>SQL_ASCII</literal></entry>
         <entry>unspecified (see text)</entry>
 <!--
         <entry><emphasis>any</></entry>
 -->
 <entry><emphasis>任意</></entry>
         <entry>Yes</entry>
         <entry>1</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>UHC</literal></entry>
         <entry>Unified Hangul Code</entry>
 <!--
         <entry>Korean</entry>
 -->
 <entry>韩语</entry>
         <entry>No</entry>
         <entry>1-2</entry>
         <entry><literal>WIN949</>, <literal>Windows949</></entry>
        </row>
        <row>
         <entry><literal>UTF8</literal></entry>
         <entry>Unicode, 8-bit</entry>
 <!--
         <entry><emphasis>all</></entry>
 -->
 <entry><emphasis>全部</></entry>
         <entry>Yes</entry>
         <entry>1-4</entry>
         <entry><literal>Unicode</></entry>
        </row>
        <row>
         <entry><literal>WIN866</literal></entry>
         <entry>Windows CP866</entry>
 <!--
         <entry>Cyrillic</entry>
 -->
 <entry>西里尔语</entry>
         <entry>Yes</entry>
         <entry>1</entry>
         <entry><literal>ALT</></entry>
        </row>
        <row>
         <entry><literal>WIN874</literal></entry>
         <entry>Windows CP874</entry>
 <!--
         <entry>Thai</entry>
 -->
 <entry>泰国语</entry>
         <entry>Yes</entry>
         <entry>1</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>WIN1250</literal></entry>
         <entry>Windows CP1250</entry>
 <!--
         <entry>Central European</entry>
 -->
 <entry>中欧语</entry>
         <entry>Yes</entry>
         <entry>1</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>WIN1251</literal></entry>
         <entry>Windows CP1251</entry>
 <!--
         <entry>Cyrillic</entry>
 -->
  <entry>西里尔语</entry>
         <entry>Yes</entry>
         <entry>1</entry>
         <entry><literal>WIN</></entry>
        </row>
        <row>
         <entry><literal>WIN1252</literal></entry>
         <entry>Windows CP1252</entry>
 <!--
         <entry>Western European</entry>
 -->
  <entry>西欧语</entry>
         <entry>Yes</entry>
         <entry>1</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>WIN1253</literal></entry>
         <entry>Windows CP1253</entry>
 <!--
         <entry>Greek</entry>
 -->
 <entry>希腊语</entry>
         <entry>Yes</entry>
         <entry>1</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>WIN1254</literal></entry>
         <entry>Windows CP1254</entry>
 <!--
         <entry>Turkish</entry>
 -->
 <entry>土耳其语</entry>
         <entry>Yes</entry>
         <entry>1</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>WIN1255</literal></entry>
         <entry>Windows CP1255</entry>
 <!--
         <entry>Hebrew</entry>
 -->
 <entry>希伯来语</entry>
         <entry>Yes</entry>
         <entry>1</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>WIN1256</literal></entry>
         <entry>Windows CP1256</entry>
 <!--
         <entry>Arabic</entry>
 -->
 <entry>阿拉伯语</entry>
         <entry>Yes</entry>
         <entry>1</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>WIN1257</literal></entry>
         <entry>Windows CP1257</entry>
 <!--
         <entry>Baltic</entry>
 -->
 <entry>波罗的语</entry>
         <entry>Yes</entry>
         <entry>1</entry>
         <entry></entry>
        </row>
        <row>
         <entry><literal>WIN1258</literal></entry>
         <entry>Windows CP1258</entry>
 <!--
         <entry>Vietnamese</entry>
 -->
 <entry>越南语</entry>
         <entry>Yes</entry>
         <entry>1</entry>
         <entry><literal>ABC</>, <literal>TCVN</>, <literal>TCVN5712</>, <literal>VSCII</></entry>
        </row>
       </tbody>
      </tgroup>
     </table>

     <!--
<para>
      Not all client <acronym>API</>s support all the listed character sets. For example, the
      <productname>PostgreSQL</>
      JDBC driver does not support <literal>MULE_INTERNAL</>, <literal>LATIN6</>,
      <literal>LATIN8</>, and <literal>LATIN10</>.
     </para>
-->
<para>
  并非所有<acronym>API</>都支持上面列出的编码。比如，
  <productname>PostgreSQL</> JDBC驱动就不支持<literal>MULE_INTERNAL</>, <literal>LATIN6</>,
      <literal>LATIN8</>和<literal>LATIN10</>。

</para>

     <!--
<para>
      The <literal>SQL_ASCII</> setting behaves considerably differently
      from the other settings.  When the server character set is
      <literal>SQL_ASCII</>, the server interprets byte values 0-127
      according to the ASCII standard, while byte values 128-255 are taken
      as uninterpreted characters.  No encoding conversion will be done when
      the setting is <literal>SQL_ASCII</>.  Thus, this setting is not so
      much a declaration that a specific encoding is in use, as a declaration
      of ignorance about the encoding.  In most cases, if you are
      working with any non-ASCII data, it is unwise to use the
      <literal>SQL_ASCII</> setting because
      <productname>PostgreSQL</productname> will be unable to help you by
      converting or validating non-ASCII characters.
     </para>
-->
<para>
    <literal>SQL_ASCII</>设置与其它设置表现得相当不同。如果服务器字符集是<literal>SQL_ASCII</>，
服务器根据ASCII标准解析0-127的字节值，而字节值为128-255的则当作未解析的字符。
如果设置为<literal>SQL_ASCII</>就不会有编码转换。因此，这个设置基本不用来声明所使用的编码，
因为这个声明会忽略编码。在大多数情况下，如果你使用了任何非ASCII数据，
那么使用<literal>SQL_ASCII</>设置都是不明智的，因为<productname>PostgreSQL</productname>
会无法帮助你转换或者校验非ASCII字符。

</para>
    </sect2>

   <sect2>
   <!--
    <title>Setting the Character Set</title>
-->
<title>设置字符集</title>

    
<para>
    <!--
     <command>initdb</> defines the default character set (encoding)
     for a <productname>PostgreSQL</productname> cluster. For example,
   -->
   <command>initdb</>为一个<productname>PostgreSQL</productname>
   集群定义缺省的字符集（编码），比如：
<screen>
initdb -E EUC_JP
</screen>
    <!--
     sets the default character set to
     <literal>EUC_JP</literal> (Extended Unix Code for Japanese).  You
     can use <option>&#045;-encoding</option> instead of
     <option>-E</option> if you prefer longer option strings.
     If no <option>-E</> or <option>&#045;-encoding</option> option is
     given, <command>initdb</> attempts to determine the appropriate
     encoding to use based on the specified or default locale.
 -->
 把缺省字符集设置为<literal>EUC_JP</literal>(用于日文的扩展Unix编码)。
 如果你喜欢用长选项声明的话，可以用<option>--encoding</option>代替<option>-E</option>选项。
 如果没有给出<option>-E</>或者<option>--encoding</option>选项，
 <command>initdb</>将基于指定的或者缺省的区域试图判断合适的编码。
    </para>


   
<para>
      <!--
     You can specify a non-default encoding at database creation time,
     provided that the encoding is compatible with the selected locale:
     -->
     你可以在数据库创建时指定非缺省编码，但是指定的编码必须与所选的区域相兼容：
<screen>
createdb -E EUC_KR -T template0 --lc-collate=ko_KR.euckr --lc-ctype=ko_KR.euckr korean
</screen>
      <!--
     This will create a database named <literal>korean</literal> that
     uses the character set <literal>EUC_KR</literal>, and locale <literal>ko_KR</literal>.
     Another way to accomplish this is to use this SQL command:
     -->
 将创建一个使用<literal>EUC_KR</literal>字符集以及<literal>ko_KR</literal>区域的
 名字叫<literal>korean</literal>的数据库。另外一种实现方法是使用SQL命令：
<programlisting>
CREATE DATABASE korean WITH ENCODING 'EUC_KR' LC_COLLATE='ko_KR.euckr' LC_CTYPE='ko_KR.euckr' TEMPLATE=template0;
</programlisting>
      <!--
     Notice that the above commands specify copying the <literal>template0</>
     database.  When copying any other database, the encoding and locale
     settings cannot be changed from those of the source database, because
     that might result in corrupt data.  For more information see
     <xref linkend="manage-ag-templatedbs">.
 -->
 注意上述命令声明拷贝<literal>template0</>数据库。当拷贝任何其他数据库时，
 来自源数据库的编码和区域设置不能被改变，因为可能导致数据损坏。参阅<xref linkend="manage-ag-templatedbs">
 获取更多信息。
    </para>


    
<para>
   <!--
     The encoding for a database is stored in the system catalog
     <literal>pg_database</literal>.  You can see it by using the
     <command>psql</command> <option>-l</option> option or the
     <command>\l</command> command.
   -->
 数据库的编码是存储在<literal>pg_database</literal>系统表中的。
 你可以用<command>psql</command>的<option>-l</option>选项或<command>\l</command>
 命令列出这些编码。

<screen>
$ <userinput>psql -l</userinput>
                                         List of databases
   Name    |  Owner   | Encoding  |  Collation  |    Ctype    |          Access Privileges          
-----------+----------+-----------+-------------+-------------+-------------------------------------
 clocaledb | hlinnaka | SQL_ASCII | C           | C           | 
 englishdb | hlinnaka | UTF8      | en_GB.UTF8  | en_GB.UTF8  | 
 japanese  | hlinnaka | UTF8      | ja_JP.UTF8  | ja_JP.UTF8  | 
 korean    | hlinnaka | EUC_KR    | ko_KR.euckr | ko_KR.euckr | 
 postgres  | hlinnaka | UTF8      | fi_FI.UTF8  | fi_FI.UTF8  | 
 template0 | hlinnaka | UTF8      | fi_FI.UTF8  | fi_FI.UTF8  | {=c/hlinnaka,hlinnaka=CTc/hlinnaka}
 template1 | hlinnaka | UTF8      | fi_FI.UTF8  | fi_FI.UTF8  | {=c/hlinnaka,hlinnaka=CTc/hlinnaka}
(7 rows)
</screen>
    </para>



    <important>
     <!--
<para>
      On most modern operating systems, <productname>PostgreSQL</productname>
      can determine which character set is implied by the <envar>LC_CTYPE</>
      setting, and it will enforce that only the matching database encoding is
      used.  On older systems it is your responsibility to ensure that you use
      the encoding expected by the locale you have selected.  A mistake in
      this area is likely to lead to strange behavior of locale-dependent
      operations such as sorting.
     </para>
-->
<para>

   在大多数现代操作系统中，<productname>PostgreSQL</productname>可以通过
   <envar>LC_CTYPE</>的设置决定使用哪种字符集，并且强制只使用匹配的数据库编码。在旧的操作系统上
   你有责任确保使用所选区域所期望的编码。
   如果这上面犯错误很可能导致与区域相关的操作表现出古怪的行为，比如排序。
  
</para>

     <!--
<para>
      <productname>PostgreSQL</productname> will allow superusers to create
      databases with <literal>SQL_ASCII</> encoding even when
      <envar>LC_CTYPE</> is not <literal>C</> or <literal>POSIX</>.  As noted
      above, <literal>SQL_ASCII</> does not enforce that the data stored in
      the database has any particular encoding, and so this choice poses risks
      of locale-dependent misbehavior.  Using this combination of settings is
      deprecated and may someday be forbidden altogether.
     </para>
-->
<para>
      即使当<envar>LC_CTYPE</>不是<literal>C</>或者<literal>POSIX</>时，
  <productname>PostgreSQL</productname>也允许超级用户创建 
  使用<literal>SQL_ASCII</>编码的数据库。正如 
  以上所述，<literal>SQL_ASCII</>不强制存储在数据库中的数据
  具有任何特定的编码，所以这个选择带来
  区域相关的不当行为的风险。使用这样的设置组合是不推荐的，也许有一天会被完全禁止。
</para>
    </important>
   </sect2>

   <sect2>
    <!--
    <title>Automatic Character Set Conversion Between Server and Client</title>
-->
<title>服务器和客户端之间的自动字符集转换</title>


    <!--
<para>
     <productname>PostgreSQL</productname> supports automatic
     character set conversion between server and client for certain
     character set combinations. The conversion information is stored in the
     <literal>pg_conversion</> system catalog.  <productname>PostgreSQL</>
     comes with some predefined conversions, as shown in <xref
     linkend="multibyte-translation-table">. You can create a new
     conversion using the SQL command <command>CREATE CONVERSION</command>.
    </para>
-->
<para>
   <productname>PostgreSQL</productname>支持在服务器和前端之间的自动编码转换。
   转换信息在系统表<literal>pg_conversion</>中存储。
   <productname>PostgreSQL</>带着一些预定义的转换。
   它们在<xref linkend="multibyte-translation-table">中列出。
   你可以使用SQL命令<command>CREATE CONVERSION</command>创建一个新的转换。
</para>

     <table id="multibyte-translation-table">
 <!--
      <title>Client/Server Character Set Conversions</title>
  -->
  <title>客户/服务器字符集转换</title>
      <tgroup cols="2">
       <thead>
        <row>
<!--
         <entry>Server Character Set</entry>
         <entry>Available Client Character Sets</entry>
 -->
 <entry>服务器字符集</entry>
         <entry>可用客户端字符集</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><literal>BIG5</literal></entry>
 <!--
         <entry><emphasis>not supported as a server encoding</emphasis>
         </entry>
  -->
  <entry><emphasis>不支持做服务器端编码</emphasis></entry>
        </row>
        <row>
         <entry><literal>EUC_CN</literal></entry>
         <entry><emphasis>EUC_CN</emphasis>,
         <literal>MULE_INTERNAL</literal>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>EUC_JP</literal></entry>
         <entry><emphasis>EUC_JP</emphasis>,
         <literal>MULE_INTERNAL</literal>,
         <literal>SJIS</literal>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>EUC_KR</literal></entry>
         <entry><emphasis>EUC_KR</emphasis>,
         <literal>MULE_INTERNAL</literal>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>EUC_TW</literal></entry>
         <entry><emphasis>EUC_TW</emphasis>,
         <literal>BIG5</literal>,
         <literal>MULE_INTERNAL</literal>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>GB18030</literal></entry>
         <!--
 <entry><emphasis>not supported as a server encoding</emphasis>
         </entry>
 -->
 <entry><emphasis>不支持做服务器端编码</emphasis>
         </entry>
        </row>
        <row>
         <entry><literal>GBK</literal></entry>
 <!--
         <entry><emphasis>not supported as a server encoding</emphasis>
         </entry>
 -->
 <entry><emphasis>不支持做服务器端编码</emphasis>
         </entry>
 
        </row>
        <row>
         <entry><literal>ISO_8859_5</literal></entry>
         <entry><emphasis>ISO_8859_5</emphasis>,
         <literal>KOI8R</literal>,
         <literal>MULE_INTERNAL</literal>,
         <literal>UTF8</literal>,
         <literal>WIN866</literal>,
         <literal>WIN1251</literal>
         </entry>
        </row>
        <row>
         <entry><literal>ISO_8859_6</literal></entry>
         <entry><emphasis>ISO_8859_6</emphasis>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>ISO_8859_7</literal></entry>
         <entry><emphasis>ISO_8859_7</emphasis>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>ISO_8859_8</literal></entry>
         <entry><emphasis>ISO_8859_8</emphasis>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>JOHAB</literal></entry>
         <entry><emphasis>JOHAB</emphasis>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>KOI8R</literal></entry>
         <entry><emphasis>KOI8R</emphasis>,
         <literal>ISO_8859_5</literal>,
         <literal>MULE_INTERNAL</literal>,
         <literal>UTF8</literal>,
         <literal>WIN866</literal>,
         <literal>WIN1251</literal>
         </entry>
        </row>
        <row>
         <entry><literal>KOI8U</literal></entry>
         <entry><emphasis>KOI8U</emphasis>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>LATIN1</literal></entry>
         <entry><emphasis>LATIN1</emphasis>,
         <literal>MULE_INTERNAL</literal>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>LATIN2</literal></entry>
         <entry><emphasis>LATIN2</emphasis>,
         <literal>MULE_INTERNAL</literal>,
         <literal>UTF8</literal>,
         <literal>WIN1250</literal>
         </entry>
        </row>
        <row>
         <entry><literal>LATIN3</literal></entry>
         <entry><emphasis>LATIN3</emphasis>,
         <literal>MULE_INTERNAL</literal>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>LATIN4</literal></entry>
         <entry><emphasis>LATIN4</emphasis>,
         <literal>MULE_INTERNAL</literal>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>LATIN5</literal></entry>
         <entry><emphasis>LATIN5</emphasis>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>LATIN6</literal></entry>
         <entry><emphasis>LATIN6</emphasis>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>LATIN7</literal></entry>
         <entry><emphasis>LATIN7</emphasis>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>LATIN8</literal></entry>
         <entry><emphasis>LATIN8</emphasis>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>LATIN9</literal></entry>
         <entry><emphasis>LATIN9</emphasis>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>LATIN10</literal></entry>
         <entry><emphasis>LATIN10</emphasis>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>MULE_INTERNAL</literal></entry>
         <entry><emphasis>MULE_INTERNAL</emphasis>,
          <literal>BIG5</literal>,
          <literal>EUC_CN</literal>,
          <literal>EUC_JP</literal>,
          <literal>EUC_KR</literal>,
          <literal>EUC_TW</literal>,
          <literal>ISO_8859_5</literal>,
          <literal>KOI8R</literal>,
          <literal>LATIN1</literal> to <literal>LATIN4</literal>,
          <literal>SJIS</literal>,
          <literal>WIN866</literal>,
          <literal>WIN1250</literal>,
          <literal>WIN1251</literal>
         </entry>
        </row>
        <row>
         <entry><literal>SJIS</literal></entry>
 <!--
         <entry><emphasis>not supported as a server encoding</emphasis>
         </entry>
 -->
 <entry><emphasis>不支持做服务器端编码</emphasis>
         </entry>
        </row>
        <row>
         <entry><literal>SQL_ASCII</literal></entry>
 <!--
         <entry><emphasis>any (no conversion will be performed)</emphasis>
         </entry>
 -->
 <entry><emphasis>任意(不会发生编码转换)</emphasis>
         </entry>
        </row>
        <row>
         <entry><literal>UHC</literal></entry>
 <!--
         <entry><emphasis>not supported as a server encoding</emphasis>
         </entry>
 -->
 <entry><emphasis>不支持做服务器端编码</emphasis>
         </entry>
        </row>
        <row>
         <entry><literal>UTF8</literal></entry>
 <!--
         <entry><emphasis>all supported encodings</emphasis>
         </entry>
 -->
 <entry><emphasis>所有支持的编码</emphasis>
         </entry>
        </row>
        <row>
         <entry><literal>WIN866</literal></entry>
         <entry><emphasis>WIN866</emphasis>,
          <literal>ISO_8859_5</literal>,
          <literal>KOI8R</literal>,
          <literal>MULE_INTERNAL</literal>,
          <literal>UTF8</literal>,
          <literal>WIN1251</literal>
         </entry>
        </row>
        <row>
         <entry><literal>WIN874</literal></entry>
         <entry><emphasis>WIN874</emphasis>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>WIN1250</literal></entry>
         <entry><emphasis>WIN1250</emphasis>,
          <literal>LATIN2</literal>,
          <literal>MULE_INTERNAL</literal>,
          <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>WIN1251</literal></entry>
         <entry><emphasis>WIN1251</emphasis>,
          <literal>ISO_8859_5</literal>,
          <literal>KOI8R</literal>,
          <literal>MULE_INTERNAL</literal>,
          <literal>UTF8</literal>,
          <literal>WIN866</literal>
         </entry>
        </row>
        <row>
         <entry><literal>WIN1252</literal></entry>
         <entry><emphasis>WIN1252</emphasis>,
          <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>WIN1253</literal></entry>
         <entry><emphasis>WIN1253</emphasis>,
          <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>WIN1254</literal></entry>
         <entry><emphasis>WIN1254</emphasis>,
          <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>WIN1255</literal></entry>
         <entry><emphasis>WIN1255</emphasis>,
          <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>WIN1256</literal></entry>
         <entry><emphasis>WIN1256</emphasis>,
         <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>WIN1257</literal></entry>
         <entry><emphasis>WIN1257</emphasis>,
          <literal>UTF8</literal>
         </entry>
        </row>
        <row>
         <entry><literal>WIN1258</literal></entry>
         <entry><emphasis>WIN1258</emphasis>,
         <literal>UTF8</literal>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>

    
<para>
    <!--
     To enable automatic character set conversion, you have to
     tell <productname>PostgreSQL</productname> the character set
     (encoding) you would like to use in the client. There are several
     ways to accomplish this:
    -->
 要想打开自动字符集转换功能，你必须告诉<productname>PostgreSQL</productname>
 你想在客户端使用的字符集(编码)。
 你可以用好几种方法实现这个目的。
 
     <itemizedlist>
      <listitem>
       <para>
    <!--
        Using the <command>\encoding</command> command in
        <application>psql</application>.
        <command>\encoding</command> allows you to change client
        encoding on the fly. For
        example, to change the encoding to <literal>SJIS</literal>, type:
        -->
用<application>psql</application>里的<command>\encoding</command>命令。
<command>\encoding</command>允许你动态修改客户端编码。
比如，把编码改变为<literal>SJIS</literal>，键入：

<programlisting>
\encoding SJIS
</programlisting>
       </para>


      </listitem>

      <listitem>
       <!--
<para>
        <application>libpq</> (<xref linkend="libpq-control">) has functions to control the client encoding.
       </para>
-->
<para>
    使用<application>libpq</> (<xref linkend="libpq-control">)函数控制客户端编码。
</para>
      </listitem>

      <listitem>
       
<para>
      <!--
        Using <command>SET client_encoding TO</command>.

        Setting the client encoding can be done with this SQL command:
      -->
  使用<command>SET client_encoding TO</command>。使用下面的SQL命令设置客户端编码：
<programlisting>
SET CLIENT_ENCODING TO '<replaceable>value</>';
</programlisting>
 
       <!--
        Also you can use the standard SQL syntax <literal>SET NAMES</literal>
        for this purpose:
       -->
   你也可以使用标准的SQL语法<literal>SET NAMES</literal>达到这个目的：
<programlisting>
SET NAMES '<replaceable>value</>';
</programlisting>

       <!--
        To query the current client encoding:
-->

       查询当前客户端编码：
<programlisting>
SHOW client_encoding;
</programlisting>

        <!--
        To return to the default encoding:
        -->
返回缺省编码：
<programlisting>
RESET client_encoding;
</programlisting>
       </para>

      </listitem>

      <listitem>
       <!--
<para>
        Using <envar>PGCLIENTENCODING</envar>. If the environment variable
        <envar>PGCLIENTENCODING</envar> is defined in the client's
        environment, that client encoding is automatically selected
        when a connection to the server is made.  (This can
        subsequently be overridden using any of the other methods
        mentioned above.)
       </para>
-->
<para>
  使用<envar>PGCLIENTENCODING</envar>。如果在客户端的环境里定义了 
  <envar>PGCLIENTENCODING</envar>环境变量，那么在与服务器进行连接时将自动选择这个客户端编码。
  这个编码随后可以用上面谈到的任何其它方法覆盖。

</para>
      </listitem>

      <listitem>
      <!--
<para>
       Using the configuration variable <xref
       linkend="guc-client-encoding">. If the
       <varname>client_encoding</> variable is set, that client
       encoding is automatically selected when a connection to the
       server is made.  (This can subsequently be overridden using any
       of the other methods mentioned above.)
       </para>
-->
<para>
   使用<xref linkend="guc-client-encoding">配置变量。
   如果在<varname>client_encoding</>里设置了该变量，
   那么在与服务器建立了连接之后，将自动选定这个客户端编码。
   这个设置随后可以被上面提到的其它方法覆盖。
</para>
      </listitem>

     </itemizedlist>
    </para>

    <!--
<para>
     If the conversion of a particular character is not possible
     &mdash; suppose you chose <literal>EUC_JP</literal> for the
     server and <literal>LATIN1</literal> for the client, and some
     Japanese characters are returned that do not have a representation in
     <literal>LATIN1</literal> &mdash; an error is reported.
    </para>
-->
<para>
   假如无法进行特定的字符转换&mdash; 比如，
   你选的服务器编码是<literal>EUC_JP</literal>而客户端是<literal>LATIN1</literal>，
   那么有些返回的日文字符不能转换成<literal>LATIN1</literal> &mdash;这时将报告错误。
</para>

    <!--
<para>
     If the client character set is defined as <literal>SQL_ASCII</>,
     encoding conversion is disabled, regardless of the server's character
     set.  Just as for the server, use of <literal>SQL_ASCII</> is unwise
     unless you are working with all-ASCII data.
    </para>
-->
<para>
   如果客户端字符集定义成了<literal>SQL_ASCII</>，
   那么编码转换会被关闭，不管服务器的字符集是什么都一样。
   和服务器一样，除非你的工作环境全部是ASCII数据，否则使用<literal>SQL_ASCII</>是不明智的。
</para>
   </sect2>

   <sect2>
   <!--
    <title>Further Reading</title>
-->
<title>进一步阅读</title>

    
<para>
    <!--
     These are good sources to start learning about various kinds of encoding
     systems.
    -->
 下面是学习各种类型的编码系统的好地方。

     <variablelist>
      <varlistentry>
       <term><citetitle>CJKV Information Processing: Chinese, Japanese, Korean &amp; Vietnamese Computing</citetitle></term>

       <listitem>
        <para>
         <!--
         Contains detailed explanations of <literal>EUC_JP</literal>,
         <literal>EUC_CN</literal>, <literal>EUC_KR</literal>,
         <literal>EUC_TW</literal>.
 -->
 包含<literal>EUC_JP</literal>,
         <literal>EUC_CN</literal>, <literal>EUC_KR</literal>,
         <literal>EUC_TW</literal>的详细说明。
        </para>


       </listitem>
      </varlistentry>

      <varlistentry>
       <term><ulink url="http://www.unicode.org/"></ulink></term>

       <listitem>
        <!--
<para>
         The web site of the Unicode Consortium.
        </para>
-->
<para>
       Unicode主页。
</para>
       </listitem>
      </varlistentry>

      <varlistentry>
       <term>RFC 3629</term>

       <listitem>
        <!--
<para>
         <acronym>UTF</acronym>-8 (8-bit UCS/Unicode Transformation
         Format) is defined here.
        </para>
-->
<para>
   <acronym>UTF</acronym>-8 (8-bit UCS/Unicode转换格式)的定义。
</para>
       </listitem>
      </varlistentry>
     </variablelist>
    </para>
   </sect2>

  </sect1>

</chapter>
