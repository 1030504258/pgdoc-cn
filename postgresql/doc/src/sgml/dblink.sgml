<!-- doc/src/sgml/dblink.sgml -->

<sect1 id="dblink" xreflabel="dblink">
 <title>dblink</title>

 <indexterm zone="dblink">
  <primary>dblink</primary>
 </indexterm>

 <!--
<para>
  <filename>dblink</> is a module that supports connections to
  other <productname>PostgreSQL</> databases from within a database
  session.
 </para>
-->
<para>
   <filename>dblink</>是一个在数据库会话中支持连接其他<productname>PostgreSQL</>
   数据库的模块。
</para>

 <!--
<para>
  See also <xref linkend="postgres-fdw">, which provides roughly the same
  functionality using a more modern and standards-compliant infrastructure.
 </para>
-->
<para>
    参阅<xref linkend="postgres-fdw">使用更现代且符合标准的基础设施
提供了大体一样的功能。
</para>

 <refentry id="CONTRIB-DBLINK-CONNECT">
  <refmeta>
   <refentrytitle>dblink_connect</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_connect</refname>
   <!--
   <refpurpose>opens a persistent connection to a remote database</refpurpose>
   -->
   <refpurpose>打开到远程数据库的持久连接</refpurpose>
  </refnamediv>

  <indexterm>
   <primary>dblink_connect</primary>
  </indexterm>

  <refsynopsisdiv>
<synopsis>
dblink_connect(text connstr) returns text
dblink_connect(text connname, text connstr) returns text
</synopsis>
  </refsynopsisdiv>

  <refsect1>
  <!--
   <title>Description</title>
  -->
   <title>描述</title>

   <!--
<para>
    <function>dblink_connect()</> establishes a connection to a remote
    <productname>PostgreSQL</> database.  The server and database to
    be contacted are identified through a standard <application>libpq</>
    connection string.  Optionally, a name can be assigned to the
    connection.  Multiple named connections can be open at once, but
    only one unnamed connection is permitted at a time.  The connection
    will persist until closed or until the database session is ended.
   </para>
-->
<para>
    <function>dblink_connect()</>建立了远程<productname>PostgreSQL</>数据库的连接。
连接的服务器和数据库是通过标准<application>libpq</>连接字符串被标识。
随意的，给连接分配名字。可以一次打开多个命名的连接，但是每次仅仅允许一个未命名连接。
连接将持续直到关闭或者数据库会话结束为止。

</para>

   <!--
<para>
    The connection string may also be the name of an existing foreign
    server.  It is recommended to use the foreign-data wrapper
    <literal>dblink_fdw</literal> when defining the foreign
    server.  See the example below, as well as
    <xref linkend="sql-createserver"> and
    <xref linkend="sql-createusermapping">.
   </para>
-->
<para>
   连接字符串也可能是已存在外服务器的名字。当定义外服务器时，推荐使用外数据包<literal>dblink_fdw</literal>。
   请看下面的例子，以及<xref linkend="sql-createserver">和<xref linkend="sql-createusermapping">。
</para>

  </refsect1>

  <refsect1>
  <!--
   <title>Arguments</title>
  -->
    <title>参数</title>

   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <!--
<para>
       The name to use for this connection; if omitted, an unnamed
       connection is opened, replacing any existing unnamed connection.
      </para>
-->
<para>
     用于连接的名称；如果忽略，那么打开一个未命名的连接，
 替换任何已存在未命名连接。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>connstr</parameter></term>
     <listitem>
      <!--
<para><application>libpq</>-style connection info string, for example
       <literal>hostaddr=127.0.0.1 port=5432 dbname=mydb user=postgres
       password=mypasswd</>.
       For details see <xref linkend="libpq-connstring">.
       Alternatively, the name of a foreign server.
      </para>
-->
<para>
     <application>libpq</>-形式连接信息字符串，比如<literal>hostaddr=127.0.0.1 port=5432 dbname=mydb user=postgres
       password=mypasswd</>。
   更多详情请参阅<xref linkend="libpq-connstring">。
   另外，外服务器名称。
</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
  <!--
   <title>Return Value</title>
  -->
    <title>返回值</title>

   <!--
<para>
    Returns status, which is always <literal>OK</> (since any error
    causes the function to throw an error instead of returning).
   </para>
-->
<para>
     返回状态总是<literal>OK</>（因为任何错误导致函数抛出错误而不是返回）。
</para>
  </refsect1>

  <refsect1>
   <!--
<title>Notes</title>
-->
<title>注意</title>

   <!--
<para>
    Only superusers may use <function>dblink_connect</> to create
    non-password-authenticated connections.  If non-superusers need this
    capability, use <function>dblink_connect_u</> instead.
   </para>
-->
<para>
    只有超级用户可能使用<function>dblink_connect</>创建非口令认证连接。如果
非超级用户需要这个能力，使用<function>dblink_connect_u</>。
</para>

   <!--
<para>
    It is unwise to choose connection names that contain equal signs,
    as this opens a risk of confusion with connection info strings
    in other <filename>dblink</> functions.
   </para>
-->
<para>
    选择包含等号的连接名是不明智的，正如这在其他<filename>dblink</>函数中打开
与连接信息字符串混淆的风险。
</para>
  </refsect1>

  <refsect1>
   <!--
<title>Examples</title>
-->
<title>例子</title>


<screen>
SELECT dblink_connect('dbname=postgres');
 dblink_connect
----------------
 OK
(1 row)

SELECT dblink_connect('myconn', 'dbname=postgres');
 dblink_connect
----------------
 OK
(1 row)

<!--
&#045;- FOREIGN DATA WRAPPER functionality
-->
-- 外数据封装功能
<!--
&#045;- Note: local connection must require password authentication for this to work properly
-->
-- 注意: 本地连接必须要求密码认证工作正常
<!--
&#045;-       Otherwise, you will receive the following error from dblink_connect():
-->
--       否则，你将接收到来自dblink_connect()的下面的错误:
--       ----------------------------------------------------------------------
<!--
&#045;-       ERROR:  password is required
&#045;-       DETAIL:  Non-superuser cannot connect if the server does not request a password.
&#045;-       HINT:  Target server's authentication method must be changed.
-->
--       ERROR: 需要密码
--       DETAIL: 如果服务器不需要密码，那么非超级用户无法连接。
--       HINT:  必须改变目标服务器的身份验证方法。



CREATE SERVER fdtest FOREIGN DATA WRAPPER dblink_fdw OPTIONS (hostaddr '127.0.0.1', dbname 'contrib_regression');

CREATE USER dblink_regression_test WITH PASSWORD 'secret';
CREATE USER MAPPING FOR dblink_regression_test SERVER fdtest OPTIONS (user 'dblink_regression_test', password 'secret');
GRANT USAGE ON FOREIGN SERVER fdtest TO dblink_regression_test;
GRANT SELECT ON TABLE foo TO dblink_regression_test;

\set ORIGINAL_USER :USER
\c - dblink_regression_test
SELECT dblink_connect('myconn', 'fdtest');
 dblink_connect 
----------------
 OK
(1 row)

SELECT * FROM dblink('myconn','SELECT * FROM foo') AS t(a int, b text, c text[]);
 a  | b |       c       
----+---+---------------
  0 | a | {a0,b0,c0}
  1 | b | {a1,b1,c1}
  2 | c | {a2,b2,c2}
  3 | d | {a3,b3,c3}
  4 | e | {a4,b4,c4}
  5 | f | {a5,b5,c5}
  6 | g | {a6,b6,c6}
  7 | h | {a7,b7,c7}
  8 | i | {a8,b8,c8}
  9 | j | {a9,b9,c9}
 10 | k | {a10,b10,c10}
(11 rows)

\c - :ORIGINAL_USER
REVOKE USAGE ON FOREIGN SERVER fdtest FROM dblink_regression_test;
REVOKE SELECT ON TABLE foo FROM dblink_regression_test;
DROP USER MAPPING FOR dblink_regression_test SERVER fdtest;
DROP USER dblink_regression_test;
DROP SERVER fdtest;
</screen>

  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-CONNECT-U">
  <refmeta>
   <refentrytitle>dblink_connect_u</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_connect_u</refname>
   <!--
   <refpurpose>opens a persistent connection to a remote database, insecurely</refpurpose>
   -->
    <refpurpose>危险的打开一个到远程数据库的持久连接</refpurpose>
  </refnamediv>

  <indexterm>
   <primary>dblink_connect_u</primary>
  </indexterm>

  <refsynopsisdiv>
<synopsis>
dblink_connect_u(text connstr) returns text
dblink_connect_u(text connname, text connstr) returns text
</synopsis>
  </refsynopsisdiv>

  <refsect1>
  <!--
   <title>Description</title>
  -->
   <title>描述</title>

   <!--
<para>
    <function>dblink_connect_u()</> is identical to
    <function>dblink_connect()</>, except that it will allow non-superusers
    to connect using any authentication method.
   </para>
-->
<para>
   <function>dblink_connect_u()</>与<function>dblink_connect()</>是相同的，
   除了它将允许非超级用户使用任何身份验证方法进行连接。
   
</para>

   <!--
<para>
    If the remote server selects an authentication method that does not
    involve a password, then impersonation and subsequent escalation of
    privileges can occur, because the session will appear to have
    originated from the user as which the local <productname>PostgreSQL</>
    server runs.  Also, even if the remote server does demand a password,
    it is possible for the password to be supplied from the server
    environment, such as a <filename>~/.pgpass</> file belonging to the
    server's user.  This opens not only a risk of impersonation, but the
    possibility of exposing a password to an untrustworthy remote server.
    Therefore, <function>dblink_connect_u()</> is initially
    installed with all privileges revoked from <literal>PUBLIC</>,
    making it un-callable except by superusers.  In some situations
    it may be appropriate to grant <literal>EXECUTE</> permission for
    <function>dblink_connect_u()</> to specific users who are considered
    trustworthy, but this should be done with care.  It is also recommended
    that any <filename>~/.pgpass</> file belonging to the server's user
    <emphasis>not</> contain any records specifying a wildcard host name.
   </para>
-->
<para>
   如果远程服务器选择一个不涉及密码的身份验证方法，然后模拟并且产生权限的随后升级，
   因为该会话将出现于用户，正如本地<productname>PostgreSQL</>服务器运行的那个。
   同时，即使远程服务器确实需要密码，从服务器环境提供密码是可能的，比如
   <filename>~/.pgpass</>文件从属于服务器的用户。这不仅仅打开模拟风险，而且
   可能将密码暴露给不信任的远程服务器。
   因此，<function>dblink_connect_u()</>初始安装从<literal>PUBLIC</>撤销的所有权限。
   使得它不可请求即付只有超级用户可以。
   在一些情况下可以为<function>dblink_connect_u()</>指定可以信赖的用户适当授予
   <literal>EXECUTE</>权限，但这应该仔细的做。
   推荐任何从属于服务器的用户的<filename>~/.pgpass</>文件<emphasis>不</>包含
   指定通配符主机名的任何记录。 
   
</para>

   <!--
<para>
    For further details see <function>dblink_connect()</>.
   </para>
-->
<para>
    更多详情请参阅<function>dblink_connect()</>。
</para>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-DISCONNECT">
  <refmeta>
   <refentrytitle>dblink_disconnect</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_disconnect</refname>
   <!--
   <refpurpose>closes a persistent connection to a remote database</refpurpose>
   -->
    <refpurpose>关闭远程数据库的持久连接</refpurpose>
  </refnamediv>

  <indexterm>
   <primary>dblink_disconnect</primary>
  </indexterm>

  <refsynopsisdiv>
<synopsis>
dblink_disconnect() returns text
dblink_disconnect(text connname) returns text
</synopsis>
  </refsynopsisdiv>

  <refsect1>
  <!--
   <title>Description</title>
  -->
    <title>描述</title>

   <!--
<para>
    <function>dblink_disconnect()</> closes a connection previously opened
    by <function>dblink_connect()</>.  The form with no arguments closes
    an unnamed connection.
   </para>
-->
<para>
    <function>dblink_disconnect()</>关闭先前通过<function>dblink_connect()</>打开的连接。无参数形式关闭一个未命名连接。
</para>
  </refsect1>

  <refsect1>
  <!--
   <title>Arguments</title>
   -->
    <title>参数</title>

   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <!--
<para>
       The name of a named connection to be closed.
      </para>
-->
<para>
    被关闭的命名连接的名称。
</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
  <!--
   <title>Return Value</title>
  -->
     <title>返回值</title>

   <!--
<para>
    Returns status, which is always <literal>OK</> (since any error
    causes the function to throw an error instead of returning).
   </para>
-->
<para>
    返回状态始终是<literal>OK</>（因为任何错误导致函数抛出错误而不是返回）。
</para>
  </refsect1>

  <refsect1>
   <!--
<title>Examples</title>
-->
<title>例子</title>

<screen>
SELECT dblink_disconnect();
 dblink_disconnect
-------------------
 OK
(1 row)

SELECT dblink_disconnect('myconn');
 dblink_disconnect
-------------------
 OK
(1 row)
</screen>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-FUNCTION">
  <refmeta>
   <refentrytitle>dblink</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink</refname>
   <!--
   <refpurpose>executes a query in a remote database</refpurpose>
   -->
   <refpurpose>在远程数据库中执行查询</refpurpose>
  </refnamediv>

  <indexterm>
   <primary>dblink</primary>
  </indexterm>

  <refsynopsisdiv>
<synopsis>
dblink(text connname, text sql [, bool fail_on_error]) returns setof record
dblink(text connstr, text sql [, bool fail_on_error]) returns setof record
dblink(text sql [, bool fail_on_error]) returns setof record
</synopsis>
  </refsynopsisdiv>

  <refsect1>
  <!--
   <title>Description</title>
  -->
    <title>描述</title>

   <!--
<para>
    <function>dblink</> executes a query (usually a <command>SELECT</>,
    but it can be any SQL statement that returns rows) in a remote database.
   </para>
-->
<para>
   <function>dblink</>在远程数据库中执行查询（通常<command>SELECT</>，但是它
   可以是任何返回行的SQL语句）。
</para>

   <!--
<para>
    When two <type>text</> arguments are given, the first one is first
    looked up as a persistent connection's name; if found, the command
    is executed on that connection.  If not found, the first argument
    is treated as a connection info string as for <function>dblink_connect</>,
    and the indicated connection is made just for the duration of this command.
   </para>
-->
<para>
    当给定两个<type>text</>参数时，第一个作为持久连接名称首先被查找；如果发现了，
那么在连接上执行该命令。如果没有发现，那么第一个参数被看作<function>dblink_connect</>的连接信息字符串，并且指定连接为了该命令的整个时间段。

</para>
  </refsect1>

  <refsect1>
  <!--
   <title>Arguments</title>
   -->
      <title>参数</title>

   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <!--
<para>
       Name of the connection to use; omit this parameter to use the
       unnamed connection.
      </para>
-->
<para>
     要使用的连接名称；省略这个参数使用未命名连接。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>connstr</parameter></term>
     <listitem>
      <!--
<para>
       A connection info string, as previously described for
       <function>dblink_connect</>.
      </para>
-->
<para>
    连接信息字符串，如先前描述的<function>dblink_connect</>。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>sql</parameter></term>
     <listitem>
      <!--
<para>
       The SQL query that you wish to execute in the remote database,
       for example <literal>select * from foo</>.
      </para>
-->
<para>
       你希望在远程数据库中执行的SQL查询，比如<literal>select * from foo</>。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>fail_on_error</parameter></term>
     <listitem>
      <!--
<para>
       If true (the default when omitted) then an error thrown on the
       remote side of the connection causes an error to also be thrown
       locally. If false, the remote error is locally reported as a NOTICE,
       and the function returns no rows.
      </para>
-->
<para>
    如果真（忽略时缺省）那么在连接的远程端抛出的错误也会导致本地抛出错误，
如果假，那么远程错误在本地作为NOTICE被报告，
并且函数没有返回行。
</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
  <!--
   <title>Return Value</title>
  -->
     <title>返回值</title>
   
   
<para>
    <!--
    The function returns the row(s) produced by the query.  Since
    <function>dblink</> can be used with any query, it is declared
    to return <type>record</>, rather than specifying any particular
    set of columns.  This means that you must specify the expected
    set of columns in the calling query &mdash; otherwise
    <productname>PostgreSQL</> would not know what to expect.
    Here is an example:
    -->
该函数返回查询产生的行。因为<function>dblink</>可以用于任何查询，
它被声明为返回<type>record</>，而不是指定任何特定列。这意味着
在调用查询中你必须指定预期列；
否则<productname>PostgreSQL</>不知道发生什么，这有个例子：


<programlisting>
SELECT *
    FROM dblink('dbname=mydb', 'select proname, prosrc from pg_proc')
      AS t1(proname name, prosrc text)
    WHERE proname LIKE 'bytea%';
</programlisting>
    <!--
    The <quote>alias</> part of the <literal>FROM</> clause must
    specify the column names and types that the function will return.
    (Specifying column names in an alias is actually standard SQL
    syntax, but specifying column types is a <productname>PostgreSQL</>
    extension.)  This allows the system to understand what
    <literal>*</> should expand to, and what <structname>proname</>
    in the <literal>WHERE</> clause refers to, in advance of trying
    to execute the function.  At run time, an error will be thrown
    if the actual query result from the remote database does not
    have the same number of columns shown in the <literal>FROM</> clause.
    The column names need not match, however, and <function>dblink</>
    does not insist on exact type matches either.  It will succeed
    so long as the returned data strings are valid input for the
    column type declared in the <literal>FROM</> clause.
-->
<literal>FROM</>子句的<quote>alias</>部分必须指定函数将要返回的列名和类型。
（在别名中指定列名实际上是标准SQL语法，但是指定列类型是<productname>PostgreSQL</>扩展。）
这允许系统理解<literal>*</>应该扩展到什么，以及在<literal>WHERE</>子句中<structname>proname</>
指向什么，提前尝试执行该函数。在运行时，如果远程数据库的实际查询结果没有<literal>FROM</>子句中显示
的相同列数，那么将抛出错误。列名不需要匹配，然而，<function>dblink</>
不坚持确切类型匹配。只要返回的数据字符串对于<literal>FROM</>子句中声明的
列类型是有效输入那么它将成功。

   </para>

  </refsect1>

  <refsect1>
   <!--
<title>Notes</title>
-->
<title>注意</title>

   
<para>
    <!--
    A convenient way to use <function>dblink</> with predetermined
    queries is to create a view.
    This allows the column type information to be buried in the view,
    instead of having to spell it out in every query.  For example,
    -->
预定义查询使用<function>dblink</>的一个便捷方式是创建视图。
这允许将列类型信息放在视图中，而不是在每个查询中拼出它。比如，


<programlisting>
CREATE VIEW myremote_pg_proc AS
  SELECT *
    FROM dblink('dbname=postgres', 'select proname, prosrc from pg_proc')
    AS t1(proname name, prosrc text);

SELECT * FROM myremote_pg_proc WHERE proname LIKE 'bytea%';
</programlisting></para>

  </refsect1>

  <refsect1>
   <!--
<title>Examples</title>
-->
<title>例子</title>

<screen>
SELECT * FROM dblink('dbname=postgres', 'select proname, prosrc from pg_proc')
  AS t1(proname name, prosrc text) WHERE proname LIKE 'bytea%';
  proname   |   prosrc
------------+------------
 byteacat   | byteacat
 byteaeq    | byteaeq
 bytealt    | bytealt
 byteale    | byteale
 byteagt    | byteagt
 byteage    | byteage
 byteane    | byteane
 byteacmp   | byteacmp
 bytealike  | bytealike
 byteanlike | byteanlike
 byteain    | byteain
 byteaout   | byteaout
(12 rows)

SELECT dblink_connect('dbname=postgres');
 dblink_connect
----------------
 OK
(1 row)

SELECT * FROM dblink('select proname, prosrc from pg_proc')
  AS t1(proname name, prosrc text) WHERE proname LIKE 'bytea%';
  proname   |   prosrc
------------+------------
 byteacat   | byteacat
 byteaeq    | byteaeq
 bytealt    | bytealt
 byteale    | byteale
 byteagt    | byteagt
 byteage    | byteage
 byteane    | byteane
 byteacmp   | byteacmp
 bytealike  | bytealike
 byteanlike | byteanlike
 byteain    | byteain
 byteaout   | byteaout
(12 rows)

SELECT dblink_connect('myconn', 'dbname=regression');
 dblink_connect
----------------
 OK
(1 row)

SELECT * FROM dblink('myconn', 'select proname, prosrc from pg_proc')
  AS t1(proname name, prosrc text) WHERE proname LIKE 'bytea%';
  proname   |   prosrc
------------+------------
 bytearecv  | bytearecv
 byteasend  | byteasend
 byteale    | byteale
 byteagt    | byteagt
 byteage    | byteage
 byteane    | byteane
 byteacmp   | byteacmp
 bytealike  | bytealike
 byteanlike | byteanlike
 byteacat   | byteacat
 byteaeq    | byteaeq
 bytealt    | bytealt
 byteain    | byteain
 byteaout   | byteaout
(14 rows)
</screen>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-EXEC">
  <refmeta>
   <refentrytitle>dblink_exec</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_exec</refname>
   <!--
   <refpurpose>executes a command in a remote database</refpurpose>
   -->
   <refpurpose>在远程数据库中执行命令</refpurpose>
  </refnamediv>

  <indexterm>
   <primary>dblink_exec</primary>
  </indexterm>

  <refsynopsisdiv>
<synopsis>
dblink_exec(text connname, text sql [, bool fail_on_error]) returns text
dblink_exec(text connstr, text sql [, bool fail_on_error]) returns text
dblink_exec(text sql [, bool fail_on_error]) returns text
</synopsis>
  </refsynopsisdiv>

  <refsect1>
  <!--
   <title>Description</title>
   -->
   <title>描述</title>

   <!--
<para>
    <function>dblink_exec</> executes a command (that is, any SQL statement
    that doesn't return rows) in a remote database.
   </para>
-->
<para>
      <function>dblink_exec</>在远程数据库中执行命令（即不返回行的任何SQL语句）。
</para>

   <!--
<para>
    When two <type>text</> arguments are given, the first one is first
    looked up as a persistent connection's name; if found, the command
    is executed on that connection.  If not found, the first argument
    is treated as a connection info string as for <function>dblink_connect</>,
    and the indicated connection is made just for the duration of this command.
   </para>
-->
<para>
    当给定两个<type>text</>参数时，第一个作为持久连接名称首先被查找；如果发现了，
那么在连接上执行该命令。如果没有发现，
那么第一个参数被看作<function>dblink_connect</>的连接信息字符串，
并且指定连接为了该命令的整个时间段。
</para>
  </refsect1>

  <refsect1>
  <!--
   <title>Arguments</title>
  -->
    <title>参数</title> 
   
   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <!--
<para>
       Name of the connection to use; omit this parameter to use the
       unnamed connection.
      </para>
-->
<para>
     要使用的连接名称；省略这个参数使用未命名连接。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>connstr</parameter></term>
     <listitem>
      <!--
<para>
       A connection info string, as previously described for
       <function>dblink_connect</>.
      </para>
-->
<para>
       连接信息字符串，如先前描述的<function>dblink_connect</>。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>sql</parameter></term>
     <listitem>
      <!--
<para>
       The SQL command that you wish to execute in the remote database,
       for example
       <literal>insert into foo values(0,'a','{"a0","b0","c0"}')</>.
      </para>
-->
<para>
     你希望在远程数据库中执行的SQL命令，
 比如<literal>insert into foo values(0,'a','{"a0","b0","c0"}')</>。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>fail_on_error</parameter></term>
     <listitem>
      <!--
<para>
       If true (the default when omitted) then an error thrown on the
       remote side of the connection causes an error to also be thrown
       locally. If false, the remote error is locally reported as a NOTICE,
       and the function's return value is set to <literal>ERROR</>.
      </para>
-->
<para>
      如果真（忽略时缺省）那么在连接的远程端抛出的错误也会导致本地抛出错误，
如果假，那么远程错误在本地作为NOTICE被报告，
并且函数的返回值设置为<literal>ERROR</>。
</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
  <!--
   <title>Return Value</title>
  -->
    <title>返回值</title>

   <!--
<para>
    Returns status, either the command's status string or <literal>ERROR</>.
   </para>
-->
<para>
     返回状态，该命令的状态字符串或者<literal>ERROR</>。
</para>
  </refsect1>

  <refsect1>
   <!--
<title>Examples</title>
-->
<title>例子</title>

<screen>
SELECT dblink_connect('dbname=dblink_test_standby');
 dblink_connect
----------------
 OK
(1 row)

SELECT dblink_exec('insert into foo values(21,''z'',''{"a0","b0","c0"}'');');
   dblink_exec
-----------------
 INSERT 943366 1
(1 row)

SELECT dblink_connect('myconn', 'dbname=regression');
 dblink_connect
----------------
 OK
(1 row)

SELECT dblink_exec('myconn', 'insert into foo values(21,''z'',''{"a0","b0","c0"}'');');
   dblink_exec
------------------
 INSERT 6432584 1
(1 row)

SELECT dblink_exec('myconn', 'insert into pg_class values (''foo'')',false);
NOTICE:  sql error
DETAIL:  ERROR:  null value in column "relnamespace" violates not-null constraint

 dblink_exec
-------------
 ERROR
(1 row)
</screen>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-OPEN">
  <refmeta>
   <refentrytitle>dblink_open</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_open</refname>
   <!--
   <refpurpose>opens a cursor in a remote database</refpurpose>
   -->
    <refpurpose>打开远程数据库中的游标</refpurpose>
  </refnamediv>

  <indexterm>
   <primary>dblink_open</primary>
  </indexterm>

  <refsynopsisdiv>
<synopsis>
dblink_open(text cursorname, text sql [, bool fail_on_error]) returns text
dblink_open(text connname, text cursorname, text sql [, bool fail_on_error]) returns text
</synopsis>
  </refsynopsisdiv>

  <refsect1>
  <!--
   <title>Description</title>
  -->
   <title>描述</title>

   <!--
<para>
    <function>dblink_open()</> opens a cursor in a remote database.
    The cursor can subsequently be manipulated with
    <function>dblink_fetch()</> and <function>dblink_close()</>.
   </para>
-->
<para>
     <function>dblink_open()</>打开了远程数据库中的游标。
 游标可以随后使用<function>dblink_fetch()</>和<function>dblink_close()</>
 被操作。
 
</para>
  </refsect1>

  <refsect1>
  <!--
   <title>Arguments</title>
  -->
    <title>参数</title>

   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <!--
<para>
       Name of the connection to use; omit this parameter to use the
       unnamed connection.
      </para>
-->
<para>
      要使用的连接名称；省略这个参数使用未命名连接。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>cursorname</parameter></term>
     <listitem>
      <!--
<para>
       The name to assign to this cursor.
      </para>
-->
<para>
      分配给这个游标的名称。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>sql</parameter></term>
     <listitem>
      <!--
<para>
       The <command>SELECT</> statement that you wish to execute in the remote
       database, for example <literal>select * from pg_class</>.
      </para>
-->
<para>
     你希望在远程数据库中执行的<command>SELECT</>语句，比如<literal>select * from pg_class</>。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>fail_on_error</parameter></term>
     <listitem>
      <!--
<para>
       If true (the default when omitted) then an error thrown on the
       remote side of the connection causes an error to also be thrown
       locally. If false, the remote error is locally reported as a NOTICE,
       and the function's return value is set to <literal>ERROR</>.
      </para>
-->
<para>
      如果真（忽略时缺省）那么在连接的远程端抛出的错误也会导致本地抛出错误，
  如果假，那么远程错误在本地作为NOTICE被报告，
  并且函数的返回值设置为<literal>ERROR</>。
</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
  <!--
   <title>Return Value</title>
  -->
    <title>返回值</title>

   <!--
<para>
    Returns status, either <literal>OK</> or <literal>ERROR</>.
   </para>
-->
<para>
     返回状态，<literal>OK</>或者<literal>ERROR</>。
</para>
  </refsect1>

  <refsect1>
   <!--
<title>Notes</title>
-->
<title>注意</title>

   <!--
<para>
    Since a cursor can only persist within a transaction,
    <function>dblink_open</> starts an explicit transaction block
    (<command>BEGIN</>) on the remote side, if the remote side was
    not already within a transaction.  This transaction will be
    closed again when the matching <function>dblink_close</> is
    executed.  Note that if
    you use <function>dblink_exec</> to change data between
    <function>dblink_open</> and <function>dblink_close</>,
    and then an error occurs or you use <function>dblink_disconnect</> before
    <function>dblink_close</>, your change <emphasis>will be
    lost</> because the transaction will be aborted.
   </para>
-->
<para>
     因为游标只能停留在事务块中，如果远程端已经不在事务中，
 那么<function>dblink_open</>在远程端开始显式事务块（<command>BEGIN</>），
 当执行匹配的<function>dblink_close</>时，则该事务将再次被关闭。
 注意如果在<function>dblink_open</>和<function>dblink_close</>之间使用
 <function>dblink_exec</>改变数据，那么会产生错误或者你在<function>dblink_close</>之前使用
 <function>dblink_disconnect</>，你的改变<emphasis>将丢失</>，因为终止了事务。
 
</para>
  </refsect1>

  <refsect1>
   <!--
<title>Examples</title>
-->
<title>例子</title>

<screen>
SELECT dblink_connect('dbname=postgres');
 dblink_connect
----------------
 OK
(1 row)

SELECT dblink_open('foo', 'select proname, prosrc from pg_proc');
 dblink_open
-------------
 OK
(1 row)
</screen>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-FETCH">
  <refmeta>
   <refentrytitle>dblink_fetch</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_fetch</refname>
   <!--
   <refpurpose>returns rows from an open cursor in a remote database</refpurpose>
   -->
   <refpurpose>从远程数据库中打开的游标中返回行</refpurpose>
  </refnamediv>

  <indexterm>
   <primary>dblink_fetch</primary>
  </indexterm>

  <refsynopsisdiv>
<synopsis>
dblink_fetch(text cursorname, int howmany [, bool fail_on_error]) returns setof record
dblink_fetch(text connname, text cursorname, int howmany [, bool fail_on_error]) returns setof record
</synopsis>
  </refsynopsisdiv>

  <refsect1>
  <!--
   <title>Description</title>
  -->
   <title>描述</title>

   <!--
<para>
    <function>dblink_fetch</> fetches rows from a cursor previously
    established by <function>dblink_open</>.
   </para>
-->
<para>
     <function>dblink_fetch</>通过<function>dblink_open</>预先建立的游标中抓取行。
</para>
  </refsect1>

  <refsect1>
  <!--
   <title>Arguments</title>
  -->
   <title>参数</title>
  
  
   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <!--
<para>
       Name of the connection to use; omit this parameter to use the
       unnamed connection.
      </para>
-->
<para>
      要使用的连接名称；省略这个参数使用未命名连接。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>cursorname</parameter></term>
     <listitem>
      <!--
<para>
       The name of the cursor to fetch from.
      </para>
-->
<para>
       获取游标名称。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>howmany</parameter></term>
     <listitem>
      <!--
<para>
       The maximum number of rows to retrieve. The next <parameter>howmany</>
       rows are fetched, starting at the current cursor position, moving
       forward. Once the cursor has reached its end, no more rows are produced.
      </para>
-->
<para>
      要检索的最大行数。抓取下一个<parameter>howmany</>行，
  从当前光标位置开始，向前移动。一旦游标已经到达末尾，不会产生更多行。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>fail_on_error</parameter></term>
     <listitem>
      <!--
<para>
       If true (the default when omitted) then an error thrown on the
       remote side of the connection causes an error to also be thrown
       locally. If false, the remote error is locally reported as a NOTICE,
       and the function returns no rows.
      </para>
-->
<para>
      如果真（忽略时缺省）那么在连接的远程端抛出的错误也会导致本地抛出错误，
如果假，那么远程错误在本地作为NOTICE被报告，
并且函数没有返回行。
</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
  <!--
   <title>Return Value</title>
  -->
   <title>返回值</title>

   <!--
<para>
    The function returns the row(s) fetched from the cursor.  To use this
    function, you will need to specify the expected set of columns,
    as previously discussed for <function>dblink</>.
   </para>
-->
<para>
    该函数返回从游标中抓取的行。要使用该函数，你将需要
指定预期的字段集，正如前面讨论的<function>dblink</>。
</para>
  </refsect1>

  <refsect1>
   <!--
<title>Notes</title>
-->
<title>注意</title>

   <!--
<para>
    On a mismatch between the number of return columns specified in the
    <literal>FROM</> clause, and the actual number of columns returned by the
    remote cursor, an error will be thrown. In this event, the remote cursor
    is still advanced by as many rows as it would have been if the error had
    not occurred.  The same is true for any other error occurring in the local
    query after the remote <command>FETCH</> has been done.
   </para>
-->
<para>
    在<literal>FROM</>子句上指定的返回列数之间的不匹配，并且通过远程游标返回实际列数，将抛出一个错误。在这种情况下，远程游标仍然按照没有产生错误时一样的行增长。
同样的在远程<command>FETCH</>执行后本地查询产生的任何其他错误也是这样。
</para>
  </refsect1>

  <refsect1>
   <!--
<title>Examples</title>
-->
<title>例子</title>

<screen>
SELECT dblink_connect('dbname=postgres');
 dblink_connect
----------------
 OK
(1 row)

SELECT dblink_open('foo', 'select proname, prosrc from pg_proc where proname like ''bytea%''');
 dblink_open
-------------
 OK
(1 row)

SELECT * FROM dblink_fetch('foo', 5) AS (funcname name, source text);
 funcname |  source
----------+----------
 byteacat | byteacat
 byteacmp | byteacmp
 byteaeq  | byteaeq
 byteage  | byteage
 byteagt  | byteagt
(5 rows)

SELECT * FROM dblink_fetch('foo', 5) AS (funcname name, source text);
 funcname  |  source
-----------+-----------
 byteain   | byteain
 byteale   | byteale
 bytealike | bytealike
 bytealt   | bytealt
 byteane   | byteane
(5 rows)

SELECT * FROM dblink_fetch('foo', 5) AS (funcname name, source text);
  funcname  |   source
------------+------------
 byteanlike | byteanlike
 byteaout   | byteaout
(2 rows)

SELECT * FROM dblink_fetch('foo', 5) AS (funcname name, source text);
 funcname | source
----------+--------
(0 rows)
</screen>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-CLOSE">
  <refmeta>
   <refentrytitle>dblink_close</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_close</refname>
   <!--
   <refpurpose>closes a cursor in a remote database</refpurpose>
   -->
    <refpurpose>关闭远程数据库中的游标</refpurpose>
  </refnamediv>

  <indexterm>
   <primary>dblink_close</primary>
  </indexterm>

  <refsynopsisdiv>
<synopsis>
dblink_close(text cursorname [, bool fail_on_error]) returns text
dblink_close(text connname, text cursorname [, bool fail_on_error]) returns text
</synopsis>
  </refsynopsisdiv>

  <refsect1>
  <!--
   <title>Description</title>
  -->
   <title>描述</title>

   <!--
<para>
    <function>dblink_close</> closes a cursor previously opened with
    <function>dblink_open</>.
   </para>
-->
<para>
    <function>dblink_close</>关闭先前使用<function>dblink_open</>打开的游标。
</para>
  </refsect1>

  <refsect1>
  <!--
   <title>Arguments</title>
  -->
   <title>参数</title>

   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <!--
<para>
       Name of the connection to use; omit this parameter to use the
       unnamed connection.
      </para>
-->
<para>
      要使用的连接名称；省略这个参数使用未命名连接。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>cursorname</parameter></term>
     <listitem>
      <!--
<para>
       The name of the cursor to close.
      </para>
-->
<para>
     关闭的游标名称。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>fail_on_error</parameter></term>
     <listitem>
      <!--
<para>
       If true (the default when omitted) then an error thrown on the
       remote side of the connection causes an error to also be thrown
       locally. If false, the remote error is locally reported as a NOTICE,
       and the function's return value is set to <literal>ERROR</>.
      </para>
-->
<para>
      如果真（忽略时缺省）那么在连接的远程端抛出的错误也会导致本地抛出错误，
  如果假，那么远程错误在本地作为NOTICE被报告，
  并且函数的返回值被设置为<literal>ERROR</>。
</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
  <!--
   <title>Return Value</title>
  -->
    <title>返回值</title>

   <!--
<para>
    Returns status, either <literal>OK</> or <literal>ERROR</>.
   </para>
-->
<para>
    返回状态，<literal>OK</>或者<literal>ERROR</>。
</para>
  </refsect1>

  <refsect1>
   <!--
<title>Notes</title>
-->
<title>注意</title>

   <!--
<para>
    If <function>dblink_open</> started an explicit transaction block,
    and this is the last remaining open cursor in this connection,
    <function>dblink_close</> will issue the matching <command>COMMIT</>.
   </para>
-->
<para>
    如果<function>dblink_open</>启动了一个显式事务块，并且这是在该连接中最后保持打开的游标。
<function>dblink_close</>将提交匹配的<command>COMMIT</>。
</para>
  </refsect1>

  <refsect1>
   <!--
<title>Examples</title>
-->
<title>例子</title>

<screen>
SELECT dblink_connect('dbname=postgres');
 dblink_connect
----------------
 OK
(1 row)

SELECT dblink_open('foo', 'select proname, prosrc from pg_proc');
 dblink_open
-------------
 OK
(1 row)

SELECT dblink_close('foo');
 dblink_close
--------------
 OK
(1 row)
</screen>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-GET-CONNECTIONS">
  <refmeta>
   <refentrytitle>dblink_get_connections</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_get_connections</refname>
   <!--
   <refpurpose>returns the names of all open named dblink connections</refpurpose>
   -->
   <refpurpose>返回所有打开命名dblink连接的名字</refpurpose>
  </refnamediv>

  <indexterm>
   <primary>dblink_get_connections</primary>
  </indexterm>

  <refsynopsisdiv>
<synopsis>
dblink_get_connections() returns text[]
</synopsis>
  </refsynopsisdiv>

  <refsect1>
  <!--
   <title>Description</title>
  -->
    <title>描述</title>

   <!--
<para>
    <function>dblink_get_connections</> returns an array of the names
    of all open named <filename>dblink</> connections.
   </para>
-->
<para>
    <function>dblink_get_connections</>返回所有打开已命名<filename>dblink</>连接的名字数组。
</para>
  </refsect1>

  <refsect1>
  <!--
   <title>Return Value</title>
  -->
   <title>返回值</title>

   <!--
<para>Returns a text array of connection names, or NULL if none.</para>
-->
<para>
     返回连接名称的文本数组，如果没有的话返回NULL。
</para>
  </refsect1>

  <refsect1>
   <!--
<title>Examples</title>
-->
<title>例子</title>

<programlisting>
SELECT dblink_get_connections();
</programlisting>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-ERROR-MESSAGE">
  <refmeta>
   <refentrytitle>dblink_error_message</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_error_message</refname>
   <!--
   <refpurpose>gets last error message on the named connection</refpurpose>
   -->
   <refpurpose>获取命名连接上的最后错误信息</refpurpose>
   
   
  </refnamediv>

  <indexterm>
   <primary>dblink_error_message</primary>
  </indexterm>

  <refsynopsisdiv>
<synopsis>
dblink_error_message(text connname) returns text
</synopsis>
  </refsynopsisdiv>

  <refsect1>
  <!--
   <title>Description</title>
  -->
    <title>描述</title>

   <!--
<para>
    <function>dblink_error_message</> fetches the most recent remote
    error message for a given connection.
   </para>
-->
<para>
     <function>dblink_error_message</>抓取给定连接的最新远程错误信息。
</para>
  </refsect1>

  <refsect1>
  <!--
   <title>Arguments</title>
  -->
    <title>参数</title>

   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <!--
<para>
       Name of the connection to use.
      </para>
-->
<para>
    使用连接的名字。
</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
  <!--
   <title>Return Value</title>
  -->
    <title>返回值</title>

   <!--
<para>
    Returns last error message, or an empty string if there has been
    no error in this connection.
   </para>
-->
<para>
    返回最后错误信息，或者如果在这个连接中没有错误，则返回空字符串。
</para>
  </refsect1>

  <refsect1>
   <!--
<title>Examples</title>
-->
<title>例子</title>

<programlisting>
SELECT dblink_error_message('dtest1');
</programlisting>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-SEND-QUERY">
  <refmeta>
   <refentrytitle>dblink_send_query</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_send_query</refname>
   <!--
   <refpurpose>sends an async query to a remote database</refpurpose>
   -->
   <refpurpose>发送一个异步查询到远程数据库</refpurpose>
  </refnamediv>

  <indexterm>
   <primary>dblink_send_query</primary>
  </indexterm>

  <refsynopsisdiv>
<synopsis>
dblink_send_query(text connname, text sql) returns int
</synopsis>
  </refsynopsisdiv>

  <refsect1>
  <!--
   <title>Description</title>
  -->
   <title>描述</title>

   <!--
<para>
    <function>dblink_send_query</> sends a query to be executed
    asynchronously, that is, without immediately waiting for the result.
    There must not be an async query already in progress on the
    connection.
   </para>
-->
<para>
    <function>dblink_send_query</>发送异步执行的查询，也就是说，没有立即等待结果。
在连接进行的过程中没有一个异步查询。
</para>

   <!--
<para>
    After successfully dispatching an async query, completion status
    can be checked with <function>dblink_is_busy</>, and the results
    are ultimately collected with <function>dblink_get_result</>.
    It is also possible to attempt to cancel an active async query
    using <function>dblink_cancel_query</>.
   </para>
-->
<para>
    在成功调度异步查询之后，完成状态可以用<function>dblink_is_busy</>被检查，
结果最终使用<function>dblink_get_result</>收集。
尝试使用<function>dblink_cancel_query</>取消活跃的异步查询是可能的。
</para>
  </refsect1>

  <refsect1>
  <!--
   <title>Arguments</title>
  -->
   <title>参数</title>

   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <!--
<para>
       Name of the connection to use.
      </para>
-->
<para>
      使用的连接名字。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>sql</parameter></term>
     <listitem>
      <!--
<para>
       The SQL statement that you wish to execute in the remote database,
       for example <literal>select * from pg_class</>.
      </para>
-->
<para>
     你希望在远程数据库中执行的SQL语句，比如<literal>select * from pg_class</>。
</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
  <!--
   <title>Return Value</title>
  -->
    <title>返回值</title>

   <!--
<para>
    Returns 1 if the query was successfully dispatched, 0 otherwise.
   </para>
-->
<para>
    如果查询被成功调度，则返回1。否则返回0。
</para>
  </refsect1>

  <refsect1>
   <!--
<title>Examples</title>
-->
<title>例子</title>

<programlisting>
SELECT dblink_send_query('dtest1', 'SELECT * FROM foo WHERE f1 &lt; 3');
</programlisting>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-IS-BUSY">
  <refmeta>
   <refentrytitle>dblink_is_busy</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_is_busy</refname>
   <!--
   <refpurpose>checks if connection is busy with an async query</refpurpose>
   -->
   <refpurpose>检查是否连接忙于异步查询</refpurpose>
  </refnamediv>

  <indexterm>
   <primary>dblink_is_busy</primary>
  </indexterm>

  <refsynopsisdiv>
<synopsis>
dblink_is_busy(text connname) returns int
</synopsis>
  </refsynopsisdiv>

  <refsect1>
  <!--
   <title>Description</title>
  -->
   <title>描述</title>
  
   <!--
<para>
    <function>dblink_is_busy</> tests whether an async query is in progress.
   </para>
-->
<para>
    <function>dblink_is_busy</>测试是否异步查询在进行中。
</para>
  </refsect1>

  <refsect1>
  <!--
   <title>Arguments</title>
  -->
     <title>参数</title>

   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <!--
<para>
       Name of the connection to check.
      </para>
-->
<para>
      检查连接的名字。
</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
  <!--
   <title>Return Value</title>
  -->
     <title>返回值</title>

   <!--
<para>
    Returns 1 if connection is busy, 0 if it is not busy.
    If this function returns 0, it is guaranteed that
    <function>dblink_get_result</> will not block.
   </para>
-->
<para>
    如果连接繁忙，则返回1，如果不繁忙，则返回0。
如果该函数返回0，那么保证<function>dblink_get_result</>将不阻塞。
</para>
  </refsect1>

  <refsect1>
   <!--
<title>Examples</title>
-->
<title>例子</title>

<programlisting>
SELECT dblink_is_busy('dtest1');
</programlisting>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-GET-NOTIFY">
  <refmeta>
   <refentrytitle>dblink_get_notify</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_get_notify</refname>
   <!--
   <refpurpose>retrieve async notifications on a connection</refpurpose>
   -->
   <refpurpose>在连接上检索异步通知</refpurpose>
   
  </refnamediv>

  <indexterm>
   <primary>dblink_get_notify</primary>
  </indexterm>

  <refsynopsisdiv>
<synopsis>
dblink_get_notify() returns setof (notify_name text, be_pid int, extra text)
dblink_get_notify(text connname) returns setof (notify_name text, be_pid int, extra text)
</synopsis>
  </refsynopsisdiv>

  <refsect1>
  <!--
   <title>Description</title>
  -->
    <title>描述</title>

   <!--
<para>
    <function>dblink_get_notify</> retrieves notifications on either
    the unnamed connection, or on a named connection if specified.
    To receive notifications via dblink, <function>LISTEN</> must
    first be issued, using <function>dblink_exec</>.
    For details see <xref linkend="sql-listen"> and <xref linkend="sql-notify">.
   </para>
-->
<para>
    <function>dblink_get_notify</>在未命名连接上检索通知，或者如果指定了则在命名的连接上。
为了通过dblink接收通知，必须首先使用<function>dblink_exec</>发出<function>LISTEN</>，
更多详情请参阅<xref linkend="sql-listen">和<xref linkend="sql-notify">。
</para>

  </refsect1>

  <refsect1>
  <!--
   <title>Arguments</title>
  -->
    <title>参数</title>

   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <!--
<para>
       The name of a named connection to get notifications on.
      </para>
-->
<para>
    获取通知的已命名连接名字。
</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
  <!--
   <title>Return Value</title>
  -->
   <title>返回值</title>
   
    <!--
<para>Returns <type>setof (notify_name text, be_pid int, extra text)</type>, or an empty set if none.</para>
-->
<para>
    返回<type>setof (notify_name text, be_pid int, extra text)</type>，如果没有则返回空集。
</para>
  </refsect1>

  <refsect1>
   <!--
<title>Examples</title>
-->
<title>例子</title>

<screen>
SELECT dblink_exec('LISTEN virtual');
 dblink_exec 
-------------
 LISTEN
(1 row)

SELECT * FROM dblink_get_notify();
 notify_name | be_pid | extra
-------------+--------+-------
(0 rows)

NOTIFY virtual;
NOTIFY

SELECT * FROM dblink_get_notify();
 notify_name | be_pid | extra
-------------+--------+-------
 virtual     |   1229 |
(1 row)
</screen>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-GET-RESULT">
  <refmeta>
   <refentrytitle>dblink_get_result</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_get_result</refname>
   <!--
   <refpurpose>gets an async query result</refpurpose>
   -->
    <refpurpose>获得异步查询结果</refpurpose>
  </refnamediv>

  <indexterm>
   <primary>dblink_get_result</primary>
  </indexterm>

  <refsynopsisdiv>
<synopsis>
dblink_get_result(text connname [, bool fail_on_error]) returns setof record
</synopsis>
  </refsynopsisdiv>

  <refsect1>
  <!--
   <title>Description</title>
  -->
    <title>描述</title>

   <!--
<para>
    <function>dblink_get_result</> collects the results of an
    asynchronous query previously sent with <function>dblink_send_query</>.
    If the query is not already completed, <function>dblink_get_result</>
    will wait until it is.
   </para>
-->
<para>
    <function>dblink_get_result</>收集先前使用<function>dblink_send_query</>发送的异步查询结果。
    如果还没完成查询，那么<function>dblink_get_result</>将等待它。
</para>
  </refsect1>

  <refsect1>
  <!--
   <title>Arguments</title>
  -->
     <title>参数</title>

   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <!--
<para>
       Name of the connection to use.
      </para>
-->
<para>
       要使用的连接名字。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>fail_on_error</parameter></term>
     <listitem>
      <!--
<para>
       If true (the default when omitted) then an error thrown on the
       remote side of the connection causes an error to also be thrown
       locally. If false, the remote error is locally reported as a NOTICE,
       and the function returns no rows.
      </para>
-->
<para>
        如果真（忽略时缺省）那么在连接的远程端抛出的错误也会导致本地抛出错误，
如果假，那么远程错误在本地作为NOTICE被报告，
并且函数没有返回行。
</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
  <!--
   <title>Return Value</title>
  -->
  <title>返回值</title>
  
   <!--
<para>
    For an async query (that is, a SQL statement returning rows),
    the function returns the row(s) produced by the query.  To use this
    function, you will need to specify the expected set of columns,
    as previously discussed for <function>dblink</>.
   </para>
-->
<para>
   一个异步查询（也就是说，返回行的SQL语句），
   该函数返回通过查询产生的行。要使用该函数，你将需要指定预期的字段集，
   正如前面讨论的<function>dblink</>。
</para>

   <!--
<para>
    For an async command (that is, a SQL statement not returning rows),
    the function returns a single row with a single text column containing
    the command's status string.  It is still necessary to specify that
    the result will have a single text column in the calling <literal>FROM</>
    clause.
   </para>
-->
<para>
    一个异步命令（也就是说，没有返回行的SQL语句），
该函数返回带有该命令的状态字符串的单文本列的单一行。
声明结果将在调用<literal>FROM</>子句中有单一文本列。
</para>
  </refsect1>

  <refsect1>
   <!--
<title>Notes</title>
-->
<title>注意</title>

   <!--
<para>
    This function <emphasis>must</> be called if
    <function>dblink_send_query</> returned 1.
    It must be called once for each query
    sent, and one additional time to obtain an empty set result,
    before the connection can be used again.
   </para>
-->
<para>
    如果<function>dblink_send_query</>返回1，那么<emphasis>必须</>调用该函数。
它必须被每一个查询调用，并且一个额外时间来获取空集结果，
连接之前可以再次使用。

</para>

   <!--
<para>
    When using <function>dblink_send_query</> and
    <function>dblink_get_result</>, <application>dblink</> fetches the entire
    remote query result before returning any of it to the local query
    processor.  If the query returns a large number of rows, this can result
    in transient memory bloat in the local session.  It may be better to open
    such a query as a cursor with <function>dblink_open</> and then fetch a
    manageable number of rows at a time.  Alternatively, use plain
    <function>dblink()</>, which avoids memory bloat by spooling large result
    sets to disk.
   </para>
-->
<para>
    当在返回它到本地查询处理器之前使用<function>dblink_send_query</>和
    <function>dblink_get_result</>, <application>dblink</>抓取
整个远程查询结果。如果查询返回大量行，那么
这可以导致本地会话短暂内存膨胀。它可以更好的打开这个查询比如使用<function>dblink_open</>的游标，
然后抓取每次可管理的行数。另外，使用普通的<function>dblink()</>通过多任务缓冲处理大量结果集到磁盘避免内存膨胀。
</para>
  </refsect1>

  <refsect1>
   <!--
<title>Examples</title>
-->
<title>例子</title>

<screen>
contrib_regression=# SELECT dblink_connect('dtest1', 'dbname=contrib_regression');
 dblink_connect
----------------
 OK
(1 row)

contrib_regression=# SELECT * FROM
contrib_regression-# dblink_send_query('dtest1', 'select * from foo where f1 &lt; 3') AS t1;
 t1
----
  1
(1 row)

contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text, f3 text[]);
 f1 | f2 |     f3
----+----+------------
  0 | a  | {a0,b0,c0}
  1 | b  | {a1,b1,c1}
  2 | c  | {a2,b2,c2}
(3 rows)

contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text, f3 text[]);
 f1 | f2 | f3
----+----+----
(0 rows)

contrib_regression=# SELECT * FROM
contrib_regression-# dblink_send_query('dtest1', 'select * from foo where f1 &lt; 3; select * from foo where f1 &gt; 6') AS t1;
 t1
----
  1
(1 row)

contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text, f3 text[]);
 f1 | f2 |     f3
----+----+------------
  0 | a  | {a0,b0,c0}
  1 | b  | {a1,b1,c1}
  2 | c  | {a2,b2,c2}
(3 rows)

contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text, f3 text[]);
 f1 | f2 |      f3
----+----+---------------
  7 | h  | {a7,b7,c7}
  8 | i  | {a8,b8,c8}
  9 | j  | {a9,b9,c9}
 10 | k  | {a10,b10,c10}
(4 rows)

contrib_regression=# SELECT * FROM dblink_get_result('dtest1') AS t1(f1 int, f2 text, f3 text[]);
 f1 | f2 | f3
----+----+----
(0 rows)
</screen>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-CANCEL-QUERY">
  <refmeta>
   <refentrytitle>dblink_cancel_query</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_cancel_query</refname>
   <!--
   <refpurpose>cancels any active query on the named connection</refpurpose>
   -->
   <refpurpose>取消在已经命名连接上的任何活跃查询</refpurpose>
  </refnamediv>

  <indexterm>
   <primary>dblink_cancel_query</primary>
  </indexterm>

  <refsynopsisdiv>
<synopsis>
dblink_cancel_query(text connname) returns text
</synopsis>
  </refsynopsisdiv>

  <refsect1>
  <!--
   <title>Description</title>
  -->
    <title>描述</title>

   <!--
<para>
    <function>dblink_cancel_query</> attempts to cancel any query that
    is in progress on the named connection.  Note that this is not
    certain to succeed (since, for example, the remote query might
    already have finished).  A cancel request simply improves the
    odds that the query will fail soon.  You must still complete the
    normal query protocol, for example by calling
    <function>dblink_get_result</>.
   </para>
-->
<para>
    <function>dblink_cancel_query</>尝试取消在已命名连接上进行的任何查询。
注意这不一定成功（因为，比如远程查询可能已经完成）。
取消查询仅仅提高了查询将失败的可能性。你还必须完成正常查询协议，比如
通过调用<function>dblink_get_result</>。
</para>
  </refsect1>

  <refsect1>
  <!--
   <title>Arguments</title>
  -->
    <title>参数</title>

   <variablelist>
    <varlistentry>
     <term><parameter>conname</parameter></term>
     <listitem>
      <!--
<para>
       Name of the connection to use.
      </para>
-->
<para>
      使用连接名称。
</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
  <!--
   <title>Return Value</title>
  -->
    <title>返回值</title>

   <!--
<para>
    Returns <literal>OK</> if the cancel request has been sent, or
    the text of an error message on failure.
   </para>
-->
<para>
    如果已经发送取消请求，那么返回<literal>OK</>，或者失败的错误消息文本。
</para>
  </refsect1>

  <refsect1>
   <!--
<title>Examples</title>
-->
<title>例子</title>

<programlisting>
SELECT dblink_cancel_query('dtest1');
</programlisting>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-GET-PKEY">
  <refmeta>
   <refentrytitle>dblink_get_pkey</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_get_pkey</refname>
   <!--
   <refpurpose>returns the positions and field names of a relation's
    primary key fields
   </refpurpose>
   -->
   <refpurpose>
     返回位置和关系的主键字段的字段名字
   </refpurpose>
   
  </refnamediv>

  <indexterm>
   <primary>dblink_get_pkey</primary>
  </indexterm>

  <refsynopsisdiv>
<synopsis>
dblink_get_pkey(text relname) returns setof dblink_pkey_results
</synopsis>
  </refsynopsisdiv>

  <refsect1>
  <!--
   <title>Description</title>
  -->
    <title>描述</title>

   <!--
<para>
    <function>dblink_get_pkey</> provides information about the primary
    key of a relation in the local database.  This is sometimes useful
    in generating queries to be sent to remote databases.
   </para>
-->
<para>
    <function>dblink_get_pkey</>提供在本地数据库中关系的主键的信息。
有时在生成被发送到远程数据库的查询中有用。
</para>
  </refsect1>

  <refsect1>
  <!--
   <title>Arguments</title>
   -->
    <title>参数</title>

   <variablelist>
    <varlistentry>
     <term><parameter>relname</parameter></term>
     <listitem>
      <!--
<para>
       Name of a local relation, for example <literal>foo</> or
       <literal>myschema.mytab</>.  Include double quotes if the
       name is mixed-case or contains special characters, for
       example <literal>"FooBar"</>; without quotes, the string
       will be folded to lower case.
      </para>
-->
<para>
     本地关系名字，比如<literal>foo</>或者
       <literal>myschema.mytab</>。如果名字是混合情况下或者包含特殊字符，那么包含双引号，
   比如<literal>"FooBar"</>；没有引号，则字符串被折叠成小写字母。
</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
  <!--
   <title>Return Value</title>
  -->
   <title>返回值</title> 
  
   
<para>
    <!--
    Returns one row for each primary key field, or no rows if the relation
    has no primary key.  The result row type is defined as
    -->
为每个主键字段返回一行，如果关系没有主键，那么不返回行。结果行类型被定义为

<programlisting>
CREATE TYPE dblink_pkey_results AS (position int, colname text);
</programlisting>
    <!--
    The <literal>position</> column simply runs from 1 to <replaceable>N</>;
    it is the number of the field within the primary key, not the number
    within the table's columns.
-->
<literal>position</>列简单的从1到<replaceable>N</>运行；
它是主键内的字段数，而不是表的列数。
   </para>

  </refsect1>

  <refsect1>
   <!--
<title>Examples</title>
-->
<title>例子</title>

<screen>
CREATE TABLE foobar (
    f1 int,
    f2 int,
    f3 int,
    PRIMARY KEY (f1, f2, f3)
);
CREATE TABLE

SELECT * FROM dblink_get_pkey('foobar');
 position | colname
----------+---------
        1 | f1
        2 | f2
        3 | f3
(3 rows)
</screen>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-BUILD-SQL-INSERT">
  <refmeta>
   <refentrytitle>dblink_build_sql_insert</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_build_sql_insert</refname>
   <!--
   <refpurpose>
    builds an INSERT statement using a local tuple, replacing the
    primary key field values with alternative supplied values
   </refpurpose>
   -->
   <refpurpose>
    使用本地元组建立INSERT语句，使用可选的已提供的值替换主键字段
   </refpurpose>
   
   
  </refnamediv>

  <indexterm>
   <primary>dblink_build_sql_insert</primary>
  </indexterm>

  <refsynopsisdiv>
<synopsis>
dblink_build_sql_insert(text relname,
                        int2vector primary_key_attnums,
                        integer num_primary_key_atts,
                        text[] src_pk_att_vals_array,
                        text[] tgt_pk_att_vals_array) returns text
</synopsis>
  </refsynopsisdiv>

  <refsect1>
  <!--
   <title>Description</title>
  -->
    <title>描述</title>

   <!--
<para>
    <function>dblink_build_sql_insert</> can be useful in doing selective
    replication of a local table to a remote database.  It selects a row
    from the local table based on primary key, and then builds a SQL
    <command>INSERT</> command that will duplicate that row, but with
    the primary key values replaced by the values in the last argument.
    (To make an exact copy of the row, just specify the same values for
    the last two arguments.)
   </para>
-->
<para>
    <function>dblink_build_sql_insert</>可以用于执行远程数据库本地表的选择行复制。
它从基于主键的本地表选择行，然后建立一个SQL <command>INSERT</>命令复制该行，
但是随着主键值被最后参数中的值替换。
（为了准确拷贝行，请为最后两个参数指定同一值）。
</para>
  </refsect1>

  <refsect1>
  <!--
   <title>Arguments</title>
  -->
    <title>参数</title>

   <variablelist>
    <varlistentry>
     <term><parameter>relname</parameter></term>
     <listitem>
      <!--
<para>
       Name of a local relation, for example <literal>foo</> or
       <literal>myschema.mytab</>.  Include double quotes if the
       name is mixed-case or contains special characters, for
       example <literal>"FooBar"</>; without quotes, the string
       will be folded to lower case.
      </para>
-->
<para>
      本地关系名称，比如<literal>foo</>或者
       <literal>myschema.mytab</>。如果名字是混合情况下或者包含特殊字符，那么包含双引号，
   比如<literal>"FooBar"</>；没有引号，则字符串被折叠成小写字母。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>primary_key_attnums</parameter></term>
     <listitem>
      <!--
<para>
       Attribute numbers (1-based) of the primary key fields,
       for example <literal>1 2</>.
      </para>
-->
<para>
     主键字段的属性数量（1维），比如<literal>1 2</>。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>num_primary_key_atts</parameter></term>
     <listitem>
      <!--
<para>
       The number of primary key fields.
      </para>
-->
<para>
     主键字段数。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>src_pk_att_vals_array</parameter></term>
     <listitem>
      <!--
<para>
       Values of the primary key fields to be used to look up the
       local tuple.  Each field is represented in text form.
       An error is thrown if there is no local row with these
       primary key values.
      </para>
-->
<para>
       主键字段值用于查找本地元组。每个字段用文本形式表示。
   如果在这些主键值中没有本地行，那么抛出错误。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>tgt_pk_att_vals_array</parameter></term>
     <listitem>
      <!--
<para>
       Values of the primary key fields to be placed in the resulting
       <command>INSERT</> command.  Each field is represented in text form.
      </para>
-->
<para>
     主键字段值被放置在<command>INSERT</>命令中。每个字段用文本形式表示。
</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
  <!--
   <title>Return Value</title>
   -->
   <title>返回值</title>

   <!--
<para>Returns the requested SQL statement as text.</para>
-->
<para>
    作为文本返回所请求的SQL语句。
</para>
  </refsect1>

  <refsect1>
   <!--
<title>Notes</title>
-->
<title>注意</title>

   <!--
<para>
    As of <productname>PostgreSQL</> 9.0, the attribute numbers in
    <parameter>primary_key_attnums</parameter> are interpreted as logical
    column numbers, corresponding to the column's position in
    <literal>SELECT * FROM relname</>.  Previous versions interpreted the
    numbers as physical column positions.  There is a difference if any
    column(s) to the left of the indicated column have been dropped during
    the lifetime of the table.
   </para>
-->
<para>
     <productname>PostgreSQL</> 9.0，<parameter>primary_key_attnums</parameter>中
 的属性号被解释为逻辑列数，对应<literal>SELECT * FROM relname</>中的列的位置。
 先前版本作为物理列位置进行解释。如果在整个表周期中指定列左侧的任何列已经被删除了，
 那么这是有区别的。
</para>
  </refsect1>

  <refsect1>
   <!--
<title>Examples</title>
-->
<title>例子</title>

<screen>
SELECT dblink_build_sql_insert('foo', '1 2', 2, '{"1", "a"}', '{"1", "b''a"}');
             dblink_build_sql_insert
--------------------------------------------------
 INSERT INTO foo(f1,f2,f3) VALUES('1','b''a','1')
(1 row)
</screen>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-BUILD-SQL-DELETE">
  <refmeta>
   <refentrytitle>dblink_build_sql_delete</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_build_sql_delete</refname>
   <!--
   <refpurpose>builds a DELETE statement using supplied values for primary
    key field values
   </refpurpose>
   -->
   <refpurpose>使用已提供的值为主键字段值建立一个DELETE语句
   </refpurpose>
   
   
  </refnamediv>

  <indexterm>
   <primary>dblink_build_sql_delete</primary>
  </indexterm>

  <refsynopsisdiv>
<synopsis>
dblink_build_sql_delete(text relname,
                        int2vector primary_key_attnums,
                        integer num_primary_key_atts,
                        text[] tgt_pk_att_vals_array) returns text
</synopsis>
  </refsynopsisdiv>

  <refsect1>
   <title>Description</title>

   <!--
<para>
    <function>dblink_build_sql_delete</> can be useful in doing selective
    replication of a local table to a remote database.  It builds a SQL
    <command>DELETE</> command that will delete the row with the given
    primary key values.
   </para>
-->
<para>
   <function>dblink_build_sql_delete</>可以用于执行远程数据库本地表的选择行复制。
它建立一个SQL <command>DELETE</>命令将删除给定主键值的行。

</para>
  </refsect1>

  <refsect1>
  <!--
   <title>Arguments</title>
   -->
   <title>参数</title>

   <variablelist>
    <varlistentry>
     <term><parameter>relname</parameter></term>
     <listitem>
      <!--
<para>
       Name of a local relation, for example <literal>foo</> or
       <literal>myschema.mytab</>.  Include double quotes if the
       name is mixed-case or contains special characters, for
       example <literal>"FooBar"</>; without quotes, the string
       will be folded to lower case.
      </para>
-->
<para>
     本地关系名字，比如<literal>foo</>或者
       <literal>myschema.mytab</>。如果名字是混合情况下或者包含特殊字符，那么包含双引号，
   比如<literal>"FooBar"</>；没有引号，则字符串被折叠成小写字母。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>primary_key_attnums</parameter></term>
     <listitem>
      <!--
<para>
       Attribute numbers (1-based) of the primary key fields,
       for example <literal>1 2</>.
      </para>
-->
<para>
     主键字段的属性数量（1维），比如<literal>1 2</>。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>num_primary_key_atts</parameter></term>
     <listitem>
      <!--
<para>
       The number of primary key fields.
      </para>
-->
<para>
      主键字段数量。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>tgt_pk_att_vals_array</parameter></term>
     <listitem>
      <!--
<para>
       Values of the primary key fields to be used in the resulting
       <command>DELETE</> command.  Each field is represented in text form.
      </para>
-->
<para>
    主键字段值用于<command>DELETE</>命令。每个字段用文本形式表示。

</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
  <!--
   <title>Return Value</title>
   -->
   <title>返回值</title>

   <!--
<para>Returns the requested SQL statement as text.</para>
-->
<para>
    作为文本返回所请求的SQL语句。
</para>
  </refsect1>

  <refsect1>
   <!--
<title>Notes</title>
-->
<title>注意</title>

   <!--
<para>
    As of <productname>PostgreSQL</> 9.0, the attribute numbers in
    <parameter>primary_key_attnums</parameter> are interpreted as logical
    column numbers, corresponding to the column's position in
    <literal>SELECT * FROM relname</>.  Previous versions interpreted the
    numbers as physical column positions.  There is a difference if any
    column(s) to the left of the indicated column have been dropped during
    the lifetime of the table.
   </para>
-->
<para>
    <productname>PostgreSQL</> 9.0，<parameter>primary_key_attnums</parameter>中
 的属性号被解释为逻辑列数，对应<literal>SELECT * FROM relname</>中的列的位置。
 先前版本作为物理列位置进行解释。如果在整个表周期中指定列左侧的任何列已经被删除了，
 那么这是有区别的。
</para>
  </refsect1>

  <refsect1>
   <!--
<title>Examples</title>
-->
<title>例子</title>

<screen>
SELECT dblink_build_sql_delete('"MyFoo"', '1 2', 2, '{"1", "b"}');
           dblink_build_sql_delete
---------------------------------------------
 DELETE FROM "MyFoo" WHERE f1='1' AND f2='b'
(1 row)
</screen>
  </refsect1>
 </refentry>

 <refentry id="CONTRIB-DBLINK-BUILD-SQL-UPDATE">
  <refmeta>
   <refentrytitle>dblink_build_sql_update</refentrytitle>
   <manvolnum>3</manvolnum>
  </refmeta>

  <refnamediv>
   <refname>dblink_build_sql_update</refname>
   <!--
   <refpurpose>builds an UPDATE statement using a local tuple, replacing
    the primary key field values with alternative supplied values
   </refpurpose>
   -->
   <refpurpose>使用本地元组建立UPDATE语句，
   使用可选的已提供的值替换主键字段</refpurpose>
   
  </refnamediv>

  <indexterm>
   <primary>dblink_build_sql_update</primary>
  </indexterm>

  <refsynopsisdiv>
<synopsis>
dblink_build_sql_update(text relname,
                        int2vector primary_key_attnums,
                        integer num_primary_key_atts,
                        text[] src_pk_att_vals_array,
                        text[] tgt_pk_att_vals_array) returns text
</synopsis>
  </refsynopsisdiv>

  <refsect1>
  <!--
   <title>Description</title>
   -->
    <title>描述</title>

   <!--
<para>
    <function>dblink_build_sql_update</> can be useful in doing selective
    replication of a local table to a remote database.  It selects a row
    from the local table based on primary key, and then builds a SQL
    <command>UPDATE</> command that will duplicate that row, but with
    the primary key values replaced by the values in the last argument.
    (To make an exact copy of the row, just specify the same values for
    the last two arguments.)  The <command>UPDATE</> command always assigns
    all fields of the row &mdash; the main difference between this and
    <function>dblink_build_sql_insert</> is that it's assumed that
    the target row already exists in the remote table.
   </para>
-->
<para>
    <function>dblink_build_sql_update</>可以用于执行远程数据库本地表的选择行复制。
它从基于主键的本地表选择行，然后建立一个SQL <command>UPDATE</>命令复制该行，
但是随着主键值被最后参数中的值替换。
（为了准确拷贝行，请为最后两个参数指定同一值）。<command>UPDATE</>命令总是
分配行中所有字段；在这个和<function>dblink_build_sql_insert</>之间的
主要区别是目标行已经存在于远程表中是个假设。
</para>
  </refsect1>

  <refsect1>
  <!--
   <title>Arguments</title>
   -->
    <title>参数</title>

   <variablelist>
    <varlistentry>
     <term><parameter>relname</parameter></term>
     <listitem>
      <!--
<para>
       Name of a local relation, for example <literal>foo</> or
       <literal>myschema.mytab</>.  Include double quotes if the
       name is mixed-case or contains special characters, for
       example <literal>"FooBar"</>; without quotes, the string
       will be folded to lower case.
      </para>
-->
<para>
    本地关系名字，比如<literal>foo</>或者
       <literal>myschema.mytab</>。如果名字是混合情况下或者包含特殊字符，那么包含双引号，
   比如<literal>"FooBar"</>；没有引号，则字符串被折叠成小写字母。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>primary_key_attnums</parameter></term>
     <listitem>
      <!--
<para>
       Attribute numbers (1-based) of the primary key fields,
       for example <literal>1 2</>.
      </para>
-->
<para>
    主键字段的属性数量（1维），比如<literal>1 2</>。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>num_primary_key_atts</parameter></term>
     <listitem>
      <!--
<para>
       The number of primary key fields.
      </para>
-->
<para>
     主键字段数量。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>src_pk_att_vals_array</parameter></term>
     <listitem>
      <!--
<para>
       Values of the primary key fields to be used to look up the
       local tuple.  Each field is represented in text form.
       An error is thrown if there is no local row with these
       primary key values.
      </para>
-->
<para>
     主键字段值用于查找本地元组。每个字段用文本形式表示。
   如果在这些主键值中没有本地行，那么抛出错误。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><parameter>tgt_pk_att_vals_array</parameter></term>
     <listitem>
      <!--
<para>
       Values of the primary key fields to be placed in the resulting
       <command>UPDATE</> command.  Each field is represented in text form.
      </para>
-->
<para>
     主键字段值被放置在<command>UPDATE</>命令中。每个字段用文本形式表示。
</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </refsect1>

  <refsect1>
  <!--
   <title>Return Value</title>
   -->
   <title>返回值</title>

   <!--
<para>Returns the requested SQL statement as text.</para>
-->
<para>
    作为文本返回请求的SQL语句。
</para>
  </refsect1>

  <refsect1>
   <!--
<title>Notes</title>
-->
<title>注意</title>

   <!--
<para>
    As of <productname>PostgreSQL</> 9.0, the attribute numbers in
    <parameter>primary_key_attnums</parameter> are interpreted as logical
    column numbers, corresponding to the column's position in
    <literal>SELECT * FROM relname</>.  Previous versions interpreted the
    numbers as physical column positions.  There is a difference if any
    column(s) to the left of the indicated column have been dropped during
    the lifetime of the table.
   </para>
-->
<para>
    <productname>PostgreSQL</> 9.0，<parameter>primary_key_attnums</parameter>中
 的属性号被解释为逻辑列数，对应<literal>SELECT * FROM relname</>中的列的位置。
 先前版本作为物理列位置进行解释。如果在整个表周期中指定列左侧的任何列已经被删除了，
 那么这是有区别的。
</para>
  </refsect1>

  <refsect1>
   <!--
<title>Examples</title>
-->
<title>例子</title>

<screen>
SELECT dblink_build_sql_update('foo', '1 2', 2, '{"1", "a"}', '{"1", "b"}');
                   dblink_build_sql_update
-------------------------------------------------------------
 UPDATE foo SET f1='1',f2='b',f3='1' WHERE f1='1' AND f2='b'
(1 row)
</screen>
  </refsect1>
 </refentry>

</sect1>