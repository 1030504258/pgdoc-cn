<!-- doc/src/sgml/extend.sgml -->

 <chapter id="extend">
 <!--
  <title>Extending <acronym>SQL</acronym></title>
 -->
 <title>扩展<acronym>SQL</acronym></title>

  <indexterm zone="extend">
   <primary>extending SQL</primary>
  </indexterm>

  
<para>
   <!--
   In  the  sections  that follow, we will discuss how you
   can extend the <productname>PostgreSQL</productname>
   <acronym>SQL</acronym> query language by adding:
   -->
   在本章的剩余部分，
我们将讨论你如何通过增加下面几种对象来扩展<productname>PostgreSQL</productname>
的<acronym>SQL</acronym>查询语言：
   <itemizedlist spacing="compact" mark="bullet">
    <listitem>
     <para>
 <!--
      functions (starting in <xref linkend="xfunc">)
  -->
  函数（开始于<xref linkend="xfunc">）
     </para>

    </listitem>
    <listitem>
     <!--
<para>
      aggregates (starting in <xref linkend="xaggr">)
     </para>
-->
<para>
     聚集（开始于<xref linkend="xaggr">）
</para>
    </listitem>
    <listitem>
     <!--
<para>
      data types (starting in <xref linkend="xtypes">)
     </para>
-->
<para>
     数据类型（开始于<xref linkend="xtypes">）
</para>
    </listitem>
    <listitem>
     <!--
<para>
      operators (starting in <xref linkend="xoper">)
     </para>
-->
<para>
    操作符（开始于<xref linkend="xoper">）
</para>
    </listitem>
    <listitem>
     <!--
<para>
      operator classes for indexes (starting in <xref linkend="xindex">)
     </para>
-->
<para>
    索引操作符类（开始于<xref linkend="xindex">）
</para>
    </listitem>
    <listitem>
     <!--
<para>
      packages of related objects (starting in <xref linkend="extend-extensions">)
     </para>
-->
<para>
    相关对象打包（开始于<xref linkend="extend-extensions">）
</para>
    </listitem>
   </itemizedlist>
  </para>

  <sect1 id="extend-how">
  <!--
   <title>How Extensibility Works</title>
  -->
    <title>扩展性是如何实现的</title>

   <!--
<para>
    <productname>PostgreSQL</productname> is extensible because its operation  is
    catalog-driven.   If  you  are familiar with standard
    relational database systems, you know that  they  store  information
    about  databases,  tables,  columns,  etc., in what are
    commonly known as system catalogs.  (Some systems  call
    this  the data dictionary.)  The catalogs appear to the
    user as tables like any other, but  the  <acronym>DBMS</acronym>  stores
    its  internal  bookkeeping in them.  One key difference
    between <productname>PostgreSQL</productname> and  standard  relational database systems  is
    that <productname>PostgreSQL</productname> stores much more information in its
    catalogs: not only information about tables and  columns,
    but also information about data types, functions, access
    methods, and so on.  These tables can be  modified  by
    the  user, and since <productname>PostgreSQL</productname> bases its operation
    on these tables, this means that <productname>PostgreSQL</productname> can  be
    extended   by   users.    By  comparison,  conventional
    database systems can only be extended by changing hardcoded
    procedures in the source code or by loading modules
    specially written by the <acronym>DBMS</acronym> vendor.
   </para>
-->
<para>
    <productname>PostgreSQL</productname>可扩展的原因是它的操作是由表驱动的。
如果你熟悉标准的关系数据库系统，
你就知道它们把数据库、表、字段等信息存储在一个被称为系统表
(有些系统称为数据字典)的地方。这些表与其它表没什么不同，
只不过<acronym>DBMS</acronym>把它自己内部的信息存放于此罢了。
<productname>PostgreSQL</productname>与其它系统的不同之处在于它在系统表里存储了更多的信息：
除了关于表和列/字段的信息之外，
还有关于它们的类型、函数、访问方式之类的信息。这些表可以被用户修改，
而且由于<productname>PostgreSQL</productname>的内部操作是以这些表为基础的，
这就意味着<productname>PostgreSQL</productname>可以被用户进行扩展。相比之下，
传统的数据库系统只能通过修改源代码或加载由DBMS供应商提供的特殊模块来扩展。
</para>

   <!--
<para>
    The <productname>PostgreSQL</productname> server can moreover
    incorporate user-written code into itself through dynamic loading.
    That is, the user can specify an object code file (e.g., a shared
    library) that implements a new type or function, and
    <productname>PostgreSQL</productname> will load it as required.
    Code written in <acronym>SQL</acronym> is even more trivial to add
    to the server.  This ability to modify its operation <quote>on the
    fly</quote> makes <productname>PostgreSQL</productname> uniquely
    suited for rapid prototyping of new applications and storage
    structures.
   </para>
-->
<para>
  <productname>PostgreSQL</productname>还可以通过动态加载的方法与用户书写的代码结合在一起。
也就是说，用户可以把一个目标代码文件(通常是共享库)
声明为一个新类型或函数的实现，
这时<productname>PostgreSQL</productname>将根据需要加载它们。
用<acronym>SQL</acronym>书写的代码甚至更容易加入到服务器中去。
这种可以<quote>在线</quote>更改操作的能力
使<productname>PostgreSQL</productname>特别适合于新应用和新存储结构的快速定型。
</para>
  </sect1>

  <sect1 id="extend-type-system">
  <!--
   <title>The <productname>PostgreSQL</productname> Type System</title>
  -->
    <title><productname>PostgreSQL</productname>类型系统</title>

   <indexterm zone="extend-type-system">
    <primary>base type</primary>
   </indexterm>

   <indexterm zone="extend-type-system">
    <primary>data type</primary>
    <secondary>base</secondary>
   </indexterm>

   <indexterm zone="extend-type-system">
    <primary>composite type</primary>
   </indexterm>

   <indexterm zone="extend-type-system">
    <primary>data type</primary>
    <secondary>composite</secondary>
   </indexterm>

   <!--
<para>
    <productname>PostgreSQL</productname> data types are divided into base
    types, composite types, domains, and pseudo-types.
   </para>
-->
<para>
   <productname>PostgreSQL</productname>数据类型可以分为基本类型、复合类型、域、伪类型。
</para>

   <sect2>
   <!--
    <title>Base Types</title>
   -->
     <title>基本类型</title>

    <!--
<para>
     Base types are those, like <type>int4</type>, that are
     implemented below the level of the <acronym>SQL</> language
     (typically in a low-level language such as C).  They generally
     correspond to what are often known as abstract data types.
     <productname>PostgreSQL</productname> can only operate on such
     types through functions provided by the user and only understands
     the behavior of such types to the extent that the user describes
     them.  Base types are further subdivided into scalar and array
     types.  For each scalar type, a corresponding array type is
     automatically created that can hold variable-size arrays of that
     scalar type.
    </para>
-->
<para>
    基本类型是那些在<acronym>SQL</>语言层次更低级别(通常是C语言)上实现的类型(比如<type>int4</type>类型)，
它们通常与抽像数据类型对应。<productname>PostgreSQL</productname>对这些数据类型只能通过用户提供的函数来操作，
并且对这些数据类型行为的理解只限于用户所描述的范围。基本类型进一步分成标量和数组类型。
对于每种标量类型，系统都会自动创建一个对应的数组类型，可以保存该标量类型的变长数组。
</para>
   </sect2>

   <sect2>
   <!--
    <title>Composite Types</title>
   -->
     <title>复合类型</title>

    <!--
<para>
     Composite types, or row types, are created whenever the user
     creates a table. It is also possible to use <xref
     linkend="sql-createtype"> to
     define a <quote>stand-alone</> composite type with no associated
     table.  A composite type is simply a list of types with
     associated field names.  A value of a composite type is a row or
     record of field values.  The user can access the component fields
     from <acronym>SQL</> queries. Refer to <xref linkend="rowtypes">
     for more information on composite types.
    </para>
-->
<para>
    复合类型(或者说行类型)是用户创建表时创建的。
也可以用<xref linkend="sql-createtype">创建一个<quote>独立的</>、没有关联表的复合类型。
复合类型只是一个带着相关字段名称的基本类型的列表。
复合类型的数值是一行字段值或者一条字段值组成的记录。
用户可以从<acronym>SQL</>查询里访问其字段。
参考<xref linkend="rowtypes">获取更多复合类型的相关信息。
</para>
   </sect2>

   <sect2 id="extend-type-system-domains">
   
   <!--
    <title>Domains</title>
   -->
   <title>域</title>
    <!--
<para>
     A domain is based on a particular base type and for many purposes
     is interchangeable with its base type.  However, a domain can
     have constraints that restrict its valid values to a subset of
     what the underlying base type would allow.
    </para>
-->
<para>
    域基于一种特定的基本类型，从很多角度来看，它们也可以和其对应的基本类型交换。
但是，域可以有约束，把它的有效值限制在其对应的基本类型的有效值范围的一个子集中。
</para>

    <!--
<para>
     Domains can be created using the <acronym>SQL</> command
     <xref linkend="sql-createdomain">.
     Their creation and use is not discussed in this chapter.
    </para>
-->
<para>
     域可以使用<acronym>SQL</>命令<xref linkend="sql-createdomain">创建。
它们的创建和使用不在本章讨论。
</para>

   </sect2>

   <sect2>
   <!--
    <title>Pseudo-Types</title>
   -->
     <title>伪-类型</title>
    <!--
<para>
     There are a few <quote>pseudo-types</> for special purposes.
     Pseudo-types cannot appear as columns of tables or attributes of
     composite types, but they can be used to declare the argument and
     result types of functions.  This provides a mechanism within the
     type system to identify special classes of functions.  <xref
     linkend="datatype-pseudotypes-table"> lists the existing
     pseudo-types.
    </para>
-->
<para>
     有一些用于特殊目的<quote>伪类型</>。伪类型不能作为表的字段类型，
也不能作为复合类型的属性，但是它们可以用于声明函数的参数和结果类型。
这样就在类型系统里提供了一个标识特殊类型函数的机制。
<xref linkend="datatype-pseudotypes-table">列出了现有的伪类型。
</para>
   </sect2>

   <sect2 id="extend-types-polymorphic">
   <!--
    <title>Polymorphic Types</title>
-->
<title>多态类型</title>

   <indexterm zone="extend-types-polymorphic">
    <primary>polymorphic type</primary>
   </indexterm>

   <indexterm zone="extend-types-polymorphic">
    <primary>polymorphic function</primary>
   </indexterm>

   <indexterm zone="extend-types-polymorphic">
    <primary>type</primary>
    <secondary>polymorphic</secondary>
   </indexterm>

   <indexterm zone="extend-types-polymorphic">
    <primary>function</primary>
    <secondary>polymorphic</secondary>
   </indexterm>

    <!--
<para>
     Five pseudo-types of special interest are <type>anyelement</>,
     <type>anyarray</>, <type>anynonarray</>, <type>anyenum</>,
     and <type>anyrange</>,
     which are collectively called <firstterm>polymorphic types</>.
     Any function declared using these types is said to be
     a <firstterm>polymorphic function</>.  A polymorphic function can
     operate on many different data types, with the specific data type(s)
     being determined by the data types actually passed to it in a particular
     call.
    </para>
-->
<para>
    <type>anyelement</>,<type>anyarray</>, <type>anynonarray</>, <type>anyenum</>,
和<type>anyrange</>是五种特别有趣的伪类型，它们被称作<firstterm>多态类型</>。
任何用这些类型定义的函数就叫做<firstterm>多态函数</>。
一种多态函数可以在许多不同的数据类型上操作，
它们根据调用中实际传递进来的数据类型判断具体的类型。
</para>

    <!--
<para>
     Polymorphic arguments and results are tied to each other and are resolved
     to a specific data type when a query calling a polymorphic function is
     parsed.  Each position (either argument or return value) declared as
     <type>anyelement</type> is allowed to have any specific actual
     data type, but in any given call they must all be the
     <emphasis>same</emphasis> actual type. Each
     position declared as <type>anyarray</type> can have any array data type,
     but similarly they must all be the same type.  And similarly,
     positions declared as <type>anyrange</type> must all be the same range
     type.  Furthermore, if there are
     positions declared <type>anyarray</type> and others declared
     <type>anyelement</type>, the actual array type in the
     <type>anyarray</type> positions must be an array whose elements are
     the same type appearing in the <type>anyelement</type> positions.
     Similarly, if there are positions declared <type>anyrange</type>
     and others declared <type>anyelement</type>, the actual range type in
     the <type>anyrange</type> positions must be a range whose subtype is
     the same type appearing in the <type>anyelement</type> positions.
     <type>anynonarray</> is treated exactly the same as <type>anyelement</>,
     but adds the additional constraint that the actual type must not be
     an array type.
     <type>anyenum</> is treated exactly the same as <type>anyelement</>,
     but adds the additional constraint that the actual type must
     be an enum type.
    </para>
-->
<para>
    多态参数和结果是相互绑定的，并且在分析查询调用的函数时解析成特定的数据类型。
每个声明成<type>anyelement</type>的位置(参数或者返回类型)都允许拥有一个特定的实际数据类型，
但是在任何给定的调用过程中，它们都必须是<emphasis>同样的</emphasis>类型。
每个声明为<type>anyarray</type>的位置都可以是任何数组数据类型，类似的，声明为<type>anyrange</type>的位置
也必许都是同样的类型。而且，如果有些位置声明为<type>anyarray</type>而其它位置声明为<type>anyelement</type>，
那么在<type>anyarray</type>位置上的类型必须是元素类型与那些出现在<type>anyelement</type>位置上的类型相同的数组。
类似的，如果有声明为<type>anyrange</type>的位置而且其他的声明为<type>anyelement</type>，那么
在<type>anyrange</type>位置上的类型必须是子类型与那些出现在<type>anyelement</type>位置上类型相同
的范围。<type>anynonarray</>实际上被看做<type>anyelement</>，
但却多一个约束：实际类型必须不能是一个数组类型。
<type>anyenum</>实际上被看做<type>anyelement</>，但却多一个约束：
实际类型必须是一个枚举类型。
</para>

    <!--
<para>
     Thus, when more than one argument position is declared with a polymorphic
     type, the net effect is that only certain combinations of actual argument
     types are allowed.  For example, a function declared as
     <literal>equal(anyelement, anyelement)</> will take any two input values,
     so long as they are of the same data type.
    </para>
-->
<para>
    因此，如果多个参数位置声明为多态类型，其实际效果是只允许某些实际参数类型的组合出现。 
比如，一个函数声明为<literal>equal(anyelement, anyelement)</>将接受任何两个输入值，只要它们的数据类型相同。
</para>

    <!--
<para>
     When the return value of a function is declared as a polymorphic type,
     there must be at least one argument position that is also polymorphic,
     and the actual data type supplied as the argument determines the actual
     result type for that call.  For example, if there were not already
     an array subscripting mechanism, one could define a function that
     implements subscripting as <literal>subscript(anyarray, integer)
     returns anyelement</>.  This declaration constrains the actual first
     argument to be an array type, and allows the parser to infer the correct
     result type from the actual first argument's type.  Another example
     is that a function declared as <literal>f(anyarray) returns anyenum</>
     will only accept arrays of enum types.
    </para>
-->
<para>
    如果一个函数的返回值声明为多态类型，那么至少有一个参数位置也是多态的，
并且提供给参数的类型决定本次调用实际返回的类型。比如，如果没有数组下标机制，
那么我们可以定义一个实现下标的函数<literal>subscript(anyarray, integer) returns anyelement</>。
这个声明约束第一个实际参数是一个数组类型，并且允许分析器从第一个参数的实际类型推导出正确的返回类型。
声明为一个<literal>f(anyarray) returns anyenum</>的函数的另一个例子只接受枚举类型的数组。
</para>

    <!--
<para>
     Note that <type>anynonarray</> and <type>anyenum</> do not represent
     separate type variables; they are the same type as
     <type>anyelement</type>, just with an additional constraint.  For
     example, declaring a function as <literal>f(anyelement, anyenum)</>
     is equivalent to declaring it as <literal>f(anyenum, anyenum)</>:
     both actual arguments have to be the same enum type.
    </para>
-->
<para>
    需要注意的是，<type>anynonarray</>和<type>anyenum</>不代表不同的类型变量；
它们是与<type>anyelement</type>相同的类型，只有一个额外的约束。
例如，声明一个函数为<literal>f(anyelement, anyenum)</>
等同于声明它为<literal>f(anyenum, anyenum)</>:
两个实际参数必须是相同的枚举类型。
</para>

    <!--
<para>
     A variadic function (one taking a variable number of arguments, as in
     <xref linkend="xfunc-sql-variadic-functions">) can be
     polymorphic: this is accomplished by declaring its last parameter as
     <literal>VARIADIC</> <type>anyarray</>.  For purposes of argument
     matching and determining the actual result type, such a function behaves
     the same as if you had written the appropriate number of
     <type>anynonarray</> parameters.
    </para>
-->
<para>
    一个可变参数函数（其使用一个可变数目的参数，如<xref linkend="xfunc-sql-variadic-functions">中描述）
可以是多态的：
可以通过声明它的最后一个参数为<literal>VARIADIC</> <type>anyarray</>来实现。
为了实现参数匹配并决定实际结果类型，
这样一个函数的行为等同于将<type>anynonarray</>参数写一个合适的数目。
</para>
   </sect2>
  </sect1>

  &xfunc;
  &xaggr;
  &xtypes;
  &xoper;
  &xindex;


  <sect1 id="extend-extensions">
  <!--
   <title>Packaging Related Objects into an Extension</title>
   -->
   <title>包装相关对象到一个扩展</title>

   <indexterm zone="extend-extensions">
    <primary>extension</primary>
   </indexterm>

   <!--
<para>
    A useful extension to <productname>PostgreSQL</> typically includes
    multiple SQL objects; for example, a new data type will require new
    functions, new operators, and probably new index operator classes.
    It is helpful to collect all these objects into a single package
    to simplify database management.  <productname>PostgreSQL</> calls
    such a package an <firstterm>extension</>.  To define an extension,
    you need at least a <firstterm>script file</> that contains the
    <acronym>SQL</> commands to create the extension's objects, and a
    <firstterm>control file</> that specifies a few basic properties
    of the extension itself.  If the extension includes C code, there
    will typically also be a shared library file into which the C code
    has been built.  Once you have these files, a simple
    <xref linkend="sql-createextension"> command loads the objects into
    your database.
   </para>
-->
<para>
    <productname>PostgreSQL</>的一个有用扩展通常包括
多个SQL对象；例如，一个新的数据类型将需要新的函数，新的操作符，以及可能的新的索引操作类。
为了简化数据库管理有助于收集所有这些对象到一个单一的包。
<productname>PostgreSQL</>调用这样的包如<firstterm>extension</>。为了定义一个扩展，
你至少需要一个<firstterm>脚本文件</>包含<acronym>SQL</>命令以创建扩展的对象，并且
<firstterm>控制文件</>指定扩展本身的几个基本性质。如果扩展包括C代码，
通常也是一个共享库文件的已经编译的C代码。
一旦你有了这些文件，一个简单的<xref linkend="sql-createextension">命令加载对象到你的数据库。
</para>

   <!--
<para>
    The main advantage of using an extension, rather than just running the
    <acronym>SQL</> script to load a bunch of <quote>loose</> objects
    into your database, is that <productname>PostgreSQL</> will then
    understand that the objects of the extension go together.  You can
    drop all the objects with a single <xref linkend="sql-dropextension">
    command (no need to maintain a separate <quote>uninstall</> script).
    Even more useful, <application>pg_dump</> knows that it should not
    dump the individual member objects of the extension &mdash; it will
    just include a <command>CREATE EXTENSION</> command in dumps, instead.
    This vastly simplifies migration to a new version of the extension
    that might contain more or different objects than the old version.
    Note however that you must have the extension's control, script, and
    other files available when loading such a dump into a new database.
   </para>
-->
<para>
    使用一个扩展的主要优点，不是运行
<acronym>SQL</>脚本加载一组<quote>loose</>对象到
你的数据库，而是<productname>PostgreSQL</>将一起了解扩展的对象。
你可以删除使用单独<xref linkend="sql-dropextension">命令的
所有的对象（不需要维护一个单独的<quote>卸载</>脚本）。
更有用的，<application>pg_dump</>知道
它不应该转储扩展的单个成员对象&mdash；
它会只包括<command>CREATE EXTENSION</>命令创建扩展。
这大大简化了迁移到一个新的扩展版本，
可能含有比旧版本更多的或不同的对象。
但是请注意，当装载转储到一个新的数据库的时候，你必须有扩展的控制，脚本，以及
其他可用的文件。
</para>

   <!--
<para>
    <productname>PostgreSQL</> will not let you drop an individual object
    contained in an extension, except by dropping the whole extension.
    Also, while you can change the definition of an extension member object
    (for example, via <command>CREATE OR REPLACE FUNCTION</command> for a
    function), bear in mind that the modified definition will not be dumped
    by <application>pg_dump</>.  Such a change is usually only sensible if
    you concurrently make the same change in the extension's script file.
    (But there are special provisions for tables containing configuration
    data; see below.)
   </para>
-->
<para>
    <productname>PostgreSQL</>不会让你删除
包含在扩展中的单独的对象，除了减少整个扩展。
同时，虽然你可以改变扩展成员对象的定义
（例如，通过<command>CREATE OR REPLACE FUNCTION</command>函数），记住修改后的定义将不会
通过<application>pg_dump</>被转储。这种变化通常是唯一明智的，如果
你同时在扩展的脚本文件中有相同的变化。
（但对包含配置数据的表有特殊规定；见下文。）
</para>

   <!--
<para>
    The extension mechanism also has provisions for packaging modification
    scripts that adjust the definitions of the SQL objects contained in an
    extension.  For example, if version 1.1 of an extension adds one function
    and changes the body of another function compared to 1.0, the extension
    author can provide an <firstterm>update script</> that makes just those
    two changes.  The <command>ALTER EXTENSION UPDATE</> command can then
    be used to apply these changes and track which version of the extension
    is actually installed in a given database.
   </para>
-->
<para>
    扩展机制也为包装修改脚本制定规定，它调整包含扩展的SQL对象的定义。
例如，如果扩展的版本1.1增加了一个功能并且
改变相比较于1.0的另一个函数的主体，扩展可以提供一个<firstterm>更新脚本</>，只是那两个改变。
<command>ALTER EXTENSION UPDATE</>命令可以用于应用这些变化，并且
跟踪扩展的版本，实际上是安装在一个给定的数据库中。
</para>

   <!--
<para>
    The kinds of SQL objects that can be members of an extension are shown in
    the description of <xref linkend="sql-alterextension">.  Notably, objects
    that are database-cluster-wide, such as databases, roles, and tablespaces,
    cannot be extension members since an extension is only known within one
    database.  (Although an extension script is not prohibited from creating
    such objects, if it does so they will not be tracked as part of the
    extension.)  Also notice that while a table can be a member of an
    extension, its subsidiary objects such as indexes are not directly
    considered members of the extension.
    Another important point is that schemas can belong to extensions, but not
    vice versa: an extension as such has an unqualified name and does not
    exist <quote>within</> any schema.  The extension's member objects,
    however, will belong to schemas whenever appropriate for their object
    types.  It may or may not be appropriate for an extension to own the
    schema(s) its member objects are within.
   </para>
-->
<para>
    一些SQL对象是显示在<xref linkend="sql-alterextension">的描述中的扩展对象。
值得注意的是，对象是数据库集群范围，如数据库，角色，和表空间，
无法扩展成员，因为扩展在一个数据库中是唯一已知的。
（虽然并不禁止扩展脚本创建这样的对象，如果它这样做，
他们将不会作为跟踪扩展。）也注意到，当一个表可以是扩展成员时，
其子对象如索引不直接考虑扩展成员。
另外重要的一点是，模式可以属于扩展，但非
反之亦然：扩展这样有一个不合格的名称并且不
存在任何模式<quote>内部</>。
扩展的成员对象，然而，将属于模式，
只要适合他们的对象类型。它可能或可能不适合拥有模式成员对象的一个扩展。
</para>

   <sect2>
   <!--
    <title>Extension Files</title>
   -->
    <title>扩展文件</title>

   <indexterm>
    <primary>control file</primary>
   </indexterm>

    <!--
<para>
     The <xref linkend="sql-createextension"> command relies on a control
     file for each extension, which must be named the same as the extension
     with a suffix of <literal>.control</>, and must be placed in the
     installation's <literal>SHAREDIR/extension</literal> directory.  There
     must also be at least one <acronym>SQL</> script file, which follows the
     naming pattern
     <literal><replaceable>extension</>&#045;-<replaceable>version</>.sql</literal>
     (for example, <literal>foo&#045;-1.0.sql</> for version <literal>1.0</> of
     extension <literal>foo</>).  By default, the script file(s) are also
     placed in the <literal>SHAREDIR/extension</literal> directory; but the
     control file can specify a different directory for the script file(s).
    </para>
-->
<para>
     <xref linkend="sql-createextension">命令依赖于每个扩展的控制文件，
它必须被命名为和带有<literal>.control</>后缀的扩展相同。并且被放置在安装的
<literal>SHAREDIR/extension</literal>目录中。必须至少有一个<acronym>SQL</>脚本文件，
遵循命名模式<literal><replaceable>extension</>--<replaceable>version</>.sql</literal>
（比如，扩展<literal>foo</>的版本<literal>1.0</>是<literal>foo--1.0.sql</>）。
缺省，脚本文件也被放置在<literal>SHAREDIR/extension</literal>目录中；
但是控制文件可以为脚本文件声明不同的目录。
</para>

    <!--
<para>
     The file format for an extension control file is the same as for the
     <filename>postgresql.conf</> file, namely a list of
     <replaceable>parameter_name</> <literal>=</> <replaceable>value</>
     assignments, one per line.  Blank lines and comments introduced by
     <literal>#</> are allowed.  Be sure to quote any value that is not
     a single word or number.
    </para>
-->
<para>
    扩展控制文件的文件格式与<filename>postgresql.conf</>文件相同，
<replaceable>parameter_name</> <literal>=</> <replaceable>value</>
任务列表，每行一个。通过允许<literal>#</>引进空行和注释。
确保引用任何值，不是单词或者数字。
</para>

    <!--
<para>
     A control file can set the following parameters:
    </para>
-->
<para>
    控制文件可以设置以下参数：
</para>

    <variablelist>
     <varlistentry>
      <term><varname>directory</varname> (<type>string</type>)</term>
      <listitem>
       <!--
<para>
        The directory containing the extension's <acronym>SQL</> script
        file(s).  Unless an absolute path is given, the name is relative to
        the installation's <literal>SHAREDIR</literal> directory.  The
        default behavior is equivalent to specifying
        <literal>directory = 'extension'</>.
       </para>
-->
<para>
      该目录包含扩展的<acronym>SQL</>脚本文件。
除非给定绝对路径名，名字是相对于安装的<literal>SHAREDIR</literal>目录。
默认操作相当于指定<literal>directory = 'extension'</>。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>default_version</varname> (<type>string</type>)</term>
      <listitem>
       <!--
<para>
        The default version of the extension (the one that will be installed
        if no version is specified in <command>CREATE EXTENSION</>).  Although
        this can be omitted, that will result in <command>CREATE EXTENSION</>
        failing if no <literal>VERSION</> option appears, so you generally
        don't want to do that.
       </para>
-->
<para>
      扩展的默认版本（如果在<command>CREATE EXTENSION</>中没有声明版本，则一个将被安装）。
虽然这可以被省略，如果没有<literal>VERSION</>选项，这将导致<command>CREATE EXTENSION</>
失败，所以你通常不想这样做。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>comment</varname> (<type>string</type>)</term>
      <listitem>
       <!--
<para>
        A comment (any string) about the extension.  Alternatively,
        the comment can be set by means of the <xref linkend="sql-comment">
        command in the script file.
       </para>
-->
<para>
     关于扩展的注释（任何字符串）。另外，注释可以通过脚本文件中的<xref linkend="sql-comment">
命令进行设置。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>encoding</varname> (<type>string</type>)</term>
      <listitem>
       <!--
<para>
        The character set encoding used by the script file(s).  This should
        be specified if the script files contain any non-ASCII characters.
        Otherwise the files will be assumed to be in the database encoding.
       </para>
-->
<para>
       通过脚本文件使用字符集编码。如果脚本文件包含任何非-ASCII字符，则被声明。
   否则这些文件被认为数据库编码。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>module_pathname</varname> (<type>string</type>)</term>
      <listitem>
       <!--
<para>
        The value of this parameter will be substituted for each occurrence
        of <literal>MODULE_PATHNAME</> in the script file(s).  If it is not
        set, no substitution is made.  Typically, this is set to
        <literal>$libdir/<replaceable>shared_library_name</></literal> and
        then <literal>MODULE_PATHNAME</> is used in <command>CREATE
        FUNCTION</> commands for C-language functions, so that the script
        files do not need to hard-wire the name of the shared library.
       </para>
-->
<para>
      这个参数的值将
为了每个发生在脚本文件中的<literal>MODULE_PATHNAME</>被替换。如果它不被设置，
则没有替代。通常情况下，这是设置为
<literal>$libdir/<replaceable>shared_library_name</></literal>并且
<literal>MODULE_PATHNAME</>在<command>CREATE FUNCTION</>命令中为C语言函数被使用，
因此脚本文件不需要硬线共享库的名字。 
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>requires</varname> (<type>string</type>)</term>
      <listitem>
       <!--
<para>
        A list of names of extensions that this extension depends on,
        for example <literal>requires = 'foo, bar'</literal>.  Those
        extensions must be installed before this one can be installed.
       </para>
-->
<para>
      这个扩展取决于扩展名列表，比如<literal>requires = 'foo, bar'</literal>。
这些扩展必须在可以被安装前被安装。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>superuser</varname> (<type>boolean</type>)</term>
      <listitem>
       <!--
<para>
        If this parameter is <literal>true</> (which is the default),
        only superusers can create the extension or update it to a new
        version.  If it is set to <literal>false</>, just the privileges
        required to execute the commands in the installation or update script
        are required.
       </para>
-->
<para>
    如果这个参数是<literal>true</>（缺省），只有超级用户可以创建扩展或者更新它到一个新版本。
如果它被设置为<literal>false</>，仅仅需要安装过程中执行命令所需的权限或者更新脚本。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>relocatable</varname> (<type>boolean</type>)</term>
      <listitem>
       <!--
<para>
        An extension is <firstterm>relocatable</> if it is possible to move
        its contained objects into a different schema after initial creation
        of the extension.  The default is <literal>false</>, i.e. the
        extension is not relocatable.
        See below for more information.
       </para>
-->
<para>
       如果扩展初始化创建之后可能移动所包含的对象到不同的模式中，
则扩展是<firstterm>浮动的</>。缺省是<literal>false</>等，这个扩展是不浮动的。
参见下文获取更多信息。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>schema</varname> (<type>string</type>)</term>
      <listitem>
       <!--
<para>
        This parameter can only be set for non-relocatable extensions.
        It forces the extension to be loaded into exactly the named schema
        and not any other.  See below for more information.
       </para>
-->
<para>
      这个参数只能设置为非-浮动的扩展。它强制扩展被加载到精确的命名模式中，并且
没有任何其他的。参见下文获取更多信息。
</para>
      </listitem>
     </varlistentry>
    </variablelist>

    <!--
<para>
     In addition to the primary control file
     <literal><replaceable>extension</>.control</literal>,
     an extension can have secondary control files named in the style
     <literal><replaceable>extension</>&#045;-<replaceable>version</>.control</literal>.
     If supplied, these must be located in the script file directory.
     Secondary control files follow the same format as the primary control
     file.  Any parameters set in a secondary control file override the
     primary control file when installing or updating to that version of
     the extension.  However, the parameters <varname>directory</> and
     <varname>default_version</> cannot be set in a secondary control file.
    </para>
-->
<para>
     除了初步控制文件<literal><replaceable>extension</>.control</literal>，
扩展有在形式<literal><replaceable>extension</>--<replaceable>version</>.control</literal>
中命名的二级控制文件。如果被提供，这些必须位于脚本文件目录中。
二级控制文件遵循同样格式作为初步控制文件。
当安装或者更新扩展版本的时候，在二级控制文件中设置的任何参数覆盖初步控制文件，
然而，不能在二级控制文件中设置参数<varname>directory</>和
<varname>default_version</>。
</para>

    <!--
<para>
     An extension's <acronym>SQL</> script files can contain any SQL commands,
     except for transaction control commands (<command>BEGIN</>,
     <command>COMMIT</>, etc) and commands that cannot be executed inside a
     transaction block (such as <command>VACUUM</>).  This is because the
     script files are implicitly executed within a transaction block.
    </para>
-->
<para>
    扩展的<acronym>SQL</>脚本文件可以包含任何SQL命令，除了事务控制命令
(<command>BEGIN</>，<command>COMMIT</>等)以及不能在一个事务块中执行的命令（比如<command>VACUUM</>）。
这是因为脚本文件在事务块中是隐式执行的。
</para>

    <!--
<para>
     An extension's <acronym>SQL</> script files can also contain lines
     beginning with <literal>\echo</>, which will be ignored (treated as
     comments) by the extension mechanism.  This provision is commonly used
     to throw an error if the script file is fed to <application>psql</>
     rather than being loaded via <command>CREATE EXTENSION</> (see example
     script below).  Without that, users might accidentally load the
     extension's contents as <quote>loose</> objects rather than as an
     extension, a state of affairs that's a bit tedious to recover from.
    </para>
-->
<para>
    扩展的<acronym>SQL</>脚本文件也可以包含以<literal>\echo</>开头的行，
这被扩展机制忽略（作为注释）。如果脚本文件给<application>psql</>而不是通过<command>CREATE EXTENSION</>
（参见下文例子脚本）被加载，则这个规定往往抛出错误。
没有那些，用户可能无意中加载扩展内容作为<quote>loose</>对象而不是作为扩展，
从中恢复的事态有点繁琐。
</para>

    <!--
<para>
     While the script files can contain any characters allowed by the specified
     encoding, control files should contain only plain ASCII, because there
     is no way for <productname>PostgreSQL</> to know what encoding a
     control file is in.  In practice this is only an issue if you want to
     use non-ASCII characters in the extension's comment.  Recommended
     practice in that case is to not use the control file <varname>comment</>
     parameter, but instead use <command>COMMENT ON EXTENSION</>
     within a script file to set the comment.
    </para>
-->
<para>
     当脚本文件可以包含指定编码允许的任何字符时，则控制文件应该包含纯ASCII，
因为<productname>PostgreSQL</>不知道控制文件中的编码方式。
实践中如果你想在扩展注释中使用非-ASCII字符，这个是一个问题。
在这种情况下推荐做法是不使用控制文件<varname>comment</>参数，但是代替使用
脚本文件中的<command>COMMENT ON EXTENSION</>设置comment。 
</para>

   </sect2>

   <sect2>
   <!--
    <title>Extension Relocatability</title>
   -->
     <title>扩展浮动</title>
    <!--
<para>
     Users often wish to load the objects contained in an extension into a
     different schema than the extension's author had in mind.  There are
     three supported levels of relocatability:
    </para>
-->
<para>
     用户通常希望加载包含在扩展中的对象到一个扩展者考虑到的不同的模式中。
有浮动的三种支持级别。
</para>

    <itemizedlist>
     <listitem>
      <!--
<para>
       A fully relocatable extension can be moved into another schema
       at any time, even after it's been loaded into a database.
       This is done with the <command>ALTER EXTENSION SET SCHEMA</>
       command, which automatically renames all the member objects into
       the new schema.  Normally, this is only possible if the extension
       contains no internal assumptions about what schema any of its
       objects are in.  Also, the extension's objects must all be in one
       schema to begin with (ignoring objects that do not belong to any
       schema, such as procedural languages).  Mark a fully relocatable
       extension by setting <literal>relocatable = true</> in its control
       file.
      </para>
-->
<para>
       一个完全可浮动扩展可移动到任何时间下的另一个模式，
即使它被加载到数据库之后。
这是执行了<command>ALTER EXTENSION SET SCHEMA</>命令，
它可以自动重命名所有成员对象到新模式中，
通常情况下，这是唯一可能的扩展，如果扩展包含关于任何对象在什么模式中的非内部假设。
同时，扩展的对象都必须在一个模式中（忽略不属于任何模式的对象，如程序语言）。
通过设置控制文件中<literal>relocatable = true</>标记完全的浮动扩展。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       An extension might be relocatable during installation but not
       afterwards.  This is typically the case if the extension's script
       file needs to reference the target schema explicitly, for example
       in setting <literal>search_path</> properties for SQL functions.
       For such an extension, set <literal>relocatable = false</> in its
       control file, and use <literal>@extschema@</> to refer to the target
       schema in the script file.  All occurrences of this string will be
       replaced by the actual target schema's name before the script is
       executed.  The user can set the target schema using the
       <literal>SCHEMA</> option of <command>CREATE EXTENSION</>.
      </para>
-->
<para>
    一个扩展可能会在安装过程中被重定位，但不是之后。
这是通常的情况，如果扩展的脚本文件需要参考明确的目标模式，例如
在为SQL函数设置<literal>search_path</>属性时。对于这种扩展，
在控制文件中设置<literal>relocatable = false</>，
并且使用<literal>@extschema@</>指向脚本文件中的目标模式。
在执行脚本前该字符串的所有出现将被实际的目标模式的名字取代。
用户可以使用<command>CREATE EXTENSION</>
的<literal>SCHEMA</>选项设置目标模式。 
</para>
     </listitem>

     <listitem>
      <!--
<para>
       If the extension does not support relocation at all, set
       <literal>relocatable = false</> in its control file, and also set
       <literal>schema</> to the name of the intended target schema.  This
       will prevent use of the <literal>SCHEMA</> option of <command>CREATE
       EXTENSION</>, unless it specifies the same schema named in the control
       file.  This choice is typically necessary if the extension contains
       internal assumptions about schema names that can't be replaced by
       uses of <literal>@extschema@</>.  The <literal>@extschema@</>
       substitution mechanism is available in this case too, although it is
       of limited use since the schema name is determined by the control file.
      </para>
-->
<para>
     如果扩展不支持重定位，则在控制文件中设置
<literal>relocatable = false</>，并且设置
<literal>schema</>到目标模式名。
这将防止使用<command>CREATE EXTENSION</>的<literal>SCHEMA</>选项，
除非指定了控制文件命名的相同模式。
如果扩展包含关于模式名不能被<literal>@extschema@</>替代的内部假设，
这种选择通常是必要的。在这种情况下<literal>@extschema@</>替代机制可用，尽管
它是有限的使用，因为模式名称是由控制文件确定的。
</para>
     </listitem>
    </itemizedlist>

    
<para>
    <!--
     In all cases, the script file will be executed with
     <xref linkend="guc-search-path"> initially set to point to the target
     schema; that is, <command>CREATE EXTENSION</> does the equivalent of
     this:
-->
在所有情况下，脚本文件与<xref linkend="guc-search-path">初始设置指向
目标模式一起被执行；也就是说，<command>CREATE EXTENSION</>相当于：
<programlisting>
SET LOCAL search_path TO @extschema@;
</programlisting>
    <!--
     This allows the objects created by the script file to go into the target
     schema.  The script file can change <varname>search_path</> if it wishes,
     but that is generally undesirable.  <varname>search_path</> is restored
     to its previous setting upon completion of <command>CREATE EXTENSION</>.
-->
 这允许通过脚本文件创建的对象到目标模式。如果它希望，则脚本文件可以改变<varname>search_path</>。
但是这通常是不可取的，<varname>search_path</>被存储到<command>CREATE EXTENSION</>的
先前设置完成。
    </para>

    <!--
<para>
     The target schema is determined by the <varname>schema</> parameter in
     the control file if that is given, otherwise by the <literal>SCHEMA</>
     option of <command>CREATE EXTENSION</> if that is given, otherwise the
     current default object creation schema (the first one in the caller's
     <varname>search_path</>).  When the control file <varname>schema</>
     parameter is used, the target schema will be created if it doesn't
     already exist, but in the other two cases it must already exist.
    </para>
-->
<para>
     如果它被给定，目标模式是由控制文件中的<varname>schema</>参数决定的。
否则由<command>CREATE EXTENSION</>的<literal>SCHEMA</>选项决定。
否则当前的默认对象创建模式（调用者<varname>search_path</>的第一个）。
当使用控制文件<varname>schema</>，如果它不存在，则创建目标模式，
但是在其他两种情况下，它必须已经存在。
</para>

    <!--
<para>
     If any prerequisite extensions are listed in <varname>requires</varname>
     in the control file, their target schemas are appended to the initial
     setting of <varname>search_path</>.  This allows their objects to be
     visible to the new extension's script file.
    </para>
-->
<para>
    如果任何先决条件扩展列在控制文件的<varname>requires</varname>中，目标模式附加到
<varname>search_path</>的初始设置中。这允许对象对于新的扩展脚本文件时可见的。
</para>

    <!--
<para>
     Although a non-relocatable extension can contain objects spread across
     multiple schemas, it is usually desirable to place all the objects meant
     for external use into a single schema, which is considered the extension's
     target schema.  Such an arrangement works conveniently with the default
     setting of <varname>search_path</> during creation of dependent
     extensions.
    </para>
-->
<para>
    尽管非可重定位扩展可以通过多个模式包含对象，为了外部使用把所有的对象放到一个单独模式中是可取的，
这被认为是扩展的目标模式。在相关扩展创建过程中，这样的安排方便<varname>search_path</>的缺省设置。
</para>
   </sect2>

   <sect2>
   <!--
    <title>Extension Configuration Tables</title>
 -->
    <title>扩展配置表</title>

    <!--
<para>
     Some extensions include configuration tables, which contain data that
     might be added or changed by the user after installation of the
     extension.  Ordinarily, if a table is part of an extension, neither
     the table's definition nor its content will be dumped by
     <application>pg_dump</>.  But that behavior is undesirable for a
     configuration table; any data changes made by the user need to be
     included in dumps, or the extension will behave differently after a dump
     and reload.
    </para>
-->
<para>
    一些扩展包含配置表，
其中包含的数据可能安装扩展之后被用户添加或更改。
通常，如果一个表是扩展部分，既不是表的定义，
也不是被<application>pg_dump</>备份的内容，
但这样的行为对配置表是不需要的；
用户修改的任何数据需要包含到备份中，
或备份和重载之后扩展会有不同的表现。
</para>

   <indexterm>
    <primary>pg_extension_config_dump</primary>
   </indexterm>

    
<para>
    <!--
     To solve this problem, an extension's script file can mark a table
     it has created as a configuration table, which will cause
     <application>pg_dump</> to include the table's contents (not its
     definition) in dumps.  To do that, call the function
     <function>pg_extension_config_dump(regclass, text)</> after creating the
     table, for example
 -->
 为了解决这个问题，扩展的脚本文件可以标记表，它已经作为配置表被创建，其中
将导致<application>pg_dump</>包含转储中表的内容（不是定义）。要做到这一点，
在创建表之后调用<function>pg_extension_config_dump(regclass, text)</>，比如：

<programlisting>
CREATE TABLE my_config (key text, value text);

SELECT pg_catalog.pg_extension_config_dump('my_config', '');
</programlisting>
    <!--
     Any number of tables can be marked this way.
-->
这种方式可以标记任何数量表。
    </para>

    
<para>
    <!--
     When the second argument of <function>pg_extension_config_dump</> is
     an empty string, the entire contents of the table are dumped by
     <application>pg_dump</>.  This is usually only correct if the table
     is initially empty as created by the extension script.  If there is
     a mixture of initial data and user-provided data in the table,
     the second argument of <function>pg_extension_config_dump</> provides
     a <literal>WHERE</> condition that selects the data to be dumped.
     For example, you might do
 -->
 当<function>pg_extension_config_dump</>的第二个参数是空字符串时，
该表的所有内容都被<application>pg_dump</>备份。如果表
最初扩展脚本创建为空，通常是唯一正确的。如果有
一个初始数据和用户表中提供的数据的混合，则<function>pg_extension_config_dump</>的
第二个参数提供了<literal>WHERE</>条件选择被备份的数据。比如，你可能做

<programlisting>
CREATE TABLE my_config (key text, value text, standard_entry boolean);

SELECT pg_catalog.pg_extension_config_dump('my_config', 'WHERE NOT standard_entry');
</programlisting>
     <!--
     and then make sure that <structfield>standard_entry</> is true only
     in the rows created by the extension's script.
 -->
 并且确保通过扩展脚本创建的行<structfield>standard_entry</>为真。
    </para>

    <!--
<para>
     More complicated situations, such as initially-provided rows that might
     be modified by users, can be handled by creating triggers on the
     configuration table to ensure that modified rows are marked correctly.
    </para>
-->
<para>
     更加复杂的情况，比如初始化提供的行可能通过用户被修改，通过在配置表上创建触发器被处理
 以确保正确标记修改的行。
</para>

    <!--
<para>
     You can alter the filter condition associated with a configuration table
     by calling <function>pg_extension_config_dump</> again.  (This would
     typically be useful in an extension update script.)  The only way to mark
     a table as no longer a configuration table is to dissociate it from the
     extension with <command>ALTER EXTENSION ... DROP TABLE</>.
    </para>
-->
<para>
    你可以通过再次调用<function>pg_extension_config_dump</>修改与配置表相关的过滤条件。
这在扩展更新脚本中通常是有用的。
标记表不再为配置表的唯一方法是从带有<command>ALTER EXTENSION ... DROP TABLE</>
的扩展中分离出来。

</para>
   </sect2>

   <sect2>
   <!--
    <title>Extension Updates</title>
   -->
     <title>扩展更新</title>
    <!--
<para>
     One advantage of the extension mechanism is that it provides convenient
     ways to manage updates to the SQL commands that define an extension's
     objects.  This is done by associating a version name or number with
     each released version of the extension's installation script.
     In addition, if you want users to be able to update their databases
     dynamically from one version to the next, you should provide
     <firstterm>update scripts</> that make the necessary changes to go from
     one version to the next.  Update scripts have names following the pattern
     <literal><replaceable>extension</>&#045;-<replaceable>oldversion</>&#045;-<replaceable>newversion</>.sql</literal>
     (for example, <literal>foo&#045;-1.0&#045;-1.1.sql</> contains the commands to modify
     version <literal>1.0</> of extension <literal>foo</> into version
     <literal>1.1</>).
    </para>
-->
<para>
    扩展机制的一个优点是，它提供了方便管理更新定义一个扩展对象的SQL命令的方式。
这是通过将版本的名称或号链接扩展的安装脚本的每个发布版本做到的。
此外，如果您希望用户可以动态的从一个版本到下一个更新他们的数据库
，你应该提供<firstterm>update scripts</>执行一个版本到下一个做出必要的改变。
以下模式<literal><replaceable>extension</>--<replaceable>oldversion</>--<replaceable>newversion</>.sql</literal>
更新脚本的名字。（比如，<literal>foo--1.0--1.1.sql</>使用命令修改扩展<literal>foo</>
的版本<literal>1.0</>到版本<literal>1.1</>）。
</para>

    <!--
<para>
     Given that a suitable update script is available, the command
     <command>ALTER EXTENSION UPDATE</> will update an installed extension
     to the specified new version.  The update script is run in the same
     environment that <command>CREATE EXTENSION</> provides for installation
     scripts: in particular, <varname>search_path</> is set up in the same
     way, and any new objects created by the script are automatically added
     to the extension.
    </para>
-->
<para>
    给定一个可用的合适更新脚本，
命令<command>ALTER EXTENSION UPDATE</>将更新已安装扩展到指定的新版本。
运行在相同环境中的更新脚本，<command>CREATE EXTENSION</>    
提供了安装环境脚本：特别是，<varname>search_path</>以相同
方式进行设置，并通过脚本创建任何新的对象被自动添加到扩展中。
</para>

    <!--
<para>
     If an extension has secondary control files, the control parameters
     that are used for an update script are those associated with the script's
     target (new) version.
    </para>
-->
<para>
    如果扩展有二次控制文件，控制参数用于与脚本目标（新）版本联系的更新脚本。
</para>

    <!--
<para>
     The update mechanism can be used to solve an important special case:
     converting a <quote>loose</> collection of objects into an extension.
     Before the extension mechanism was added to
     <productname>PostgreSQL</productname> (in 9.1), many people wrote
     extension modules that simply created assorted unpackaged objects.
     Given an existing database containing such objects, how can we convert
     the objects into a properly packaged extension?  Dropping them and then
     doing a plain <command>CREATE EXTENSION</> is one way, but it's not
     desirable if the objects have dependencies (for example, if there are
     table columns of a data type created by the extension).  The way to fix
     this situation is to create an empty extension, then use <command>ALTER
     EXTENSION ADD</> to attach each pre-existing object to the extension,
     then finally create any new objects that are in the current extension
     version but were not in the unpackaged release.  <command>CREATE
     EXTENSION</> supports this case with its <literal>FROM</> <replaceable
     class="parameter">old_version</> option, which causes it to not run the
     normal installation script for the target version, but instead the update
     script named
     <literal><replaceable>extension</>&#045;-<replaceable>old_version</>&#045;-<replaceable>target_version</>.sql</literal>.
     The choice of the dummy version name to use as <replaceable
     class="parameter">old_version</> is up to the extension author, though
     <literal>unpackaged</> is a common convention.  If you have multiple
     prior versions you need to be able to update into extension style, use
     multiple dummy version names to identify them.

    </para>
-->
<para>
    更新机制可以用来解决一个重要的特殊情况：
将转变<quote>松散</>对象的集合到一个扩展。
在扩展机制被添加到<productname>PostgreSQL</productname>(9.1中)之前，
许多人写的扩展模块简化了已创建的各式各样的未包装的对象。
给定包含这样对象的现有数据库，我们怎么能转换
对象到适当成套扩展？删除它们然后执行纯<command>CREATE EXTENSION</>是一种方式，
但它不是可取的，如果对象有依赖关系（例如，如果有扩展创建的数据类型的表列）。
修复这种情况的方式是创建一个空的扩展，然后使用<command>ALTER EXTENSION ADD</>
把每个预先存在的对象附属在扩展中，
最后在当前扩展版本中创建任何新的对象，
但不在未包装发布中。<command>CREATE EXTENSION</>
支持带有<literal>FROM</> <replaceable class="parameter">old_version</>选项的情况。
这导致它不运行目标版本的正常安装脚本，而是更新脚本命名
<literal><replaceable>extension</>--<replaceable>old_version</>--<replaceable>target_version</>.sql</literal>。
虚拟版本名称选择使用<replaceable class="parameter">old_version</>胜任扩展发起者，
尽管<literal>未包装</>是一种常见的公约。如果你有多个以前的版本，你需要能够更新扩展风格，
使用多个虚拟版本名称来识别它们。
</para>

    <!--
<para>
     <command>ALTER EXTENSION</> is able to execute sequences of update
     script files to achieve a requested update.  For example, if only
     <literal>foo&#045;-1.0&#045;-1.1.sql</> and <literal>foo&#045;-1.1&#045;-2.0.sql</> are
     available, <command>ALTER EXTENSION</> will apply them in sequence if an
     update to version <literal>2.0</> is requested when <literal>1.0</> is
     currently installed.
    </para>
-->
<para>
    <command>ALTER EXTENSION</>能够执行更新
脚本文件序列以实现请求更新。例如，如果只有
<literal>foo--1.0--1.1.sql</>和<literal>foo--1.1--2.0.sql</>可用，
当目前安装的是<literal>1.0</>时，
如果需要更新到版本<literal>2.0</>，
<command>ALTER EXTENSION</>将在序列中应用它们。
</para>

    <!--
<para>
     <productname>PostgreSQL</> doesn't assume anything about the properties
     of version names: for example, it does not know whether <literal>1.1</>
     follows <literal>1.0</>.  It just matches up the available version names
     and follows the path that requires applying the fewest update scripts.
     (A version name can actually be any string that doesn't contain
     <literal>&#045;-</> or leading or trailing <literal>-</>.)
    </para>
-->
<para>
    <productname>PostgreSQL</>不假定任何有关版本名称的属性：
例如，它不知道<literal>1.1</>遵循<literal>1.0</>。
它只匹配可用的版本名称并且
遵循路径要求应用最新的更新脚本。
（一个版本的名称可以是不包含
<literal>--</>或前导或尾随<literal>-</>的任意字符串。）
</para>

    <!--
<para>
     Sometimes it is useful to provide <quote>downgrade</> scripts, for
     example <literal>foo&#045;-1.1&#045;-1.0.sql</> to allow reverting the changes
     associated with version <literal>1.1</>.  If you do that, be careful
     of the possibility that a downgrade script might unexpectedly
     get applied because it yields a shorter path.  The risky case is where
     there is a <quote>fast path</> update script that jumps ahead several
     versions as well as a downgrade script to the fast path's start point.
     It might take fewer steps to apply the downgrade and then the fast
     path than to move ahead one version at a time.  If the downgrade script
     drops any irreplaceable objects, this will yield undesirable results.
    </para>
-->
<para>
    有时提供<quote>downgrade</>脚本是非常有用的，
例如<literal>foo--1.1--1.0.sql</>允许恢复与版本<literal>1.1</>相关的变化。
如果你这样做了，小心downgrade脚本可能会意外地
因它产生一个较短的路径而得以应用的可能性。
风险情况下有一个<quote>快速路径</>更新脚本，向前跳几个版本
以及降级脚本到快速路径的起点。
这可能需要较少的步骤应用降级，然后快速路径向前一次移动一个版本。
如果降级脚本删除任何不可替代的对象，这将产生不良的结果。

</para>

    
<para>
     <!--
     To check for unexpected update paths, use this command:
 -->
 为了检查意外的更新路径，使用这个命令：
 
<programlisting>
SELECT * FROM pg_extension_update_paths('<replaceable>extension_name</>');
</programlisting>
    <!--
     This shows each pair of distinct known version names for the specified
     extension, together with the update path sequence that would be taken to
     get from the source version to the target version, or <literal>NULL</> if
     there is no available update path.  The path is shown in textual form
     with <literal>&#045;-</> separators.  You can use
     <literal>regexp_split_to_array(path,'&#045;-')</> if you prefer an array
     format.
-->
 这显示了已指定扩展的每对不同已知的版本名称，
以及更新路径序列将采取从源版本到目标版本，
或者如果没有可用的更新路径，则为<literal>NULL</>。
路径以带有<literal>--</>分隔符的文本形式显示。
如果你喜欢数组形式，则可以使用<literal>regexp_split_to_array(path,'--')</>。
    </para>

   </sect2>

   <sect2>
   <!--
    <title>Extension Example</title>
   -->
     <title>扩展实例</title>
    <!--
<para>
     Here is a complete example of an <acronym>SQL</>-only
     extension, a two-element composite type that can store any type of value
     in its slots, which are named <quote>k</> and <quote>v</>.  Non-text
     values are automatically coerced to text for storage.
    </para>
-->
<para>
     这是一个<acronym>SQL</>扩展的完整实例，二元复合类型可以存储插槽中的任何类型的值，
被命名为<quote>k</>和<quote>v</>。非-文本值自动强制转换为文本存储。
</para>

    
<para>
    <!--
     The script file <filename>pair&#045;-1.0.sql</> looks like this:
 -->
 脚本文件<filename>pair--1.0.sql</>看起来像：

<programlisting><![CDATA[
-- complain if script is sourced in psql, rather than via CREATE EXTENSION
\echo Use "CREATE EXTENSION pair" to load this file. \quit

CREATE TYPE pair AS ( k text, v text );

CREATE OR REPLACE FUNCTION pair(anyelement, text)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::pair';

CREATE OR REPLACE FUNCTION pair(text, anyelement)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::pair';

CREATE OR REPLACE FUNCTION pair(anyelement, anyelement)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::pair';

CREATE OR REPLACE FUNCTION pair(text, text)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::pair;';

CREATE OPERATOR ~> (LEFTARG = text, RIGHTARG = anyelement, PROCEDURE = pair);
CREATE OPERATOR ~> (LEFTARG = anyelement, RIGHTARG = text, PROCEDURE = pair);
CREATE OPERATOR ~> (LEFTARG = anyelement, RIGHTARG = anyelement, PROCEDURE = pair);
CREATE OPERATOR ~> (LEFTARG = text, RIGHTARG = text, PROCEDURE = pair);
]]>
</programlisting>
    </para>

   
<para>
     <!--
     The control file <filename>pair.control</> looks like this:
     -->
 控制文件<filename>pair.control</>看起来像：
 
<programlisting>
# pair extension
comment = 'A key/value pair data type'
default_version = '1.0'
relocatable = true
</programlisting>
    </para>
    
<para>
     <!--
     While you hardly need a makefile to install these two files into the
     correct directory, you could use a <filename>Makefile</> containing this:
     -->
 当你几乎不需要makefile安装这两个文件到正确目录时，你可以使用
 包含下面内容的<filename>Makefile</>：
 
<programlisting>
EXTENSION = pair
DATA = pair--1.0.sql

PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)
include $(PGXS)
</programlisting>
     <!--
     This makefile relies on <acronym>PGXS</acronym>, which is described
     in <xref linkend="extend-pgxs">.  The command <literal>make install</>
     will install the control and script files into the correct
     directory as reported by <application>pg_config</>.
 -->
 这个makefile依赖于<acronym>PGXS</acronym>，在<xref linkend="extend-pgxs">中描述。
命令<literal>make install</>将安装控制和脚本文件到正确目录，通过<application>pg_config</>
报告。

    </para>

    <!--
<para>
     Once the files are installed, use the
     <xref linkend="sql-createextension"> command to load the objects into
     any particular database.
    </para>
-->
<para>
     一旦安装了这些文件，使用<xref linkend="sql-createextension">命令加载对象到
任何特定数据库。
</para>
   </sect2>
  </sect1>

  <sect1 id="extend-pgxs">
  <!--
   <title>Extension Building Infrastructure</title>
  -->
   <title>扩展基础设施建设</title>
  
   <indexterm zone="extend-pgxs">
    <primary>pgxs</primary>
   </indexterm>

   <!--
<para>
    If you are thinking about distributing your
    <productname>PostgreSQL</> extension modules, setting up a
    portable build system for them can be fairly difficult.  Therefore
    the <productname>PostgreSQL</> installation provides a build
    infrastructure for extensions, called <acronym>PGXS</acronym>, so
    that simple extension modules can be built simply against an
    already installed server.  <acronym>PGXS</acronym> is mainly intended
    for extensions that include C code, although it can be used for
    pure-SQL extensions too.  Note that <acronym>PGXS</acronym> is not
    intended to be a universal build system framework that can be used
    to build any software interfacing to <productname>PostgreSQL</>;
    it simply automates common build rules for simple server extension
    modules.  For more complicated packages, you might need to write your
    own build system.
   </para>
-->
<para>
    如果你正在考虑分配你的<productname>PostgreSQL</>的扩展模块，
为它们设置便携式编译系统相当困难。
因此<productname>PostgreSQL</>安装提供了一个构建
基础设施的扩展，称为<acronym>PGXS</acronym>，所以
这个简单的扩展模块可以在已安装的服务器上简单编译。
<acronym>PGXS</acronym>的主要目的是为了包含C代码的扩展，
虽然它也可以用于纯SQL扩展。
注意：<acronym>PGXS</acronym>不打算
作为一个通用编译系统框架，可用于构建  
任何软件接口到<productname>PostgreSQL</>；
它只是为了简单的服务器扩展模块自动化公共建立规则。
对于更复杂的软件包，您可能需要写入自己的构建系统。
</para>

   
<para>
   <!--
    To use the <acronym>PGXS</acronym> infrastructure for your extension,
    you must write a simple makefile.
    In the makefile, you need to set some variables
    and finally include the global <acronym>PGXS</acronym> makefile.
    Here is an example that builds an extension module named
    <literal>isbn_issn</literal>, consisting of a shared library containing
    some C code, an extension control file, a SQL script, and a documentation
    text file:
-->
为了您的扩展使用<acronym>PGXS</acronym>设施，
你必须写一个简单的makefile。
在makefile中，你需要设置一些变量并且
最后包括全局<acronym>PGXS</acronym> makefile。
下面是一个例子，建立一个<literal>isbn_issn</literal>命名的扩展模块， 
由包含一些C代码，扩展的控制文件，SQL脚本，和文本文件的共享库组成：

<programlisting>
MODULES = isbn_issn
EXTENSION = isbn_issn
DATA = isbn_issn--1.0.sql
DOCS = README.isbn_issn

PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)
include $(PGXS)
</programlisting>
    <!--
    The last three lines should always be the same.  Earlier in the
    file, you assign variables or add custom
    <application>make</application> rules.
-->
最后三行总是相同的。早在文件中，你可以指定变量或者添加自定义<application>make</application>
规则。
   </para>

   
<para>
    <!--
    Set one of these three variables to specify what is built:
-->
    设置这三个变量之一指定建立什么：
 
    <variablelist>
     <varlistentry>
      <term><varname>MODULES</varname></term>
      <listitem>
       <para>
   <!--
        list of shared-library objects to be built from source files with same
        stem (do not include library suffixes in this list)
-->
    从源文件同一地方编译共享库对象列表（不包括列表中的库后缀）   
       </para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>MODULE_big</varname></term>
      <listitem>
       <!--
<para>
        a shared library to build from multiple source files
        (list object files in <varname>OBJS</varname>)
       </para>
-->
<para>
     从多个源文件构建共享库（在<varname>OBJS</varname>中列出对象文件）
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>PROGRAM</varname></term>
      <listitem>
       <!--
<para>
        an executable program to build
        (list object files in <varname>OBJS</varname>)
       </para>
-->
<para>
     建立可执行程序（在<varname>OBJS</varname>中列出对象文件）
</para>
      </listitem>
     </varlistentry>
    </variablelist>
    <!--
    The following variables can also be set:
    -->
下面的变量也可以设置：
    <variablelist>
     <varlistentry>
      <term><varname>EXTENSION</varname></term>
      <listitem>
       <!--
<para>
        extension name(s); for each name you must provide an
        <literal><replaceable>extension</replaceable>.control</literal> file,
        which will be installed into
        <literal><replaceable>prefix</replaceable>/share/extension</literal>
       </para>
-->
<para>
     扩展名：对于每一个名字你必须提供一个<literal><replaceable>extension</replaceable>.control</literal>
文件，它将被安装到<literal><replaceable>prefix</replaceable>/share/extension</literal>中。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>MODULEDIR</varname></term>
      <listitem>
       <!--
<para>
        subdirectory of <literal><replaceable>prefix</>/share</literal>
        into which DATA and DOCS files should be installed
        (if not set, default is <literal>extension</literal> if
        <varname>EXTENSION</varname> is set,
        or <literal>contrib</literal> if not)
       </para>
-->
<para>
     DATA和DOCS文件应该被安装到<literal><replaceable>prefix</>/share</literal>
子目录中（如果没有设置，如果设置<varname>EXTENSION</varname>，
缺省是<literal>extension</literal>。如果没有则为<literal>contrib</literal>）。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>DATA</varname></term>
      <listitem>
       <!--
<para>
        random files to install into <literal><replaceable>prefix</replaceable>/share/$MODULEDIR</literal>
       </para>
-->
<para>
    随机文件安装到<literal><replaceable>prefix</replaceable>/share/$MODULEDIR</literal>。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>DATA_built</varname></term>
      <listitem>
       <!--
<para>
        random files to install into
        <literal><replaceable>prefix</replaceable>/share/$MODULEDIR</literal>,
        which need to be built first
       </para>
-->
<para>
    随机文件安装到<literal><replaceable>prefix</replaceable>/share/$MODULEDIR</literal>，
这首先需要编译。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>DATA_TSEARCH</varname></term>
      <listitem>
       <!--
<para>
        random files to install under
        <literal><replaceable>prefix</replaceable>/share/tsearch_data</literal>
       </para>
-->
<para>
    随机文件安装到<literal><replaceable>prefix</replaceable>/share/tsearch_data</literal>中。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>DOCS</varname></term>
      <listitem>
       <!--
<para>
        random files to install under
        <literal><replaceable>prefix</replaceable>/doc/$MODULEDIR</literal>
       </para>
-->
<para>
    随机文件安装到<literal><replaceable>prefix</replaceable>/doc/$MODULEDIR</literal>
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>SCRIPTS</varname></term>
      <listitem>
       <!--
<para>
        script files (not binaries) to install into
        <literal><replaceable>prefix</replaceable>/bin</literal>
       </para>
-->
<para>
   脚本文件（非二进制数）安装到<literal><replaceable>prefix</replaceable>/bin</literal>中
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>SCRIPTS_built</varname></term>
      <listitem>
       <!--
<para>
        script files (not binaries) to install into
        <literal><replaceable>prefix</replaceable>/bin</literal>,
        which need to be built first
       </para>
-->
<para>
     脚本文件（非二进制数）安装到<literal><replaceable>prefix</replaceable>/bin</literal>，
这需要首先编译。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>REGRESS</varname></term>
      <listitem>
       <!--
<para>
        list of regression test cases (without suffix), see below
       </para>
-->
<para>
      回归测试用例列表（没有后缀），参见下文。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>REGRESS_OPTS</varname></term>
      <listitem>
       <!--
<para>
        additional switches to pass to <application>pg_regress</>
       </para>
-->
<para>
    另外切换到<application>pg_regress</>
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>EXTRA_CLEAN</varname></term>
      <listitem>
       <!--
<para>
        extra files to remove in <literal>make clean</literal>
       </para>
-->
<para>
       <literal>make clean</literal>中删除额外文件
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>PG_CPPFLAGS</varname></term>
      <listitem>
       <!--
<para>
        will be added to <varname>CPPFLAGS</varname>
       </para>
-->
<para>
     被添加到<varname>CPPFLAGS</varname>
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>PG_LIBS</varname></term>
      <listitem>
       <!--
<para>
        will be added to <varname>PROGRAM</varname> link line
       </para>
-->
<para>
       被添加到<varname>PROGRAM</varname>连接线
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>SHLIB_LINK</varname></term>
      <listitem>
       <!--
<para>
        will be added to <varname>MODULE_big</varname> link line
       </para>
-->
<para>
       被添加到<varname>MODULE_big</varname>连接线
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>PG_CONFIG</varname></term>
      <listitem>
       <!--
<para>
        path to <application>pg_config</> program for the
        <productname>PostgreSQL</productname> installation to build against
        (typically just <literal>pg_config</> to use the first one in your
        <varname>PATH</>)
       </para>
-->
<para>
       为了<productname>PostgreSQL</productname>安装编译其路径指向<application>pg_config</>
应用程序（通常<literal>pg_config</>使用你的<varname>PATH</>中的第一个）。
</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <!--
<para>
    Put this makefile as <literal>Makefile</literal> in the directory
    which holds your extension. Then you can do
    <literal>make</literal> to compile, and then <literal>make
    install</literal> to install your module.  By default, the extension is
    compiled and installed for the
    <productname>PostgreSQL</productname> installation that
    corresponds to the first <command>pg_config</command> program
    found in your <varname>PATH</>.  You can use a different installation by
    setting <varname>PG_CONFIG</varname> to point to its
    <command>pg_config</command> program, either within the makefile
    or on the <literal>make</literal> command line.
   </para>
-->
<para>
    把这个makefile作为<literal>Makefile</literal>放在持有你的扩展的目录中。
然后你可以执行<literal>make</literal>编译，
然后<literal>make install</literal>安装模块。默认情况下，为<productname>PostgreSQL</productname>对应于
你的<varname>PATH</>中找到的第一个<command>pg_config</command>程序扩展被
编译安装。你可以通过设置<varname>PG_CONFIG</varname>指向
<command>pg_config</command>程序来使用一个不同的安装，
或者在makefile中或在<literal>make</literal>命令行上。
</para>

   <caution>
    <!--
<para>
     Changing <varname>PG_CONFIG</varname> only works when building
     against <productname>PostgreSQL</productname> 8.3 or later.
     With older releases it does not work to set it to anything except
     <literal>pg_config</>; you must alter your <varname>PATH</>
     to select the installation to build against.
    </para>
-->
<para>
    当编译<productname>PostgreSQL</productname> 8.3或更高版本时，
改变<varname>PG_CONFIG</varname>。老版本不工作设置它除了<literal>pg_config</>；
你必须改变你的<varname>PATH</>来选择编译安装。
</para>
   </caution>

   <!--
<para>
    The scripts listed in the <varname>REGRESS</> variable are used for
    regression testing of your module, which can be invoked by <literal>make
    installcheck</literal> after doing <literal>make install</>.  For this to
    work you must have a running <productname>PostgreSQL</productname> server.
    The script files listed in <varname>REGRESS</> must appear in a
    subdirectory named <literal>sql/</literal> in your extension's directory.
    These files must have extension <literal>.sql</literal>, which must not be
    included in the <varname>REGRESS</varname> list in the makefile.  For each
    test there should also be a file containing the expected output in a
    subdirectory named <literal>expected/</literal>, with the same stem and
    extension <literal>.out</literal>.  <literal>make installcheck</literal>
    executes each test script with <application>psql</>, and compares the
    resulting output to the matching expected file.  Any differences will be
    written to the file <literal>regression.diffs</literal> in <command>diff
    -c</command> format.  Note that trying to run a test that is missing its
    expected file will be reported as <quote>trouble</quote>, so make sure you
    have all expected files.
   </para>
-->
<para>
    在<varname>REGRESS</>变量中列出的脚本用于
你的模块的回归测试，这可以在执行<literal>make install</>之后通过
<literal>make installcheck</literal>调用。
为了可以运行你必须有一个运行的<productname>PostgreSQL</productname>服务器。
在<varname>REGRESS</>中的脚本文件必须出现在您的扩展目录中的<literal>sql/</literal>
命名的子目录中。这些文件必须有扩展<literal>.sql</literal>，
这没有包含在makefile列出的<varname>REGRESS</varname>中。
每个测试还应在<literal>expected/</literal>命名的子目录中包含一个预期的输出文件，
以及相同的词干和扩展<literal>.out</literal>。
<literal>make installcheck</literal>执行每个<application>psql</>的测试脚本，
并且比较结果输出到匹配期望的文件。
任何差异会写入<command>diff -c</command>格式的文件<literal>regression.diffs</literal>中。
请注意，试图运行一个测试，缺少预期的文件将被作为<quote>问题</quote>报告，
所以确保你有所有预期的文件。
</para>

   <tip>
    <!--
<para>
     The easiest way to create the expected files is to create empty files,
     then do a test run (which will of course report differences).  Inspect
     the actual result files found in the <literal>results/</literal>
     directory, then copy them to <literal>expected/</literal> if they match
     what you expect from the test.
    </para>
-->
<para>
     创造期望文件的最简单的方法是创建空文件，
然后做一个测试运行（这当然会报告差异）。检查
在<literal>results/</literal>目录中发现的实际结果文件，如果匹配从这个试验中你期望的，
那么将它们复制到<literal>expected/</literal>。
</para>

   </tip>
  </sect1>

 </chapter>
