<!-- doc/src/sgml/postgres-fdw.sgml -->

<sect1 id="postgres-fdw" xreflabel="postgres_fdw">
<!--==========================orignal english content==========================
 <title>postgres_fdw</title>
____________________________________________________________________________-->
 <title>postgres_fdw</title>

<!--==========================orignal english content==========================
 <indexterm zone="postgres-fdw">
  <primary>postgres_fdw</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="postgres-fdw">
  <primary>postgres_fdw</primary>
 </indexterm>

<!--==========================orignal english content==========================
 <para>
  The <filename>postgres_fdw</filename> module provides the foreign-data wrapper
  <literal>postgres_fdw</literal>, which can be used to access data
  stored in external <productname>PostgreSQL</productname> servers.
 </para>
____________________________________________________________________________-->
 <para>
  <filename>postgres_fdw</filename>模块提供了外部数据包装器<literal>postgres_fdw</literal>，它可以被用来访问存储在外部<productname>PostgreSQL</productname>服务器中的数据。
 </para>

<!--==========================orignal english content==========================
 <para>
  The functionality provided by this module overlaps substantially
  with the functionality of the older <xref linkend="dblink"/> module.
  But <filename>postgres_fdw</filename> provides more transparent and
  standards-compliant syntax for accessing remote tables, and can give
  better performance in many cases.
 </para>
____________________________________________________________________________-->
 <para>
  这个模块提供的功能大体上覆盖了较老的<xref linkend="dblink"/>模块的功能。但是<filename>postgres_fdw</filename>提供了更透明且更兼容标准的语法来访问远程表，并且可以在很多情况下给出更好的性能。
 </para>

<!--==========================orignal english content==========================
 <para>
  To prepare for remote access using <filename>postgres_fdw</filename>:
  <orderedlist spacing="compact">
   <listitem>
    <para>
     Install the  <filename>postgres_fdw</filename> extension using <xref
     linkend="sql-createextension"/>.
    </para>
   </listitem>
   <listitem>
    <para>
     Create a foreign server object, using <xref linkend="sql-createserver"/>,
     to represent each remote database you want to connect to.
     Specify connection information, except <literal>user</literal> and
     <literal>password</literal>, as options of the server object.
    </para>
   </listitem>
   <listitem>
    <para>
     Create a user mapping, using <xref linkend="sql-createusermapping"/>, for
     each database user you want to allow to access each foreign server.
     Specify the remote user name and password to use as
     <literal>user</literal> and <literal>password</literal> options of the
     user mapping.
    </para>
   </listitem>
   <listitem>
    <para>
     Create a foreign table, using <xref linkend="sql-createforeigntable"/>
     or <xref linkend="sql-importforeignschema"/>,
     for each remote table you want to access.  The columns of the foreign
     table must match the referenced remote table.  You can, however, use
     table and/or column names different from the remote table's, if you
     specify the correct remote names as options of the foreign table object.
    </para>
   </listitem>
  </orderedlist>
 </para>
____________________________________________________________________________-->
 <para>
  要使用<filename>postgres_fdw</filename>来为远程访问做准备：
  <orderedlist spacing="compact">
   <listitem>
    <para>
     使用<xref linkend="sql-createextension"/>来安装<filename>postgres_fdw</filename>扩展。
    </para>
   </listitem>
   <listitem>
    <para>
     使用<xref linkend="sql-createserver"/>创建一个外部服务器对象，它用来表示你想连接的每一个远程数据库。指定除了<literal>user</literal>和<literal>password</literal>之外的连接信息作为该服务器对象的选项。
    </para>
   </listitem>
   <listitem>
    <para>
     使用<xref linkend="sql-createusermapping"/>创建一个用户映射，每一个用户映射都代表你想允许一个数据库用户访问一个外部服务器。指定远程用户名和口令作为用户映射的<literal>user</literal>和<literal>password</literal>选项。
    </para>
   </listitem>
   <listitem>
    <para>
     为每一个你想访问的远程表使用<xref linkend="sql-createforeigntable"/>或者<xref linkend="sql-importforeignschema"/>创建一个外部表。外部表的列必须匹配被引用的远程表。但是，如果你在外部表对象的选项中指定了正确的远程名称，你可以使用不同于远程表的表名和/或列名。
    </para>
   </listitem>
  </orderedlist>
 </para>

<!--==========================orignal english content==========================
 <para>
  Now you need only <command>SELECT</command> from a foreign table to access
  the data stored in its underlying remote table.  You can also modify
  the remote table using <command>INSERT</command>, <command>UPDATE</command>, or
  <command>DELETE</command>.  (Of course, the remote user you have specified
  in your user mapping must have privileges to do these things.)
 </para>
____________________________________________________________________________-->
 <para>
  现在你只需要从一个外部表<command>SELECT</command>来访问存储在它的底层的远程表中的数据。你也可以使用<command>INSERT</command>、<command>UPDATE</command>、<command>DELETE</command>或<command>TRUNCATE</command>修改远程表（当然，你在你的用户映射中已经指定的远程用户必须具有做这些事情的权限）。
 </para>
 <para>
   请注意，在访问或修改远程表时, <command>SELECT</command>, <command>UPDATE</command>, <command>DELETE</command>或<command>TRUNCATE</command>中指定的<literal>ONLY</literal>选项没有效果。
  </para>
 
<!--==========================orignal english content==========================
 <para>
  Note that <filename>postgres_fdw</filename> currently lacks support for
  <command>INSERT</command> statements with an <literal>ON CONFLICT DO
  UPDATE</literal> clause.  However, the <literal>ON CONFLICT DO NOTHING</literal>
  clause is supported, provided a unique index inference specification
  is omitted.
  Note also that <filename>postgres_fdw</filename> supports row movement
  invoked by <command>UPDATE</command> statements executed on partitioned
  tables, but it currently does not handle the case where a remote partition
  chosen to insert a moved row into is also an <command>UPDATE</command>
  target partition that will be updated later.
 </para>
____________________________________________________________________________-->
 <para>
  注意当前<filename>postgres_fdw</filename>缺少对于带<literal>ON CONFLICT DO UPDATE</literal>子句的<command>INSERT</command>语句的支持。不过，它支持<literal>ON CONFLICT DO NOTHING</literal>子句，已提供的唯一索引推断说明会被省略。
  请注意，<filename>postgres_fdw</filename>还支持由在分区表上执行的<command>UPDATE</command>语句触发的行移动，但目前不处理远程分区选择插入移动行的情况，并且该远程分区本身也是同一命令中将在其他位置更新的<command>UPDATE</command>目标分区。
 </para>

<!--==========================orignal english content==========================
 <para>
  It is generally recommended that the columns of a foreign table be declared
  with exactly the same data types, and collations if applicable, as the
  referenced columns of the remote table.  Although <filename>postgres_fdw</filename>
  is currently rather forgiving about performing data type conversions at
  need, surprising semantic anomalies may arise when types or collations do
  not match, due to the remote server interpreting <literal>WHERE</literal> clauses
  slightly differently from the local server.
 </para>
____________________________________________________________________________-->
 <para>
  我们通常推荐一个外部表的列被声明为与被引用的远程表列完全相同的数据类型和排序规则（如果可用）。尽管<filename>postgres_fdw</filename>目前已经能够容忍在需要时执行数据类型转换，但是当类型或排序规则不匹配时可能会发生奇怪的语义异常，因为远程服务器解释查询条件时可能会与本地服务器有所不同。
 </para>

<!--==========================orignal english content==========================
 <para>
  Note that a foreign table can be declared with fewer columns, or with a
  different column order, than its underlying remote table has.  Matching
  of columns to the remote table is by name, not position.
 </para>
____________________________________________________________________________-->
 <para>
  注意一个外部表可以被声明比底层的远程表较少的列，或者使用一种不同的列序。与远程表的列匹配是通过名字而不是位置进行的。
 </para>

 <sect2>
<!--==========================orignal english content==========================
  <title>FDW Options of postgres_fdw</title>
____________________________________________________________________________-->
  <title>postgres_fdw 的 FDW 选项</title>

  <sect3>
<!--==========================orignal english content==========================
   <title>Connection Options</title>
____________________________________________________________________________-->
   <title>连接选项</title>

<!--==========================orignal english content==========================
   <para>
    A foreign server using the <filename>postgres_fdw</filename> foreign data wrapper
    can have the same options that <application>libpq</application> accepts in
    connection strings, as described in <xref linkend="libpq-paramkeywords"/>,
    except that these options are not allowed or have special handling:

    <itemizedlist spacing="compact">
     <listitem>
      <para>
       <literal>user</literal>, <literal>password</literal> and <literal>sslpassword</literal> (specify these
       in a user mapping, instead, or use a service file)
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>client_encoding</literal> (this is automatically set from the local
       server encoding)
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>fallback_application_name</literal> (always set to
       <literal>postgres_fdw</literal>)
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>sslkey</literal> and <literal>sslcert</literal> - these may
       appear in <emphasis>either or both</emphasis> a connection and a user
       mapping. If both are present, the user mapping setting overrides the
       connection setting.
      </para>
     </listitem>
    </itemizedlist>
   </para>
____________________________________________________________________________-->
   <para>
    一个使用<filename>postgres_fdw</filename>外部数据包装器的外部服务器可以使用和<application>libpq</application>在连接字符串中能接受的选项，如<xref linkend="libpq-paramkeywords"/>所述，除了这些选项不被允许或有特殊处理：

    <itemizedlist spacing="compact">
     <listitem>
      <para>
       <literal>user</literal>、<literal>password</literal>和<literal>sslpassword</literal>（应该在用户映射中指定这些，或者使用服务文件）
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>client_encoding</literal>（这是自动从本地服务器编码设置）
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>fallback_application_name</literal>（总是设置为<literal>postgres_fdw</literal>）
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>sslkey</literal>和<literal>sslcert</literal> - 这些可能出现在<emphasis>either or both</emphasis>连接和用户映射中。如果两者都存在，则用户映射设置会覆盖连接设置。
      </para>
     </listitem>
    </itemizedlist>
   </para>

<!--==========================orignal english content==========================
   <para>
    Only superusers may create or modify user mappings with the
    <literal>sslcert</literal> or <literal>sslkey</literal> settings.
   </para>
____________________________________________________________________________-->
   <para>
    只有超级用户可以使用<literal>sslcert</literal>或<literal>sslkey</literal>设置创建或修改用户映射。
   </para>
<!--==========================orignal english content==========================
   <para>
    Only superusers may connect to foreign servers without password
    authentication, so always specify the <literal>password</literal> option
    for user mappings belonging to non-superusers.
   </para>
____________________________________________________________________________-->
   <para>
    只有超级用户可以在不经过口令认证的情况下连接到外部服务器，因此应总是为属于非超级用户的用户映射指定<literal>password</literal>选项。
   </para>
<!--==========================orignal english content==========================
   <para>
    A superuser may override this check on a per-user-mapping basis by setting
    the user mapping option <literal>password_required 'false'</literal>, e.g.,
<programlisting>
ALTER USER MAPPING FOR some_non_superuser SERVER loopback_nopw
OPTIONS (ADD password_required 'false');
</programlisting>
    To prevent unprivileged users from exploiting the authentication rights
    of the unix user the postgres server is running as to escalate to superuser
    rights, only the superuser may set this option on a user mapping.
    </para>
____________________________________________________________________________-->
   <para>
    超级用户可以通过设置用户映射选项<literal>password_required 'false'</literal>在每个用户映射的基础上覆盖此检查，例如，
<programlisting>
ALTER USER MAPPING FOR some_non_superuser SERVER loopback_nopw
OPTIONS (ADD password_required 'false');
</programlisting>
    为了防止非特权用户利用正在运行的 postgres 服务器升级到超级用户权限的 unix 用户的身份验证权限，只有超级用户可以在用户映射上设置此选项。
    </para>
<!--==========================orignal english content==========================
    <para>
    Care is required to ensure that this does not allow the mapped
    user the ability to connect as superuser to the mapped database per
    CVE-2007-3278 and CVE-2007-6601. Don't set
    <literal>password_required=false</literal>
    on the <literal>public</literal> role. Keep in mind that the mapped
    user can potentially use any client certificates,
    <filename>.pgpass</filename>,
    <filename>.pg_service.conf</filename> etc in the unix home directory of the
    system user the postgres server runs as. They can also use any trust
    relationship granted by authentication modes like <literal>peer</literal>
    or <literal>ident</literal> authentication.
   </para>
____________________________________________________________________________-->
    <para>
    需要注意确保这不允许映射用户能够根据 CVE-2007-3278 和 CVE-2007-6601 作为超级用户连接到映射数据库。
    不要在<literal>public</literal>角色上设置<literal>password_required=false</literal>。
    请记住，映射的用户可能会使用 postgres 服务器运行的系统用户的 unix 主目录中的任何客户端证书，
    <filename>.pgpass</filename>、<filename>.pg_service.conf</filename>等。
    他们还可以使用由诸如<literal>peer</literal>或<literal>ident</literal>身份验证等身份验证模式授予的任何信任关系。
   </para>
  </sect3>

  <sect3>
<!--==========================orignal english content==========================
   <title>Object Name Options</title>
____________________________________________________________________________-->
   <title>对象名称选项</title>

<!--==========================orignal english content==========================
   <para>
    These options can be used to control the names used in SQL statements
    sent to the remote <productname>PostgreSQL</productname> server.  These
    options are needed when a foreign table is created with names different
    from the underlying remote table's names.
   </para>
____________________________________________________________________________-->
   <para>
    这些选项可以被用来控制使用在被发送到远程<productname>PostgreSQL</productname>服务器的 SQL 语句中使用的名称。当一个外部表被使用不同于底层远程表的名称创建时，就需要这些选项。
   </para>

   <variablelist>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><literal>schema_name</literal></term>
____________________________________________________________________________-->
     <term><literal>schema_name</literal></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       This option, which can be specified for a foreign table, gives the
       schema name to use for the foreign table on the remote server.  If this
       option is omitted, the name of the foreign table's schema is used.
      </para>
____________________________________________________________________________-->
      <para>
       这个选项给出用在远程服务器之上的外部表的模式名称，它可以为一个外部表指定。如果这个选项被忽略，该外部表的模式名称将被使用。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><literal>table_name</literal></term>
____________________________________________________________________________-->
     <term><literal>table_name</literal></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       This option, which can be specified for a foreign table, gives the
       table name to use for the foreign table on the remote server.  If this
       option is omitted, the foreign table's name is used.
      </para>
____________________________________________________________________________-->
      <para>
       这个选项给出用在远程服务器上的外部表给出表名，它可以为一个外部表指定。如果这个选项被忽略，该外部表的名字将被使用。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><literal>column_name</literal></term>
____________________________________________________________________________-->
     <term><literal>column_name</literal></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       This option, which can be specified for a column of a foreign table,
       gives the column name to use for the column on the remote server.
       If this option is omitted, the column's name is used.
      </para>
____________________________________________________________________________-->
      <para>
       这个选项给出用在远程服务器上列的列名，它可以为一个外部表的一个列指定。如果这个选项被忽略，该列的名字将被使用。
      </para>
     </listitem>
    </varlistentry>

   </variablelist>

  </sect3>

  <sect3>
<!--==========================orignal english content==========================
   <title>Cost Estimation Options</title>
____________________________________________________________________________-->
   <title>代价估计选项</title>

<!--==========================orignal english content==========================
   <para>
    <filename>postgres_fdw</filename> retrieves remote data by executing queries
    against remote servers, so ideally the estimated cost of scanning a
    foreign table should be whatever it costs to be done on the remote
    server, plus some overhead for communication.  The most reliable way to
    get such an estimate is to ask the remote server and then add something
    for overhead &mdash; but for simple queries, it may not be worth the cost
    of an additional remote query to get a cost estimate.
    So <filename>postgres_fdw</filename> provides the following options to control
    how cost estimation is done:
   </para>
____________________________________________________________________________-->
   <para>
    <filename>postgres_fdw</filename>通过在远程服务器上执行查询来检索远程数据，因此理想的扫描一个外部表的估计代价应该是在远程服务器上完成它的花销，外加一些通信开销。得到这样一个估计的最可靠的方法是询问远程服务器并加上一些通信开销 &mdash; 但是对于简单查询，不值得为获得一个代价估计而额外使用一次远程查询。因此<filename>postgres_fdw</filename>提供了下列选项来控制如何完成代价估计：
   </para>

   <variablelist>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><literal>use_remote_estimate</literal></term>
____________________________________________________________________________-->
     <term><literal>use_remote_estimate</literal></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       This option, which can be specified for a foreign table or a foreign
       server, controls whether <filename>postgres_fdw</filename> issues remote
       <command>EXPLAIN</command> commands to obtain cost estimates.
       A setting for a foreign table overrides any setting for its server,
       but only for that table.
       The default is <literal>false</literal>.
      </para>
____________________________________________________________________________-->
      <para>
       这个选项控制<filename>postgres_fdw</filename>是否发出<command>EXPLAIN</command>命令来获得代价估计，它可以为一个外部表或一个外部服务器指定。一个外部表的设置会覆盖它的服务器的任何设置，但是只用于这个表。默认值是<literal>false</literal>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><literal>fdw_startup_cost</literal></term>
____________________________________________________________________________-->
     <term><literal>fdw_startup_cost</literal></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       This option, which can be specified for a foreign server, is a numeric
       value that is added to the estimated startup cost of any foreign-table
       scan on that server.  This represents the additional overhead of
       establishing a connection, parsing and planning the query on the
       remote side, etc.
       The default value is <literal>100</literal>.
      </para>
____________________________________________________________________________-->
      <para>
       这个选项是一个要被加到那个服务器上所有外部表扫描的估计启动代价的浮点值。这表示建立一个连接、在远端解析和规查询的额外负荷等。默认值是<literal>100</literal>。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><literal>fdw_tuple_cost</literal></term>
____________________________________________________________________________-->
     <term><literal>fdw_tuple_cost</literal></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       This option, which can be specified for a foreign server, is a numeric
       value that is used as extra cost per-tuple for foreign-table
       scans on that server.  This represents the additional overhead of
       data transfer between servers.  You might increase or decrease this
       number to reflect higher or lower network delay to the remote server.
       The default value is <literal>0.01</literal>.
      </para>
____________________________________________________________________________-->
      <para>
       这个选项是一个浮点值，它被用作那个服务器上外部表扫描的每元组额外代价，它可以为一个外部服务器指定。这表示在服务器之间数据传输的额外负荷。你可以增加或减少这个数来反映到远程服务器更高或更低的网络延迟。默认值是<literal>0.01</literal>。
      </para>
     </listitem>
    </varlistentry>

   </variablelist>

<!--==========================orignal english content==========================
   <para>
    When <literal>use_remote_estimate</literal> is true,
    <filename>postgres_fdw</filename> obtains row count and cost estimates from the
    remote server and then adds <literal>fdw_startup_cost</literal> and
    <literal>fdw_tuple_cost</literal> to the cost estimates.  When
    <literal>use_remote_estimate</literal> is false,
    <filename>postgres_fdw</filename> performs local row count and cost estimation
    and then adds <literal>fdw_startup_cost</literal> and
    <literal>fdw_tuple_cost</literal> to the cost estimates.  This local
    estimation is unlikely to be very accurate unless local copies of the
    remote table's statistics are available.  Running
    <xref linkend="sql-analyze"/> on the foreign table is the way to update
    the local statistics; this will perform a scan of the remote table and
    then calculate and store statistics just as though the table were local.
    Keeping local statistics can be a useful way to reduce per-query planning
    overhead for a remote table &mdash; but if the remote table is
    frequently updated, the local statistics will soon be obsolete.
   </para>
____________________________________________________________________________-->
   <para>
    当<literal>use_remote_estimate</literal>为真时，<filename>postgres_fdw</filename>从远程服务器获得行计数和代价估计，然后在代价估计上加上<literal>fdw_startup_cost</literal>和<literal>fdw_tuple_cost</literal>。当<literal>use_remote_estimate</literal>为假时，<filename>postgres_fdw</filename>执行本地行计数和代价估计，并且接着在代价估计上加上<literal>fdw_startup_cost</literal> 和<literal>fdw_tuple_cost</literal>。这种本地估计不会很准确，除非有远程表统计数据的本地拷贝可用。在外部表上运行<xref linkend="sql-analyze"/>是更新本地统计数据的方法，这将执行远程表的一次扫描并接着计算和存储统计数据，就好像表在本地一样。保留本地统计数据可能是一种有用的方法来减少一个远程表的预查询规划负荷 &mdash; 但是如果远程表被频繁更新，本地统计数据将很快就被废弃。
   </para>

  </sect3>
  
  <sect3>
<!--==========================orignal english content==========================
   <title>Remote Execution Options</title>
____________________________________________________________________________-->
   <title>远程执行选项</title>

<!--==========================orignal english content==========================
   <para>
    By default, only <literal>WHERE</literal> clauses using built-in operators and
    functions will be considered for execution on the remote server.  Clauses
    involving non-built-in functions are checked locally after rows are
    fetched.  If such functions are available on the remote server and can be
    relied on to produce the same results as they do locally, performance can
    be improved by sending such <literal>WHERE</literal> clauses for remote
    execution.  This behavior can be controlled using the following option:
   </para>
____________________________________________________________________________-->
   <para>
    默认情况下，只有使用了内建操作符和函数的<literal>WHERE</literal>子句才会被考虑在远程服务器上执行。涉及非内建函数的子句将会在取完行后在本地进行检查。如果这类函数在远程服务器上可用并且可以用来产生和本地执行时一样的结果，则可以通过将这种<literal>WHERE</literal>子句发送到远程执行来提高性能。可以用下面的选项控制这种行为：
   </para>

   <variablelist>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><literal>extensions</literal></term>
____________________________________________________________________________-->
     <term><literal>extensions</literal></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       This option is a comma-separated list of names
       of <productname>PostgreSQL</productname> extensions that are installed, in
       compatible versions, on both the local and remote servers.  Functions
       and operators that are immutable and belong to a listed extension will
       be considered shippable to the remote server.
       This option can only be specified for foreign servers, not per-table.
      </para>
____________________________________________________________________________-->
      <para>
       这个选项是一个用逗号分隔的已安装的<productname>PostgreSQL</productname>扩展名称列表，这些扩展在本地和远程服务器上具有兼容的版本。属于一个该列表中扩展的 immutable 函数和操作符将被考虑转移到远程服务器上执行。这个选项只能为外部服务器指定，无法逐个表指定。
      </para>

<!--==========================orignal english content==========================
      <para>
       When using the <literal>extensions</literal> option, <emphasis>it is the
       user's responsibility</emphasis> that the listed extensions exist and behave
       identically on both the local and remote servers.  Otherwise, remote
       queries may fail or behave unexpectedly.
      </para>
____________________________________________________________________________-->
      <para>
       在使用<literal>extensions</literal>选项时，<emphasis>用户应该负责确保</emphasis>列出的扩展在本地和远程服务器上都存在且保持一致。否则，远程查询可能失败或者行为异常。
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><literal>fetch_size</literal></term>
____________________________________________________________________________-->
     <term><literal>fetch_size</literal></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       This option specifies the number of rows <filename>postgres_fdw</filename>
       should get in each fetch operation. It can be specified for a foreign
       table or a foreign server. The option specified on a table overrides
       an option specified for the server.
       The default is <literal>100</literal>.
      </para>
____________________________________________________________________________-->
      <para>
       这个选项指定在每次获取行的操作中<filename>postgres_fdw</filename>应该得到的行数。可以为一个外部表或者外部服务器指定这个选项。在表上指定的选项将会覆盖在服务器级别上指定的选项。默认值为<literal>100</literal>。
      </para>
     </listitem>
    </varlistentry>

  <varlistentry>
       <term><literal>batch_size</literal></term>
       <listitem>
        <para>
         这个选项指定了每次插入操作中<filename>postgres_fdw</filename>的行数。应该在每个插入操作中插入多少行。它可以被指定为一个
         可以为一个外域表或一个外域服务器指定。在一个表上指定的选项覆盖为服务器指定的选项，默认是<literal>1</literal>。
        </para>

        <para>
         请注意，<filename>postgres_fdw</filename>一次插入的实际行数取决于列数和提供的数据。
         取决于列的数量和提供的
         <literal>batch_size</literal>值。这个批处理是作为一个单一的
         查询，并且libpq协议（<filename>postgres_fdw</filename>用来连接到远程服务器）。
         用于连接到远程服务器）将单个查询中的参数数量限制为65535。
         单个查询的参数数量限制为65535。当列的数量*<literal>batch_size</literal>
         超过限制时，<literal>batch_size</literal>将被调整以避免错误。
         避免出错。
        </para>
       </listitem>
      </para>
   </varlistentry>
   </variablelist>

  </sect3>

  <sect3>
     <title>Asynchronous Execution Options</title>

     <para>
      <filename>postgres_fdw</filename> 支持异步执行，可以并发地运行一个 <structname>Append</structname> 节点的多个部分，相比串行化的方式能获得更好的性能提升。可以使用以下选项来控制该执行行为：
     </para>

     <variablelist>

      <varlistentry>
       <term><literal>async_capable</literal></term>
       <listitem>
        <para>
         这个选项控制<filename>postgres_fdw</filename>是否允许异步执行的外部表被同时扫描。它可以为一个外部表或一个外部服务器指定。一个表级的选项覆盖一个服务器级的选项。默认是<literal>false</literal>。
        </para>

        <para>
        为了确保从外部服务器返回的数据一致性，<filename>postgres_fdw</filename> 只会为一个特定的外部服务器打开一个连接，并且顺序运行所有针对该服务器的查询，即使涉及多个外部表也是如此，除非这些表受不同用户映射的影响。在这种情况下，禁用此选项可能更有效，以消除运行异步查询所带来的开销。
        </para>

        <para>
        在一个<structname>Append</structname>节点中，即使有部分子计划是同步执行，也有部分子计划是异步执行，异步执行仍被应用。在这种情况下，如果异步子计划是使用<filename>postgres_fdw</filename>处理的，则需要等到至少有一个同步子计划返回所有元组，才能返回异步子计划的元组，因为当异步子计划等待发送给外部服务器的异步查询的结果时，同步子计划正在执行。该行为可能会在未来的版本中更改。
        </para>
       </listitem>
      </varlistentry>

     </variablelist>
    </sect3>

  <sect3>
<!--==========================orignal english content==========================
   <title>Updatability Options</title>
____________________________________________________________________________-->
   <title>可更新性选项</title>

<!--==========================orignal english content==========================
   <para>
    By default all foreign tables using <filename>postgres_fdw</filename> are assumed
    to be updatable.  This may be overridden using the following option:
   </para>
____________________________________________________________________________-->
   <para>
    默认情况下，所有使用<filename>postgres_fdw</filename>的外部表都被假定是可更新的。这可以使用下列选项覆盖：
   </para>

   <variablelist>

    <varlistentry>
<!--==========================orignal english content==========================
     <term><literal>updatable</literal></term>
____________________________________________________________________________-->
     <term><literal>updatable</literal></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       This option controls whether <filename>postgres_fdw</filename> allows foreign
       tables to be modified using <command>INSERT</command>, <command>UPDATE</command> and
       <command>DELETE</command> commands.  It can be specified for a foreign table
       or a foreign server.  A table-level option overrides a server-level
       option.
       The default is <literal>true</literal>.
      </para>
____________________________________________________________________________-->
      <para>
       这个选项控制<filename>postgres_fdw</filename>是否允许外部表被使用<command>INSERT</command>、<command>UPDATE</command>和<command>DELETE</command>命令更新。它可以为一个外部表或一个外部服务器指定。一个表级选项会覆盖一个服务器级选项。默认值是<literal>true</literal>。
      </para>

<!--==========================orignal english content==========================
      <para>
       Of course, if the remote table is not in fact updatable, an error
       would occur anyway.  Use of this option primarily allows the error to
       be thrown locally without querying the remote server.  Note however
       that the <literal>information_schema</literal> views will report a
       <filename>postgres_fdw</filename> foreign table to be updatable (or not)
       according to the setting of this option, without any check of the
       remote server.
      </para>
____________________________________________________________________________-->
      <para>
       当然，如果远程表实际上并非可更新的，将产生一个错误。这个选项的使用主要是允许在不查询远程服务器的情况下在本地抛出错误。但是要注意<literal>information_schema</literal>视图会根据这个选项的设置报告一个<filename>postgres_fdw</filename>外部表是可更新的（或者不可更新），而不需要远程服务器的任何检查。
      </para>
     </listitem>
    </varlistentry>

   </variablelist>

  </sect3>
    <sect3>
     <title>Truncatability Options</title>

     <para>
     默认情况下，使用 <filename>postgres_fdw</filename> 的所有外部表都被认为是可截断的。可以使用以下选项覆盖该行为：
     </para>

     <variablelist>

      <varlistentry>
       <term><literal>truncatable</literal></term>
       <listitem>
        <para>
        此选项控制<filename>postgres_fdw</filename>是否允许使用 <command>TRUNCATE</command> 命令截断外部表。它可以指定为外部表或外部服务器。 表级别的选项将覆盖服务器级别的选项。默认值为<literal>true</literal>。
        </para>

        <para>
         当然，如果远程表实际上无法被清空，那么就会出现错误。该选项的使用主要可以在不查询远程服务器的情况下本地抛出错误。
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </sect3>

  <sect3>
<!--==========================orignal english content==========================
   <title>Importing Options</title>
____________________________________________________________________________-->
   <title>导入选项</title>

<!--==========================orignal english content==========================
   <para>
    <filename>postgres_fdw</filename> is able to import foreign table definitions
    using <xref linkend="sql-importforeignschema"/>.  This command creates
    foreign table definitions on the local server that match tables or
    views present on the remote server.  If the remote tables to be imported
    have columns of user-defined data types, the local server must have
    compatible types of the same names.
   </para>
____________________________________________________________________________-->
   <para>
    <filename>postgres_fdw</filename>能使用<xref linkend="sql-importforeignschema"/>导入外部表定义。这个命令会在本地服务器上创建外部表定义，这个定义能匹配存在于远程服务器上的表或者视图。如果要被导入的远程表有用户自定义数据类型的列，本地服务器上也必须具有相同名称的兼容类型。
   </para>

<!--==========================orignal english content==========================
   <para>
    Importing behavior can be customized with the following options
    (given in the <command>IMPORT FOREIGN SCHEMA</command> command):
   </para>
____________________________________________________________________________-->
   <para>
    导入行为可以用下列选项自定义（在<command>IMPORT FOREIGN SCHEMA</command>命令中给出）：
   </para>

   <variablelist>
    <varlistentry>
<!--==========================orignal english content==========================
     <term><literal>import_collate</literal></term>
____________________________________________________________________________-->
     <term><literal>import_collate</literal></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       This option controls whether column <literal>COLLATE</literal> options
       are included in the definitions of foreign tables imported
       from a foreign server. The default is <literal>true</literal>.  You might
       need to turn this off if the remote server has a different set of
       collation names than the local server does, which is likely to be the
       case if it's running on a different operating system.
      </para>
____________________________________________________________________________-->
      <para>
       这个选项控制是否在从外部服务器导入的外部表定义中包括列的<literal>COLLATE</literal>选项。默认是<literal>true</literal>。如果远程服务器具有和本地服务器不同的排序规则名集合，可能需要关闭这个选项，在不同的操作系统上运行时很可能就是这样。
       这么做，然而有一个非常严重的风险，即导入表的列排序规则(collations)将不匹配基础数据，从而导致异常的查询行为。
      </para>

      <para>
       即使此参数设置为<literal>true</literal>，导入远程服务器默认排序规则的列也存在风险。它们将以<literal>COLLATE "default"</literal>被导入，这将选择本地服务器的默认排序规则，而这可能是不同的。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
<!--==========================orignal english content==========================
     <term><literal>import_default</literal></term>
____________________________________________________________________________-->
     <term><literal>import_default</literal></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       This option controls whether column <literal>DEFAULT</literal> expressions
       are included in the definitions of foreign tables imported
       from a foreign server. The default is <literal>false</literal>.  If you
       enable this option, be wary of defaults that might get computed
       differently on the local server than they would be on the remote
       server; <function>nextval()</function> is a common source of problems.
       The <command>IMPORT</command> will fail altogether if an imported default
       expression uses a function or operator that does not exist locally.
      </para>
____________________________________________________________________________-->
      <para>
       这个选项控制是否在从外部服务器导入的外部表定义中包括列的<literal>DEFAULT</literal>表达式。默认是<literal>false</literal>。如果启用这个选项，要当心在远程服务器和本地服务器上计算表达式的方式不同，<function>nextval()</function>常会导致这类问题。如果导入的默认值表达式使用了一个本地不存在的函数或者操作符，<command>IMPORT</command>将整个失败。
      </para>
     </listitem>
    </varlistentry>
    <varlistentry>
         <term><literal>import_generated</literal></term>
         <listitem>
          <para>
          此选项控制导入自外部服务器的外部表定义是否包括列 <literal>GENERATED</literal> 表达式。 默认值为 <literal>true</literal>，如果导入的生成表达式使用本地不存在的函数或运算符，则整个 <command>IMPORT</command> 将失败。
          </para>
         </listitem>
        </varlistentry>
    <varlistentry>
<!--==========================orignal english content==========================
     <term><literal>import_not_null</literal></term>
____________________________________________________________________________-->
     <term><literal>import_not_null</literal></term>
     <listitem>
<!--==========================orignal english content==========================
      <para>
       This option controls whether column <literal>NOT NULL</literal>
       constraints are included in the definitions of foreign tables imported
       from a foreign server. The default is <literal>true</literal>.
      </para>
____________________________________________________________________________-->
      <para>
       这个选项控制是否在从外部服务器导入的外部表定义中包括列的<literal>NOT NULL</literal>约束。默认是<literal>true</literal>。
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

<!--==========================orignal english content==========================
   <para>
    Note that constraints other than <literal>NOT NULL</literal> will never be
    imported from the remote tables.  Although <productname>PostgreSQL</productname>
    does support <literal>CHECK</literal> constraints on foreign tables, there is no
    provision for importing them automatically, because of the risk that a
    constraint expression could evaluate differently on the local and remote
    servers.  Any such inconsistency in the behavior of a <literal>CHECK</literal>
    constraint could lead to hard-to-detect errors in query optimization.
    So if you wish to import <literal>CHECK</literal> constraints, you must do so
    manually, and you should verify the semantics of each one carefully.
    For more detail about the treatment of <literal>CHECK</literal> constraints on
    foreign tables, see <xref linkend="sql-createforeigntable"/>.
   </para>
____________________________________________________________________________-->
   <para>
    注意除<literal>NOT NULL</literal>之外的约束将不会从远程表中导入。虽然<productname>PostgreSQL</productname>确实支持外部表上的检查约束，但不会自动导入它们，因为存在本地和远程服务器计算约束表达式方式不同的风险。检查约束中的任何这类不一致都可能导致查询优化中很难检测的错误。因此，如果你希望导入检查约束，你必须手工来做，并且你应该仔细地验证每一个这种约束的语义。有关处理外部表上检查约束的更多细节，请见<xref linkend="sql-createforeigntable"/>。
   </para>

<!--==========================orignal english content==========================
   <para>
    Tables or foreign tables which are partitions of some other table are
    automatically excluded.  Partitioned tables are imported, unless they
    are a partition of some other table.  Since all data can be accessed
    through the partitioned table which is the root of the partitioning
    hierarchy, this approach should allow access to all the data without
    creating extra objects.
   </para>
____________________________________________________________________________-->
   <para>
   作为其他表的分区的表或外部表只在明确指定它们在限制为<literal>LIMIT TO</literal>子句中时才被导入。否则，它们将自动从<xref linkend="sql-importforeignschema"/>中排除。由于可以通过分区层次结构的根即分区表来访问所有数据，因此仅导入分区表应该允许访问所有数据而不创建额外的对象。
   </para>

   </sect3>
   <sect3>
       <title>Connection Management Options</title>

       <para>
        默认情况下，<filename>postgres_fdw</filename>连接到外部服务器的所有连接都保持打开状态以便于重复使用。
       </para>

       <variablelist>

        <varlistentry>
         <term><literal>keep_connections</literal></term>
         <listitem>
          <para>
          该选项控制<filename>postgres_fdw</filename>是否保持与外部服务器的连接，以便后续查询可以重复使用它们。它仅适用于外部服务器。默认情况下为<literal>on</literal>。如果设置为<literal>off</literal>，则每个事务结束时将丢弃到该外部服务器的所有连接。
         </para>
         </listitem>
        </varlistentry>

       </variablelist>
      </sect3>
 </sect2>

<sect2>
  <title>Functions</title>

  <variablelist>
   <varlistentry>
    <term><function>postgres_fdw_get_connections(OUT server_name text, OUT valid boolean) returns setof record</function></term>
    <listitem>
     <para>
      该函数返回所有由本地会话到外部服务器<filename>postgres_fdw</filename>建立的开放连接的外部服务器名称。此外，它还返回每个连接是否有效。如果当前本地事务中使用外部服务器连接，但其外部服务器或用户映射已更改或删除，则返回<literal>false</literal>（注：如果服务器已删除，则无效连接的服务器名称将为<literal>NULL</literal>），然后这些无效连接将在该事务结束时关闭。否则将返回<literal>true</literal>。如果没有打开的连接，则不返回记录。该函数的示例用法：
<screen>
postgres=# SELECT * FROM postgres_fdw_get_connections() ORDER BY 1;
 server_name | valid
-------------+-------
 loopback1   | t
 loopback2   | f
</screen>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><function>postgres_fdw_disconnect(server_name text) returns boolean</function></term>
    <listitem>
     <para>
     该函数从本地会话到给定名称的外部服务器上使用的所有由<filename>postgres_fdw</filename>建立的连接。注意，可以使用不同的用户映射在给定服务器上建立多个连接。如果在当前本地事务中使用了这些连接，则它们不会被断开，并报告警告消息。如果至少断开一个连接，此功能将返回<literal>true</literal>，否则返回<literal>false</literal>。如果找不到具有给定名称的外部服务器，将报告错误。该函数的示例用法：
<screen>
postgres=# SELECT postgres_fdw_disconnect('loopback1');
 postgres_fdw_disconnect
-------------------------
 t
</screen>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><function>postgres_fdw_disconnect_all() returns boolean</function></term>
    <listitem>
     <para>
     该函数会从本地会话到外部服务器断开<filename>postgres_fdw</filename>建立的所有连接。如果这些连接在当前事务中使用，则不会断开并报告警告消息。如果至少断开了一个连接，则该函数返回<literal>true</literal>，否则返回<literal>false</literal>。 返回该函数的用例示例：
<screen>
postgres=# SELECT postgres_fdw_disconnect_all();
 postgres_fdw_disconnect_all
-----------------------------
 t
</screen>
     </para>
    </listitem>
   </varlistentry>
   </variablelist>

</sect2>

 <sect2>
<!--==========================orignal english content==========================
  <title>Connection Management</title>
____________________________________________________________________________-->
  <title>连接管理</title>

<!--==========================orignal english content==========================
  <para>
   <filename>postgres_fdw</filename> establishes a connection to a
   foreign server during the first query that uses a foreign table
   associated with the foreign server.  This connection is kept and
   re-used for subsequent queries in the same session.  However, if
   multiple user identities (user mappings) are used to access the foreign
   server, a connection is established for each user mapping.
  </para>
____________________________________________________________________________-->
  <para>
   <filename>postgres_fdw</filename>在第一个使用关联到外部服务器的外部表的查询期间建立一个到外部服务器的连接。默认地这个连接会被保持，并被重用于同一个会话中的后续查询。这个行为可以通过外部服务器的<literal>keep_connections</literal>选项来控制，如果使用了多个用户实体（用户映射）来访问外部服务器，会为每一个用户映射建立一个连接。
  </para>
  <para>
   当更改外部服务器或用户映射的定义或删除它们时，相关的连接可能会关闭。但是请注意，如果在当前本地事务中使用任何连接，则将其保留到事务结束。已关闭的连接将在未来使用一个外部表的查询时重新建立。
  </para>
  <para>
     一旦与外部服务器建立了连接，默认情况下会一直保持直到相应本地或远程会话退出。如果想显式断开一个连接，可以将外部服务器的<literal>keep_connections</literal> 选项禁用，或使用<function>postgres_fdw_disconnect</function> 和<function>postgres_fdw_disconnect_all</function>函数。例如，这些函数对于关闭不再需要的连接很有用，从而释放外部服务器上的连接。
  </para>
 </sect2>

 <sect2>
<!--==========================orignal english content==========================
  <title>Transaction Management</title>
____________________________________________________________________________-->
  <title>事务管理</title>

<!--==========================orignal english content==========================
  <para>
   During a query that references any remote tables on a foreign server,
   <filename>postgres_fdw</filename> opens a transaction on the
   remote server if one is not already open corresponding to the current
   local transaction.  The remote transaction is committed or aborted when
   the local transaction commits or aborts.  Savepoints are similarly
   managed by creating corresponding remote savepoints.
  </para>
____________________________________________________________________________-->
  <para>
   在一个引用外部服务器上任何远程表的查询期间，如果还没有根据当前的本地事务打开一个远程事务，<filename>postgres_fdw</filename>将在远程服务器上打开一个事务。当本地事务提交或中止时，远程事务也被提交或中止。保存点也相似地采用创建相应的远程保存点来管理。
  </para>

<!--==========================orignal english content==========================
  <para>
   The remote transaction uses <literal>SERIALIZABLE</literal>
   isolation level when the local transaction has <literal>SERIALIZABLE</literal>
   isolation level; otherwise it uses <literal>REPEATABLE READ</literal>
   isolation level.  This choice ensures that if a query performs multiple
   table scans on the remote server, it will get snapshot-consistent results
   for all the scans.  A consequence is that successive queries within a
   single transaction will see the same data from the remote server, even if
   concurrent updates are occurring on the remote server due to other
   activities.  That behavior would be expected anyway if the local
   transaction uses <literal>SERIALIZABLE</literal> or <literal>REPEATABLE READ</literal>
   isolation level, but it might be surprising for a <literal>READ
   COMMITTED</literal> local transaction.  A future
   <productname>PostgreSQL</productname> release might modify these rules.
  </para>
____________________________________________________________________________-->
  <para>
   当本地事务为<literal>SERIALIZABLE</literal>隔离级别时，远程事务使用<literal>SERIALIZABLE</literal>隔离级别；否则它使用<literal>REPEATABLE READ</literal>隔离级别。如果一个查询在远程服务器上执行多个表查询，这种选择保证它将为所有扫描得到快照一致的结果。一种后果是在单一事务中的后继查询将会看到来自远程服务器的相同数据，即便由于其他活动在远程服务器上发生了其他并发更新。如果本地事务使用<literal>SERIALIZABLE</literal>或<literal>REPEATABLE READ</literal>隔离级别，这种行为也是可以预期的，但是对于一个<literal>READ COMMITTED</literal>本地事务它是奇怪的。一个未来的<productname>PostgreSQL</productname>发布可能会修改这些规则。
  </para>

<!--==========================orignal english content==========================
  <para>
   Note that it is currently not supported by
   <filename>postgres_fdw</filename> to prepare the remote transaction for
   two-phase commit.
  </para>
____________________________________________________________________________-->
  <para>
   请注意<filename>postgres_fdw</filename>当前不支持为两阶段提交准备远程事务。
  </para>
 </sect2>

 <sect2>
<!--==========================orignal english content==========================
  <title>Remote Query Optimization</title>
____________________________________________________________________________-->
  <title>远程查询优化</title>

<!--==========================orignal english content==========================
  <para>
   <filename>postgres_fdw</filename> attempts to optimize remote queries to reduce
   the amount of data transferred from foreign servers.  This is done by
   sending query <literal>WHERE</literal> clauses to the remote server for
   execution, and by not retrieving table columns that are not needed for
   the current query.  To reduce the risk of misexecution of queries,
   <literal>WHERE</literal> clauses are not sent to the remote server unless they use
   only data types, operators, and functions that are built-in or belong to an
   extension that's listed in the foreign server's <literal>extensions</literal>
   option.  Operators and functions in such clauses must
   be <literal>IMMUTABLE</literal> as well.
   For an <command>UPDATE</command> or <command>DELETE</command> query,
   <filename>postgres_fdw</filename> attempts to optimize the query execution by
   sending the whole query to the remote server if there are no query
   <literal>WHERE</literal> clauses that cannot be sent to the remote server,
   no local joins for the query, no row-level local <literal>BEFORE</literal> or
   <literal>AFTER</literal> triggers or stored generated columns on the target
   table, and no <literal>CHECK OPTION</literal> constraints from parent
   views.  In <command>UPDATE</command>,
   expressions to assign to target columns must use only built-in data types,
   <literal>IMMUTABLE</literal> operators, or <literal>IMMUTABLE</literal> functions,
   to reduce the risk of misexecution of the query.
  </para>
____________________________________________________________________________-->
  <para>
   <filename>postgres_fdw</filename>尝试优化远程查询来减少从外部服务器传来的数据量。这可以通过把查询的<literal>WHERE</literal>子句发送给远程服务器执行来完成，并且还可以不检索当前查询不需要的表列。为了降低查询被误执行的风险，除非<literal>WHERE</literal>子句使用的数据类型、操作符和函数都是内建的或者属于列在该外部服务器的<literal>extensions</literal>选项中的一个扩展，将不会把<literal>WHERE</literal>子句发送到远程服务器。这些子句中的操作符合函数也必须是<literal>IMMUTABLE</literal>。对于<command>UPDATE</command>或者<command>DELETE</command>查询，
   如果没有不能发送给远程服务器的<literal>WHERE</literal>子句、
   没有查询的本地连接、目标表上没有本地的行级<literal>BEFORE</literal>或<literal>AFTER</literal>触发器或存储生成的列，
   并且没有来自父视图的<literal>CHECK OPTION</literal>约束，<filename>postgres_fdw</filename>会尝试通过将整个查询发送给远程服务器来优化查询的执行。在<command>UPDATE</command>中，赋值给目标列的表达式只能使用内建数据类型、<literal>IMMUTABLE</literal>操作符或者<literal>IMMUTABLE</literal>操作符，这样能降低查询被误执行的风险。
  </para>

<!--==========================orignal english content==========================
  <para>
   When <filename>postgres_fdw</filename> encounters a join between foreign tables on
   the same foreign server, it sends the entire join to the foreign server,
   unless for some reason it believes that it will be more efficient to fetch
   rows from each table individually, or unless the table references involved
   are subject to different user mappings.  While sending the <literal>JOIN</literal>
   clauses, it takes the same precautions as mentioned above for the
   <literal>WHERE</literal> clauses.
  </para>
____________________________________________________________________________-->
  <para>
   当<filename>postgres_fdw</filename>碰到同一个外部服务器上的外部表之间的连接时，它会把整个连接发送给外部服务器，除非由于某些原因它认为逐个从每一个表取得行的效率更高或者涉及的表引用属于不同的用户映射。在发送<literal>JOIN</literal>子句时，它也会采取和上述<literal>WHERE</literal>子句相同的预防措施。
  </para>

<!--==========================orignal english content==========================
  <para>
   The query that is actually sent to the remote server for execution can
   be examined using <command>EXPLAIN VERBOSE</command>.
  </para>
____________________________________________________________________________-->
  <para>
   实际被发送到远程服务器执行的查询可以使用<command>EXPLAIN VERBOSE</command>来检查。
  </para>
 </sect2>
 
 <sect2>
<!--==========================orignal english content==========================
  <title>Remote Query Execution Environment</title>
____________________________________________________________________________-->
  <title>远程查询执行环境</title>

<!--==========================orignal english content==========================
  <para>
   In the remote sessions opened by <filename>postgres_fdw</filename>,
   the <xref linkend="guc-search-path"/> parameter is set to
   just <literal>pg_catalog</literal>, so that only built-in objects are visible
   without schema qualification.  This is not an issue for queries
   generated by <filename>postgres_fdw</filename> itself, because it always
   supplies such qualification.  However, this can pose a hazard for
   functions that are executed on the remote server via triggers or rules
   on remote tables.  For example, if a remote table is actually a view,
   any functions used in that view will be executed with the restricted
   search path.  It is recommended to schema-qualify all names in such
   functions, or else attach <literal>SET search_path</literal> options
   (see <xref linkend="sql-createfunction"/>) to such functions
   to establish their expected search path environment.
  </para>
____________________________________________________________________________-->
  <para>
   在<filename>postgres_fdw</filename>开启的远程会话中，<xref linkend="guc-search-path"/>参数只被设置为<literal>pg_catalog</literal>，因此只有内建对象可以在无模式限定时可见。这对于<filename>postgres_fdw</filename>本身产生的查询来说不是问题，因为它总是会提供这样的限定。不过，这可能会对在远程服务器上通过触发器或者远程表上的规则执行的函数带来灾难。例如，如果一个远程表实际是一个视图，任何在该视图中使用的函数都将被在这个受限的搜索路径中执行。我们推荐在这类函数中用模式限定所有名称，或者为这类函数附着<literal>SET search_path</literal>选项（见<xref linkend="sql-createfunction"/>）来建立它们所期望的搜索路径环境。
  </para>

<!--==========================orignal english content==========================
  <para>
   <filename>postgres_fdw</filename> likewise establishes remote session settings
   for various parameters:
   <itemizedlist spacing="compact">
    <listitem>
     <para>
      <xref linkend="guc-timezone"/> is set to <literal>UTC</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      <xref linkend="guc-datestyle"/> is set to <literal>ISO</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      <xref linkend="guc-intervalstyle"/> is set to <literal>postgres</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      <xref linkend="guc-extra-float-digits"/> is set to <literal>3</literal> for remote
      servers 9.0 and newer and is set to <literal>2</literal> for older versions
     </para>
    </listitem>
   </itemizedlist>
   These are less likely to be problematic than <varname>search_path</varname>, but
   can be handled with function <literal>SET</literal> options if the need arises.
  </para>
____________________________________________________________________________-->
  <para>
   <filename>postgres_fdw</filename>同样为各种参数建立远程会话设置：
   <itemizedlist spacing="compact">
    <listitem>
     <para>
      <xref linkend="guc-timezone"/>设置为<literal>UTC</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      <xref linkend="guc-datestyle"/>设置为<literal>ISO</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      <xref linkend="guc-intervalstyle"/>设置为<literal>postgres</literal>
     </para>
    </listitem>
    <listitem>
     <para>
      对于远程服务器9.0和更新版本，<xref linkend="guc-extra-float-digits"/>
	  设置为<literal>3</literal>，并且针对更老版本设置为<literal>2</literal>
     </para>
    </listitem>
   </itemizedlist>
   这些不如<varname>search_path</varname>有那么多问题，但是如果需要也可以使用函数
   <literal>SET</literal>选项来处理。
  </para>
   
<!--==========================orignal english content==========================
  <para>
   It is <emphasis>not</emphasis> recommended that you override this behavior by
   changing the session-level settings of these parameters; that is likely
   to cause <filename>postgres_fdw</filename> to malfunction.
  </para>
____________________________________________________________________________-->
  <para>
   我们<emphasis>不</emphasis>推荐通过更改这些参数的会话级设置来推翻这种行为，这很可能会导致<filename>postgres_fdw</filename>故障。
  </para>
 </sect2>

 <sect2>
<!--==========================orignal english content==========================
  <title>Cross-Version Compatibility</title>
____________________________________________________________________________-->
  <title>跨版本兼容性</title>

<!--==========================orignal english content==========================
  <para>
   <filename>postgres_fdw</filename> can be used with remote servers dating back
   to <productname>PostgreSQL</productname> 8.3.  Read-only capability is available
   back to 8.1.  A limitation however is that <filename>postgres_fdw</filename>
   generally assumes that immutable built-in functions and operators are
   safe to send to the remote server for execution, if they appear in a
   <literal>WHERE</literal> clause for a foreign table.  Thus, a built-in
   function that was added since the remote server's release might be sent
   to it for execution, resulting in <quote>function does not exist</quote> or
   a similar error.  This type of failure can be worked around by
   rewriting the query, for example by embedding the foreign table
   reference in a sub-<literal>SELECT</literal> with <literal>OFFSET 0</literal> as an
   optimization fence, and placing the problematic function or operator
   outside the sub-<literal>SELECT</literal>.
  </para>
____________________________________________________________________________-->
  <para>
   <filename>postgres_fdw</filename>能够与最老是<productname>PostgreSQL</productname> 8.3 的远程服务器一起使用。只读能力则最低可以在 8.1 中使用。但是一个限制是<filename>postgres_fdw</filename>通常假定不变的内建函数和操作符是安全的，如果它们出现在一个外部表的<literal>WHERE</literal>子句中，它们可以发送给远程服务器执行。因此，由于一个由于远程服务器的发布可能被发送给它来执行而被增加的内建函数，会导致<quote>function does not exist</quote>或一个类似的错误。这类错误可以通过重写查询来解决，例如通过嵌入在一个带<literal>OFFSET 0</literal>的子<literal>SELECT</literal>中引用的外部表作为一种优化墙，并且把出问题的函数或操作符放在子<literal>SELECT</literal>的外部。
  </para>
 </sect2>

 <sect2>
<!--==========================orignal english content==========================
  <title>Examples</title>
____________________________________________________________________________-->
  <title>例子</title>

<!--==========================orignal english content==========================
  <para>
   Here is an example of creating a foreign table with
   <literal>postgres_fdw</literal>. First install the extension:
  </para>
____________________________________________________________________________-->
  <para>
   这里是一个用<literal>postgres_fdw</literal>创建外部表的例子。首先安装该扩展：
  </para>

<!--==========================orignal english content==========================
<programlisting>
CREATE EXTENSION postgres_fdw;
</programlisting>
____________________________________________________________________________-->
<programlisting>
CREATE EXTENSION postgres_fdw;
</programlisting>

<!--==========================orignal english content==========================
  <para>
   Then create a foreign server using <xref linkend="sql-createserver"/>.
   In this example we wish to connect to a <productname>PostgreSQL</productname> server
   on host <literal>192.83.123.89</literal> listening on
   port <literal>5432</literal>.  The database to which the connection is made
   is named <literal>foreign_db</literal> on the remote server:

<programlisting>
CREATE SERVER foreign_server
        FOREIGN DATA WRAPPER postgres_fdw
        OPTIONS (host '192.83.123.89', port '5432', dbname 'foreign_db');
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   然后使用<xref linkend="sql-createserver"/>创建一个外部服务器。在这个例子中我们希望连接到一个位于主机<literal>192.83.123.89</literal>上并且监听<literal>5432</literal>端口的<productname>PostgreSQL</productname>服务器。在该远程服务器上要连接的数据库名为<literal>foreign_db</literal>：

<programlisting>
CREATE SERVER foreign_server
        FOREIGN DATA WRAPPER postgres_fdw
        OPTIONS (host '192.83.123.89', port '5432', dbname 'foreign_db');
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   A user mapping, defined with <xref linkend="sql-createusermapping"/>, is
   needed as well to identify the role that will be used on the remote
   server:

<programlisting>
CREATE USER MAPPING FOR local_user
        SERVER foreign_server
        OPTIONS (user 'foreign_user', password 'password');
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   需要用<xref linkend="sql-createusermapping"/>定义一个用户映射来标识在远程服务器上使用哪个角色：

<programlisting>
CREATE USER MAPPING FOR local_user
        SERVER foreign_server
        OPTIONS (user 'foreign_user', password 'password');
</programlisting>
  </para>

<!--==========================orignal english content==========================
  <para>
   Now it is possible to create a foreign table with
   <xref linkend="sql-createforeigntable"/>.  In this example we
   wish to access the table named <structname>some_schema.some_table</structname>
   on the remote server.  The local name for it will
   be <structname>foreign_table</structname>:

<programlisting>
CREATE FOREIGN TABLE foreign_table (
        id integer NOT NULL,
        data text
)
        SERVER foreign_server
        OPTIONS (schema_name 'some_schema', table_name 'some_table');
</programlisting>

   It's essential that the data types and other properties of the columns
   declared in <command>CREATE FOREIGN TABLE</command> match the actual remote table.
   Column names must match as well, unless you attach <literal>column_name</literal>
   options to the individual columns to show how they are named in the remote
   table.
   In many cases, use of <xref linkend="sql-importforeignschema"/> is
   preferable to constructing foreign table definitions manually.
  </para>
____________________________________________________________________________-->
  <para>
   现在就可以使用<xref linkend="sql-createforeigntable"/>创建外部表了。在这个例子中我们希望访问远程服务器上名为<structname>some_schema.some_table</structname>的表。它的本地名称是<structname>foreign_table</structname>：

<programlisting>
CREATE FOREIGN TABLE foreign_table (
        id integer NOT NULL,
        data text
)
        SERVER foreign_server
        OPTIONS (schema_name 'some_schema', table_name 'some_table');
</programlisting>

   <command>CREATE FOREIGN TABLE</command>中声明的列数据类型和其他性质必须要匹配实际的远程表。列名也必须匹配，不过也可以为个别列附上<literal>column_name</literal>选项以表示它们在远程服务器上对应哪个列。在很多情况中，要手工构造外部表定义，使用<link linkend="sql-importforeignschema"><command>IMPORT FOREIGN SCHEMA</command></link>会更好。
  </para>
 </sect2>
 
 <sect2>
<!--==========================orignal english content==========================
  <title>Author</title>
____________________________________________________________________________-->
  <title>作者</title>
<!--==========================orignal english content==========================
  <para>
   Shigeru Hanada <email>shigeru.hanada@gmail.com</email>
  </para>
____________________________________________________________________________-->
  <para>
   Shigeru Hanada <email>shigeru.hanada@gmail.com</email>
  </para>
 </sect2>

</sect1>
