<!-- doc/src/sgml/sql.sgml -->

 <chapter id="sql-intro">
<!--==========================orignal english content==========================
  <title>SQL</title>
____________________________________________________________________________-->
  <title>SQL</title>

  <abstract>
<!--==========================orignal english content==========================
   <para>
    This chapter introduces the mathematical concepts behind
    relational databases. It is not required reading, so if you bog
    down or want to get straight to some simple examples feel free to
    jump ahead to the next chapter and come back when you have more
    time and patience. This stuff is supposed to be fun!
   </para>
____________________________________________________________________________-->
   <para>
    本章介绍关系数据库背后的数学概念。本章不是必读章节，因此如果你在这里停滞不前或者想直接看一些简单的例子，请随便跳到下一章并且在你有更多时间和耐心时再返回本章。这里的材料应该是有趣的！
   </para>

<!--==========================orignal english content==========================
   <para>
    This material originally appeared as a part of
    Stefan Simkovics' Master's Thesis
    (<xref linkend="SIM98" endterm="SIM98">).
   </para>
____________________________________________________________________________-->
   <para>
    这份材料最初是作为 Stefan Simkovic 的硕士学位论文（<xref linkend="SIM98" endterm="SIM98">）的一部分出现。
   </para>
  </abstract>

<!--==========================orignal english content==========================
  <para>
   <acronym>SQL</acronym> has become the most popular relational query
   language.
   The name <quote><acronym>SQL</acronym></quote> is an abbreviation for
   <firstterm>Structured Query Language</firstterm>.
   In 1974 Donald Chamberlin and others defined the
   language SEQUEL (<firstterm>Structured English Query
    Language</firstterm>) at IBM
   Research. This language was first implemented in an IBM
   prototype called SEQUEL-XRM in 1974-75. In 1976-77 a revised version
   of SEQUEL called SEQUEL/2 was defined and the name was changed to
   <acronym>SQL</acronym>
   subsequently.
  </para>
____________________________________________________________________________-->
  <para>
   <acronym>SQL</acronym>已经成为最流行的关系型查询语言。名字<quote><acronym>SQL</acronym></quote>是<firstterm>Structured Query Language</firstterm>的一个缩写。在 1974 年，Donald Chamberlin 和其他人在 IBM 的研究中定义了语言 SEQUEL （<firstterm>Structured English Query Language</firstterm>）。这种语言最早在一个 IBM 原型中实现，在 1974-1975 年被称为 SEQUEL-XRM。在 1976-1977 一个被称为 SEQUEL/2 的修改版 SEQUEL 被定义并且名字随后被改成了<acronym>SQL</acronym>。
  </para>

<!--==========================orignal english content==========================
  <para>
   A new prototype called System R was developed by IBM in 1977. System R
   implemented a large subset of SEQUEL/2 (now <acronym>SQL</acronym>)
   and a number of
   changes were made to <acronym>SQL</acronym> during the project.
   System R was installed in
   a number of user sites, both internal IBM sites and also some selected
   customer sites. Thanks to the success and acceptance of System R at
   those user sites IBM started to develop commercial products that
   implemented the <acronym>SQL</acronym> language based on the System
   R technology.
  </para>
____________________________________________________________________________-->
  <para>
   一个新的被称为系统 R 的原型在 1977 年被 IBM 开发出来。系统 R 实现了 SEQUEL/2（现在的<acronym>SQL</acronym>）的一个大的子集并且在该项目期间对<acronym>SQL</acronym>做出了一些改变。系统 R 被安装在了一些用户站点上，包括内部的 IBM 站点以及某些选择的客户站点。感谢在那些用户站点上对系统 R 的成功和接受，IBM 开始基于系统 R 的技术开发实现了<acronym>SQL</acronym>的商业产品。
  </para>

<!--==========================orignal english content==========================
  <para>
   Over the next years IBM and also a number of other vendors announced
   <acronym>SQL</acronym> products such as
   <productname>SQL/DS</productname> (IBM),
   <productname>DB2</productname> (IBM),
   <productname>ORACLE</productname> (Oracle Corp.),
   <productname>DG/SQL</productname> (Data General Corp.),
   and <productname>SYBASE</productname> (Sybase Inc.).
  </para>
____________________________________________________________________________-->
  <para>
   在接下来的数年内 IBM 和一些其他提供商宣布了各种<acronym>SQL</acronym>产品，例如
   <productname>SQL/DS</productname>（IBM）、
   <productname>DB2</productname>（IBM）、
   <productname>ORACLE</productname>（Oracle Corp.）、
   <productname>DG/SQL</productname>（Data General Corp.）和<productname>SYBASE</productname>（Sybase Inc.）。
  </para>

<!--==========================orignal english content==========================
  <para>
   <acronym>SQL</acronym> is also an official standard now. In 1982
   the American National
   Standards Institute (<acronym>ANSI</acronym>) chartered its
   Database Committee X3H2 to
   develop a proposal for a standard relational language. This proposal
   was ratified in 1986 and consisted essentially of the IBM dialect of
   <acronym>SQL</acronym>. In 1987 this <acronym>ANSI</acronym>
   standard was also accepted as an international
   standard by the International Organization for Standardization
   (<acronym>ISO</acronym>).
   This original standard version of <acronym>SQL</acronym> is often
   referred to,
   informally, as <quote><abbrev>SQL/86</abbrev></quote>. In 1989 the original
   standard was extended
   and this new standard is often, again informally, referred to as
   <quote><abbrev>SQL/89</abbrev></quote>. Also in 1989, a related standard called
   <firstterm>Database Language Embedded <acronym>SQL</acronym></firstterm>
   (<acronym>ESQL</acronym>) was developed.
  </para>
____________________________________________________________________________-->
  <para>
   <acronym>SQL</acronym>现在也是一个官方标准。在 1982 年，美国国家标准协会（<acronym>ANSI</acronym>）特许它的数据库委员会 X3H2 来开发一个用于标准关系语言的提案。这个提案在 1986 年被批准并且组成了 IBM 的<acronym>SQL</acronym>的核心部分。在 1987 年这个<acronym>ANSI</acronym>标准也被国际标准化组织（<acronym>ISO</acronym>）接受为一项国际标准。<acronym>SQL</acronym>的这个最早的标准版本常常被非正式地称作<quote><abbrev>SQL/86</abbrev></quote>。在 1989 年最早的版本被扩展并且这个新标准常常被非正式地称为<quote><abbrev>SQL/89</abbrev></quote>。也是在 1989 年，一个被称作<firstterm>数据库语言嵌入式<acronym>SQL</acronym></firstterm>（<acronym>ESQL</acronym>）的相关标准被开发出来。
  </para>

<!--==========================orignal english content==========================
  <para>
   The <acronym>ISO</acronym> and <acronym>ANSI</acronym> committees
   have been working for many years on the
   definition of a greatly expanded version of the original standard,
   referred to informally as <firstterm><acronym>SQL2</acronym></firstterm>
   or <firstterm><acronym>SQL/92</acronym></firstterm>. This version became a
   ratified standard - <quote>International Standard ISO/IEC 9075:1992,
   Database Language <acronym>SQL</acronym></quote> - in late 1992.
   <acronym>SQL/92</acronym> is the version
   normally meant when people refer to <quote>the <acronym>SQL</acronym>
   standard</quote>. A detailed
   description of <acronym>SQL/92</acronym> is given in
   <xref linkend="DATE97" endterm="DATE97">. At the time of
   writing this document a new standard informally referred to
   as <firstterm><acronym>SQL3</acronym></firstterm>
   is under development. It is planned to make <acronym>SQL</acronym>
   a Turing-complete
   language, i.e., all computable queries (e.g., recursive queries) will be
   possible. This has now been completed as SQL:2003.
  </para>
____________________________________________________________________________-->
  <para>
   <acronym>ISO</acronym>和<acronym>ANSI</acronym>委员会已经工作了多年来扩展原始的标准，这个大幅度扩展过的版本被非正式地称为<firstterm><acronym>SQL2</acronym></firstterm>或<firstterm><acronym>SQL/92</acronym></firstterm>。这个版本在 1992 年后期被批准为一项标准 - <quote>International Standard ISO/IEC 9075:1992,
   Database Language <acronym>SQL</acronym></quote>。<acronym>SQL/92</acronym>就是人们通常所指的<quote>那个<acronym>SQL</acronym>标准</quote>。关于<acronym>SQL/92</acronym>的详细描述在<xref linkend="DATE97" endterm="DATE97">中可以找到。在编写这份文档时，一项新的标准也正在开发中，它被非正式地称为<firstterm><acronym>SQL3</acronym></firstterm>。它计划将<acronym>SQL</acronym>变成一种图灵完全语言，即所有可计算的查询（例如递归查询）都会成为可能。这已经作为 SQL:2003 完成。
  </para>

  <sect1 id="rel-model">
<!--==========================orignal english content==========================
   <title>The Relational Data Model</title>
____________________________________________________________________________-->
   <title>关系数据模型</title>

<!--==========================orignal english content==========================
  <para>
    As mentioned before, <acronym>SQL</acronym> is a relational
    language. That means it is
    based on the <firstterm>relational data model</firstterm>
    first published by E.F. Codd in
    1970. We will give a formal description of the relational model
    later (in
    <xref linkend="formal-notion" endterm="formal-notion">)
    but first we want to have a look at it from a more intuitive
    point of view.
  </para>
____________________________________________________________________________-->
  <para>
    如前所述，<acronym>SQL</acronym>是一种关系型语言。这意味着它基于由 E. F. Codd 于 1970 年最早发表的<firstterm>关系数据模型</firstterm>。我们将稍后给出一些关系模型的形式化描述（在<xref linkend="formal-notion" endterm="formal-notion">中），但是首先我们想要从一种更直观的视角看看这个模型。
  </para>

<!--==========================orignal english content==========================
  <para>
    A <firstterm>relational database</firstterm> is a database that is
    perceived by its
    users as a <firstterm>collection of tables</firstterm> (and
    nothing else but tables).
    A table consists of rows and columns where each row represents a
    record and each column represents an attribute of the records
    contained in the table.
    <xref linkend="supplier-fig" endterm="supplier-fig">
    shows an example of a database consisting of three tables:

    <itemizedlist>
     <listitem>
      <para>
       SUPPLIER is a table storing the number
       (SNO), the name (SNAME) and the city (CITY) of a supplier.
      </para>
     </listitem>

     <listitem>
      <para>
       PART is a table storing the number (PNO) the name (PNAME) and
       the price (PRICE) of a part.
      </para>
     </listitem>

     <listitem>
      <para>
       SELLS stores information about which part (PNO) is sold by which
       supplier (SNO).
       It serves in a sense to connect the other two tables together.
      </para>
     </listitem>
    </itemizedlist>

    <example>
     <title id="supplier-fig">The Suppliers and Parts Database</title>
<screen>
SUPPLIER:                   SELLS:
 SNO |  SNAME  |  CITY       SNO | PNO
-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;     -&minus;-&minus;-+-&minus;-&minus;-
 1  |  Smith  | London        1  |  1
 2  |  Jones  | Paris         1  |  2
 3  |  Adams  | Vienna        2  |  4
 4  |  Blake  | Rome          3  |  1
                              3  |  3
                              4  |  2
PART:                         4  |  3
 PNO |  PNAME  |  PRICE       4  |  4
-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-
 1  |  Screw  |   10
 2  |  Nut    |    8
 3  |  Bolt   |   15
 4  |  Cam    |   25
</screen>
    </example>
   </para>
____________________________________________________________________________-->
  <para>
    一个<firstterm>关系数据库</firstterm>在其用户看来是一个<firstterm>表的集合</firstterm>（并且没有除了表之外的其他东西）。一个表由行和列组成，其中每一行表示一个记录而每一列表示表中所含记录的一个属性。<xref linkend="supplier-fig" endterm="supplier-fig">展示了一个由三个表组成的数据库的例子：

    <itemizedlist>
     <listitem>
      <para>
       SUPPLIER 是一个存储提供商的号码（SNO）、名称（SNAME）和城市（CITY）的表。
      </para>
     </listitem>

     <listitem>
      <para>
       PART 是一个存储部件的号码（PNO）、名称（PNAME）和价格（PRICE）的表。
      </para>
     </listitem>

     <listitem>
      <para>
       SELLS 存储有关哪个提供商（SNO）销售哪种部件（PNO）的信息。它的作用在某种意义上是把其他两个表连接起来。
      </para>
     </listitem>
    </itemizedlist>

    <example>
     <title id="supplier-fig">提供商和部件数据库</title>
<screen>
SUPPLIER:                   SELLS:
 SNO |  SNAME  |  CITY       SNO | PNO
----+---------+--------     -----+-----
 1  |  Smith  | London        1  |  1
 2  |  Jones  | Paris         1  |  2
 3  |  Adams  | Vienna        2  |  4
 4  |  Blake  | Rome          3  |  1
                              3  |  3
                              4  |  2
PART:                         4  |  3
 PNO |  PNAME  |  PRICE       4  |  4
----+---------+---------
 1  |  Screw  |   10
 2  |  Nut    |    8
 3  |  Bolt   |   15
 4  |  Cam    |   25
</screen>
    </example>
   </para>

<!--==========================orignal english content==========================
   <para>
    The tables PART and SUPPLIER can be regarded as
    <firstterm>entities</firstterm> and
    SELLS can be regarded as a <firstterm>relationship</firstterm>
    between a particular
    part and a particular supplier.
   </para>
____________________________________________________________________________-->
   <para>
    表 PART 和 SUPPLIER 可以被看成是<firstterm>实体</firstterm>而 SELLS 可以被看成是一个特定部件和一个特定提供商之间的一个<firstterm>关系</firstterm>。
   </para>

<!--==========================orignal english content==========================
   <para>
    As we will see later, <acronym>SQL</acronym> operates on tables
    like the ones just
    defined but before that we will study the theory of the relational
    model.
   </para>
____________________________________________________________________________-->
   <para>
    正如我们后面将看到的，<acronym>SQL</acronym>在表上操作，但是在那之前我们将先学习关系模型的理论。
   </para>
  </sect1>

  <sect1 id="relmodel-formal">
<!--==========================orignal english content==========================
   <title id="formal-notion">Relational Data Model Formalities</title>
____________________________________________________________________________-->
   <title id="formal-notion">关系数据模型形式</title>

<!--==========================orignal english content==========================
   <para>
    The mathematical concept underlying the relational model is the
    set-theoretic <firstterm>relation</firstterm> which is a subset of
    the Cartesian
    product of a list of domains. This set-theoretic relation gives
    the model its name (do not confuse it with the relationship from the
    <firstterm>Entity-Relationship model</firstterm>).
    Formally a domain is simply a set of
    values. For example the set of integers is a domain. Also the set of
    character strings of length 20 and the real numbers are examples of
    domains.
   </para>
____________________________________________________________________________-->
   <para>
    关系模型底层的数学概念是集合论的<firstterm>关系</firstterm>，它是一个域列表的笛卡尔积的一个子集。这种集合论的关系（不要把它和<firstterm>Entity-Relationship model</firstterm>中的关系弄混）为该模型带来了它的名称。形式上一个域就是一个值的集合。例如，整数集合就是一个域。长度为 20 的字符串的集合以及实数的集合也是域的例子。
   </para>

<!--==========================orignal english content==========================
   <para>
<!-&minus;
\begin{definition}
The <firstterm>Cartesian product</firstterm> of domains $D_{1},
    D_{2},\ldots, D_{k}$ written
\mbox{$D_{1} \times D_{2} \times \ldots \times D_{k}$} is the set of
all $k$-tuples $(v_{1},v_{2},\ldots,v_{k})$ such that \mbox{$v_{1} \in
D_{1}, v_{2} \in D_{2}, \ldots, v_{k} \in D_{k}$}.
\end{definition}
-&minus;>
    The <firstterm>Cartesian product</firstterm> of domains
    <parameter>D<subscript>1</subscript></parameter>,
    <parameter>D<subscript>2</subscript></parameter>,
    ...
    <parameter>D<subscript>k</subscript></parameter>,
    written
    <parameter>D<subscript>1</subscript></parameter> &times;
    <parameter>D<subscript>2</subscript></parameter> &times;
    ... &times;
    <parameter>D<subscript>k</subscript></parameter>
    is the set of all k-tuples
    <parameter>v<subscript>1</subscript></parameter>,
    <parameter>v<subscript>2</subscript></parameter>,
    ...
    <parameter>v<subscript>k</subscript></parameter>,
    such that
    <parameter>v<subscript>1</subscript></parameter> &isin;
    <parameter>D<subscript>1</subscript></parameter>,
    <parameter>v<subscript>2</subscript></parameter> &isin;
    <parameter>D<subscript>2</subscript></parameter>,
    ...
    <parameter>v<subscript>k</subscript></parameter> &isin;
    <parameter>D<subscript>k</subscript></parameter>.
   </para>
____________________________________________________________________________-->
   <para>
<!--
\begin{definition}
The <firstterm>Cartesian product</firstterm> of domains $D_{1},
    D_{2},\ldots, D_{k}$ written
\mbox{$D_{1} \times D_{2} \times \ldots \times D_{k}$} is the set of
all $k$-tuples $(v_{1},v_{2},\ldots,v_{k})$ such that \mbox{$v_{1} \in
D_{1}, v_{2} \in D_{2}, \ldots, v_{k} \in D_{k}$}.
\end{definition}
-->
    域
    <parameter>D<subscript>1</subscript></parameter>、
    <parameter>D<subscript>2</subscript></parameter>、
    ...
    <parameter>D<subscript>k</subscript></parameter>的<firstterm>笛卡尔积</firstterm>集被写成
    <parameter>D<subscript>1</subscript></parameter> &times;
    <parameter>D<subscript>2</subscript></parameter> &times;
    ... &times;
    <parameter>D<subscript>k</subscript></parameter>，它是一个所有 k 元组
    <parameter>v<subscript>1</subscript></parameter>、
    <parameter>v<subscript>2</subscript></parameter>、
    ...
    <parameter>v<subscript>k</subscript></parameter>的集合
    这样
    <parameter>v<subscript>1</subscript></parameter> &isin;
    <parameter>D<subscript>1</subscript></parameter>、
    <parameter>v<subscript>2</subscript></parameter> &isin;
    <parameter>D<subscript>2</subscript></parameter>、
    ...
    <parameter>v<subscript>k</subscript></parameter> &isin;
    <parameter>D<subscript>k</subscript></parameter>。
   </para>

<!--==========================orignal english content==========================
   <para>
    For example, when we have
<!-&minus;
 $k=2$, $D_{1}=\{0,1\}$ and
$D_{2}=\{a,b,c\}$, then $D_{1} \times D_{2}$ is
$\{(0,a),(0,b),(0,c),(1,a),(1,b),(1,c)\}$.
-&minus;>
    <parameter>k</parameter>=2,
    <parameter>D<subscript>1</subscript></parameter>=<literal>{0,1}</literal> and
    <parameter>D<subscript>2</subscript></parameter>=<literal>{a,b,c}</literal> then
    <parameter>D<subscript>1</subscript></parameter> &times;
    <parameter>D<subscript>2</subscript></parameter> is
    <literal>{(0,a),(0,b),(0,c),(1,a),(1,b),(1,c)}</literal>.
   </para>
____________________________________________________________________________-->
   <para>
    例如，当我们有
<!--
 $k=2$, $D_{1}=\{0,1\}$ and
$D_{2}=\{a,b,c\}$, then $D_{1} \times D_{2}$ is
$\{(0,a),(0,b),(0,c),(1,a),(1,b),(1,c)\}$.
-->
    <parameter>k</parameter>=2、
    <parameter>D<subscript>1</subscript></parameter>=<literal>{0,1}</literal>并且
    <parameter>D<subscript>2</subscript></parameter>=<literal>{a,b,c}</literal>那么
    <parameter>D<subscript>1</subscript></parameter> &times;
    <parameter>D<subscript>2</subscript></parameter>是
    <literal>{(0,a),(0,b),(0,c),(1,a),(1,b),(1,c)}</literal>。
   </para>

<!--==========================orignal english content==========================
   <para>
<!-&minus;
\begin{definition}
A Relation is any subset of the Cartesian product of one or more
domains: $R \subseteq$ \mbox{$D_{1} \times D_{2} \times \ldots \times D_{k}$}
\end{definition}
-&minus;>
    A Relation is any subset of the Cartesian product of one or more
    domains: <parameter>R</parameter> &sube;
    <parameter>D<subscript>1</subscript></parameter> &times;
    <parameter>D<subscript>2</subscript></parameter> &times;
    ... &times;
    <parameter>D<subscript>k</subscript></parameter>.
   </para>
____________________________________________________________________________-->
   <para>
<!--
\begin{definition}
A Relation is any subset of the Cartesian product of one or more
domains: $R \subseteq$ \mbox{$D_{1} \times D_{2} \times \ldots \times D_{k}$}
\end{definition}
-->
    一个关系是一个或多个域的笛卡尔积的任意子集：<parameter>R</parameter> &sube;
    <parameter>D<subscript>1</subscript></parameter> &times;
    <parameter>D<subscript>2</subscript></parameter> &times;
    ... &times;
    <parameter>D<subscript>k</subscript></parameter>。
   </para>

<!--==========================orignal english content==========================
   <para>
    For example <literal>{(0,a),(0,b),(1,a)}</literal> is a relation;
    it is in fact a subset of
    <parameter>D<subscript>1</subscript></parameter> &times;
    <parameter>D<subscript>2</subscript></parameter>
    mentioned above.
   </para>
____________________________________________________________________________-->
   <para>
    例如<literal>{(0,a),(0,b),(1,a)}</literal>是一个关系，它实际上是上面提到的
    <parameter>D<subscript>1</subscript></parameter> &times;
    <parameter>D<subscript>2</subscript></parameter>的一个子集。
   </para>

<!--==========================orignal english content==========================
   <para>
    The members of a relation are called tuples. Each relation of some
    Cartesian product
    <parameter>D<subscript>1</subscript></parameter> &times;
    <parameter>D<subscript>2</subscript></parameter> &times;
    ... &times;
    <parameter>D<subscript>k</subscript></parameter>
    is said to have arity <literal>k</literal> and is therefore a set
    of <literal>k</literal>-tuples.
   </para>
____________________________________________________________________________-->
   <para>
    一个关系的成员被称为元组。某个笛卡尔积
    <parameter>D<subscript>1</subscript></parameter> &times;
    <parameter>D<subscript>2</subscript></parameter> &times;
    ... &times;
    <parameter>D<subscript>k</subscript></parameter>的每一个关系被说成有元数<literal>k</literal>并且因此是一个<literal>k</literal>-元组的集合。
   </para>

<!--==========================orignal english content==========================
   <para>
    A relation can be viewed as a table (as we already did, remember
    <xref linkend="supplier-fig" endterm="supplier-fig"> where
    every tuple is represented by a row and every column corresponds to
    one component of a tuple. Giving names (called attributes) to the
    columns leads to the definition of a
    <firstterm>relation scheme</firstterm>.
   </para>
____________________________________________________________________________-->
   <para>
    一个关系可以被视为一个表（和我们已经做过的一样，记住<xref linkend="supplier-fig" endterm="supplier-fig">中每一个元组被表示为一行并且每一列对应一个元组的一个部分。为列命名（称为属性）就得到了一个<firstterm>关系模式</firstterm>的定义。
   </para>

<!--==========================orignal english content==========================
   <para>
<!-&minus;
\begin{definition}
A {\it relation scheme} $R$ is a finite set of attributes
\mbox{$\{A_{1},A_{2},\ldots,A_{k}\}$}. There is a domain $D_{i}$ for
each attribute $A_{i}, 1 \le i \le k$ where the values of the
attributes are taken from. We often write a relation scheme as
\mbox{$R(A_{1},A_{2},\ldots,A_{k})$}.
\end{definition}
-&minus;>
    A <firstterm>relation scheme</firstterm> <literal>R</literal> is a
    finite set of attributes
    <parameter>A<subscript>1</subscript></parameter>,
    <parameter>A<subscript>2</subscript></parameter>,
    ...
    <parameter>A<subscript>k</subscript></parameter>.
    There is a domain
    <parameter>D<subscript>i</subscript></parameter>,
    for each attribute
    <parameter>A<subscript>i</subscript></parameter>,
    1 &lt;= <literal>i</literal> &lt;= <literal>k</literal>,
    where the values of the attributes are taken from. We often write
    a relation scheme as
    <literal>R(<parameter>A<subscript>1</subscript></parameter>,
    <parameter>A<subscript>2</subscript></parameter>,
    ...
    <parameter>A<subscript>k</subscript></parameter>)</literal>.

    <note>
     <para>
      A <firstterm>relation scheme</firstterm> is just a kind of template
      whereas a <firstterm>relation</firstterm> is an instance of a
      <firstterm>relation
       scheme</firstterm>. The relation consists of tuples (and can
      therefore be
      viewed as a table); not so the relation scheme.
     </para>
    </note>
   </para>
____________________________________________________________________________-->
   <para>
<!--
\begin{definition}
A {\it relation scheme} $R$ is a finite set of attributes
\mbox{$\{A_{1},A_{2},\ldots,A_{k}\}$}. There is a domain $D_{i}$ for
each attribute $A_{i}, 1 \le i \le k$ where the values of the
attributes are taken from. We often write a relation scheme as
\mbox{$R(A_{1},A_{2},\ldots,A_{k})$}.
\end{definition}
-->
    一个<firstterm>关系模式</firstterm> <literal>R</literal>是一个属性
    <parameter>A<subscript>1</subscript></parameter>、
    <parameter>A<subscript>2</subscript></parameter>、
    ...
    <parameter>A<subscript>k</subscript></parameter>的有限集合。
    对每一个属性<parameter>A<subscript>i</subscript></parameter>（
    1 &lt;= <literal>i</literal> &lt;= <literal>k</literal>）有一个域
    <parameter>D<subscript>i</subscript></parameter>，属性的值来自于对应的域中。我们常常把一个关系模式写成
    <literal>R(<parameter>A<subscript>1</subscript></parameter>,
    <parameter>A<subscript>2</subscript></parameter>,
    ...
    <parameter>A<subscript>k</subscript></parameter>)</literal>。

    <note>
     <para>
      一个<firstterm>关系模式</firstterm>只是一种模板，而一个<firstterm>关系</firstterm>是一种<firstterm>关系模式</firstterm>的一个实例。关系由元组构成（并且因此能被看成是一个表），但关系模式不是这样。
     </para>
    </note>
   </para>

   <sect2>
<!--==========================orignal english content==========================
    <title id="domains">Domains vs. Data Types</title>
____________________________________________________________________________-->
    <title id="domains">域 vs. 数据类型</title>

<!--==========================orignal english content==========================
    <para>
     We often talked about <firstterm>domains</firstterm>
     in the last section. Recall that a
     domain is, formally, just a set of values (e.g., the set of integers or
     the real numbers). In terms of database systems we often talk of
     <firstterm>data types</firstterm> instead of domains.
     When we define a table we have to make
     a decision about which attributes to include. Additionally we
     have to decide which kind of data is going to be stored as
     attribute values. For example the values of
     <classname>SNAME</classname> from the table
     <classname>SUPPLIER</classname> will be character strings,
     whereas <classname>SNO</classname> will store
     integers. We define this by assigning a data type to each
     attribute. The type of <classname>SNAME</classname> will be
     <type>VARCHAR(20)</type> (this is the <acronym>SQL</acronym> type
     for character strings of length &lt;= 20),
     the type of <classname>SNO</classname> will be
     <type>INTEGER</type>. With the assignment of a data type we also
     have selected
     a domain for an attribute. The domain of
     <classname>SNAME</classname> is the set of all
     character strings of length &lt;= 20,
     the domain of <classname>SNO</classname> is the set of
     all integer numbers.
    </para>
____________________________________________________________________________-->
    <para>
     我们在上一节里经常谈到<firstterm>域</firstterm>。回想一下，形式化地来说，一个域就是一个值的集合（例如整数集合或实数集合）。在数据库系统的术语中，我们经常用<firstterm>数据类型</firstterm>来代替域。当我们定义一个表时，我们必须决定包括哪些属性。另外我们还必须决定将存储哪种数据来作为属性值。例如表<classname>SUPPLIER</classname>中<classname>SNAME</classname>的值将是字符串，而<classname>SNO</classname>将存储整数。我们通过为每一个属性分派一种数据类型来定义这些。<classname>SNAME</classname>的类型将是<type>VARCHAR(20)</type>（这是<acronym>SQL</acronym>对于长度 &lt;= 20 的字符串的类型），<classname>SNO</classname>的类型将是<type>INTEGER</type>。通过一个数据类型的指派，我们还可以为一个属性选择一个域。<classname>SNAME</classname>的域是所有长度 &lt;= 20 的字符串的集合，<classname>SNO</classname>的域是所有整数的集合。
    </para>
   </sect2>
  </sect1>

  <sect1 id="relmodel-oper">
<!--==========================orignal english content==========================
   <title id="operations">Operations in the Relational Data Model</title>
____________________________________________________________________________-->
   <title id="operations">关系数据模型中的操作</title>

<!--==========================orignal english content==========================
   <para>
    In the previous section
    (<xref linkend="formal-notion" endterm="formal-notion">)
    we defined the mathematical notion of
    the relational model. Now we know how the data can be stored using a
    relational data model but we do not know what to do with all these
    tables to retrieve something from the database yet. For example somebody
    could ask for the names of all suppliers that sell the part
    'Screw'. Therefore two rather different kinds of notations for
    expressing operations on relations have been defined:

    <itemizedlist>
     <listitem>
      <para>
       The <firstterm>Relational Algebra</firstterm> which is an
       algebraic notation,
       where queries are expressed by applying specialized operators to the
       relations.
      </para>
     </listitem>

     <listitem>
      <para>
       The <firstterm>Relational Calculus</firstterm> which is a
       logical notation,
       where queries are expressed by formulating some logical restrictions
       that the tuples in the answer must satisfy.
      </para>
    </listitem>
    </itemizedlist>
   </para>
____________________________________________________________________________-->
   <para>
    在前一节（<xref linkend="formal-notion" endterm="formal-notion">）中，我们定义了关系模型的数学符号。现在我们知道数据是如何使用一个关系数据模型存储的，但是我们还不知道如何操作所有这些表来从数据库中检索一些东西。例如，某人可能会询问所有出售部件 'Screw' 的供应商的名字。因此有两种不同的表达关系上操作的记号法：

    <itemizedlist>
     <listitem>
      <para>
       <firstterm>关系代数</firstterm>是一种代数记号法，在其中查询被表达为在关系上应用专门的操作符。
      </para>
     </listitem>

     <listitem>
      <para>
       <firstterm>关系演算</firstterm>是一种逻辑记号法，在其中通过用公式表示答案中元组应该满足的一些逻辑限制来表达查询。
      </para>
    </listitem>
    </itemizedlist>
   </para>

   <sect2>
<!--==========================orignal english content==========================
    <title id="rel-alg">Relational Algebra</title>
____________________________________________________________________________-->
    <title id="rel-alg">关系代数</title>

<!--==========================orignal english content==========================
    <para>
     The <firstterm>Relational Algebra</firstterm> was introduced by
     E. F. Codd in 1972. It consists of a set of operations on relations:

     <itemizedlist>
      <listitem>
       <para>
        SELECT (&sigma;): extracts <firstterm>tuples</firstterm> from
        a relation that
        satisfy a given restriction. Let <parameter>R</parameter> be a
        table that contains an attribute
        <parameter>A</parameter>.
&sigma;<subscript>A=a</subscript>(R) = {t &isin; R &mid; t(A) = a}
        where <literal>t</literal> denotes a
        tuple of <parameter>R</parameter> and <literal>t(A)</literal>
        denotes the value of attribute <parameter>A</parameter> of
        tuple <literal>t</literal>.
       </para>
      </listitem>

      <listitem>
       <para>
        PROJECT (&pi;): extracts specified
        <firstterm>attributes</firstterm> (columns) from a
        relation. Let <classname>R</classname> be a relation
        that contains an attribute <classname>X</classname>.
        &pi;<subscript>X</subscript>(<classname>R</classname>) = {t(X) &mid; t &isin; <classname>R</classname>},
        where <literal>t</literal>(<classname>X</classname>) denotes the value of
        attribute <classname>X</classname> of tuple <literal>t</literal>.
       </para>
      </listitem>

      <listitem>
       <para>
        PRODUCT (&times;): builds the Cartesian product of two
        relations. Let <classname>R</classname> be a table with arity
        <literal>k</literal><subscript>1</subscript> and let
        <classname>S</classname> be a table with
        arity <literal>k</literal><subscript>2</subscript>.
        <classname>R</classname> &times; <classname>S</classname>
        is the set of all
        <literal>k</literal><subscript>1</subscript>
        + <literal>k</literal><subscript>2</subscript>-tuples
        whose first <literal>k</literal><subscript>1</subscript>
        components form a tuple in <classname>R</classname> and whose last
        <literal>k</literal><subscript>2</subscript> components form a
        tuple in <classname>S</classname>.
       </para>
      </listitem>

      <listitem>
       <para>
        UNION (&cup;): builds the set-theoretic union of two
        tables. Given the tables <classname>R</classname> and
        <classname>S</classname> (both must have the same arity),
        the union <classname>R</classname> &cup; <classname>S</classname>
        is the set of tuples that are in <classname>R</classname>
        or <classname>S</classname> or both.
       </para>
      </listitem>

      <listitem>
       <para>
        INTERSECT (&cap;): builds the set-theoretic intersection of two
        tables. Given the tables <classname>R</classname> and
        <classname>S</classname>,
        <classname>R</classname> &cap; <classname>S</classname> is the
        set of tuples
        that are in <classname>R</classname> and in
        <classname>S</classname>.
        We again require that <classname>R</classname> and
        <classname>S</classname> have the
        same arity.
       </para>
      </listitem>

      <listitem>
       <para>
        DIFFERENCE (&minus; or &setmn;): builds the set difference of
        two tables. Let <classname>R</classname> and <classname>S</classname>
        again be two tables with the same
        arity. <classname>R</classname> - <classname>S</classname>
        is the set of tuples in <classname>R</classname> but not in
        <classname>S</classname>.
       </para>
      </listitem>

      <listitem>
       <para>
        JOIN (&prod;): connects two tables by their common
        attributes. Let <classname>R</classname> be a table with the
        attributes <classname>A</classname>,<classname>B</classname>
        and <classname>C</classname> and
        let <classname>S</classname> be a table with the attributes
        <classname>C</classname>,<classname>D</classname>
        and <classname>E</classname>. There is one
        attribute common to both relations,
        the attribute <classname>C</classname>.
<!-&minus;
        <classname>R</classname> &prod; <classname>S</classname> =
        &pi;<subscript><classname>R</classname>.<classname>A</classname>,<classname>R</classname>.<classname>B</classname>,<classname>R</classname>.<classname>C</classname>,<classname>S</classname>.<classname>D</classname>,<classname>S</classname>.<classname>E</classname></subscript>(&sigma;<subscript><classname>R</classname>.<classname>C</classname>=<classname>S</classname>.<classname>C</classname></subscript>(<classname>R</classname> &times; <classname>S</classname>)).
-&minus;>
        R &prod; S = &pi;<subscript>R.A,R.B,R.C,S.D,S.E</subscript>(&sigma;<subscript>R.C=S.C</subscript>(R &times; S)).
        What are we doing here? We first calculate the Cartesian
        product
        <classname>R</classname> &times; <classname>S</classname>.
        Then we select those tuples whose values for the common
        attribute <classname>C</classname> are equal
        (&sigma;<subscript>R.C = S.C</subscript>).
        Now we have a table
        that contains the attribute <classname>C</classname>
        two times and we correct this by
        projecting out the duplicate column.
       </para>

       <example>
        <title id="join-example">An Inner Join</title>

        <para>
         Let's have a look at the tables that are produced by evaluating the steps
         necessary for a join.
         Let the following two tables be given:

<screen>
R:                 S:
 A | B | C          C | D | E
-&minus;-+-&minus;-+-&minus;-        -&minus;-+-&minus;-+-&minus;-
 1 | 2 | 3          3 | a | b
 4 | 5 | 6          6 | c | d
 7 | 8 | 9
</screen>
        </para>
       </example>

       <para>
        First we calculate the Cartesian product
        <classname>R</classname> &times; <classname>S</classname> and
        get:

<screen>
R x S:
 A | B | R.C | S.C | D | E
-&minus;-+-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-+-&minus;-
 1 | 2 |  3  |  3  | a | b
 1 | 2 |  3  |  6  | c | d
 4 | 5 |  6  |  3  | a | b
 4 | 5 |  6  |  6  | c | d
 7 | 8 |  9  |  3  | a | b
 7 | 8 |  9  |  6  | c | d
</screen>
       </para>

       <para>
        After the selection
        &sigma;<subscript>R.C=S.C</subscript>(R &times; S)
        we get:

<screen>
 A | B | R.C | S.C | D | E
-&minus;-+-&minus;-+-&minus;-&minus;-+-&minus;-&minus;-+-&minus;-+-&minus;-
 1 | 2 |  3  |  3  | a | b
 4 | 5 |  6  |  6  | c | d
</screen>
       </para>

       <para>
        To remove the duplicate column
        <classname>S</classname>.<classname>C</classname>
        we project it out by the following operation:
        &pi;<subscript>R.A,R.B,R.C,S.D,S.E</subscript>(&sigma;<subscript>R.C=S.C</subscript>(R &times; S))
        and get:

<screen>
 A | B | C | D | E
-&minus;-+-&minus;-+-&minus;-+-&minus;-+-&minus;-
 1 | 2 | 3 | a | b
 4 | 5 | 6 | c | d
</screen>
       </para>
      </listitem>

      <listitem>
       <para>
        DIVIDE (&divide;): Let <classname>R</classname> be a table
        with the attributes A, B, C, and D and let
        <classname>S</classname> be a table with the attributes
        C and D.
        Then we define the division as:

<programlisting>
R &divide; S = {t &mid; &forall; t<subscript>s</subscript> &isin; S &exist; t<subscript>r</subscript> &isin; R
</programlisting>

        such that
t<subscript>r</subscript>(A,B)=t&and;t<subscript>r</subscript>(C,D)=t<subscript>s</subscript>}
        where
        t<subscript>r</subscript>(x,y)
        denotes a
        tuple of table <classname>R</classname> that consists only of
        the components <literal>x</literal> and <literal>y</literal>.
        Note that the tuple <literal>t</literal> only consists of the
        components <classname>A</classname> and
        <classname>B</classname> of relation <classname>R</classname>.
       </para>

       <para id="divide-example">
        Given the following tables

<screen>
R:                    S:
 A | B | C | D         C | D
-&minus;-+-&minus;-+-&minus;-+-&minus;-       -&minus;-+-&minus;-
 a | b | c | d         c | d
 a | b | e | f         e | f
 b | c | e | f
 e | d | c | d
 e | d | e | f
 a | b | d | e
</screen>

        R &divide; S
        is derived as

<screen>
 A | B
-&minus;-+-&minus;-
 a | b
 e | d
</screen>
       </para>
      </listitem>
     </itemizedlist>
    </para>
____________________________________________________________________________-->
    <para>
     <firstterm>关系代数</firstterm>由 E. F. Codd 于 1972 年引入。它由一组关系上的操作构成：

     <itemizedlist>
      <listitem>
       <para>
        SELECT (&sigma;)：从一个关系中抽取满足一个给定限制的<firstterm>元组</firstterm>。令<parameter>R</parameter>是一个包含属性<parameter>A</parameter>的表。
&sigma;<subscript>A=a</subscript>(R) = {t &isin; R &mid; t(A) = a}
        其中<literal>t</literal>表示<parameter>R</parameter>的一个元组并且<literal>t(A)</literal>表示元组<literal>t</literal>中属性<parameter>A</parameter>的值。
       </para>
      </listitem>

      <listitem>
       <para>
        PROJECT (&pi;)：从一个关系中抽取指定的<firstterm>属性</firstterm>（列）。令<classname>R</classname>是一个包含属性<classname>X</classname>的关系。
        &pi;<subscript>X</subscript>(<classname>R</classname>) = {t(X) &mid; t &isin; <classname>R</classname>}
        其中<literal>t</literal>(<classname>X</classname>) 表示元组<literal>t</literal>中属性<classname>X</classname>的值。
       </para>
      </listitem>

      <listitem>
       <para>
        PRODUCT (&times;)：构建两个关系的笛卡尔积。令<classname>R</classname>是一个元数为<literal>k</literal><subscript>1</subscript>的表并且令<classname>S</classname>是一个元数为<literal>k</literal><subscript>2</subscript>的表。<classname>R</classname> &times; <classname>S</classname>是所有<literal>k</literal><subscript>1</subscript>
        + <literal>k</literal><subscript>2</subscript>-元组的集合，这种元组的前<literal>k</literal><subscript>1</subscript>个分量来自于<classname>R</classname>中的一个元组并且后<literal>k</literal><subscript>2</subscript>个分量来自<classname>S</classname>中的一个元组。
       </para>
      </listitem>

      <listitem>
       <para>
        UNION (&cup;)：构建两个表的集合论并。给定表<classname>R</classname>和<classname>S</classname>（都必须具有相同的元数），并<classname>R</classname> &cup; <classname>S</classname>是由来自<classname>R</classname>的元组和来自<classname>S</classname>的元组构成的集合。
       </para>
      </listitem>

      <listitem>
       <para>
        INTERSECT (&cap;)：构建两个表的集合论交。给定表<classname>R</classname>和<classname>S</classname>，<classname>R</classname> &cap; <classname>S</classname>是同时在<classname>R</classname>和<classname>S</classname>中的元组的集合。这里我们再次要求<classname>R</classname>和<classname>S</classname>具有相同的元数。
       </para>
      </listitem>

      <listitem>
       <para>
        DIFFERENCE (&minus; or &setmn;)：构建两个表的集合差。令<classname>R</classname>和<classname>S</classname>是具有相同元数的两个表。<classname>R</classname> - <classname>S</classname>是在<classname>R</classname>中但不在<classname>S</classname>中的元组的集合。
       </para>
      </listitem>

      <listitem>
       <para>
        JOIN (&prod;)：通过两个表的公共属性连接它们。令<classname>R</classname>是一个有属性<classname>A</classname>、<classname>B</classname>和<classname>C</classname>的表，并且令<classname>S</classname>是一个有属性<classname>C</classname>、<classname>D</classname>和<classname>E</classname>的表。在两个表之间有一个公共属性<classname>C</classname>。
<!--
        <classname>R</classname> &prod; <classname>S</classname> =
        &pi;<subscript><classname>R</classname>.<classname>A</classname>,<classname>R</classname>.<classname>B</classname>,<classname>R</classname>.<classname>C</classname>,<classname>S</classname>.<classname>D</classname>,<classname>S</classname>.<classname>E</classname></subscript>(&sigma;<subscript><classname>R</classname>.<classname>C</classname>=<classname>S</classname>.<classname>C</classname></subscript>(<classname>R</classname> &times; <classname>S</classname>)).
-->
        R &prod; S = &pi;<subscript>R.A,R.B,R.C,S.D,S.E</subscript>(&sigma;<subscript>R.C=S.C</subscript>(R &times; S))。
        这里我们要做什么呢？我们首先计算笛卡尔积<classname>R</classname> &times; <classname>S</classname>。然后我们选择那些在公共属性<classname>C</classname>上值相等（&sigma;<subscript>R.C = S.C</subscript>）的元组。现在我们得到一个表，它包含了属性<classname>C</classname>两次，并且我们会将重复列投影掉。
       </para>

       <example>
        <title id="join-example">一个内连接</title>

        <para>
         让我们看看通过计算一次连接所需的步骤产生的表。给定下面的两个表：

<screen>
R:                 S:
 A | B | C          C | D | E
---+---+---        ---+---+---
 1 | 2 | 3          3 | a | b
 4 | 5 | 6          6 | c | d
 7 | 8 | 9
</screen>
        </para>
       </example>

       <para>
        首先我们计算笛卡尔积<classname>R</classname> &times; <classname>S</classname>，并且得到：

<screen>
R x S:
 A | B | R.C | S.C | D | E
---+---+-----+-----+---+---
 1 | 2 |  3  |  3  | a | b
 1 | 2 |  3  |  6  | c | d
 4 | 5 |  6  |  3  | a | b
 4 | 5 |  6  |  6  | c | d
 7 | 8 |  9  |  3  | a | b
 7 | 8 |  9  |  6  | c | d
</screen>
       </para>

       <para>
        在进行选择
        &sigma;<subscript>R.C=S.C</subscript>(R &times; S)
        后我们得到：

<screen>
 A | B | R.C | S.C | D | E
---+---+-----+-----+---+---
 1 | 2 |  3  |  3  | a | b
 4 | 5 |  6  |  6  | c | d
</screen>
       </para>

       <para>
        为了消除重复列<classname>S</classname>.<classname>C</classname>，我们通过下面的操作将它投影掉：
        &pi;<subscript>R.A,R.B,R.C,S.D,S.E</subscript>(&sigma;<subscript>R.C=S.C</subscript>(R &times; S))
        并且得到：

<screen>
 A | B | C | D | E
---+---+---+---+---
 1 | 2 | 3 | a | b
 4 | 5 | 6 | c | d
</screen>
       </para>
      </listitem>

      <listitem>
       <para>
        DIVIDE (&divide;)：令<classname>R</classname>是一个有属性 A、B、C 和 D 的表并且另<classname>S</classname>是一个有属性 C 和 D 的表。那么我们定义除为：

<programlisting>
R &divide; S = {t &mid; &forall; t<subscript>s</subscript> &isin; S &exist; t<subscript>r</subscript> &isin; R
</programlisting>

        这样
t<subscript>r</subscript>(A,B)=t&and;t<subscript>r</subscript>(C,D)=t<subscript>s</subscript>}
        其中
        t<subscript>r</subscript>(x,y)
        表示一个表<classname>R</classname>的元组，它由两个分量<literal>x</literal>和<literal>y</literal>组成。注意该元组<literal>t</literal>只由关系<classname>R</classname>的分量<classname>A</classname>和<classname>B</classname>组成。
       </para>

       <para id="divide-example">
        给定下列表

<screen>
R:                    S:
 A | B | C | D         C | D
---+---+---+---       ---+---
 a | b | c | d         c | d
 a | b | e | f         e | f
 b | c | e | f
 e | d | c | d
 e | d | e | f
 a | b | d | e
</screen>

        R &divide; S
        会得到

<screen>
 A | B
---+---
 a | b
 e | d
</screen>
       </para>
      </listitem>
     </itemizedlist>
    </para>

<!--==========================orignal english content==========================
    <para>
     For a more detailed description and definition of the relational
     algebra refer to [<xref linkend="ULL88" endterm="ULL88">] or
     [<xref linkend="DATE04" endterm="DATE04">].
    </para>
____________________________________________________________________________-->
    <para>
     关于关系代数的详细描述和定义可以参考 [<xref linkend="ULL88" endterm="ULL88">] 或 [<xref linkend="DATE04" endterm="DATE04">]。
    </para>

    <example>
<!--==========================orignal english content==========================
     <title id="suppl-rel-alg">A Query Using Relational Algebra</title>
____________________________________________________________________________-->
     <title id="suppl-rel-alg">使用关系代数的一个查询</title>
<!--==========================orignal english content==========================
     <para>
      Recall that we formulated all those relational operators to be able to
      retrieve data from the database. Let's return to our example from
      the previous
      section (<xref linkend="operations" endterm="operations">)
      where someone wanted to know the names of all
      suppliers that sell the part <literal>Screw</literal>.
      This question can be answered
      using relational algebra by the following operation:

<programlisting>
&pi;<subscript>SUPPLIER.SNAME</subscript>(&sigma;<subscript>PART.PNAME='Screw'</subscript>(SUPPLIER &prod; SELLS &prod; PART))
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      回顾一下，我们形式化了所有那些能从数据库中检索数据的操作符。让我们回到前一节（<xref linkend="operations" endterm="operations">）中的例子，其中某人想要知道所有销售部件<literal>Screw</literal>的供应商的名称。这个问题可以通过使用下列操作的关系代数来回答：

<programlisting>
&pi;<subscript>SUPPLIER.SNAME</subscript>(&sigma;<subscript>PART.PNAME='Screw'</subscript>(SUPPLIER &prod; SELLS &prod; PART))
</programlisting>
     </para>

<!--==========================orignal english content==========================
     <para>
      We call such an operation a query. If we evaluate the above query
      against the our example tables
      (<xref linkend="supplier-fig" endterm="supplier-fig">)
      we will obtain the following result:

<screen>
 SNAME
-&minus;-&minus;-&minus;-
 Smith
 Adams
</screen>
     </para>
____________________________________________________________________________-->
     <para>
      我们称这样一种操作为查询。如果我们针对我们的例子表（<xref linkend="supplier-fig" endterm="supplier-fig">）计算上面的查询，我们将得到下面的结果：

<screen>
 SNAME
-------
 Smith
 Adams
</screen>
     </para>
    </example>
   </sect2>

   <sect2 id="rel-calc">
<!--==========================orignal english content==========================
    <title>Relational Calculus</title>
____________________________________________________________________________-->
    <title>关系演算</title>

<!--==========================orignal english content==========================
    <para>
     The relational calculus is based on the
     <firstterm>first order logic</firstterm>. There are
     two variants of the relational calculus:

     <itemizedlist>
      <listitem>
       <para>
        The <firstterm>Domain Relational Calculus</firstterm>
        (<acronym>DRC</acronym>), where variables
        stand for components (attributes) of the tuples.
       </para>
      </listitem>

      <listitem>
       <para>
        The <firstterm>Tuple Relational Calculus</firstterm>
        (<acronym>TRC</acronym>), where variables stand for tuples.
       </para>
      </listitem>
     </itemizedlist>
    </para>
____________________________________________________________________________-->
    <para>
     关系演算基于<firstterm>一阶逻辑</firstterm>。关系演算有两种变体：

     <itemizedlist>
      <listitem>
       <para>
        <firstterm>域关系演算</firstterm>（<acronym>DRC</acronym>），其中变量代表元组的分量（属性）。
       </para>
      </listitem>

      <listitem>
       <para>
        <firstterm>元组关系演算</firstterm>（<acronym>TRC</acronym>），其中变量代表元组。
       </para>
      </listitem>
     </itemizedlist>
    </para>

<!--==========================orignal english content==========================
    <para>
     We want to discuss the tuple relational calculus only because it is
     the one underlying the most relational languages. For a detailed
     discussion on <acronym>DRC</acronym> (and also
     <acronym>TRC</acronym>) see
     <xref linkend="DATE04" endterm="DATE04">
     or
     <xref linkend="ULL88" endterm="ULL88">.
    </para>
____________________________________________________________________________-->
    <para>
     我们只想讨论元组关系演算，因为它是处于大部分关系语言底层的一种语言。关于<acronym>DRC</acronym>（以及还有<acronym>TRC</acronym>）的详细讨论可以见
     <xref linkend="DATE04" endterm="DATE04">
     或
     <xref linkend="ULL88" endterm="ULL88">。
    </para>
   </sect2>

   <sect2>
<!--==========================orignal english content==========================
    <title>Tuple Relational Calculus</title>
____________________________________________________________________________-->
    <title>元组关系演算</title>

<!--==========================orignal english content==========================
    <para>
     The queries used in <acronym>TRC</acronym> are of the following
     form:

<programlisting>
x(A) &mid; F(x)
</programlisting>

     where <literal>x</literal> is a tuple variable
     <classname>A</classname> is a set of attributes and <literal>F</literal> is a
     formula. The resulting relation consists of all tuples
     <literal>t(A)</literal> that satisfy <literal>F(t)</literal>.
    </para>
____________________________________________________________________________-->
    <para>
     <acronym>TRC</acronym>中用到的查询具有下面的形式：

<programlisting>
x(A) &mid; F(x)
</programlisting>

     其中<literal>x</literal>是一个元组变量，<classname>A</classname>是一个属性集合而<literal>F</literal>是一个公式。由所有满足<literal>F(t)</literal>的元组<literal>t(A)</literal>构成结果关系。
    </para>

<!--==========================orignal english content==========================
    <para>
     If we want to answer the question from example
     <xref linkend="suppl-rel-alg" endterm="suppl-rel-alg">
     using <acronym>TRC</acronym> we formulate the following query:

<programlisting>
{x(SNAME) &mid; x &isin; SUPPLIER &and;
    &exist; y &isin; SELLS &exist; z &isin; PART (y(SNO)=x(SNO) &and;
    z(PNO)=y(PNO) &and;
    z(PNAME)='Screw')}
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     如果我们想要使用<acronym>TRC</acronym>来回答例子<xref linkend="suppl-rel-alg" endterm="suppl-rel-alg">中的问题，我们可以构造下面的查询：

<programlisting>
{x(SNAME) &mid; x &isin; SUPPLIER &and;
    &exist; y &isin; SELLS &exist; z &isin; PART (y(SNO)=x(SNO) &and;
    z(PNO)=y(PNO) &and;
    z(PNAME)='Screw')}
</programlisting>
    </para>

<!--==========================orignal english content==========================
    <para>
     Evaluating the query against the tables from
     <xref linkend="supplier-fig" endterm="supplier-fig">
     again leads to the same result
     as in
     <xref linkend="suppl-rel-alg" endterm="suppl-rel-alg">.
    </para>
____________________________________________________________________________-->
    <para>
     针对<xref linkend="supplier-fig" endterm="supplier-fig">中的表计算该查询会再次得到<xref linkend="suppl-rel-alg" endterm="suppl-rel-alg">中相同的结果。
    </para>
   </sect2>

   <sect2 id="alg-vs-calc">
<!--==========================orignal english content==========================
    <title>Relational Algebra vs. Relational Calculus</title>
____________________________________________________________________________-->
    <title>关系代数 vs. 关系演算</title>

<!--==========================orignal english content==========================
    <para>
     The relational algebra and the relational calculus have the same
     <firstterm>expressive power</firstterm>; i.e., all queries that
     can be formulated using relational algebra can also be formulated
     using the relational calculus and vice versa.
     This was first proved by E. F. Codd in
     1972. This proof is based on an algorithm (<quote>Codd's reduction
     algorithm</quote>) by which an arbitrary expression of the relational
     calculus can be reduced to a semantically equivalent expression of
     relational algebra. For a more detailed discussion on that refer to
     <xref linkend="DATE04" endterm="DATE04">
     and
     <xref linkend="ULL88" endterm="ULL88">.
    </para>
____________________________________________________________________________-->
    <para>
     关系代数和关系演算具有相同的<firstterm>表达能力</firstterm>，即所有能用关系代数表达的查询也能使用关系演算表达，反之亦然。这最初被 E. F. Codd 在 1972 年所证明。这个证明基于一个算法（<quote>Codd 的规约算法</quote>），通过它一个任意关系演算表达式可以被规约到一个语义上等价的关系代数表达式。关于此的详细讨论可以参考
     <xref linkend="DATE04" endterm="DATE04">
     和
     <xref linkend="ULL88" endterm="ULL88">。
    </para>

<!--==========================orignal english content==========================
    <para>
     It is sometimes said that languages based on the relational
     calculus are <quote>higher level</quote> or <quote>more
     declarative</quote> than languages based on relational algebra
     because the algebra (partially) specifies the order of operations
     while the calculus leaves it to a compiler or interpreter to
     determine the most efficient order of evaluation.
    </para>
____________________________________________________________________________-->
    <para>
     有时候我们说基于关系演算的语言比基于关系代数的语言<quote>更高层</quote>或者<quote>更具说明性</quote>，因为代数（部分地）指定了操作的顺序，而演算把决定最有效计算顺序的工作留给一个编译器或解释器来做。
    </para>
   </sect2>
  </sect1>

  <sect1 id="sql-language">
<!--==========================orignal english content==========================
   <title>The <acronym>SQL</acronym> Language</title>
____________________________________________________________________________-->
   <title><acronym>SQL</acronym>语言</title>

<!--==========================orignal english content==========================
   <para>
    As is the case with most modern relational languages,
    <acronym>SQL</acronym> is based on the tuple
    relational calculus. As a result every query that can be formulated
    using the tuple relational calculus (or equivalently, relational
    algebra) can also be formulated using
    <acronym>SQL</acronym>. There are, however,
    capabilities beyond the scope of relational algebra or calculus. Here
    is a list of some additional features provided by
    <acronym>SQL</acronym> that are not
    part of relational algebra or calculus:

    <itemizedlist>
     <listitem>
      <para>
       Commands for insertion, deletion or modification of data.
      </para>
     </listitem>

     <listitem>
      <para>
       Arithmetic capability: In <acronym>SQL</acronym> it is possible
       to involve
       arithmetic operations as well as comparisons, e.g.:

<programlisting>
A &lt; B + 3.
</programlisting>

       Note
       that + or other arithmetic operators appear neither in relational
       algebra nor in relational calculus.
      </para>
     </listitem>

     <listitem>
      <para>
       Assignment and Print Commands: It is possible to print a
       relation constructed by a query and to assign a computed relation to a
       relation name.
      </para>
     </listitem>

     <listitem>
      <para>
       Aggregate Functions: Operations such as
       <firstterm>average</firstterm>, <firstterm>sum</firstterm>,
       <firstterm>max</firstterm>, etc. can be applied to columns of a
       relation to
       obtain a single quantity.
      </para>
     </listitem>
    </itemizedlist>
   </para>
____________________________________________________________________________-->
   <para>
    作为一种现代关系语言，<acronym>SQL</acronym>基于元组关系演算。因此每一个能用元组关系演算（或者等价的关系代数）表达的查询也能用<acronym>SQL</acronym>表达。但是，它有超出关系代数或演算范围的能力。这里是<acronym>SQL</acronym>提供的一些额外特性的列表，它们不是关系代数或演算的一部分：

    <itemizedlist>
     <listitem>
      <para>
       用于插入、删除或修改数据的命令。
      </para>
     </listitem>

     <listitem>
      <para>
       算术能力：在<acronym>SQL</acronym>中能够和比较一样涉及算术操作，例如：

<programlisting>
A &lt; B + 3.
</programlisting>

       注意在关系代数或关系演算中不出现 + 或其他算术操作符。
      </para>
     </listitem>

     <listitem>
      <para>
       赋值和打印命令：可以打印由一个查询构造的关系并且为一个计算的关系指派一个关系名。
      </para>
     </listitem>

     <listitem>
      <para>
       聚集函数：诸如<firstterm>average</firstterm>、<firstterm>sum</firstterm>、<firstterm>max</firstterm>等操作可以被应用在一个关系的列上来得到一个单一量。
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <sect2 id="select">
<!--==========================orignal english content==========================
    <title id="select-title">Select</title>
____________________________________________________________________________-->
    <title id="select-title">选择</title>

<!--==========================orignal english content==========================
    <para>
     The most often used command in <acronym>SQL</acronym> is the
     <command>SELECT</command> statement,
     used to retrieve data. The syntax is:

<synopsis>
SELECT [ ALL | DISTINCT [ ON ( <replaceable class="PARAMETER">expression</replaceable> [, ...] ) ] ]
    * | <replaceable class="PARAMETER">expression</replaceable> [ [ AS ] <replaceable class="PARAMETER">output_name</replaceable> ] [, ...]
    [ INTO [ TEMPORARY | TEMP ] [ TABLE ] <replaceable class="PARAMETER">new_table</replaceable> ]
    [ FROM <replaceable class="PARAMETER">from_item</replaceable> [, ...] ]
    [ WHERE <replaceable class="PARAMETER">condition</replaceable> ]
    [ GROUP BY <replaceable class="PARAMETER">expression</replaceable> [, ...] ]
    [ HAVING <replaceable class="PARAMETER">condition</replaceable> [, ...] ]
    [ { UNION | INTERSECT | EXCEPT } [ ALL ] <replaceable class="PARAMETER">select</replaceable> ]
    [ ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC | DESC | USING <replaceable class="parameter">operator</replaceable> ] [ NULLS { FIRST | LAST } ] [, ...] ]
    [ LIMIT { <replaceable class="PARAMETER">count</replaceable> | ALL } ]
    [ OFFSET <replaceable class="PARAMETER">start</replaceable> ]
    [ FOR { UPDATE | SHARE } [ OF <replaceable class="parameter">table_name</replaceable> [, ...] ] [ NOWAIT | SKIP LOCKED ] [...] ]
</synopsis>
    </para>
____________________________________________________________________________-->
    <para>
     <acronym>SQL</acronym>中最常用的命令是<command>SELECT</command>语句，它被用来检索数据。语法是：

<synopsis>
SELECT [ ALL | DISTINCT [ ON ( <replaceable class="PARAMETER">expression</replaceable> [, ...] ) ] ]
    * | <replaceable class="PARAMETER">expression</replaceable> [ [ AS ] <replaceable class="PARAMETER">output_name</replaceable> ] [, ...]
    [ INTO [ TEMPORARY | TEMP ] [ TABLE ] <replaceable class="PARAMETER">new_table</replaceable> ]
    [ FROM <replaceable class="PARAMETER">from_item</replaceable> [, ...] ]
    [ WHERE <replaceable class="PARAMETER">condition</replaceable> ]
    [ GROUP BY <replaceable class="PARAMETER">expression</replaceable> [, ...] ]
    [ HAVING <replaceable class="PARAMETER">condition</replaceable> [, ...] ]
    [ { UNION | INTERSECT | EXCEPT } [ ALL ] <replaceable class="PARAMETER">select</replaceable> ]
    [ ORDER BY <replaceable class="parameter">expression</replaceable> [ ASC | DESC | USING <replaceable class="parameter">operator</replaceable> ] [ NULLS { FIRST | LAST } ] [, ...] ]
    [ LIMIT { <replaceable class="PARAMETER">count</replaceable> | ALL } ]
    [ OFFSET <replaceable class="PARAMETER">start</replaceable> ]
    [ FOR { UPDATE | SHARE } [ OF <replaceable class="parameter">table_name</replaceable> [, ...] ] [ NOWAIT | SKIP LOCKED ] [...] ]
</synopsis>
    </para>

<!--==========================orignal english content==========================
    <para>
     Now we will illustrate the complex syntax of the
     <command>SELECT</command> statement with various examples. The
     tables used for the examples are defined in <xref
     linkend="supplier-fig" endterm="supplier-fig">.
    </para>
____________________________________________________________________________-->
    <para>
     现在我们将通过多个例子阐述<command>SELECT</command>语句的复杂语法。这些例子中用到的表被定义在<xref linkend="supplier-fig" endterm="supplier-fig">中。
    </para>

    <sect3>
<!--==========================orignal english content==========================
     <title>Simple Selects</title>
____________________________________________________________________________-->
     <title>简单选择</title>

<!--==========================orignal english content==========================
     <para>
      Here are some simple examples using a <command>SELECT</command> statement:

      <example>
       <title id="simple-query">Simple Query with Qualification</title>
       <para>
        To retrieve all tuples from table PART where the attribute PRICE is
        greater than 10 we formulate the following query:

<programlisting>
SELECT * FROM PART
    WHERE PRICE &gt; 10;
</programlisting>

        and get the table:

<screen>
 PNO |  PNAME  |  PRICE
-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;
  3  |  Bolt   |   15
  4  |  Cam    |   25
</screen>
       </para>

       <para>
        Using <quote>*</quote> in the <command>SELECT</command> statement
        will deliver all attributes from the table. If we want to retrieve
        only the attributes PNAME and PRICE from table PART we use the
        statement:

<programlisting>
SELECT PNAME, PRICE
    FROM PART
    WHERE PRICE &gt; 10;
</programlisting>

        In this case the result is:

<screen>
                      PNAME  |  PRICE
                     -&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;
                      Bolt   |   15
                      Cam    |   25
</screen>

        Note that the <acronym>SQL</acronym> <command>SELECT</command>
        corresponds to the <quote>projection</quote> in relational algebra
        not to the <quote>selection</quote> (see <xref linkend="rel-alg"
        endterm="rel-alg"> for more details).
       </para>

       <para>
        The qualifications in the WHERE clause can also be logically connected
        using the keywords OR, AND, and NOT:

<programlisting>
SELECT PNAME, PRICE
    FROM PART
    WHERE PNAME = 'Bolt' AND
         (PRICE = 0 OR PRICE &lt;= 15);
</programlisting>

        will lead to the result:

<screen>
 PNAME  |  PRICE
-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;
 Bolt   |   15
</screen>
       </para>

       <para>
        Arithmetic operations can be used in the target list and in the WHERE
        clause. For example if we want to know how much it would cost if we
        take two pieces of a part we could use the following query:

<programlisting>
SELECT PNAME, PRICE * 2 AS DOUBLE
    FROM PART
    WHERE PRICE * 2 &lt; 50;
</programlisting>

        and we get:

<screen>
 PNAME  |  DOUBLE
-&minus;-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-
 Screw  |    20
 Nut    |    16
 Bolt   |    30
</screen>

        Note that the word DOUBLE after the keyword AS is the new title of the
        second column. This technique can be used for every element of the
        target list to assign a new title to the resulting
        column. This new title
        is often referred to as alias. The alias cannot be used throughout the
        rest of the query.
       </para>
      </example>
     </para>
____________________________________________________________________________-->
     <para>
      这里是一些使用<command>SELECT</command>语句的简单例子：

      <example>
       <title id="simple-query">带条件的简单查询</title>
       <para>
        要从表 PART 中检索属性 PRICE 大于 10 的所有元组，我们可以用下面的查询：

<programlisting>
SELECT * FROM PART
    WHERE PRICE &gt; 10;
</programlisting>

        并且得到表：

<screen>
 PNO |  PNAME  |  PRICE
-----+---------+--------
  3  |  Bolt   |   15
  4  |  Cam    |   25
</screen>
       </para>

       <para>
        在<command>SELECT</command>中使用<quote>*</quote>将会显示表中所有的属性。如果我们想只检索表 PART 中的 PNAME 和 PRICE 属性，我们使用语句：

<programlisting>
SELECT PNAME, PRICE
    FROM PART
    WHERE PRICE &gt; 10;
</programlisting>

        在这种情况下结果是：

<screen>
                      PNAME  |  PRICE
                     --------+--------
                      Bolt   |   15
                      Cam    |   25
</screen>

        注意<acronym>SQL</acronym> <command>SELECT</command>对应于关系代数中的<quote>投影</quote>而不是<quote>选择</quote>（详见<xref linkend="rel-alg" endterm="rel-alg">）。
       </para>

       <para>
        WHERE 子句中的条件也可以用关键词 OR、AND 和 NOT 进行连接：

<programlisting>
SELECT PNAME, PRICE
    FROM PART
    WHERE PNAME = 'Bolt' AND
         (PRICE = 0 OR PRICE &lt;= 15);
</programlisting>

        将会得到结果：

<screen>
 PNAME  |  PRICE
--------+--------
 Bolt   |   15
</screen>
       </para>

       <para>
        算术运算可以被用在目标列表和 WHERE 子句中。例如我们想要知道买两份部件的价格，我们可以使用下面的查询：

<programlisting>
SELECT PNAME, PRICE * 2 AS DOUBLE
    FROM PART
    WHERE PRICE * 2 &lt; 50;
</programlisting>

        并且我们得到：

<screen>
 PNAME  |  DOUBLE
--------+---------
 Screw  |    20
 Nut    |    16
 Bolt   |    30
</screen>

        注意关键词 AS 后面的词 DOUBLE 是第二列的新标题。这种技术可以被用在目标列表中的每一个元素上来为结果列指派一个新标题。这种新标题通常被称为别名。别名不能被用在该查询的剩余部分。
       </para>
      </example>
     </para>
    </sect3>

    <sect3>
<!--==========================orignal english content==========================
     <title>Joins</title>
____________________________________________________________________________-->
     <title>连接</title>

<!--==========================orignal english content==========================
     <para id="simple-join">
      The following example shows how <firstterm>joins</firstterm> are
      realized in <acronym>SQL</acronym>.
     </para>
____________________________________________________________________________-->
     <para id="simple-join">
      下面的例子展示了<firstterm>连接</firstterm>在<acronym>SQL</acronym>中是如何实现的。
     </para>

<!--==========================orignal english content==========================
     <para>
      To join the three tables SUPPLIER, PART and SELLS over their common
      attributes we formulate the following statement:

<programlisting>
SELECT S.SNAME, P.PNAME
    FROM SUPPLIER S, PART P, SELLS SE
    WHERE S.SNO = SE.SNO AND
          P.PNO = SE.PNO;
</programlisting>

      and get the following table as a result:

<screen>
 SNAME | PNAME
-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-
 Smith | Screw
 Smith | Nut
 Jones | Cam
 Adams | Screw
 Adams | Bolt
 Blake | Nut
 Blake | Bolt
 Blake | Cam
</screen>
     </para>
____________________________________________________________________________-->
     <para>
      要在三个表 SUPPLIER、PART 和 SELLS 的公共属性上连接它们，我们可以用下面的语句：

<programlisting>
SELECT S.SNAME, P.PNAME
    FROM SUPPLIER S, PART P, SELLS SE
    WHERE S.SNO = SE.SNO AND
          P.PNO = SE.PNO;
</programlisting>

      并且得到下面的结果表：

<screen>
 SNAME | PNAME
-------+-------
 Smith | Screw
 Smith | Nut
 Jones | Cam
 Adams | Screw
 Adams | Bolt
 Blake | Nut
 Blake | Bolt
 Blake | Cam
</screen>
     </para>

<!--==========================orignal english content==========================
     <para>
      In the FROM clause we introduced an alias name for every relation
      because there are common named attributes (SNO and PNO) among the
      relations. Now we can distinguish between the common named attributes
      by simply prefixing the attribute name with the alias name followed by
      a dot. The join is calculated in the same way as shown in
      <xref linkend="join-example" endterm="join-example">.
      First the Cartesian product

      SUPPLIER &times; PART &times; SELLS

      is derived. Now only those tuples satisfying the
      conditions given in the WHERE clause are selected (i.e., the common
      named attributes have to be equal). Finally we project out all
      columns but S.SNAME and P.PNAME.
     </para>
____________________________________________________________________________-->
     <para>
      在 FROM 子句中我们为每一个关系引入了一个别名，因为在关系之间有公共命名属性（SNO 和 PNO）。现在我们可以通过在属性名前面放上别名及一个句点来区分公共命名属性。连接采用<xref linkend="join-example" endterm="join-example">中所示的相同方式计算。首先是生成笛卡尔积

      SUPPLIER &times; PART &times; SELLS

      。现在只选择那些满足 WHERE 子句中给定条件的元组（即公共命名属性必须相等）。最后我们投影掉除 S.SNAME 和 P.PNAME 之外的其他列。
     </para>

<!--==========================orignal english content==========================
     <para>
     Another way to perform joins is to use the SQL JOIN syntax as follows:
<programlisting>
SELECT sname, pname from supplier
    JOIN sells USING (sno)
    JOIN part USING (pno);
</programlisting>
    giving again:
<screen>
 sname | pname
-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-
 Smith | Screw
 Adams | Screw
 Smith | Nut
 Blake | Nut
 Adams | Bolt
 Blake | Bolt
 Jones | Cam
 Blake | Cam
(8 rows)
</screen>
     </para>
____________________________________________________________________________-->
     <para>
     另一种执行连接的方法是使用如下的 SQL JOIN 语法：
<programlisting>
SELECT sname, pname from supplier
    JOIN sells USING (sno)
    JOIN part USING (pno);
</programlisting>
    再次得到：
<screen>
 sname | pname
-------+-------
 Smith | Screw
 Adams | Screw
 Smith | Nut
 Blake | Nut
 Adams | Bolt
 Blake | Bolt
 Jones | Cam
 Blake | Cam
(8 rows)
</screen>
     </para>

<!--==========================orignal english content==========================
     <para>
     A joined table, created using JOIN syntax, is a table reference list
     item that occurs in a FROM clause and before any WHERE, GROUP BY,
     or HAVING clause.  Other table references, including table names or
     other JOIN clauses, can be included in the FROM clause if separated
     by commas.  JOINed tables are logically like any other
     table listed in the FROM clause.
     </para>
____________________________________________________________________________-->
     <para>
     使用 JOIN 语法创建的一个连接表，是一个出现在 FROM 子句中的表引用列表项并且它位于任何 WHERE、GROUP BY 或 HAVING 子句之前。其他表引用（包括表名或其他 JOIN 子句）可以用逗号分隔的方式被包括在 FROM 子句中。JOIN 的表逻辑上和列在 FROM 子句中的其他表是相似的。
     </para>

<!--==========================orignal english content==========================
     <para>
      SQL JOINs come in two main types, CROSS JOINs (unqualified joins)
      and <firstterm>qualified JOINs</>.  Qualified joins can be further
      subdivided based on the way in which the <firstterm>join condition</>
      is specified (ON, USING, or NATURAL) and the way in which it is
      applied (INNER or OUTER join).
     </para>
____________________________________________________________________________-->
     <para>
      SQL JOIN 有两种主要类型：CROSS JOIN（无条件连接）和<firstterm>条件 JOIN</>。条件连接可以进一步被按照<firstterm>连接条件</>被指定的方式（ON、USING 或 NATURAL）和被应用的方式（INNER 或 OUTER 连接）来划分。
     </para>

    <variablelist>
<!--==========================orignal english content==========================
        <title>Join Types</title>
____________________________________________________________________________-->
        <title>连接类型</title>
        <varlistentry>
<!--==========================orignal english content==========================
            <term>CROSS JOIN</term>
____________________________________________________________________________-->
            <term>CROSS JOIN</term>
            <listitem>
<!--==========================orignal english content==========================
            <cmdsynopsis>
                <arg choice="req"> <replaceable class="parameter">T1</replaceable> </arg>
                <command> CROSS JOIN </command>
                <arg choice="req"> <replaceable class="parameter">T2</replaceable> </arg>
            </cmdsynopsis>
____________________________________________________________________________-->
            <cmdsynopsis>
                <arg choice="req"> <replaceable class="parameter">T1</replaceable> </arg>
                <command> CROSS JOIN </command>
                <arg choice="req"> <replaceable class="parameter">T2</replaceable> </arg>
            </cmdsynopsis>

<!--==========================orignal english content==========================
            <para>
            A cross join takes two tables T1 and T2 having N and M rows
            respectively, and returns a joined table containing all
            N*M possible joined rows. For each row R1 of T1, each row
            R2 of T2 is joined with R1 to yield a joined table row JR
            consisting of all fields in R1 and R2. A CROSS JOIN is
            equivalent to an INNER JOIN ON TRUE.
            </para>
____________________________________________________________________________-->
            <para>
            一个交叉连接采用两个表 T1 和 T2，它们分别有 N 和 M 行，并且返回一个连接表，其中包含所有的 N*M 个可能的连接行。对于 T1 的每一行 R1，T2 的每一行 R2 都会与 R1 连接来得到一个连接表行 JR，JR 由 R1 和 R2 中所有的域组成。一个 CROSS JOIN 等价于一个 INNER JOIN ON TRUE。
            </para>
            </listitem>
        </varlistentry>

        <varlistentry>
<!--==========================orignal english content==========================
            <term>Qualified JOINs</term>
____________________________________________________________________________-->
            <term>条件 JOIN</term>
            <listitem>

<!--==========================orignal english content==========================
            <cmdsynopsis>
            <arg choice="req"> <replaceable class="parameter">T1</replaceable> </arg>
            <arg choice="opt"> NATURAL </arg>
            <group choice="opt">
                <arg choice="opt"> INNER </arg>
                <arg choice="plain">
                <group choice="req">
                    <arg choice="plain"> LEFT </arg>
                    <arg choice="plain"> RIGHT </arg>
                    <arg choice="plain"> FULL </arg>
                </group>
                <arg choice="opt"> OUTER </arg>
                    </arg>
                </group>
            <command> JOIN </command>
            <arg choice="req"> <replaceable class="parameter">T2</replaceable> </arg>
            <group choice="req">
                <arg choice="plain"> ON <replaceable>search condition</replaceable></arg>
                <arg choice="plain"> USING ( <replaceable>join column list</replaceable> ) </arg>
            </group>
            </cmdsynopsis>
____________________________________________________________________________-->
            <cmdsynopsis>
            <arg choice="req"> <replaceable class="parameter">T1</replaceable> </arg>
            <arg choice="opt"> NATURAL </arg>
            <group choice="opt">
                <arg choice="opt"> INNER </arg>
                <arg choice="plain">
                <group choice="req">
                    <arg choice="plain"> LEFT </arg>
                    <arg choice="plain"> RIGHT </arg>
                    <arg choice="plain"> FULL </arg>
                </group>
                <arg choice="opt"> OUTER </arg>
                    </arg>
                </group>
            <command> JOIN </command>
            <arg choice="req"> <replaceable class="parameter">T2</replaceable> </arg>
            <group choice="req">
                <arg choice="plain"> ON <replaceable>搜索条件</replaceable></arg>
                <arg choice="plain"> USING ( <replaceable>连接列列表</replaceable> ) </arg>
            </group>
            </cmdsynopsis>

<!--==========================orignal english content==========================
            <para>
            A qualified JOIN must specify its join condition
            by providing one (and only one) of NATURAL, ON, or
            USING.  The ON clause
            takes a <replaceable>search condition</replaceable>,
            which is the same as in a WHERE clause.  The USING
            clause takes a comma-separated list of column names,
            which the joined tables must have in common, and joins
            the tables on equality of those columns.  NATURAL is
            shorthand for a USING clause that lists all the common
            column names of the two tables.  A side-effect of both
            USING and NATURAL is that only one copy of each joined
            column is emitted into the result table (compare the
            relational-algebra definition of JOIN, shown earlier).
            </para>
____________________________________________________________________________-->
            <para>
            一个条件 JOIN 必须通过提供一个（并且只要一个）NATURAL、ON 或 USING 来指定它的连接条件。ON 子句用一个和 WHERE 子句中相同的<replaceable>搜索条件</replaceable>。USING 子句采用一个用逗号分隔的列名列表，其中的列是被连接表必须公有的并且将连接要求在那些列上相等。NATURAL 是一个列出两个表公共列名的 USING 子句的简写。USING 和 NATURAL 都有的一个副作用是每种被连接列只会有一个拷贝被发送到结果表中（比较一下先前关系代数中对 JOIN 的定义）。
            </para>

            <!-- begin join semantics -->
            <variablelist>
            <varlistentry>
<!--==========================orignal english content==========================
                <term>
                    <cmdsynopsis>
                        <arg choice="opt"> INNER </arg>
                        <command> JOIN </command>
                    </cmdsynopsis>
                </term>
____________________________________________________________________________-->
                <term>
                    <cmdsynopsis>
                        <arg choice="opt"> INNER </arg>
                        <command> JOIN </command>
                    </cmdsynopsis>
                </term>
                <listitem>
<!--==========================orignal english content==========================
                <para>
                For each row R1 of T1, the joined table has a row for each row
                in T2 that satisfies the join condition with R1.
                </para>
____________________________________________________________________________-->
                <para>
                对 T1 的每一行 R1，连接表为 T2 中与 R1 满足连接条件的每一行都有一个行。
                </para>
                <tip>
<!--==========================orignal english content==========================
                <para>
                    The words INNER and OUTER are optional for all JOINs.
                    INNER is the default.  LEFT, RIGHT, and FULL imply an
                    OUTER JOIN.
                    </para>
____________________________________________________________________________-->
                <para>
                    单词 INNER 和 OUTER 对于所有 JOIN 都是可选的。INNER 是默认值。LEFT、RIGHT 和 FULL 暗示一个 OUTER JOIN。
                    </para>
                </tip>
                </listitem>
            </varlistentry>
            <varlistentry>
<!--==========================orignal english content==========================
                <term>
                    <cmdsynopsis>
                        <arg choice="plain"> LEFT </arg>
                        <arg choice="opt"> OUTER </arg>
                        <command> JOIN </command>
                    </cmdsynopsis>
                </term>
____________________________________________________________________________-->
                <term>
                    <cmdsynopsis>
                        <arg choice="plain"> LEFT </arg>
                        <arg choice="opt"> OUTER </arg>
                        <command> JOIN </command>
                    </cmdsynopsis>
                </term>
                <listitem>
<!--==========================orignal english content==========================
                <para>
                First, an INNER JOIN is performed.
                Then, for each row in T1 that does not satisfy the join
                condition with any row in T2, an additional joined row is
                returned with null fields in the columns from T2.
                </para>
____________________________________________________________________________-->
                <para>
                首先执行一个 INNER JOIN。然后对于 T1 中每一个与 T2 中任意行都不满足连接条件的行，将返回一个额外的连接行，它在来自于 T2 的列上取空值。
                </para>
                <tip>
<!--==========================orignal english content==========================
                    <para>
                    The joined table unconditionally has a row for each row in T1.
                    </para>
____________________________________________________________________________-->
                    <para>
                    连接表对于 T1 的每一行都无条件地有一行。
                    </para>
                </tip>
                </listitem>
            </varlistentry>
            <varlistentry>
<!--==========================orignal english content==========================
                <term>
                    <cmdsynopsis>
                        <arg choice="plain"> RIGHT </arg>
                        <arg choice="opt"> OUTER </arg>
                        <command> JOIN </command>
                    </cmdsynopsis>
                </term>
____________________________________________________________________________-->
                <term>
                    <cmdsynopsis>
                        <arg choice="plain"> RIGHT </arg>
                        <arg choice="opt"> OUTER </arg>
                        <command> JOIN </command>
                    </cmdsynopsis>
                </term>
                <listitem>
<!--==========================orignal english content==========================
                <para>
                First, an INNER JOIN is performed.
                Then, for each row in T2 that does not satisfy the join
                condition with any row in T1, an additional joined row is
                returned with null fields in the columns from T1.
                </para>
____________________________________________________________________________-->
                <para>
                首先执行一个 INNER JOIN。然后对于 T2 中每一个与 T1 中任意行都不满足连接条件的行，将返回一个额外的连接行，它在来自于 T1 的列上取空值。
                </para>
                <tip>
<!--==========================orignal english content==========================
                    <para>
                    The joined table unconditionally has a row for each row in T2.
                    </para>
____________________________________________________________________________-->
                    <para>
                    连接表对于 T2 的每一行都无条件地有一行。
                    </para>
                </tip>
                </listitem>
            </varlistentry>
            <varlistentry>
<!--==========================orignal english content==========================
                <term>
                    <cmdsynopsis>
                        <arg choice="plain"> FULL </arg>
                        <arg choice="opt"> OUTER </arg>
                        <command> JOIN </command>
                    </cmdsynopsis>
                </term>
____________________________________________________________________________-->
                <term>
                    <cmdsynopsis>
                        <arg choice="plain"> FULL </arg>
                        <arg choice="opt"> OUTER </arg>
                        <command> JOIN </command>
                    </cmdsynopsis>
                </term>
                <listitem>
<!--==========================orignal english content==========================
                <para>
                First, an INNER JOIN is performed.
                Then, for each row in T1 that does not satisfy the join
                condition with any row in T2, an additional joined row is
                returned with null fields in the columns from T2.
                Also, for each row in T2 that does not satisfy the join
                condition with any row in T1, an additional joined row is
                returned with null fields in the columns from T1.
                </para>
____________________________________________________________________________-->
                <para>
                首先执行一个 INNER JOIN。然后对于 T1 中每一个与 T2 中任意行都不满足连接条件的行，将返回一个额外的连接行，它在来自于 T2 的列上取空值。此外，对于 T2 中每一个与 T1 中任意行都不满足连接条件的行，将返回一个额外的连接行，它在来自于 T1 的列上取空值。
                </para>
                <tip>
<!--==========================orignal english content==========================
                    <para>
                    The joined table unconditionally has a row for every row of T1
                    and a row for every row of T2.
                    </para>
____________________________________________________________________________-->
                    <para>
                    连接表对于 T1 的每一行和 T2 的每一行都无条件地有一行。
                    </para>
                </tip>
                </listitem>
            </varlistentry>
            </variablelist>
            <!-- end join semantics -->

            </listitem>
        </varlistentry>
     </variablelist>

<!--==========================orignal english content==========================
     <para>
     JOINs of all types can be chained together or nested where either or both of
     <replaceable class="parameter">T1</replaceable> and
     <replaceable class="parameter">T2</replaceable> can be JOINed tables.
     Parenthesis can be used around JOIN clauses to control the order
     of JOINs which are otherwise processed left to right.
     </para>
____________________________________________________________________________-->
     <para>
     所有类型的 JOIN 都可以被串在一起或者嵌套，其中<replaceable class="parameter">T1</replaceable>和<replaceable class="parameter">T2</replaceable>的其中之一或两者都能作为 要连接的表。圆括号可以被用在 JOIN 子句周围来控制 JOIN 的顺序，否则将按照从左至右的顺序处理。
     </para>

    </sect3>

    <sect3>
<!--==========================orignal english content==========================
     <title id="aggregates-tutorial">Aggregate Functions</title>
____________________________________________________________________________-->
     <title id="aggregates-tutorial">聚集函数</title>

<!--==========================orignal english content==========================
     <para>
      <acronym>SQL</acronym> provides aggregate functions such as AVG,
      COUNT, SUM, MIN, and MAX.  The argument(s) of an aggregate function
      are evaluated at each row that satisfies the WHERE
      clause, and the aggregate function is calculated over this set
      of input values.  Normally, an aggregate delivers a single
      result for a whole <command>SELECT</command> statement.  But if
      grouping is specified in the query, then a separate calculation
      is done over the rows of each group, and an aggregate result is
      delivered per group (see next section).

      <example>
       <title id="aggregates-example">Aggregates</title>

       <para>
        If we want to know the average cost of all parts in table PART we use
        the following query:

<programlisting>
SELECT AVG(PRICE) AS AVG_PRICE
    FROM PART;
</programlisting>
       </para>

       <para>
        The result is:

<screen>
 AVG_PRICE
-&minus;-&minus;-&minus;-&minus;-&minus;-
   14.5
</screen>
       </para>

       <para>
        If we want to know how many parts are defined in table PART we use
        the statement:

<programlisting>
SELECT COUNT(PNO)
    FROM PART;
</programlisting>

        and get:

<screen>
 COUNT
-&minus;-&minus;-&minus;-
   4
</screen>

       </para>
      </example>
     </para>
____________________________________________________________________________-->
     <para>
      <acronym>SQL</acronym>提供了诸如 AVG、COUNT、SUM、MIN 和 MAX 之类的聚集函数。一个聚集函数的参数会在每一个满足 WHERE 子句的行上计算，并且该聚集函数会在这个输入值的集合上进行计算。通常，对于一整个<command>SELECT</command>语句，一个聚集只会发送一个单一结果。但是如果在该查询中指定了分组，那么在每一个组的行上会完成一次独立的计算，并且会为每一个组发送一个聚集结果（见下一节）。

      <example>
       <title id="aggregates-example">聚集</title>

       <para>
        如果我们想知道表 PART 中所有部件的平均花销，我们可以使用下面的查询：

<programlisting>
SELECT AVG(PRICE) AS AVG_PRICE
    FROM PART;
</programlisting>
       </para>

       <para>
        结果是：

<screen>
 AVG_PRICE
-----------
   14.5
</screen>
       </para>

       <para>
        如果我们想了解在表 PART 中定义了多少种部件，我们可以用这个语句：

<programlisting>
SELECT COUNT(PNO)
    FROM PART;
</programlisting>

        并且得到：

<screen>
 COUNT
-------
   4
</screen>

       </para>
      </example>
     </para>
    </sect3>

    <sect3>
<!--==========================orignal english content==========================
     <title>Aggregation by Groups</title>
____________________________________________________________________________-->
     <title>通过分组聚集</title>

<!--==========================orignal english content==========================
     <para>
      <acronym>SQL</acronym> allows one to partition the tuples of a table
      into groups. Then the
      aggregate functions described above can be applied to the groups &mdash;
      i.e., the value of the aggregate function is no longer calculated over
      all the values of the specified column but over all values of a
      group. Thus the aggregate function is evaluated separately for every
      group.
     </para>
____________________________________________________________________________-->
     <para>
      <acronym>SQL</acronym>允许我们把一个表的元组划分成分组。那么上述的聚集函数就可以被应用到分组上 &mdash; 即聚集函数的值不再是根据指定列上的所有值计算，而是根据一个分组的所有值计算。因此聚集函数是为每一个分组独立计算的。
     </para>

<!--==========================orignal english content==========================
     <para>
      The partitioning of the tuples into groups is done by using the
      keywords <command>GROUP BY</command> followed by a list of
      attributes that define the
      groups. If we have
      <command>GROUP BY A<subscript>1</subscript>, &tdot;, A<subscript>k</subscript></command>
      we partition
      the relation into groups, such that two tuples are in the same group
      if and only if they agree on all the attributes
      A<subscript>1</subscript>, &tdot;, A<subscript>k</subscript>.

      <example>
       <title id="aggregates-groupby">Aggregates</title>
       <para>
        If we want to know how many parts are sold by every supplier we
        formulate the query:

<programlisting>
SELECT S.SNO, S.SNAME, COUNT(SE.PNO)
    FROM SUPPLIER S, SELLS SE
    WHERE S.SNO = SE.SNO
    GROUP BY S.SNO, S.SNAME;
</programlisting>

        and get:

<screen>
 SNO | SNAME | COUNT
-&minus;-&minus;-+-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-
  1  | Smith |   2
  2  | Jones |   1
  3  | Adams |   2
  4  | Blake |   3
</screen>
       </para>

       <para>
        Now let's have a look of what is happening here.
        First the join of the
        tables SUPPLIER and SELLS is derived:

<screen>
 S.SNO | S.SNAME | SE.PNO
-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;
   1   |  Smith  |   1
   1   |  Smith  |   2
   2   |  Jones  |   4
   3   |  Adams  |   1
   3   |  Adams  |   3
   4   |  Blake  |   2
   4   |  Blake  |   3
   4   |  Blake  |   4
</screen>
       </para>

       <para>
        Next we partition the tuples into groups by putting all tuples
        together that agree on both attributes S.SNO and S.SNAME:

<screen>
 S.SNO | S.SNAME | SE.PNO
-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;
   1   |  Smith  |   1
                 |   2
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
   2   |  Jones  |   4
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
   3   |  Adams  |   1
                 |   3
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
   4   |  Blake  |   2
                 |   3
                 |   4
</screen>
       </para>

       <para>
        In our example we got four groups and now we can apply the aggregate
        function COUNT to every group leading to the final result of the query
        given above.
       </para>
      </example>
     </para>
____________________________________________________________________________-->
     <para>
      要将元组划分成分组，可以使用关键词<command>GROUP BY</command>及其后定义分组的属性列表。如果我们有<command>GROUP BY A<subscript>1</subscript>, &tdot;, A<subscript>k</subscript></command>，我们就将关系划分成了分组，这样只有当两个元组在所有的属性 A<subscript>1</subscript>, &tdot;, A<subscript>k</subscript> 上达成一致时，它们才属于同一个分组。

      <example>
       <title id="aggregates-groupby">聚集</title>
       <para>
        如果我们想知道每一个供应商销售多少种部件，我们可以构造查询：

<programlisting>
SELECT S.SNO, S.SNAME, COUNT(SE.PNO)
    FROM SUPPLIER S, SELLS SE
    WHERE S.SNO = SE.SNO
    GROUP BY S.SNO, S.SNAME;
</programlisting>

        并且得到：

<screen>
 SNO | SNAME | COUNT
-----+-------+-------
  1  | Smith |   2
  2  | Jones |   1
  3  | Adams |   2
  4  | Blake |   3
</screen>
       </para>

       <para>
        现在让我们看看这里发生了什么。首先表 SUPPLIER 和 SELLS 的连接被生成：

<screen>
 S.SNO | S.SNAME | SE.PNO
-------+---------+--------
   1   |  Smith  |   1
   1   |  Smith  |   2
   2   |  Jones  |   4
   3   |  Adams  |   1
   3   |  Adams  |   3
   4   |  Blake  |   2
   4   |  Blake  |   3
   4   |  Blake  |   4
</screen>
       </para>

       <para>
        接着我们把元组划分成分组，做法是把所有在属性 S.SNO 和 S.SNAME 上相等的元组放在一起：

<screen>
 S.SNO | S.SNAME | SE.PNO
-------+---------+--------
   1   |  Smith  |   1
                 |   2
--------------------------
   2   |  Jones  |   4
--------------------------
   3   |  Adams  |   1
                 |   3
--------------------------
   4   |  Blake  |   2
                 |   3
                 |   4
</screen>
       </para>

       <para>
        在我们的例子中得到了四个分组并且现在我们可以将聚集函数 COUNT 应用在每一个分组上来得到上面给定查询的最终结果。
       </para>
      </example>
     </para>

<!--==========================orignal english content==========================
     <para>
      Note that for a query using GROUP BY and aggregate
      functions to make sense, the target list can only refer directly to
      the attributes being grouped by.  Other attributes can only be used
      inside the arguments of aggregate functions.  Otherwise there would
      not be a unique value to associate with the other attributes.
     </para>
____________________________________________________________________________-->
     <para>
      注意要使一个使用 GROUP BY 和聚集函数的查询有意义，目标列表只能直接引用被分组的属性。其他属性只能被用在聚集函数的参数中。否则将不会有唯一的值与其他属性相关联。
     </para>

<!--==========================orignal english content==========================
     <para>
      Also observe that it makes no sense to ask for an aggregate of
      an aggregate, e.g., AVG(MAX(sno)), because a
      <command>SELECT</command> only does one pass of grouping and
      aggregation.  You can get a result of this kind by using a
      temporary table or a sub-SELECT in the FROM clause to do the
      first level of aggregation.
     </para>
____________________________________________________________________________-->
     <para>
      还可以观察到，求一个聚集的聚集是没有意义的，例如 AVG(MAX(sno))，因为一个<command>SELECT</command>只做一趟分组以及聚集。你可以在 FROM 子句中使用一个临时表或者子-SELECT 来做第一层聚集，然后再来得到这类查询的结果。
     </para>
    </sect3>

    <sect3>
<!--==========================orignal english content==========================
     <title>Having</title>
____________________________________________________________________________-->
     <title>Having</title>

<!--==========================orignal english content==========================
     <para>
      The HAVING clause works much like the WHERE clause and is used to
      consider only those groups satisfying the qualification given in the
      HAVING clause.  Essentially, WHERE filters out unwanted input rows
      before grouping and aggregation are done, whereas HAVING filters out
      unwanted group rows post-GROUP.  Therefore, WHERE cannot refer to the
      results of aggregate functions.  On the other hand, there's no point
      in writing a HAVING condition that doesn't involve an aggregate
      function!  If your condition doesn't involve aggregates, you might
      as well write it in WHERE, and thereby avoid the computation of
      aggregates for groups that you're just going to throw away anyway.

      <example>
       <title id="having-example">Having</title>

       <para>
        If we want only those suppliers selling more than one part we use the
        query:

<programlisting>
SELECT S.SNO, S.SNAME, COUNT(SE.PNO)
    FROM SUPPLIER S, SELLS SE
    WHERE S.SNO = SE.SNO
    GROUP BY S.SNO, S.SNAME
    HAVING COUNT(SE.PNO) &gt; 1;
</programlisting>

        and get:

<screen>
 SNO | SNAME | COUNT
-&minus;-&minus;-+-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-
  1  | Smith |   2
  3  | Adams |   2
  4  | Blake |   3
</screen>
       </para>
      </example>
     </para>
____________________________________________________________________________-->
     <para>
      HAVING 子句工作起来非常像 WHERE 子句并且被用来只考虑那些满足 HAVING 子句中给定条件的分组。本质上，WHERE 会在分组和聚集完成之前过滤掉不需要的输入行，而 HAVING 则会过滤掉分组之后的不需要的分组行。因此，WHERE 不能饮用聚集函数的结果。从另一方面来说，写一个不涉及聚集函数的 HAVING 条件是没有意义的！如果你的条件不涉及聚集，你应该把它写在 WHERE 中，并且因此可以避免在那些你本来准备丢弃掉的分组上计算聚集。

      <example>
       <title id="having-example">Having</title>

       <para>
        如果我们还想要那些销售超过一种部件的供应商，我们可以使用查询：

<programlisting>
SELECT S.SNO, S.SNAME, COUNT(SE.PNO)
    FROM SUPPLIER S, SELLS SE
    WHERE S.SNO = SE.SNO
    GROUP BY S.SNO, S.SNAME
    HAVING COUNT(SE.PNO) &gt; 1;
</programlisting>

        并且得到：

<screen>
 SNO | SNAME | COUNT
-----+-------+-------
  1  | Smith |   2
  3  | Adams |   2
  4  | Blake |   3
</screen>
       </para>
      </example>
     </para>
    </sect3>

    <sect3>
<!--==========================orignal english content==========================
     <title>Subqueries</title>
____________________________________________________________________________-->
     <title>子查询</title>

<!--==========================orignal english content==========================
     <para>
      In the WHERE and HAVING clauses the use of subqueries (subselects) is
      allowed in every place where a value is expected. In this case the
      value must be derived by evaluating the subquery first. The usage of
      subqueries extends the expressive power of
      <acronym>SQL</acronym>.

      <example>
       <title id="subselect-example">Subselect</title>

       <para>
        If we want to know all parts having a greater price than the part
        named 'Screw' we use the query:

<programlisting>
SELECT *
    FROM PART
    WHERE PRICE &gt; (SELECT PRICE FROM PART
                   WHERE PNAME='Screw');
</programlisting>
       </para>

       <para>
        The result is:

<screen>
 PNO |  PNAME  |  PRICE
-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;
  3  |  Bolt   |   15
  4  |  Cam    |   25
</screen>
       </para>

       <para>
        When we look at the above query we can see the keyword
        <command>SELECT</command> two times. The first one at the
        beginning of the query - we will refer to it as outer
        <command>SELECT</command> - and the one in the WHERE clause which
        begins a nested query - we will refer to it as inner
        <command>SELECT</command>. For every tuple of the outer
        <command>SELECT</command> the inner <command>SELECT</command> has
        to be evaluated. After every evaluation we know the price of the
        tuple named 'Screw' and we can check if the price of the actual
        tuple is greater.  (Actually, in this example the inner query need
        only be evaluated once, since it does not depend on the state of
        the outer query.)
       </para>

       <para>
        If we want to know all suppliers that do not sell any part
        (e.g., to be able to remove these suppliers from the database) we use:

<programlisting>
SELECT *
    FROM SUPPLIER S
    WHERE NOT EXISTS
        (SELECT * FROM SELLS SE
         WHERE SE.SNO = S.SNO);
</programlisting>
       </para>

       <para>
        In our example the result will be empty because every supplier
        sells at least one part. Note that we use S.SNO from the outer
        <command>SELECT</command> within the WHERE clause of the inner
        <command>SELECT</command>. Here the subquery must be evaluated
        afresh for each tuple from the outer query, i.e., the value for
        S.SNO is always taken from the current tuple of the outer
        <command>SELECT</command>.
       </para>
      </example>
     </para>
____________________________________________________________________________-->
     <para>
      在 WHERE 和 HAVING 子句中，可以在任何需要一个值的地方使用子查询（子选择）。在这种情况下，必须先计算子查询来得到该值。子查询的使用扩展了<acronym>SQL</acronym>的表达能力。

      <example>
       <title id="subselect-example">子选择</title>

       <para>
        如果我们想要知道所有价格比名为 'Screw' 的部件高的部件，我们可以使用查询：

<programlisting>
SELECT *
    FROM PART
    WHERE PRICE &gt; (SELECT PRICE FROM PART
                   WHERE PNAME='Screw');
</programlisting>
       </para>

       <para>
        结果是：

<screen>
 PNO |  PNAME  |  PRICE
-----+---------+--------
  3  |  Bolt   |   15
  4  |  Cam    |   25
</screen>
       </para>

       <para>
        当我们查看上述查询时，我们可以看到关键词<command>SELECT</command>两次。第一个出现在该查询的开始 - 我们将称之为外部<command>SELECT</command> - 以及另外一个出现在 WHERE 子句中，它开始了一个嵌套的查询 - 我们将称之为内部<command>SELECT</command>。对于外部<command>SELECT</command>的每一个元组，内部<command>SELECT</command>都必须被计算一次。在每一次计算后我们就知道名为 'Screw' 的元组的价格，并且我们能够检查实际元组的价格是否超过之（实际上，在这个例子中内部查询只需要被计算一次，因为它不依赖于外部查询）。
       </para>

       <para>
        如果我们想知道所有不销售任何部件的供应商（例如这样可以从数据库中移除这些供应商），我们可以使用：

<programlisting>
SELECT *
    FROM SUPPLIER S
    WHERE NOT EXISTS
        (SELECT * FROM SELLS SE
         WHERE SE.SNO = S.SNO);
</programlisting>
       </para>

       <para>
        在我们的例子中，结果将为空，因为每一个供应商至少销售一种部件。注意我们在内部<command>SELECT</command>的 WHERE 子句中使用了来自于外部<command>SELECT</command>的 S.SNO。这里子查询必须为来自于外部查询的每一个元组都计算一次以得到最新值，即 S.SNO 的值总是从外部<command>SELECT</command>的当前元组中取得。
       </para>
      </example>
     </para>
    </sect3>

    <sect3>
<!--==========================orignal english content==========================
     <title>Subqueries in FROM</title>
____________________________________________________________________________-->
     <title>FROM 中的子查询</title>

<!--==========================orignal english content==========================
     <para>
      A somewhat different way of using subqueries is to put them in the
      FROM clause.  This is a useful feature because a subquery of this
      kind can output multiple columns and rows, whereas a subquery used
      in an expression must deliver just a single result.  It also lets
      us get more than one round of grouping/aggregation without resorting
      to a temporary table.

      <example>
       <title id="subselect-in-from-example">Subselect in FROM</title>

       <para>
        If we want to know the highest average part price among all our
        suppliers, we cannot write MAX(AVG(PRICE)), but we can write:

<programlisting>
SELECT MAX(subtable.avgprice)
    FROM (SELECT AVG(P.PRICE) AS avgprice
          FROM SUPPLIER S, PART P, SELLS SE
          WHERE S.SNO = SE.SNO AND
                P.PNO = SE.PNO
          GROUP BY S.SNO) subtable;
</programlisting>

        The subquery returns one row per supplier (because of its GROUP BY)
        and then we aggregate over those rows in the outer query.
       </para>
      </example>
     </para>
____________________________________________________________________________-->
     <para>
      一种使用子查询的不同方式是把它们放在 FROM 子句中。这是一种有用的特性，因为一个这种形式的子查询可以输出多列和多行，而被用在表达式中的一个子查询只能给出一个单一结果。它也让我们可以在无需依靠一个临时表就可以多轮次的分组/聚集。

      <example>
       <title id="subselect-in-from-example">FROM 中的子选择</title>

       <para>
        如果我们想知道所有供应商中最高的平均部件价格，我们不能写成 MAX(AVG(PRICE))，但我们可以写：

<programlisting>
SELECT MAX(subtable.avgprice)
    FROM (SELECT AVG(P.PRICE) AS avgprice
          FROM SUPPLIER S, PART P, SELLS SE
          WHERE S.SNO = SE.SNO AND
                P.PNO = SE.PNO
          GROUP BY S.SNO) subtable;
</programlisting>

        子查询为每一个供应商返回一行（因为它有 GROUP BY），并且我们在外部查询中对那些行进行聚集。
       </para>
      </example>
     </para>
    </sect3>

    <sect3>
<!--==========================orignal english content==========================
     <title>Union, Intersect, Except</title>
____________________________________________________________________________-->
     <title>并、交、差</title>

<!--==========================orignal english content==========================
     <para>
      These operations calculate the union, intersection and set theoretic
      difference of the tuples derived by two subqueries.

      <example>
       <title id="union-example">Union, Intersect, Except</title>

       <para>
        The following query is an example for UNION:

<programlisting>
SELECT S.SNO, S.SNAME, S.CITY
    FROM SUPPLIER S
    WHERE S.SNAME = 'Jones'
UNION
    SELECT S.SNO, S.SNAME, S.CITY
    FROM SUPPLIER S
    WHERE S.SNAME = 'Adams';
</programlisting>

gives the result:

<screen>
 SNO | SNAME |  CITY
-&minus;-&minus;-+-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;
  2  | Jones | Paris
  3  | Adams | Vienna
</screen>
       </para>

       <para>
        Here is an example for INTERSECT:

<programlisting>
SELECT S.SNO, S.SNAME, S.CITY
    FROM SUPPLIER S
    WHERE S.SNO &gt; 1
INTERSECT
    SELECT S.SNO, S.SNAME, S.CITY
    FROM SUPPLIER S
    WHERE S.SNO &lt; 3;
</programlisting>

        gives the result:

<screen>
 SNO | SNAME |  CITY
-&minus;-&minus;-+-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;
  2  | Jones | Paris
</screen>

        The only tuple returned by both parts of the query is the one having SNO=2.
       </para>

       <para>
        Finally an example for EXCEPT:

<programlisting>
SELECT S.SNO, S.SNAME, S.CITY
    FROM SUPPLIER S
    WHERE S.SNO &gt; 1
EXCEPT
    SELECT S.SNO, S.SNAME, S.CITY
    FROM SUPPLIER S
    WHERE S.SNO &gt; 3;
</programlisting>

        gives the result:

<screen>
 SNO | SNAME |  CITY
-&minus;-&minus;-+-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;
  2  | Jones | Paris
  3  | Adams | Vienna
</screen>
       </para>
      </example>
     </para>
____________________________________________________________________________-->
     <para>
      These operations calculate the union, intersection and set theoretic
      difference of the tuples derived by two subqueries.

      <example>
       <title id="union-example">并、交、差</title>

       <para>
        下面的查询是一个 UNION 的例子：

<programlisting>
SELECT S.SNO, S.SNAME, S.CITY
    FROM SUPPLIER S
    WHERE S.SNAME = 'Jones'
UNION
    SELECT S.SNO, S.SNAME, S.CITY
    FROM SUPPLIER S
    WHERE S.SNAME = 'Adams';
</programlisting>

给出结果：

<screen>
 SNO | SNAME |  CITY
-----+-------+--------
  2  | Jones | Paris
  3  | Adams | Vienna
</screen>
       </para>

       <para>
        下面是 INTERSECT 的一个例子：

<programlisting>
SELECT S.SNO, S.SNAME, S.CITY
    FROM SUPPLIER S
    WHERE S.SNO &gt; 1
INTERSECT
    SELECT S.SNO, S.SNAME, S.CITY
    FROM SUPPLIER S
    WHERE S.SNO &lt; 3;
</programlisting>

        给出结果：

<screen>
 SNO | SNAME |  CITY
-----+-------+--------
  2  | Jones | Paris
</screen>

        该查询的两部分会返回的唯一元组是具有 SNO=2 的那一个。
       </para>

       <para>
        最后是 EXCEPT 的一个例子：

<programlisting>
SELECT S.SNO, S.SNAME, S.CITY
    FROM SUPPLIER S
    WHERE S.SNO &gt; 1
EXCEPT
    SELECT S.SNO, S.SNAME, S.CITY
    FROM SUPPLIER S
    WHERE S.SNO &gt; 3;
</programlisting>

        给出结果：

<screen>
 SNO | SNAME |  CITY
-----+-------+--------
  2  | Jones | Paris
  3  | Adams | Vienna
</screen>
       </para>
      </example>
     </para>
    </sect3>
   </sect2>

   <sect2 id="datadef">
<!--==========================orignal english content==========================
    <title>Data Definition</title>
____________________________________________________________________________-->
    <title>数据定义</title>

<!--==========================orignal english content==========================
    <para>
     There is a set of commands used for data definition included in the
     <acronym>SQL</acronym> language.
    </para>
____________________________________________________________________________-->
    <para>
     这是包括在<acronym>SQL</acronym>语言中的一组用于数据定义的命令。
    </para>

    <sect3 id="create">
<!--==========================orignal english content==========================
     <title id="create-title">Create Table</title>
____________________________________________________________________________-->
     <title id="create-title">创建表</title>

<!--==========================orignal english content==========================
     <para>
      The most fundamental command for data definition is the
      one that creates a new relation (a new table). The syntax of the
      <command>CREATE TABLE</command> command is:

<synopsis>
CREATE TABLE <replaceable class="parameter">table_name</replaceable>
    (<replaceable class="parameter">name_of_attr_1</replaceable> <replaceable class="parameter">type_of_attr_1</replaceable>
     [, <replaceable class="parameter">name_of_attr_2</replaceable> <replaceable class="parameter">type_of_attr_2</replaceable>
     [, ...]]);
</synopsis>

      <example>
       <title id="table-create">Table Creation</title>

       <para>
        To create the tables defined in
        <xref linkend="supplier-fig" endterm="supplier-fig"> the
        following <acronym>SQL</acronym> statements are used:

<programlisting>
CREATE TABLE SUPPLIER
    (SNO   INTEGER,
     SNAME VARCHAR(20),
     CITY  VARCHAR(20));
</programlisting>

<programlisting>
CREATE TABLE PART
    (PNO   INTEGER,
     PNAME VARCHAR(20),
     PRICE DECIMAL(4 , 2));
</programlisting>

<programlisting>
CREATE TABLE SELLS
    (SNO INTEGER,
     PNO INTEGER);
</programlisting>
       </para>
      </example>
     </para>
____________________________________________________________________________-->
     <para>
      数据定义中最基础的命令是创建一个新关系（一个新表）的命令。<command>CREATE TABLE</command>命令的语法是：

<synopsis>
CREATE TABLE <replaceable class="parameter">table_name</replaceable>
    (<replaceable class="parameter">name_of_attr_1</replaceable> <replaceable class="parameter">type_of_attr_1</replaceable>
     [, <replaceable class="parameter">name_of_attr_2</replaceable> <replaceable class="parameter">type_of_attr_2</replaceable>
     [, ...]]);
</synopsis>

      <example>
       <title id="table-create">表创建</title>

       <para>
        要创建<xref linkend="supplier-fig" endterm="supplier-fig">中定义的表，使用下面的<acronym>SQL</acronym>语句：

<programlisting>
CREATE TABLE SUPPLIER
    (SNO   INTEGER,
     SNAME VARCHAR(20),
     CITY  VARCHAR(20));
</programlisting>

<programlisting>
CREATE TABLE PART
    (PNO   INTEGER,
     PNAME VARCHAR(20),
     PRICE DECIMAL(4 , 2));
</programlisting>

<programlisting>
CREATE TABLE SELLS
    (SNO INTEGER,
     PNO INTEGER);
</programlisting>
       </para>
      </example>
     </para>
    </sect3>

    <sect3>
<!--==========================orignal english content==========================
     <title>Data Types in <acronym>SQL</acronym></title>
____________________________________________________________________________-->
     <title><acronym>SQL</acronym>中的数据类型</title>

<!--==========================orignal english content==========================
     <para>
      The following is a list of some data types that are supported by
      <acronym>SQL</acronym>:

      <itemizedlist>
       <listitem>
        <para>
         INTEGER: signed fullword binary integer (31 bits precision).
        </para>
       </listitem>

       <listitem>
        <para>
         SMALLINT: signed halfword binary integer (15 bits precision).
        </para>
       </listitem>

       <listitem>
        <para>
         DECIMAL (<replaceable class="parameter">p</replaceable>[,<replaceable class="parameter">q</replaceable>]):
         signed packed decimal number of up to
         <replaceable class="parameter">p</replaceable>
         digits, with
         <replaceable class="parameter">q</replaceable>
         digits to the right of the decimal point.
         If <replaceable class="parameter">q</replaceable>
         is omitted it is assumed to be 0.
        </para>
       </listitem>

       <listitem>
        <para>
         FLOAT: signed doubleword floating point number.
        </para>
       </listitem>

       <listitem>
        <para>
         VARCHAR(<replaceable class="parameter">n</replaceable>):
         varying length character string of maximum length
         <replaceable class="parameter">n</replaceable>.
        </para>
       </listitem>

       <listitem>
        <para>
         CHAR(<replaceable class="parameter">n</replaceable>):
         fixed length character string of length
         <replaceable class="parameter">n</replaceable>.
        </para>
       </listitem>

      </itemizedlist>
     </para>
____________________________________________________________________________-->
     <para>
      下面是<acronym>SQL</acronym>所支持的一些数据类型的列表：

      <itemizedlist>
       <listitem>
        <para>
         INTEGER：有符号全字二进制整数（31 位精度）。
        </para>
       </listitem>

       <listitem>
        <para>
         SMALLINT：有符号半字二进制整数（15 位精度）。
        </para>
       </listitem>

       <listitem>
        <para>
         DECIMAL (<replaceable class="parameter">p</replaceable>[,<replaceable class="parameter">q</replaceable>])：带符号压缩十进制数字，最高<replaceable class="parameter">p</replaceable>个数位，其中<replaceable class="parameter">q</replaceable>个数位位于小数点右边。如果<replaceable class="parameter">q</replaceable>被忽略，则它被假定为 0。
        </para>
       </listitem>

       <listitem>
        <para>
         FLOAT：有符号双字浮点数字。
        </para>
       </listitem>

       <listitem>
        <para>
         VARCHAR(<replaceable class="parameter">n</replaceable>)：最大长度为<replaceable class="parameter">n</replaceable>的变长字符串。
        </para>
       </listitem>

       <listitem>
        <para>
         CHAR(<replaceable class="parameter">n</replaceable>)：长度为<replaceable class="parameter">n</replaceable>的定长字符串。
        </para>
       </listitem>

      </itemizedlist>
     </para>
    </sect3>

    <sect3>
<!--==========================orignal english content==========================
     <title>Create Index</title>
____________________________________________________________________________-->
     <title>创建索引</title>

<!--==========================orignal english content==========================
     <para>
      Indexes are used to speed up access to a relation. If a relation <classname>R</classname>
      has an index on attribute <classname>A</classname> then we can
      retrieve all tuples <replaceable>t</replaceable>
      having
      <replaceable>t</replaceable>(<classname>A</classname>) = <replaceable>a</replaceable>
      in time roughly proportional to the number of such
      tuples <replaceable>t</replaceable>
      rather than in time proportional to the size of <classname>R</classname>.
     </para>
____________________________________________________________________________-->
     <para>
      索引被用来加速对一个关系的访问。如果一个关系<classname>R</classname>在属性<classname>A</classname>上有一个索引，那么我们可以检索所有<replaceable>t</replaceable>(<classname>A</classname>) = <replaceable>a</replaceable>的元组<replaceable>t</replaceable>，所花费的时间大约与这类元组<replaceable>t</replaceable>的数量成比例，而不是与<classname>R</classname>的尺寸成比例。
     </para>

<!--==========================orignal english content==========================
     <para>
      To create an index in <acronym>SQL</acronym>
      the <command>CREATE INDEX</command> command is used. The syntax is:

<programlisting>
CREATE INDEX <replaceable class="parameter">index_name</replaceable>
    ON <replaceable class="parameter">table_name</replaceable> ( <replaceable class="parameter">name_of_attribute</replaceable> );
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      要在<acronym>SQL</acronym>中创建一个索引，可以使用<command>CREATE INDEX</command>命令。语法是：

<programlisting>
CREATE INDEX <replaceable class="parameter">index_name</replaceable>
    ON <replaceable class="parameter">table_name</replaceable> ( <replaceable class="parameter">name_of_attribute</replaceable> );
</programlisting>
     </para>

<!--==========================orignal english content==========================
     <para>
      <example>
       <title id="index-create">Create Index</title>

       <para>
        To create an index named I on attribute SNAME of relation SUPPLIER
        we use the following statement:

<programlisting>
CREATE INDEX I ON SUPPLIER (SNAME);
</programlisting>
     </para>

       <para>
        The created index is maintained automatically, i.e., whenever a new
        tuple is inserted into the relation SUPPLIER the index I is
        adapted. Note that the only changes a user can perceive when an
        index is present are increased speed for <command>SELECT</command>
        and decreases in speed of updates.
       </para>
      </example>
     </para>
____________________________________________________________________________-->
     <para>
      <example>
       <title id="index-create">创建索引</title>

       <para>
        要在关系 SUPPLIER 的 SNAME 属性上创建一个名为 I 的索引，我们使用下面的语句：

<programlisting>
CREATE INDEX I ON SUPPLIER (SNAME);
</programlisting>
     </para>

       <para>
        被创建的索引将被自动维护，即不管什么时候一个新元组被插入到关系 SUPPLIER 中，索引 I 也会被更改。注意当一个索引存在时，一个用户唯一能观察到的改变是<command>SELECT</command>的速度增加了并且更新的速度降低了。
       </para>
      </example>
     </para>
    </sect3>

    <sect3>
<!--==========================orignal english content==========================
     <title>Create View</title>
____________________________________________________________________________-->
     <title>创建视图</title>

<!--==========================orignal english content==========================
     <para>
      A view can be regarded as a <firstterm>virtual table</firstterm>,
      i.e., a table that
      does not <emphasis>physically</emphasis> exist in the database
      but looks to the user
      as if it does. By contrast, when we talk of a
      <firstterm>base table</firstterm> there is
      really a physically stored counterpart of each row of the table
      somewhere in the physical storage.
     </para>
____________________________________________________________________________-->
     <para>
      一个视图可以被认为是一个<firstterm>虚拟表</firstterm>，即一个表在数据库中并不<emphasis>物理</emphasis>存在，但用户看起来却觉得它在物理上存在。相反，当我们谈论<firstterm>基本表</firstterm>时，对于该表的每一行在物理存储的某处被物理存储着。
     </para>

<!--==========================orignal english content==========================
     <para>
      Views do not have their own, physically separate, distinguishable
      stored data. Instead, the system stores the definition of the
      view (i.e., the rules about how to access physically stored base
      tables in order to materialize the view) somewhere in the system
      catalogs (see
      <xref linkend="tutorial-catalogs-title" endterm="tutorial-catalogs-title">). For a
      discussion on different techniques to implement views refer to
<!-&minus;
      section
      <xref linkend="view-impl" endterm="view-impl">.
-&minus;>
      <citetitle>SIM98</citetitle>.
     </para>
____________________________________________________________________________-->
     <para>
      视图自己没有物理上独立的、可区分的已存储数据。相反，系统会在系统目录（见<xref linkend="tutorial-catalogs-title" endterm="tutorial-catalogs-title">）中的某处存储视图的定义（即关于如何访问物理上存储的基本表来物化视图的规则）。关于实现视图的不同技术的讨论可以参考
<!--
      section
      <xref linkend="view-impl" endterm="view-impl">.
-->
      <citetitle>SIM98</citetitle>。
     </para>

<!--==========================orignal english content==========================
     <para>
      In <acronym>SQL</acronym> the <command>CREATE VIEW</command>
      command is used to define a view. The syntax
      is:

<programlisting>
CREATE VIEW <replaceable class="parameter">view_name</replaceable>
    AS <replaceable class="parameter">select_stmt</replaceable>
</programlisting>

      where <replaceable class="parameter">select_stmt</replaceable>
      is a valid select statement as defined
      in <xref linkend="select-title" endterm="select-title">.
      Note that <replaceable class="parameter">select_stmt</replaceable> is
      not executed when the view is created. It is just stored in the
      <firstterm>system catalogs</firstterm>
      and is executed whenever a query against the view is made.
     </para>
____________________________________________________________________________-->
     <para>
      在<acronym>SQL</acronym>中<command>CREATE VIEW</command>命令被用来定义一个视图。语法是：

<programlisting>
CREATE VIEW <replaceable class="parameter">view_name</replaceable>
    AS <replaceable class="parameter">select_stmt</replaceable>
</programlisting>

      其中<replaceable class="parameter">select_stmt</replaceable>是一个按照<xref linkend="select-title" endterm="select-title">中定义的合法的选择语句。注意在视图被创建时，<replaceable class="parameter">select_stmt</replaceable>不会被执行。它只是被存储在<firstterm>系统目录</firstterm>中，并且在针对该视图执行一个查询时被执行。
     </para>

<!--==========================orignal english content==========================
     <para>
      Let the following view definition be given (we use
      the tables from
      <xref linkend="supplier-fig" endterm="supplier-fig"> again):

<programlisting>
CREATE VIEW London_Suppliers
    AS SELECT S.SNAME, P.PNAME
        FROM SUPPLIER S, PART P, SELLS SE
        WHERE S.SNO = SE.SNO AND
              P.PNO = SE.PNO AND
              S.CITY = 'London';
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      给定下面的视图定义（我们再次使用来自<xref linkend="supplier-fig" endterm="supplier-fig">中的表）：

<programlisting>
CREATE VIEW London_Suppliers
    AS SELECT S.SNAME, P.PNAME
        FROM SUPPLIER S, PART P, SELLS SE
        WHERE S.SNO = SE.SNO AND
              P.PNO = SE.PNO AND
              S.CITY = 'London';
</programlisting>
     </para>

<!--==========================orignal english content==========================
     <para>
      Now we can use this <firstterm>virtual relation</firstterm>
      <classname>London_Suppliers</classname> as
      if it were another base table:

<programlisting>
SELECT * FROM London_Suppliers
    WHERE PNAME = 'Screw';
</programlisting>

      which will return the following table:

<screen>
 SNAME | PNAME
-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-
 Smith | Screw                 
</screen>
     </para>
____________________________________________________________________________-->
     <para>
      现在我们可以把这个<firstterm>虚拟关系</firstterm><classname>London_Suppliers</classname>当作一个基本表来使用：

<programlisting>
SELECT * FROM London_Suppliers
    WHERE PNAME = 'Screw';
</programlisting>

      这将返回下面的表：

<screen>
 SNAME | PNAME
-------+-------
 Smith | Screw                 
</screen>
     </para>

<!--==========================orignal english content==========================
     <para>
      To calculate this result the database system has to do a
      <emphasis>hidden</emphasis>
      access to the base tables SUPPLIER, SELLS and PART first. It
      does so by executing the query given in the view definition against
      those base tables. After that the additional qualifications
      (given in the
      query against the view) can be applied to obtain the resulting
      table.
     </para>
____________________________________________________________________________-->
     <para>
      要计算这个结果，数据库系统必须先做一次对基本表 SUPPLIER、SELLS 和 PART 的<emphasis>隐藏</emphasis>访问。它通过对那些基本表执行视图定义中给出的查询来这样做。之后附加的条件（在针对视图的查询中给出）可以被应用来得到结果表。
     </para>
    </sect3>

    <sect3>
<!--==========================orignal english content==========================
     <title>Drop Table, Drop Index, Drop View</title>
____________________________________________________________________________-->
     <title>删除表、删除索引、删除视图</title>

<!--==========================orignal english content==========================
     <para>
      To destroy a table (including all tuples stored in that table) the
      <command>DROP TABLE</command> command is used:

<programlisting>
DROP TABLE <replaceable class="parameter">table_name</replaceable>;
</programlisting>
      </para>
____________________________________________________________________________-->
     <para>
      要摧毁一个表（包括其中存储的所有元组），可以使用<command>DROP TABLE</command>命令：

<programlisting>
DROP TABLE <replaceable class="parameter">table_name</replaceable>;
</programlisting>
      </para>

<!--==========================orignal english content==========================
     <para>
      To destroy the SUPPLIER table use the following statement:

<programlisting>
DROP TABLE SUPPLIER;
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      要毁掉 SUPPLIER 表可以使用下面的语句：

<programlisting>
DROP TABLE SUPPLIER;
</programlisting>
     </para>

<!--==========================orignal english content==========================
     <para>
      The <command>DROP INDEX</command> command is used to destroy an index:

<programlisting>
DROP INDEX <replaceable class="parameter">index_name</replaceable>;
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      <command>DROP INDEX</command>命令被用来毁掉一个索引：

<programlisting>
DROP INDEX <replaceable class="parameter">index_name</replaceable>;
</programlisting>
     </para>

<!--==========================orignal english content==========================
     <para>
      Finally to destroy a given view use the command <command>DROP
      VIEW</command>:

<programlisting>
DROP VIEW <replaceable class="parameter">view_name</replaceable>;
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      最后使用命令<command>DROP VIEW</command>毁掉一个给定的视图：

<programlisting>
DROP VIEW <replaceable class="parameter">view_name</replaceable>;
</programlisting>
     </para>
    </sect3>
   </sect2>

   <sect2>
<!--==========================orignal english content==========================
    <title>Data Manipulation</title>
____________________________________________________________________________-->
    <title>数据操纵</title>

    <sect3>
<!--==========================orignal english content==========================
     <title>Insert Into</title>
____________________________________________________________________________-->
     <title>Insert Into</title>

<!--==========================orignal english content==========================
     <para>
      Once a table is created (see
      <xref linkend="create-title" endterm="create-title">), it can be filled
      with tuples using the command <command>INSERT INTO</command>.
      The syntax is:

<programlisting>
INSERT INTO <replaceable class="parameter">table_name</replaceable> (<replaceable class="parameter">name_of_attr_1</replaceable>
    [, <replaceable class="parameter">name_of_attr_2</replaceable> [, ...]])
    VALUES (<replaceable class="parameter">val_attr_1</replaceable> [, <replaceable class="parameter">val_attr_2</replaceable> [, ...]]);
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      一旦一个表被创建（见<xref linkend="create-title" endterm="create-title">），可以使用<command>INSERT INTO</command>命令为它填充元组。语法是：

<programlisting>
INSERT INTO <replaceable class="parameter">table_name</replaceable> (<replaceable class="parameter">name_of_attr_1</replaceable>
    [, <replaceable class="parameter">name_of_attr_2</replaceable> [, ...]])
    VALUES (<replaceable class="parameter">val_attr_1</replaceable> [, <replaceable class="parameter">val_attr_2</replaceable> [, ...]]);
</programlisting>
     </para>

<!--==========================orignal english content==========================
     <para>
      To insert the first tuple into the relation SUPPLIER (from
      <xref linkend="supplier-fig" endterm="supplier-fig">) we use the
      following statement:

<programlisting>
INSERT INTO SUPPLIER (SNO, SNAME, CITY)
    VALUES (1, 'Smith', 'London');
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      要向关系 SUPPLIER（来自<xref linkend="supplier-fig" endterm="supplier-fig">）插入第一个元组，我们使用下面的语句：

<programlisting>
INSERT INTO SUPPLIER (SNO, SNAME, CITY)
    VALUES (1, 'Smith', 'London');
</programlisting>
     </para>

<!--==========================orignal english content==========================
     <para>
      To insert the first tuple into the relation SELLS we use:

<programlisting>
INSERT INTO SELLS (SNO, PNO)
    VALUES (1, 1);
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      要向关系 SELLS 插入第一个元组：

<programlisting>
INSERT INTO SELLS (SNO, PNO)
    VALUES (1, 1);
</programlisting>
     </para>
    </sect3>

    <sect3>
<!--==========================orignal english content==========================
     <title>Update</title>
____________________________________________________________________________-->
     <title>更新</title>

<!--==========================orignal english content==========================
     <para>
      To change one or more attribute values of tuples in a relation the
      <command>UPDATE</command> command is used. The syntax is:

<programlisting>
UPDATE <replaceable class="parameter">table_name</replaceable>
    SET <replaceable class="parameter">name_of_attr_1</replaceable> = <replaceable class="parameter">value_1</replaceable>
        [, ... [, <replaceable class="parameter">name_of_attr_k</replaceable> = <replaceable class="parameter">value_k</replaceable>]]
    WHERE <replaceable class="parameter">condition</replaceable>;
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      要改变一个关系中一个或者多个属性值，可以使用<command>UPDATE</command>命令。语法是：

<programlisting>
UPDATE <replaceable class="parameter">table_name</replaceable>
    SET <replaceable class="parameter">name_of_attr_1</replaceable> = <replaceable class="parameter">value_1</replaceable>
        [, ... [, <replaceable class="parameter">name_of_attr_k</replaceable> = <replaceable class="parameter">value_k</replaceable>]]
    WHERE <replaceable class="parameter">condition</replaceable>;
</programlisting>
     </para>

<!--==========================orignal english content==========================
     <para>
      To change the value of attribute PRICE of the part 'Screw' in the
      relation PART we use:

<programlisting>
UPDATE PART
    SET PRICE = 15
    WHERE PNAME = 'Screw';
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      要在关系 PART 中改变部件 'Screw' 的属性 PRICE 的值，使用：

<programlisting>
UPDATE PART
    SET PRICE = 15
    WHERE PNAME = 'Screw';
</programlisting>
     </para>

<!--==========================orignal english content==========================
     <para>
      The new value of attribute PRICE of the tuple whose name is 'Screw' is
      now 15.
     </para>
____________________________________________________________________________-->
     <para>
      名字为 'Screw' 的属性 PRICE 的新值现在是 15。
     </para>
    </sect3>

    <sect3>
<!--==========================orignal english content==========================
     <title>Delete</title>
____________________________________________________________________________-->
     <title>删除</title>

<!--==========================orignal english content==========================
     <para>
      To delete a tuple from a particular table use the command DELETE
      FROM. The syntax is:

<programlisting>
DELETE FROM <replaceable class="parameter">table_name</replaceable>
    WHERE <replaceable class="parameter">condition</replaceable>;
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      要从一个特定表中删除一个元组，使用命令 DELETE FROM。语法是：

<programlisting>
DELETE FROM <replaceable class="parameter">table_name</replaceable>
    WHERE <replaceable class="parameter">condition</replaceable>;
</programlisting>
     </para>

<!--==========================orignal english content==========================
     <para>
      To delete the supplier called 'Smith' of the table SUPPLIER the
      following statement is used:

<programlisting>
DELETE FROM SUPPLIER
    WHERE SNAME = 'Smith';
</programlisting>
     </para>
____________________________________________________________________________-->
     <para>
      要在表 SUPPLIER 中删除名为 'Smith' 的供应商，可以使用下面的语句：

<programlisting>
DELETE FROM SUPPLIER
    WHERE SNAME = 'Smith';
</programlisting>
     </para>
    </sect3>
   </sect2>

   <sect2 id="tutorial-catalogs">
<!--==========================orignal english content==========================
    <title id="tutorial-catalogs-title">System Catalogs</title>
____________________________________________________________________________-->
    <title id="tutorial-catalogs-title">系统目录</title>

<!--==========================orignal english content==========================
    <para>
     In every <acronym>SQL</acronym> database system
     <firstterm>system catalogs</firstterm> are used to keep
     track of which tables, views indexes etc. are defined in the
     database. These system catalogs can be queried as if they were normal
     relations. For example there is one catalog used for the definition of
     views. This catalog stores the query from the view definition. Whenever
     a query against a view is made, the system first gets the
     <firstterm>view definition query</firstterm> out of the catalog
     and materializes the view
     before proceeding with the user query (see
<!-&minus;
      section
      <xref linkend="view-impl" endterm="view-impl">.
    <citetitle>SIM98</citetitle>
-&minus;>
     <xref linkend="SIM98" endterm="SIM98">
     for a more detailed
     description). For more information about system catalogs refer to
     <xref linkend="DATE04" endterm="DATE04">.
    </para>
____________________________________________________________________________-->
    <para>
     在每一个<acronym>SQL</acronym>数据库系统中，<firstterm>系统目录</firstterm>被用来跟踪数据库中定义了哪些表、视图、索引等等。这些系统目录可以和普通关系一样被查询。例如，有一个目录被用来存放视图的定义。这个目录存储来自视图定义的查询。任何时候发生一个针对视图的查询时，系统首先会从该系统目录中得到<firstterm>视图定义查询</firstterm>，并且在处理用户查询之前物化该视图（详见
     and materializes the view
     before proceeding with the user query (see
<!--
      section
      <xref linkend="view-impl" endterm="view-impl">.
    <citetitle>SIM98</citetitle>
-->
     <xref linkend="SIM98" endterm="SIM98">）。更多关于系统目录的信息可参考<xref linkend="DATE04" endterm="DATE04">。
    </para>
   </sect2>

   <sect2>
<!--==========================orignal english content==========================
    <title>Embedded <acronym>SQL</acronym></title>
____________________________________________________________________________-->
    <title>嵌入式<acronym>SQL</acronym></title>

<!--==========================orignal english content==========================
    <para>
     In this section we will sketch how <acronym>SQL</acronym> can be
     embedded into a host language (e.g., <literal>C</literal>).
     There are two main reasons why we want to use <acronym>SQL</acronym>
     from a host language:

     <itemizedlist>
      <listitem>
       <para>
        There are queries that cannot be formulated using pure <acronym>SQL</acronym>
        (i.e., recursive queries). To be able to perform such queries we need a
        host language with a greater expressive power than
        <acronym>SQL</acronym>.
       </para>
      </listitem>

      <listitem>
       <para>
        We simply want to access a database from some application that
        is written in the host language (e.g., a ticket reservation system
        with a graphical user interface is written in C and the information
        about which tickets are still left is stored in a database that can be
        accessed using embedded <acronym>SQL</acronym>).
       </para>
      </listitem>
     </itemizedlist>
    </para>
____________________________________________________________________________-->
    <para>
     在这一节中，我们将介绍如何把<acronym>SQL</acronym>嵌入到一种宿主语言中（例如<literal>C</literal>）。有两个原因促使我们在一个宿主语言中使用<acronym>SQL</acronym>：

     <itemizedlist>
      <listitem>
       <para>
        有些查询无法使用纯<acronym>SQL</acronym>（即递归查询）写出。要能够执行这种查询，我们需要一种比<acronym>SQL</acronym>具有更强表达能力的宿主语言。
       </para>
      </listitem>

      <listitem>
       <para>
        我们只是想在用宿主语言编写的应用中访问一个数据库（例如，一个用 C 编写的有图形用户接口的订票系统中，有关哪些票还有剩余的信息被存储在数据库中，可以使用嵌入式<acronym>SQL</acronym>访问）。
       </para>
      </listitem>
     </itemizedlist>
    </para>

<!--==========================orignal english content==========================
    <para>
     A program using embedded <acronym>SQL</acronym>
     in a host language consists of statements
     of the host language and of
     <firstterm>embedded <acronym>SQL</acronym></firstterm>
     (<acronym>ESQL</acronym>) statements. Every <acronym>ESQL</acronym>
     statement begins with the keywords <command>EXEC SQL</command>.
     The <acronym>ESQL</acronym> statements are
     transformed to statements of the host language
     by a <firstterm>precompiler</firstterm>
     (which usually inserts
     calls to library routines that perform the various <acronym>SQL</acronym>
     commands).
    </para>
____________________________________________________________________________-->
    <para>
     一个在宿主语言中使用嵌入式<acronym>SQL</acronym>的程序由宿主语言的语句和<firstterm>嵌入式<acronym>SQL</acronym></firstterm>（<acronym>ESQL</acronym>）构成。每一个<acronym>ESQL</acronym>语句开始于关键词<command>EXEC SQL</command>。<acronym>ESQL</acronym>语句会被一个<firstterm>预编译器</firstterm>（它通常将执行多个<acronym>SQL</acronym>命令的调用插入到库例程中）转换成宿主语言的语句。
    </para>

<!--==========================orignal english content==========================
    <para>
     When we look at the examples throughout
     <xref linkend="select-title" endterm="select-title"> we
     realize that the result of the queries is very often a set of
     tuples. Most host languages are not designed to operate on sets so we
     need a mechanism to access every single tuple of the set of tuples
     returned by a SELECT statement. This mechanism can be provided by
     declaring a <firstterm>cursor</firstterm>.
     After that we can use the <command>FETCH</command> command to
     retrieve a tuple and set the cursor to the next tuple.
    </para>
____________________________________________________________________________-->
    <para>
     当我们从头到尾查看<xref linkend="select-title" endterm="select-title">的例子时，我们意识到查询的结果常常是一个元组集合。大部分的宿主语言并非被设计用于在集合上操作，因此我们需要一种机制来访问一个 SELECT 语句返回的元组集合中的每一个元组。这种机制可以通过声明一个<firstterm>游标</firstterm>来提供。之后我们可以使用<command>FETCH</command>命令来检索一个元组，并且把游标指向像一个元组。
    </para>

<!--==========================orignal english content==========================
    <para>
     For a detailed discussion on embedded <acronym>SQL</acronym>
     refer to
     <xref linkend="DATE97" endterm="DATE97">,
     <xref linkend="DATE04" endterm="DATE04">,
     or
     <xref linkend="ULL88" endterm="ULL88">.
    </para>
____________________________________________________________________________-->
    <para>
     嵌入式<acronym>SQL</acronym>的详细讨论请见<xref linkend="DATE97" endterm="DATE97">、<xref linkend="DATE04" endterm="DATE04">或<xref linkend="ULL88" endterm="ULL88">。
    </para>
   </sect2>
  </sect1>
 </chapter>
