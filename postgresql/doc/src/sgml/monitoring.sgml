<!-- doc/src/sgml/monitoring.sgml -->

<chapter id="monitoring">
 <!-- 
 <title>Monitoring Database Activity</title>
 -->
 <title>监控数据库活动</title>

 <indexterm zone="monitoring">
  <!-- 
  <primary>monitoring</primary>
  <secondary>database activity</secondary>
  -->
  <primary>监控</primary>
  <secondary>数据库活动</secondary>
 </indexterm>

 <indexterm zone="monitoring">
  <!-- 
  <primary>database activity</primary>
  <secondary>monitoring</secondary>
  -->
  <primary>数据库活动</primary>
  <secondary>监控</secondary>
 </indexterm>

 <!-- 
 <para>
  A database administrator frequently wonders, <quote>What is the system
  doing right now?</quote>
  This chapter discusses how to find that out.
 </para>
 -->
 <para>
  一个数据库管理员常常会疑惑，<quote>系统现在正在做什么？</quote>
  本章讨论如何回答这个问题。
 </para>

  <!-- 
  <para>
   Several tools are available for monitoring database activity and
   analyzing performance.  Most of this chapter is devoted to describing
   <productname>PostgreSQL</productname>'s statistics collector,
   but one should not neglect regular Unix monitoring programs such as
   <command>ps</>, <command>top</>, <command>iostat</>, and <command>vmstat</>.
   Also, once one has identified a
   poorly-performing query, further investigation might be needed using
   <productname>PostgreSQL</productname>'s <xref linkend="sql-explain"> command.
   <xref linkend="using-explain"> discusses <command>EXPLAIN</>
   and other methods for understanding the behavior of an individual
   query.
  </para>
  -->
  <para>
   有一些工具可以用来监控数据库活动以及分析性能。本章大部分内容都致力于描述
   <productname>PostgreSQL</productname>的统计收集器，但是我们也不能忽视普通的 Unix 监控程序，
   如<command>ps</>、<command>top</>、<command>iostat</>和<command>vmstat</>。
   另外，一旦我们发现了一个性能差的查询，可能需要<productname>PostgreSQL</productname>
   的<xref linkend="sql-explain">命令进行进一步的调查。
   <xref linkend="using-explain">讨论了<command>EXPLAIN</>和其他用来理解个体查询行为的方法。
  </para>

 <sect1 id="monitoring-ps">
  <!-- 
  <title>Standard Unix Tools</title>
  -->
  <title>标准 Unix 工具</title>

  <indexterm zone="monitoring-ps">
   <primary>ps</primary>
   <secondary>to monitor activity</secondary>
  </indexterm>

  <para>
   <!-- 
   On most Unix platforms, <productname>PostgreSQL</productname> modifies its
   command title as reported by <command>ps</>, so that individual server
   processes can readily be identified.  A sample display is
   -->
   在大部分 Unix 平台上，<productname>PostgreSQL</productname>会修改由
   <command>ps</>报告的命令标题，这样个体服务器进程可以被标识。一个显示样例是

<screen>
$ ps auxww | grep ^postgres
postgres  15551  0.0  0.1  57536  7132 pts/0    S    18:02   0:00 postgres -i
postgres  15554  0.0  0.0  57536  1184 ?        Ss   18:02   0:00 postgres: writer process
postgres  15555  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: checkpointer process
postgres  15556  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: wal writer process
postgres  15557  0.0  0.0  58504  2244 ?        Ss   18:02   0:00 postgres: autovacuum launcher process
postgres  15558  0.0  0.0  17512  1068 ?        Ss   18:02   0:00 postgres: stats collector process
postgres  15582  0.0  0.0  58772  3080 ?        Ss   18:04   0:00 postgres: joe runbug 127.0.0.1 idle
postgres  15606  0.0  0.0  58772  3052 ?        Ss   18:07   0:00 postgres: tgl regression [local] SELECT waiting
postgres  15610  0.0  0.0  58772  3056 ?        Ss   18:07   0:00 postgres: tgl regression [local] idle in transaction
</screen>

   <!-- 
   (The appropriate invocation of <command>ps</> varies across different
   platforms, as do the details of what is shown.  This example is from a
   recent Linux system.)  The first process listed here is the
   master server process.  The command arguments
   shown for it are the same ones used when it was launched.  The next five
   processes are background worker processes automatically launched by the
   master process.  (The <quote>stats collector</> process will not be present
   if you have set the system not to start the statistics collector; likewise
   the <quote>autovacuum launcher</> process can be disabled.)
   Each of the remaining
   processes is a server process handling one client connection.  Each such
   process sets its command line display in the form
   -->
   （调用<command>ps</>的方法因平台的不同而略有不同，显示出来的细节也有一些区别。
   这个例子来自一个最近的 Linux 系统）。这里显示出来的第一个进程是主服务器进程。
   为它显示的命令参数是启动它时使用的那些。接下来的五个进程是由主进程自动启动的后台工作者进程
   （如果你已经设置系统为不启动统计收集器，<quote>统计收集器</>进程将不会出现；
   同样<quote>自动清理发动</>进程也可以被禁用）。
   剩余的每一个进程都是处理一个客户端连接的服务器进程。
   每个这样的进程都会把它的命令行显示设置为这种形式

<screen>
postgres: <replaceable>user</> <replaceable>database</> <replaceable>host</> <replaceable>activity</>
</screen>

  <!-- 
  The user, database, and (client) host items remain the same for
  the life of the client connection, but the activity indicator changes.
  The activity can be <literal>idle</> (i.e., waiting for a client command),
  <literal>idle in transaction</> (waiting for client inside a <command>BEGIN</> block),
  or a command type name such as <literal>SELECT</>.  Also,
  <literal>waiting</> is appended if the server process is presently waiting
  on a lock held by another session.  In the above example we can infer
  that process 15606 is waiting for process 15610 to complete its transaction
  and thereby release some lock.  (Process 15610 must be the blocker, because
  there is no other active session.  In more complicated cases it would be
  necessary to look into the
  <link linkend="view-pg-locks"><structname>pg_locks</structname></link>
  system view to determine who is blocking whom.)
  -->
  在该客户端连接的生命期中，用户、数据库以及（客户端）主机项保持不变，
  但是活动指示器会改变。活动可以是<literal>闲置</>（即等待客户端的命令）、
  <literal>在事务中闲置</>（在一个<command>BEGIN</>块里等待客户端）或者一个命令类型名，
  例如<literal>SELECT</>。还有，如果服务器进程正在等待一个其它会话持有的锁，
  <literal>等待中</>会被追加到上述信息中。在上面的例子中，我们可以推断：
  进程 15606 正在等待进程 15610 完成其事务并且因此释放一些锁（进程 15610 必定是阻塞者，
  因为没有其他活动会话。在更复杂的情况中，可能需要查看
  <link linkend="view-pg-locks"><structname>pg_locks</structname></link>
  系统视图来决定谁阻塞了谁）。
  </para>

  <para>
   <!-- 
   If <xref linkend="guc-cluster-name"> has been configured the
   cluster name will also be shown in <command>ps</> output:
   -->
   如果已经配置了<xref linkend="guc-cluster-name">，
   那么在<command>ps</>输出中也会显示集群名称：
<screen>
$ psql -c 'SHOW cluster_name'
 cluster_name
--------------
 server1
(1 row)

$ ps aux|grep server1
postgres   27093  0.0  0.0  30096  2752 ?        Ss   11:34   0:00 postgres: server1: writer process
...
</screen>
  </para>
  
  <!-- 
  <para>
   If you have turned off <xref linkend="guc-update-process-title"> then the
   activity indicator is not updated; the process title is set only once
   when a new process is launched.  On some platforms this saves a measurable
   amount of per-command overhead;  on others it's insignificant.
  </para>
  -->
  <para>
   如果你已经关闭了<xref linkend="guc-update-process-title">，那么活动指示器将不会被更新，
   进程标题仅在新进程被启动的时候设置一次。在某些平台上这样做可以为每个命令节省可观的开销，
   但在其它平台上却不明显。
  </para>

  <tip>
  <!-- 
  <para>
  <productname>Solaris</productname> requires special handling. You must
  use <command>/usr/ucb/ps</command>, rather than
  <command>/bin/ps</command>. You also must use two <option>w</option>
  flags, not just one. In addition, your original invocation of the
  <command>postgres</command> command must have a shorter
  <command>ps</command> status display than that provided by each
  server process.  If you fail to do all three things, the <command>ps</>
  output for each server process will be the original <command>postgres</>
  command line.
  </para>
  -->
  <para>
  <productname>Solaris</productname>需要特别的处理。你必需使用<command>/usr/ucb/ps</command>
  而不是<command>/bin/ps</command>。你还必需使用两个<option>w</option>标志，而不是一个。
  另外，你对<command>postgres</command>命令的最初调用必须用一个比服务器进程提供的短的
  <command>ps</command>状态显示。如果你没有满足全部三个要求，每个服务器进程的
  <command>ps</>输出将是原始的<command>postgres</>命令行。
  </para>
  </tip>
 </sect1>

 <sect1 id="monitoring-stats">
  <!-- 
  <title>The Statistics Collector</title>
  -->
  <title>统计收集器</title>

  <indexterm zone="monitoring-stats">
   <primary>statistics</primary>
  </indexterm>

  <!-- 
  <para>
   <productname>PostgreSQL</productname>'s <firstterm>statistics collector</>
   is a subsystem that supports collection and reporting of information about
   server activity.  Presently, the collector can count accesses to tables
   and indexes in both disk-block and individual-row terms.  It also tracks
   the total number of rows in each table, and information about vacuum and
   analyze actions for each table.  It can also count calls to user-defined
   functions and the total time spent in each one.
  </para>
  -->
  <para>
   <productname>PostgreSQL</productname>的<firstterm>统计收集器</>
   是一个支持收集和报告服务器活动信息的子系统。目前，这个收集器可以对表和索引的访问计数，
   计数可以按磁盘块和个体行来进行。它还跟踪每个表中的总行数、每个表的清理和分析动作的信息。
   它也统计调用用户定义函数的次数以及在每次调用中花费的总时间。
  </para>

  <!-- 
  <para>
   <productname>PostgreSQL</productname> also supports reporting dynamic
   information about exactly what is going on in the system right now, such as
   the exact command currently being executed by other server processes, and
   which other connections exist in the system.  This facility is independent
   of the collector process.
  </para>
  -->
  <para>
   <productname>PostgreSQL</productname>还支持报告关于系统中正在发生什么的动态信息，
   比如当前其它服务器进程正在执行的命令，系统中存在的其他链接。这是独立于收集器进程的功能。
  </para>

 <sect2 id="monitoring-stats-setup">
  <!-- 
  <title>Statistics Collection Configuration</title>
  -->
  <title>统计收集配置</title>

  <!-- 
  <para>
   Since collection of statistics adds some overhead to query execution,
   the system can be configured to collect or not collect information.
   This is controlled by configuration parameters that are normally set in
   <filename>postgresql.conf</>.  (See <xref linkend="runtime-config"> for
   details about setting configuration parameters.)
  </para>
  -->
  <para>
   因为统计收集给查询执行增加了一些负荷，系统可以被配置为收集或不收集信息。
   这是由配置参数控制的，它们通常在<filename>postgresql.conf</>中设置
   （关于设置配置参数的细节请见<xref linkend="runtime-config">）。
  </para>

  <!-- 
  <para>
   The parameter <xref linkend="guc-track-activities"> enables monitoring
   of the current command being executed by any server process.
  </para>
  -->
  <para>
   参数<xref linkend="guc-track-activities">启动监控当前被任意服务器进程执行的命令。
  </para>

  <!-- 
  <para>
   The parameter <xref linkend="guc-track-counts"> controls whether
   statistics are collected about table and index accesses.
  </para>
  -->
  <para>
   参数<xref linkend="guc-track-counts">控制是否收集关于表和索引访问的统计信息。
  </para>

  <!-- 
  <para>
   The parameter <xref linkend="guc-track-functions"> enables tracking of
   usage of user-defined functions.
  </para>
  -->
  <para>
   参数<xref linkend="guc-track-functions">启用对用户定义函数使用的跟踪。
  </para>

  <!-- 
  <para>
   The parameter <xref linkend="guc-track-io-timing"> enables monitoring
   of block read and write times.
  </para>
  -->
  <para>
   参数<xref linkend="guc-track-io-timing">启动对块读写次数的监控。
  </para>

  <!-- 
  <para>
   Normally these parameters are set in <filename>postgresql.conf</> so
   that they apply to all server processes, but it is possible to turn
   them on or off in individual sessions using the <xref
   linkend="sql-set"> command. (To prevent
   ordinary users from hiding their activity from the administrator,
   only superusers are allowed to change these parameters with
   <command>SET</>.)
  </para>
  -->
  <para>
   通常这些参数被在<filename>postgresql.conf</>中设置，
   因此它们作用于所有服务器进程，但是可以在单个会话中使用
   <xref linkend="sql-set">命令打开或关闭它们
   （为了阻止普通用户对管理员隐藏他们的活动，只允许超级用户使用
   <command>SET</>来改变这些参数）。
  </para>

  <!-- 
  <para>
   The statistics collector transmits the collected information to other
   <productname>PostgreSQL</productname> processes through temporary files.
   These files are stored in the directory named by the
   <xref linkend="guc-stats-temp-directory"> parameter,
   <filename>pg_stat_tmp</filename> by default.
   For better performance, <varname>stats_temp_directory</> can be
   pointed at a RAM-based file system, decreasing physical I/O requirements.
   When the server shuts down cleanly, a permanent copy of the statistics
   data is stored in the <filename>pg_stat</filename> subdirectory, so that
   statistics can be retained across server restarts.  When recovery is
   performed at server start (e.g. after immediate shutdown, server crash,
   and point-in-time recovery), all statistics counters are reset.
  </para>
  -->
  <para>
   统计收集器通过临时文件将收集到的信息传送给其他<productname>PostgreSQL</productname>进程。
   这些文件存储在<xref linkend="guc-stats-temp-directory">参数命名的目录中，
   默认是<filename>pg_stat_tmp</filename>。为了得到更好的性能，
   <varname>stats_temp_directory</>可以指向一个基于 RAM 的文件系统来降低物理 I/O 需求。
   当服务器干净地关闭时，一份统计数据的永久拷贝被存储在<filename>pg_stat</filename>
   子目录中，这样统计数据可以在服务器重新启动时保留。当在服务器启动时执行恢复时
   （例如立即关闭、服务器崩溃以及时间点恢复之后），所有统计计数器会被重置。
  </para>

 </sect2>

 <sect2 id="monitoring-stats-views">
  <!-- 
  <title>Viewing Statistics</title>
  -->
  <title>查看统计信息</title>

  <!-- 
  <para>
   Several predefined views, listed in <xref
   linkend="monitoring-stats-dynamic-views-table">, are available to show
   the current state of the system. There are also several other
   views, listed in <xref
   linkend="monitoring-stats-views-table">, available to show the results
   of statistics collection.  Alternatively, one can
   build custom views using the underlying statistics functions, as discussed
   in <xref linkend="monitoring-stats-functions">.
  </para>
  -->
  <para>
   <xref linkend="monitoring-stats-dynamic-views-table">中列出了一些预定义视图，
   可以用来显示系统的当前状态，在<xref linkend="monitoring-stats-views-table">
   中还列出了几个其他视图可以用来显示统计收集的结果。你也可以使用底层统计函数
   （在<xref linkend="monitoring-stats-functions">中讨论）来建立自定义的视图。
  </para>

  <!-- 
  <para>
   When using the statistics to monitor collected data, it is important
   to realize that the information does not update instantaneously.
   Each individual server process transmits new statistical counts to
   the collector just before going idle; so a query or transaction still in
   progress does not affect the displayed totals.  Also, the collector itself
   emits a new report at most once per <varname>PGSTAT_STAT_INTERVAL</varname>
   milliseconds (500 ms unless altered while building the server).  So the
   displayed information lags behind actual activity.  However, current-query
   information collected by <varname>track_activities</varname> is
   always up-to-date.
  </para>
  -->
  <para>
   在使用统计信息监控收集的数据时，你必须了解这些信息并非是实时更新的。
   每个独立的服务器进程只在进入闲置状态之前才向收集器传送新的统计计数；
   因此正在进行的查询或事务并不影响显示出来的总数。同样，收集器本身也最多每
   <varname>PGSTAT_STAT_INTERVAL</varname>毫秒（缺省为 500ms，
   除非在编译服务器的时候修改过）发送一次新的报告。因此显示的信息总是落后于实际活动。
   但是由<varname>track_activities</varname>收集的当前查询信息总是最新的。
  </para>

  <!-- 
  <para>
   Another important point is that when a server process is asked to display
   any of these statistics, it first fetches the most recent report emitted by
   the collector process and then continues to use this snapshot for all
   statistical views and functions until the end of its current transaction.
   So the statistics will show static information as long as you continue the
   current transaction.  Similarly, information about the current queries of
   all sessions is collected when any such information is first requested
   within a transaction, and the same information will be displayed throughout
   the transaction.
   This is a feature, not a bug, because it allows you to perform several
   queries on the statistics and correlate the results without worrying that
   the numbers are changing underneath you.  But if you want to see new
   results with each query, be sure to do the queries outside any transaction
   block.  Alternatively, you can invoke
   <function>pg_stat_clear_snapshot</function>(), which will discard the
   current transaction's statistics snapshot (if any).  The next use of
   statistical information will cause a new snapshot to be fetched.
  </para>
  -->
  <para>
   另一个重点是当一个服务器进程被要求显示任何这些统计信息时，
   它首先取得收集器进程最近发出的报告并且接着为所有统计视图和函数使用这个快照，
   直到它当前事务的结尾。因此统计信息在当前事务的持续期间内显示静态信息。
   相似地，关于所有会话的当前查询信息在事务中第一次请求的时候就收集了，
   并且在整个事务期间将显示相同的信息。这是一个特性而非缺陷，
   因为它允许你在该统计信息上执行多个查询，
   并且关联结果而不用担心那些数字会在你不知情的情况下改变。
   但是如果你希望每个查询都看到最新结果，要确保在任何事务块之外做那些查询。或者，
   你可以调用<function>pg_stat_clear_snapshot</function>()，那将丢弃当前事务的统计快照
   （如果有）。下次使用统计信息将导致获取一个新的快照。
  </para>

  <!-- 
  <para>
   A transaction can also see its own statistics (as yet untransmitted to the
   collector) in the views <structname>pg_stat_xact_all_tables</>,
   <structname>pg_stat_xact_sys_tables</>,
   <structname>pg_stat_xact_user_tables</>, and
   <structname>pg_stat_xact_user_functions</>.  These numbers do not act as
   stated above; instead they update continuously throughout the transaction.
  </para>
  -->
  <para>
   一个事务也可以在视图<structname>pg_stat_xact_all_tables</>、
   <structname>pg_stat_xact_sys_tables</>、<structname>pg_stat_xact_user_tables</>
   和<structname>pg_stat_xact_user_functions</>中看到自己的统计信息
   （还没有被传送给收集器）。这些数字并不像上面所说的那样行动，
   相反它们在整个事务中持续更新。
  </para>

  <table id="monitoring-stats-dynamic-views-table">
   <!-- 
   <title>Dynamic Statistics Views</title>
   -->
   <title>动态统计视图</title>

   <tgroup cols="2">
    <thead>
     <row>
      <!-- 
      <entry>View Name</entry>
      <entry>Description</entry>
      -->
      <entry>视图名称</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <structname>pg_stat_activity</structname>
       <indexterm><primary>pg_stat_activity</primary></indexterm>
      </entry>
      <!-- 
      <entry>
       One row per server process, showing information related to
       the current activity of that process, such as state and current query.
       See <xref linkend="pg-stat-activity-view"> for details.
      </entry>
      -->
      <entry>
       每个服务器进程一行，显示与那个进程的当前活动相关的信息，例如状态和当前查询。
       详见<xref linkend="pg-stat-activity-view">。
      </entry>
     </row>
     
     <row>
      <entry><structname>pg_stat_replication</><indexterm><primary>pg_stat_replication</primary></indexterm></entry>
      <!-- 
      <entry>One row per WAL sender process, showing statistics about
       replication to that sender's connected standby server.
       See <xref linkend="pg-stat-replication-view"> for details.
      </entry>
      -->
      <entry>
      每个 WAL 发送者进程一行，显示与到该发送者连接到的后备服务器的复制相关的统计信息。
      详见<xref linkend="pg-stat-replication-view">。
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_ssl</><indexterm><primary>pg_stat_ssl</primary></indexterm></entry>
      <!-- 
      <entry>One row per connection (regular and replication), showing information about
       SSL used on this connection.
       See <xref linkend="pg-stat-ssl-view"> for details.
      </entry>
      -->
      <entry>每个连接（普通或复制）一行，显示关于该连接中使用的SSL的信息。
       详细信息请参阅<xref linkend="pg-stat-ssl-view">。
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <table id="monitoring-stats-views-table">
   <!-- 
   <title>Collected Statistics Views</title>
   -->
   <title>收集的统计视图</title>

   <tgroup cols="2">
    <thead>
     <!-- 
     <row>
      <entry>View Name</entry>
      <entry>Description</entry>
     </row> 
     -->
     <row>
      <entry>视图名称</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structname>pg_stat_archiver</><indexterm><primary>pg_stat_archiver</primary></indexterm></entry>
      <!-- 
      <entry>One row only, showing statistics about the
       WAL archiver process's activity. See
       <xref linkend="pg-stat-archiver-view"> for details.
      </entry>
      -->
      <entry>只有一行，显示有关 WAL 归档进程活动的统计信息。
      详见<xref linkend="pg-stat-archiver-view">。
      </entry>
     </row>

     <row>      
      <entry><structname>pg_stat_bgwriter</><indexterm><primary>pg_stat_bgwriter</primary></indexterm></entry>
      <!-- 
      <entry>One row only, showing statistics about the
       background writer process's activity. See
       <xref linkend="pg-stat-bgwriter-view"> for details.
     </entry>
     -->
      <entry>只有一行，显示有关后台写进程活动的统计信息。
      详见<xref linkend="pg-stat-bgwriter-view">。
     </entry>
     </row>

     <row>
      <entry><structname>pg_stat_database</><indexterm><primary>pg_stat_database</primary></indexterm></entry>
      <!-- 
      <entry>One row per database, showing database-wide statistics. See
       <xref linkend="pg-stat-database-view"> for details.
      </entry>
      -->
      <entry>每个数据库一行，显示数据库范围的统计信息。
      详见<xref linkend="pg-stat-database-view">。
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_database_conflicts</><indexterm><primary>pg_stat_database_conflicts</primary></indexterm></entry>
      <!-- 
      <entry>
       One row per database, showing database-wide statistics about
       query cancels due to conflict with recovery on standby servers.
       See <xref linkend="pg-stat-database-conflicts-view"> for details.
      </entry> 
      -->
      <entry>
       每个数据库一行，显示数据库范围内由于与后备服务器上的恢复冲突而取消的查询有关的统计信息。
       详见<xref linkend="pg-stat-database-conflicts-view">。
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_all_tables</><indexterm><primary>pg_stat_all_tables</primary></indexterm></entry>
      <!-- 
      <entry>
       One row for each table in the current database, showing statistics
       about accesses to that specific table.
       See <xref linkend="pg-stat-all-tables-view"> for details.
      </entry>
      -->
      <entry>
       当前数据库中每个表一行，显示有关访问指定表的统计信息。
       详见<xref linkend="pg-stat-all-tables-view">。
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_sys_tables</><indexterm><primary>pg_stat_sys_tables</primary></indexterm></entry>
      <!-- 
      <entry>Same as <structname>pg_stat_all_tables</>, except that only
      system tables are shown.</entry>
      -->
      <entry>和<structname>pg_stat_all_tables</>一样，但只显示系统表。</entry>
     </row>

     <row>
      <entry><structname>pg_stat_user_tables</><indexterm><primary>pg_stat_user_tables</primary></indexterm></entry>
      <!-- 
      <entry>Same as <structname>pg_stat_all_tables</>, except that only user
      tables are shown.</entry>
      -->
      <entry>和<structname>pg_stat_all_tables</>一样，但只显示用户表。</entry>
     </row>

     <row>
      <entry><structname>pg_stat_xact_all_tables</><indexterm><primary>pg_stat_xact_all_tables</primary></indexterm></entry>
      <!-- 
      <entry>Similar to <structname>pg_stat_all_tables</>, but counts actions
      taken so far within the current transaction (which are <emphasis>not</>
      yet included in <structname>pg_stat_all_tables</> and related views).
      The columns for numbers of live and dead rows and vacuum and
      analyze actions are not present in this view.</entry>
      -->
      <entry>和<structname>pg_stat_all_tables</>相似，但计数动作只在当前事务内发生
      （还<emphasis>没有</>被包括在<structname>pg_stat_all_tables</>和相关视图中）。
      此视图中不存在活行和死行数以及清理和分析操作的列。</entry>
     </row>

     <row>
      <entry><structname>pg_stat_xact_sys_tables</><indexterm><primary>pg_stat_xact_sys_tables</primary></indexterm></entry>
      <!-- 
      <entry>Same as <structname>pg_stat_xact_all_tables</>, except that only
      system tables are shown.</entry>
      -->
      <entry>和<structname>pg_stat_xact_all_tables</>一样，但只显示系统表。</entry>
     </row>

     <row>
      <entry><structname>pg_stat_xact_user_tables</><indexterm><primary>pg_stat_xact_user_tables</primary></indexterm></entry>
      <!-- 
      <entry>Same as <structname>pg_stat_xact_all_tables</>, except that only
      user tables are shown.</entry>
      -->
      <entry>和<structname>pg_stat_xact_all_tables</>一样，但只显示用户表。</entry>
     </row>

     <row>
      <entry><structname>pg_stat_all_indexes</><indexterm><primary>pg_stat_all_indexes</primary></indexterm></entry>
      <!-- 
      <entry>
       One row for each index in the current database, showing statistics
       about accesses to that specific index.
       See <xref linkend="pg-stat-all-indexes-view"> for details.
      </entry>
      -->
      <entry>
       当前数据库中的每个索引一行，显示与访问指定索引有关的统计信息。
       详见<xref linkend="pg-stat-all-indexes-view">。
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_sys_indexes</><indexterm><primary>pg_stat_sys_indexes</primary></indexterm></entry>
      <!-- 
      <entry>Same as <structname>pg_stat_all_indexes</>, except that only
      indexes on system tables are shown.</entry>
      -->
      <entry>和<structname>pg_stat_all_indexes</>一样，但只显示系统表上的索引。</entry>
     </row>

     <row>
      <entry><structname>pg_stat_user_indexes</><indexterm><primary>pg_stat_user_indexes</primary></indexterm></entry>
      <!-- 
      <entry>Same as <structname>pg_stat_all_indexes</>, except that only
      indexes on user tables are shown.</entry>
      -->
      <entry>和<structname>pg_stat_all_indexes</>一样，但只显示用户表上的索引。</entry>
     </row>

     <row>
      <entry><structname>pg_statio_all_tables</><indexterm><primary>pg_statio_all_tables</primary></indexterm></entry>
      <!-- 
      <entry>
       One row for each table in the current database, showing statistics
       about I/O on that specific table.
       See <xref linkend="pg-statio-all-tables-view"> for details.
      </entry>
      -->
      <entry>
       当前数据库中的每个表一行，显示有关指定表上 I/O 的统计信息。
       详见<xref linkend="pg-statio-all-tables-view">。
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_sys_tables</><indexterm><primary>pg_statio_sys_tables</primary></indexterm></entry>
      <!-- 
      <entry>Same as <structname>pg_statio_all_tables</>, except that only
      system tables are shown.</entry>
      -->
      <entry>和<structname>pg_statio_all_tables</>一样，但只显示系统表。</entry>
     </row>

     <row>
      <entry><structname>pg_statio_user_tables</><indexterm><primary>pg_statio_user_tables</primary></indexterm></entry>
      <!-- 
      <entry>Same as <structname>pg_statio_all_tables</>, except that only
      user tables are shown.</entry>
      -->
      <entry>和<structname>pg_statio_all_tables</>一样，但只显示用户表。</entry>
     </row>

     <row>
      <entry><structname>pg_statio_all_indexes</><indexterm><primary>pg_statio_all_indexes</primary></indexterm></entry>
      <!-- 
      <entry>
       One row for each index in the current database,
       showing statistics about I/O on that specific index.
       See <xref linkend="pg-statio-all-indexes-view"> for details.
      </entry>
      -->
      <entry>
       当前数据库中的每个索引一行，显示有关指定索引上 I/O 的统计信息。
       详见<xref linkend="pg-statio-all-indexes-view">。
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_sys_indexes</><indexterm><primary>pg_statio_sys_indexes</primary></indexterm></entry>
      <!-- 
      <entry>Same as <structname>pg_statio_all_indexes</>, except that only
      indexes on system tables are shown.</entry>
      -->
      <entry>和<structname>pg_statio_all_indexes</>一样，但只显示系统表上的索引。</entry>
     </row>

     <row>
      <entry><structname>pg_statio_user_indexes</><indexterm><primary>pg_statio_user_indexes</primary></indexterm></entry>
      <!-- 
      <entry>Same as <structname>pg_statio_all_indexes</>, except that only
      indexes on user tables are shown.</entry>
      -->
      <entry>和<structname>pg_statio_all_indexes</>一样，但只显示用户表上的索引。</entry>
     </row>

     <row>
      <entry><structname>pg_statio_all_sequences</><indexterm><primary>pg_statio_all_sequences</primary></indexterm></entry>
     <!-- 
     <entry>
       One row for each sequence in the current database,
       showing statistics about I/O on that specific sequence.
       See <xref linkend="pg-statio-all-sequences-view"> for details.
     </entry>
     -->
     <entry>
       当前数据库中的每个序列一行，显示有关指定序列上 I/O 的统计信息。
       详见<xref linkend="pg-statio-all-sequences-view">。
     </entry>
     </row>

     <row>
      <entry><structname>pg_statio_sys_sequences</><indexterm><primary>pg_statio_sys_sequences</primary></indexterm></entry>
      <!-- 
      <entry>Same as <structname>pg_statio_all_sequences</>, except that only
      system sequences are shown.  (Presently, no system sequences are defined,
      so this view is always empty.)</entry>
      -->
      <entry>和<structname>pg_statio_all_sequences</>一样，但只显示系统序列
      （目前没有定义系统序列，因此这个视图总是为空）。</entry>
     </row>

     <row>
      <entry><structname>pg_statio_user_sequences</><indexterm><primary>pg_statio_user_sequences</primary></indexterm></entry>
      <!-- 
      <entry>Same as <structname>pg_statio_all_sequences</>, except that only
      user sequences are shown.</entry>
      -->
      <entry>和<structname>pg_statio_all_sequences</>一样，但只显示用户序列。</entry>
     </row>

     <row>
      <entry><structname>pg_stat_user_functions</><indexterm><primary>pg_stat_user_functions</primary></indexterm></entry>
      <!-- 
      <entry>
       One row for each tracked function, showing statistics
       about executions of that function. See
       <xref linkend="pg-stat-user-functions-view"> for details.
      </entry>
      -->
      <entry>
       每一个被跟踪的函数一行，显示与执行该函数有关的统计信息。
       详见<xref linkend="pg-stat-user-functions-view">。
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_xact_user_functions</><indexterm><primary>pg_stat_xact_user_functions</primary></indexterm></entry>
      <!-- 
      <entry>Similar to <structname>pg_stat_user_functions</>, but counts only
      calls during the current transaction (which are <emphasis>not</>
      yet included in <structname>pg_stat_user_functions</>).</entry>
     </row>
     -->
      <entry>和<structname>pg_stat_user_functions</>相似，
      但是只统计在当前事务期间的调用（还<emphasis>没有</>被包括在
      <structname>pg_stat_user_functions</>中）。</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <!-- 
  <para>
   The per-index statistics are particularly useful to determine which
   indexes are being used and how effective they are.
  </para>
  -->
  <para>
   针对每个索引的统计信息对于判断哪个索引正被使用以及它们的效果特别有用。
  </para>

  <!-- 
  <para>
   The <structname>pg_statio_</> views are primarily useful to
   determine the effectiveness of the buffer cache.  When the number
   of actual disk reads is much smaller than the number of buffer
   hits, then the cache is satisfying most read requests without
   invoking a kernel call. However, these statistics do not give the
   entire story: due to the way in which <productname>PostgreSQL</>
   handles disk I/O, data that is not in the
   <productname>PostgreSQL</> buffer cache might still reside in the
   kernel's I/O cache, and might therefore still be fetched without
   requiring a physical read. Users interested in obtaining more
   detailed information on <productname>PostgreSQL</> I/O behavior are
   advised to use the <productname>PostgreSQL</> statistics collector
   in combination with operating system utilities that allow insight
   into the kernel's handling of I/O.
  </para>
  -->
  <para>
   <structname>pg_statio_</>系列视图主要用于判断缓冲区的效果。
   当实际磁盘读取数远小于缓冲区命中时，这个缓冲能满足大部分读请求而无需进行内核调用。
   但是，这些统计信息并没有给出所有的事情：由于<productname>PostgreSQL</>
   处理磁盘 I/O 的方式，不在<productname>PostgreSQL</>
   缓冲区缓存中的数据可能仍然驻留在内核的 I/O 缓存中，
   并且因此可以被再次读取而不需要物理磁盘读取。我们建议希望了解
   <productname>PostgreSQL</> I/O 行为更多细节的用户将<productname>PostgreSQL</>
   统计收集器和操作系统中允许观察内核处理 I/O 的工具一起使用。
  </para>


  <table id="pg-stat-activity-view" xreflabel="pg_stat_activity">
   <!-- 
   <title><structname>pg_stat_activity</structname> View</title>
   -->
   <title><structname>pg_stat_activity</structname> 视图</title>

   <tgroup cols="3">
    <thead>
    <row>
      <!-- 
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
      -->
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>datid</></entry>
     <entry><type>oid</></entry>
     <!-- 
     <entry>OID of the database this backend is connected to</entry>
     -->
     <entry>这个后端连接到的数据库的OID</entry>
    </row>
    <row>
     <entry><structfield>datname</></entry>
     <entry><type>name</></entry>
     <!-- 
     <entry>Name of the database this backend is connected to</entry>
     -->
     <entry>这个后端连接到的数据库的名称</entry>
    </row>
    <row>
     <entry><structfield>pid</></entry>
     <entry><type>integer</></entry>
     <!-- 
     <entry>Process ID of this backend</entry>
     -->
     <entry>这个后端的进程 ID</entry>
    </row>
    <row>
     <entry><structfield>usesysid</></entry>
     <entry><type>oid</></entry>
     <!-- 
     <entry>OID of the user logged into this backend</entry>
     -->
     <entry>登录到这个后端的用户的OID</entry>
    </row>
    <row>
     <entry><structfield>usename</></entry>
     <entry><type>name</></entry>
     <!-- 
     <entry>Name of the user logged into this backend</entry>
     -->
     <entry>登录到这个后端的用户的名称</entry>
    </row>
    <row>
     <entry><structfield>application_name</></entry>
     <entry><type>text</></entry>
     <!-- 
     <entry>Name of the application that is connected
      to this backend</entry>
      -->
     <entry>连接到这个后端的应用的名称</entry>
    </row>
    <row>
     <entry><structfield>client_addr</></entry>
     <entry><type>inet</></entry>
     <!-- 
     <entry>IP address of the client connected to this backend.
      If this field is null, it indicates either that the client is
      connected via a Unix socket on the server machine or that this is an
      internal process such as autovacuum.
     </entry>
     -->
     <entry>连接到这个后端的客户端的 IP 地址。如果这个域为空，
     它表示客户端通过服务器机器上的一个 Unix 套接字连接或者这是一个内部进程（如自动清理）。
     </entry>
    </row>
    <row>
     <entry><structfield>client_hostname</></entry>
     <entry><type>text</></entry>
     <!-- 
     <entry>Host name of the connected client, as reported by a
      reverse DNS lookup of <structfield>client_addr</>. This field will
      only be non-null for IP connections, and only when <xref
      linkend="guc-log-hostname"> is enabled.
     </entry>
     -->
     <entry>已连接客户端的主机名，由<structfield>client_addr</>的反向 DNS 查找报告。
     这个域将只对 IP 连接非空，并且只有<xref linkend="guc-log-hostname">被启用时才会非空。
     </entry>
    </row>
    <row>
     <entry><structfield>client_port</></entry>
     <entry><type>integer</></entry>
     <!-- 
     <entry>TCP port number that the client is using for communication
      with this backend, or <literal>-1</> if a Unix socket is used
     </entry>
     -->
     <entry>客户端用于与这个后端通信的 TCP 端口号，或者如果使用 Unix 套接字则为<literal>-1</>
     </entry>
    </row>
    <row>
     <entry><structfield>backend_start</></entry>
     <entry><type>timestamp with time zone</></entry>
     <!-- 
     <entry>Time when this process was started, i.e., when the
      client connected to the server
     </entry>
     -->
     <entry>这个进程被启动的时间，即客户端是什么时候连接到服务器的
     </entry>
    </row>
    <row>
     <entry><structfield>xact_start</></entry>
     <entry><type>timestamp with time zone</></entry>
     <!-- 
     <entry>Time when this process' current transaction was started, or null
      if no transaction is active. If the current
      query is the first of its transaction, this column is equal to the
      <structfield>query_start</> column.
     </entry>
     -->
     <entry>这个进程的当前事务被启动的时间，如果没有活动事务则为空。
     如果当前查询是它的第一个事务，这一列等于<structfield>query_start</>。
     </entry>
    </row>
    <row>
     <entry><structfield>query_start</></entry>
     <entry><type>timestamp with time zone</></entry>
     <!-- 
     <entry>Time when the currently active query was started, or if
      <structfield>state</> is not <literal>active</>, when the last query
      was started
     </entry>
     -->
     <entry>当前活动查询开始的时间，如果<structfield>state</>不是
     <literal>active</>，则为上一个查询开始的时间
     </entry>
    </row>
    <row>
     <entry><structfield>state_change</></entry>
     <entry><type>timestamp with time zone</></entry>
     <!-- 
     <entry>Time when the <structfield>state</> was last changed</entry>
     -->
     <entry><structfield>state</>上一次被改变的时间</entry>
    </row>
    <row>
     <entry><structfield>waiting</></entry>
     <entry><type>boolean</></entry>
     <!-- 
     <entry>True if this backend is currently waiting on a lock</entry>
     -->
     <entry>如果这个后端正在等待一个锁则为真</entry>
    </row>
    <row>
     <entry><structfield>state</></entry>
     <entry><type>text</></entry>
     <entry><!-- 
     Current overall state of this backend.
       Possible values are:
       -->
     这个后端的当前总体状态。可能的值是：
       <itemizedlist>
         <listitem>
          <!-- 
          <para>
           <literal>active</>: The backend is executing a query.
          </para>
          -->
          <para>
           <literal>active</>：后端正在执行一个查询。
          </para>
         </listitem>
         <listitem>
          <!-- 
          <para>
           <literal>idle</>: The backend is waiting for a new client command.
          </para>
          -->
          <para>
           <literal>idle</>：后端正在等待一个新的客户端命令。
          </para>
         </listitem>
         <listitem>
          <!-- 
          <para>
           <literal>idle in transaction</>: The backend is in a transaction,
           but is not currently executing a query.
          </para>
          -->
          <para>
           <literal>idle in transaction</>：后端在一个事务中，但是当前没有执行查询。
          </para>
         </listitem>
         <listitem>
          <!-- 
          <para>
           <literal>idle in transaction (aborted)</>: This state is similar to
           <literal>idle in transaction</>, except one of the statements in
           the transaction caused an error.
          </para>
          -->
          <para>
           <literal>idle in transaction (aborted)</>：这个状态与
           <literal>idle in transaction</>相似，不过事务中的一个语句导致了一个错误。
          </para>
         </listitem>
         <listitem>
          <!-- 
          <para>
           <literal>fastpath function call</>: The backend is executing a
           fast-path function.
          </para>
          -->
          <para>
           <literal>fastpath function call</>：后端正在执行一个快速路径函数。
          </para>
         </listitem>
         <listitem>
           <!-- 
           <para>
           <literal>disabled</>: This state is reported if <xref
           linkend="guc-track-activities"> is disabled in this backend.
          </para>
          -->
           <para>
           <literal>disabled</>：如果在这个后端中<xref linkend="guc-track-activities">
           被禁用，则报告这个状态。
          </para>
         </listitem>
       </itemizedlist>
     </entry>
    </row>
    <row>
     <entry><structfield>backend_xid</structfield></entry>
     <entry><type>xid</type></entry>
     <!-- 
     <entry>Top-level transaction identifier of this backend, if any.</entry>
     -->
     <entry>这个后端的顶层事务标识符（如果存在）。</entry>
    </row>
    <row>
     <entry><structfield>backend_xmin</structfield></entry>
     <entry><type>xid</type></entry>
     <!-- 
     <entry>The current backend's <literal>xmin</> horizon.</entry>
     -->
     <entry>当前后端的<literal>xmin</>范围。</entry>
    </row>
    <row>
     <entry><structfield>query</></entry>
     <entry><type>text</></entry>
     <!-- 
     <entry>Text of this backend's most recent query. If
      <structfield>state</> is <literal>active</> this field shows the
      currently executing query. In all other states, it shows the last query
      that was executed.
     </entry>
     -->
     <entry>这个后端最近查询的文本。如果<structfield>state</>为<literal>active</>，
     这个域显示当前正在执行的查询。在所有其他状态下，它显示上一个被执行的查询。
     </entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <!-- 
  <para>
   The <structname>pg_stat_activity</structname> view will have one row
   per server process, showing information related to
   the current activity of that process.
  </para>
  -->
  <para>
   <structname>pg_stat_activity</structname>视图将为每一个服务器进程有一行，
   显示与该进程的当前活动相关的信息。
  </para>

  <note>
   <!-- 
   <para>
    The <structfield>waiting</> and <structfield>state</> columns are
    independent.  If a backend is in the <literal>active</> state,
    it may or may not be <literal>waiting</>.  If the state is
    <literal>active</> and <structfield>waiting</> is true, it means
    that a query is being executed, but is being blocked by a lock
    somewhere in the system.
   </para>
   -->
   <para>
    <structfield>waiting</>和<structfield>state</>列是独立的。如果一个后端处于
    <literal>active</>状态，它可能是也可能不是<literal>waiting</>。
    如果状态是<literal>active</>并且<structfield>waiting</>为真，
    它意味着正在执行一个查询，但是被系统中某处的一个锁阻塞。
   </para>
  </note>

  <table id="pg-stat-replication-view" xreflabel="pg_stat_replication">
   <!-- 
   <title><structname>pg_stat_replication</structname> View</title>
   -->
   <title><structname>pg_stat_replication</structname>视图</title>
   <tgroup cols="3">
    <thead>
    <row>
      <!-- 
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
      -->
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>pid</></entry>
     <entry><type>integer</></entry>
     <!-- 
     <entry>Process ID of a WAL sender process</entry>
     -->
     <entry>WAL 发送者进程的进程 ID</entry>
    </row>
    <row>
     <entry><structfield>usesysid</></entry>
     <entry><type>oid</></entry>
     <!-- 
     <entry>OID of the user logged into this WAL sender process</entry>
     -->
     <entry>登入到这个 WAL 发送者进程的用户 OID</entry>
    </row>
    <row>
     <entry><structfield>usename</></entry>
     <entry><type>name</></entry>
     <!-- 
     <entry>Name of the user logged into this WAL sender process</entry>
     -->
     <entry>登入到这个 WAL 发送者进程的用户名</entry>
    </row>
    <row>
     <entry><structfield>application_name</></entry>
     <entry><type>text</></entry>
     <!-- 
     <entry>Name of the application that is connected
      to this WAL sender</entry>
      -->
     <entry>连接到这个 WAL 发送者的应用名称</entry>
    </row>
    <row>
     <entry><structfield>client_addr</></entry>
     <entry><type>inet</></entry>
     <!-- 
     <entry>IP address of the client connected to this WAL sender.
      If this field is null, it indicates that the client is
      connected via a Unix socket on the server machine.
     </entry>
     -->
     <entry>连接到这个 WAL 发送者的客户端的 IP 地址。如果这个域为空，
     它指示该客户端是通过一个服务器机器上的 Unix 套接字连接的。
     </entry>
    </row>
    <row>
     <entry><structfield>client_hostname</></entry>
     <entry><type>text</></entry>
     <!-- 
     <entry>Host name of the connected client, as reported by a
      reverse DNS lookup of <structfield>client_addr</>. This field will
      only be non-null for IP connections, and only when <xref
      linkend="guc-log-hostname"> is enabled.
     </entry>
     -->
     <entry>已连接客户端的主机名，由<structfield>client_addr</>
     的一次反向 DNS 查找报告。这个域对于 IP 连接将只为非空，
     并且只有当<xref linkend="guc-log-hostname">被启用时才为非空。
     </entry>
    </row>
    <row>
     <entry><structfield>client_port</></entry>
     <entry><type>integer</></entry>
     <!-- 
     <entry>TCP port number that the client is using for communication
      with this WAL sender, or <literal>-1</> if a Unix socket is used
     </entry>
     -->
     <entry>客户端用来和这个 WAL 发送者通信的 TCP 端口号，
     或者如果使用 Unix 套接字则为<literal>-1</>
     </entry>
    </row>
    <row>
     <entry><structfield>backend_start</></entry>
     <entry><type>timestamp with time zone</></entry>
     <!-- 
     <entry>Time when this process was started, i.e., when the
      client connected to this WAL sender
     </entry>
     -->
     <entry>这个进程被启动的时间，即当客户端连接到这个 WAL 发送者时
     </entry>
    </row>
    <row>
     <entry><structfield>backend_xmin</structfield></entry>
     <entry><type>xid</type></entry>
     <!-- 
     <entry>This standby's <literal>xmin</> horizon reported
     by <xref linkend="guc-hot-standby-feedback">.</entry>
    </row>
    -->
     <entry><xref linkend="guc-hot-standby-feedback">报告的这个后备机的<literal>xmin</>范围。</entry>
    </row>
    <row>
     <entry><structfield>state</></entry>
     <entry><type>text</></entry>
     <!-- 
     <entry>Current WAL sender state</entry>
     -->
     <entry>当前 WAL 发送者的状态</entry>
    </row>
    <row>
     <entry><structfield>sent_location</></entry>
     <entry><type>pg_lsn</></entry>
     <!-- 
     <entry>Last transaction log position sent on this connection</entry>
     -->
     <entry>在这个连接上被发送的最后的事务日志位置</entry>
    </row>
    <row>
     <entry><structfield>write_location</></entry>
     <entry><type>pg_lsn</></entry>
     <!-- 
     <entry>Last transaction log position written to disk by this standby
      server</entry>
      -->
     <entry>被这个后备服务器写入到磁盘的最后的事务日志位置</entry>
    </row>
    <row>
     <entry><structfield>flush_location</></entry>
     <entry><type>pg_lsn</></entry>
     <!-- 
     <entry>Last transaction log position flushed to disk by this standby
      server</entry>
      -->
     <entry>被这个后备服务器刷入到磁盘的最后的事务日志位置</entry>
    </row>
    <row>
     <entry><structfield>replay_location</></entry>
     <entry><type>pg_lsn</></entry>
     <!-- 
     <entry>Last transaction log position replayed into the database on this
      standby server</entry>
      -->
     <entry>后备服务器上重放到数据库中的最后的事务日志位置</entry>
    </row>
    <row>
     <entry><structfield>sync_priority</></entry>
     <entry><type>integer</></entry>
     <!-- 
     <entry>Priority of this standby server for being chosen as the
      synchronous standby</entry>
      -->
     <entry>这个后备服务器被选中为同步后备的优先级</entry>
    </row>
    <row>
     <entry><structfield>sync_state</></entry>
     <entry><type>text</></entry>
     <!-- 
     <entry>Synchronous state of this standby server</entry>
     -->
     <entry>这个后备服务器的同步状态</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <!-- 
  <para>
   The <structname>pg_stat_replication</structname> view will contain one row
   per WAL sender process, showing statistics about replication to that
   sender's connected standby server.  Only directly connected standbys are
   listed; no information is available about downstream standby servers.
  </para>
  -->
  <para>
   <structname>pg_stat_replication</structname>视图将为每个 WAL 发送者进程包含一行，
   显示复制到发送者连接到的后备服务器的统计信息。只列出直接连接的后备服务器，
   没有关于下游后备服务器的信息。
  </para>

  <table id="pg-stat-ssl-view" xreflabel="pg_stat_ssl">
   <!-- 
   <title><structname>pg_stat_ssl</structname> View</title>
   -->
   <title><structname>pg_stat_ssl</structname> 视图</title>
   <tgroup cols="3">
    <thead>
    <row>
      <!--
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
      -->
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>pid</></entry>
     <entry><type>integer</></entry>
     <!-- 
     <entry>Process ID of a backend or WAL sender process</entry>
     -->
     <entry>后端或WAL发送者进程的进程ID</entry>
    </row>
    <row>
     <entry><structfield>ssl</></entry>
     <entry><type>boolean</></entry>
     <!-- 
     <entry>True if SSL is used on this connection</entry>
     -->
     <entry>如果在此连接上使用SSL，则为true</entry>
    </row>
    <row>
     <entry><structfield>version</></entry>
     <entry><type>text</></entry>
     <!-- 
     <entry>Version of SSL in use, or NULL if SSL is not in use
      on this connection</entry>
      -->
      <entry>正在使用的SSL版本，如果SSL未在此连接上使用，则为NULL</entry>
    </row>
    <row>
     <entry><structfield>cipher</></entry>
     <entry><type>text</></entry>
     <!-- 
     <entry>Name of SSL cipher in use, or NULL if SSL is not in use
      on this connection</entry>
      -->
      <entry>正在使用的SSL密码的名称，如果此连接上未使用SSL，则为NULL</entry>
    </row>
    <row>
     <entry><structfield>bits</></entry>
     <entry><type>integer</></entry>
     <!-- 
     <entry>Number of bits in the encryption algorithm used, or NULL
     if SSL is not used on this connection</entry>
     -->
     <entry>所使用的加密算法中的位数，如果此连接上未使用SSL，则为NULL</entry>
    </row>
    <row>
     <entry><structfield>compression</></entry>
     <entry><type>boolean</></entry>
     <!-- 
     <entry>True if SSL compression is in use, false if not,
      or NULL if SSL is not in use on this connection</entry>
      -->
      <entry>如果正在使用SSL压缩，则为true，否则为false，
      如果SSL未在此连接上使用，则为NULL</entry>
    </row>
    <row>
     <entry><structfield>clientdn</></entry>
     <entry><type>text</></entry>
     <!--
     <entry>Distinguished Name (DN) field from the client certificate
      used, or NULL if no client certificate was supplied or if SSL
      is not in use on this connection. This field is truncated if the
      DN field is longer than <symbol>NAMEDATALEN</symbol> (64 characters
      in a standard build)
     </entry>
     -->
     <entry>来自所使用的客户端证书的可分辨名称（DN）字段，
     如果未提供客户端证书或者SSL未在此连接上使用，则为NULL。
     如果DN字段长于<symbol>NAMEDATALEN</symbol>（标准构建中为64个字符），
     则此字段将被截断
     </entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <!-- 
  <para>
   The <structname>pg_stat_ssl</structname> view will contain one row per
   backend or WAL sender process, showing statistics about SSL usage on
   this connection. It can be joined to <structname>pg_stat_activity</structname>
   or <structname>pg_stat_replication</structname> on the
   <structfield>pid</structfield> column to get more details about the
   connection.
  </para> 
  -->
  <para>
   <structname>pg_stat_ssl</structname>视图将为每个后端或WAL发送者进程包含一行，
   显示有关此连接上的SSL使用情况的统计信息。它可以连接到<structfield>pid</structfield>
   列上的<structname>pg_stat_activity</structname>或<structname>pg_stat_replication</structname>，
   以获取有关连接的更多详细信息。
  </para>
  
  <table id="pg-stat-archiver-view" xreflabel="pg_stat_archiver">
   <!-- 
   <title><structname>pg_stat_archiver</structname> View</title>
   -->
   <title><structname>pg_stat_archiver</structname>视图</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
      -->
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>archived_count</></entry>
      <entry><type>bigint</type></entry>
      <!-- 
      <entry>Number of WAL files that have been successfully archived</entry>
      -->
      <entry>已被成功归档的 WAL 文件数量</entry>
     </row>
     <row>
      <entry><structfield>last_archived_wal</></entry>
      <entry><type>text</type></entry>
      <!-- 
      <entry>Name of the last WAL file successfully archived</entry>
      -->
      <entry>最后一个被成功归档的 WAL 文件名称</entry>
     </row>
     <row>
      <entry><structfield>last_archived_time</></entry>
      <entry><type>timestamp with time zone</type></entry>
      <!-- 
      <entry>Time of the last successful archive operation</entry>
      -->
      <entry>最后一次成功归档操作的时间</entry>
     </row>
     <row>
      <entry><structfield>failed_count</></entry>
      <entry><type>bigint</type></entry>
      <!-- 
      <entry>Number of failed attempts for archiving WAL files</entry>
      -->
      <entry>尝试归档 WAL 文件失败的次数</entry>
     </row>
     <row>
      <entry><structfield>last_failed_wal</></entry>
      <entry><type>text</type></entry>
      <!-- 
      <entry>Name of the WAL file of the last failed archival operation</entry>
      -->
      <entry>最后一次失败的归档操作的 WAL 文件名称</entry>
     </row>
     <row>
      <entry><structfield>last_failed_time</></entry>
      <entry><type>timestamp with time zone</type></entry>
      <!-- 
      <entry>Time of the last failed archival operation</entry>
      -->
      <entry>最后一次失败的归档操作的时间</entry>
     </row>
     <row>
      <entry><structfield>stats_reset</></entry>
      <entry><type>timestamp with time zone</type></entry>
      <!-- 
      <entry>Time at which these statistics were last reset</entry>
      -->
      <entry>这些统计信息最后一次被重置的时间</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <!-- 
  <para>
   The <structname>pg_stat_archiver</structname> view will always have a
   single row, containing data about the archiver process of the cluster.
  </para>
  -->
  <para>
   <structname>pg_stat_archiver</structname>视图将总是只有一行，
   该行包含着有关集簇的归档进程的数据。
  </para>

  <table id="pg-stat-bgwriter-view" xreflabel="pg_stat_bgwriter">
   <!-- 
   <title><structname>pg_stat_bgwriter</structname> View</title>
   -->
   <title><structname>pg_stat_bgwriter</structname>视图</title>

   <tgroup cols="3">
    <thead>
    <row>
      <!-- 
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
      -->
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>checkpoints_timed</></entry>
      <entry><type>bigint</type></entry>
      <!-- 
      <entry>Number of scheduled checkpoints that have been performed</entry>
      -->
      <entry>已经被执行的计划中检查点的数量</entry>
     </row>
     <row>
      <entry><structfield>checkpoints_req</></entry>
      <entry><type>bigint</type></entry>
      <!-- 
      <entry>Number of requested checkpoints that have been performed</entry>
      -->
      <entry>已经被执行的请求检查点的数量</entry>
     </row>
     <row>
      <entry><structfield>checkpoint_write_time</></entry>
      <entry><type>double precision</type></entry>
      <!-- 
      <entry>
        Total amount of time that has been spent in the portion of
        checkpoint processing where files are written to disk, in milliseconds
      </entry>
      -->
      <entry>文件被写入磁盘的检查点处理部分花费的总时间，以毫秒计
      </entry>
     </row>
     <row>
      <entry><structfield>checkpoint_sync_time</></entry>
      <entry><type>double precision</type></entry>
      <!-- 
      <entry>
        Total amount of time that has been spent in the portion of
        checkpoint processing where files are synchronized to disk, in
        milliseconds
      </entry>
      -->
      <entry>文件被同步到磁盘中的检查点处理部分花费的总时间，以毫秒计
      </entry>
     </row>
     <row>
      <entry><structfield>buffers_checkpoint</></entry>
      <entry><type>bigint</type></entry>
      <!-- 
      <entry>Number of buffers written during checkpoints</entry>
      -->
      <entry>在检查点期间被写的缓冲区数目</entry>
     </row>
     <row>
      <entry><structfield>buffers_clean</></entry>
      <entry><type>bigint</type></entry>
      <!-- 
      <entry>Number of buffers written by the background writer</entry>
      -->
      <entry>被后台写进程写的缓冲区数目</entry>
     </row>
     <row>
      <entry><structfield>maxwritten_clean</></entry>
      <entry><type>bigint</type></entry>
      <!-- 
      <entry>Number of times the background writer stopped a cleaning
       scan because it had written too many buffers</entry>
       -->
      <entry>后台写进程由于已经写了太多缓冲区而停止清洁扫描的次数</entry>
     </row>
     <row>
      <entry><structfield>buffers_backend</></entry>
      <entry><type>bigint</type></entry>
      <!-- 
      <entry>Number of buffers written directly by a backend</entry>
      -->
      <entry>被一个后端直接写的缓冲区数量</entry>
     </row>
     <row>
      <entry><structfield>buffers_backend_fsync</></entry>
      <entry><type>bigint</type></entry>
      <!-- 
      <entry>Number of times a backend had to execute its own
       <function>fsync</> call (normally the background writer handles those
       even when the backend does its own write)</entry>
       -->
      <entry>一个后端不得不自己执行<function>fsync</>调用的次数
      （通常即使后端自己进行写操作，后台写进程也会处理这些）</entry>
     </row>
     <row>
      <entry><structfield>buffers_alloc</></entry>
      <entry><type>bigint</type></entry>
      <!-- 
      <entry>Number of buffers allocated</entry>
      -->
      <entry>被分配的缓冲区数量</entry>
     </row>
     <row>
      <entry><structfield>stats_reset</></entry>
      <entry><type>timestamp with time zone</type></entry>
      <!-- 
      <entry>Time at which these statistics were last reset</entry>
      -->
      <entry>这些统计信息上次被重置的时间</entry>
     </row>
    </tbody>
    </tgroup>
  </table>

  <!-- 
  <para>
   The <structname>pg_stat_bgwriter</structname> view will always have a
   single row, containing global data for the cluster.
  </para>
  -->
  <para>
   <structname>pg_stat_bgwriter</structname>视图将总是只有一行，它包含集簇的全局数据。
  </para>

  <table id="pg-stat-database-view" xreflabel="pg_stat_database">
   <!-- 
   <title><structname>pg_stat_database</structname> View</title>
   -->
   <title><structname>pg_stat_database</structname>视图</title>
   <tgroup cols="3">
    <thead>
    <row>
      <!-- 
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
      -->
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>datid</></entry>
     <entry><type>oid</></entry>
     <!-- 
     <entry>OID of a database</entry>
     -->
     <entry>一个数据库的 OID</entry>
    </row>
    <row>
     <entry><structfield>datname</></entry>
     <entry><type>name</></entry>
     <!-- 
     <entry>Name of this database</entry>
     -->
     <entry>这个数据库的名称</entry>
    </row>
    <row>
     <entry><structfield>numbackends</></entry>
     <entry><type>integer</></entry>
     <!-- 
     <entry>Number of backends currently connected to this database.
     This is the only column in this view that returns a value reflecting
     current state; all other columns return the accumulated values since
     the last reset.</entry>
     -->
     <entry>当前连接到这个数据库的后端数量。这是在这个视图中唯一一个返回反映当前状态值的列。
     所有其他列返回从上次重置以来积累的值。</entry>
    </row>
    <row>
     <entry><structfield>xact_commit</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of transactions in this database that have been
      committed</entry>
      -->
     <entry>在这个数据库中已经提交的事务的数量</entry>
    </row>
    <row>
     <entry><structfield>xact_rollback</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of transactions in this database that have been
      rolled back</entry>
      -->
     <entry>在这个数据库中已经回滚的事务的数量</entry>
    </row>
    <row>
     <entry><structfield>blks_read</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of disk blocks read in this database</entry>
     -->
     <entry>在这个数据库中读取的磁盘块的数量</entry>
    </row>
    <row>
     <entry><structfield>blks_hit</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of times disk blocks were found already in the buffer
      cache, so that a read was not necessary (this only includes hits in the
      PostgreSQL buffer cache, not the operating system's file system cache)
     </entry>
     -->
     <entry>发现磁盘块已经在缓冲区缓存中的次数，这样不需要一次读取
     （这只包括 PostgreSQL 缓冲区缓存中的命中，而不包括在操作系统文件系统缓存中的命中）
     </entry>
    </row>
    <row>
     <entry><structfield>tup_returned</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of rows returned by queries in this database</entry>
     -->
     <entry>这个数据库中的查询返回的行数</entry>
    </row>
    <row>
     <entry><structfield>tup_fetched</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of rows fetched by queries in this database</entry>
     -->
     <entry>这个数据库中的查询取出的行数</entry>
    </row>
    <row>
     <entry><structfield>tup_inserted</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of rows inserted by queries in this database</entry>
     -->
     <entry>这个数据库中的查询插入的行数</entry>
    </row>
    <row>
     <entry><structfield>tup_updated</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of rows updated by queries in this database</entry>
     -->
     <entry>这个数据库中的查询更新的行数</entry>
    </row>
    <row>
     <entry><structfield>tup_deleted</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of rows deleted by queries in this database</entry>
     -->
     <entry>这个数据库中的查询删除的行数</entry>
    </row>
    <row>
     <entry><structfield>conflicts</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of queries canceled due to conflicts with recovery
      in this database. (Conflicts occur only on standby servers; see
      <xref linkend="pg-stat-database-conflicts-view"> for details.)
     </entry>
     -->
     <entry>由于与恢复冲突而在这个数据库中取消的查询数量
     （冲突只发生在后备服务器上，详见<xref linkend="pg-stat-database-conflicts-view">）。
     </entry>
    </row>
    <row>
     <entry><structfield>temp_files</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of temporary files created by queries in this database.
      All temporary files are counted, regardless of why the temporary file
      was created (e.g., sorting or hashing), and regardless of the
      <xref linkend="guc-log-temp-files"> setting.
     </entry>
     -->
     <entry>在这个数据库中通过查询创建的临时文件的数量。所有临时文件都被统计，
     不管为什么创建这些临时文件（如排序或哈希），并且不管<xref linkend="guc-log-temp-files">设置。
     </entry>
    </row>
    <row>
     <entry><structfield>temp_bytes</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Total amount of data written to temporary files by queries in
      this database. All temporary files are counted, regardless of why
      the temporary file was created, and
      regardless of the <xref linkend="guc-log-temp-files"> setting.
     </entry>
     -->
     <entry>在这个数据库中通过查询写入临时文件中的数据总量。所有临时文件都被统计，
     不管为什么创建这些临时文件（如排序或哈希），并且不管<xref linkend="guc-log-temp-files">设置。
     </entry>
    </row>
    <row>
     <entry><structfield>deadlocks</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of deadlocks detected in this database</entry>
     -->
     <entry>在这个数据库中检测到的死锁数</entry>
    </row>
    <row>
     <entry><structfield>blk_read_time</></entry>
     <entry><type>double precision</></entry>
     <!-- 
     <entry>Time spent reading data file blocks by backends in this database,
      in milliseconds</entry>
      -->
     <entry>在这个数据库中通过后端读取数据文件块花费的时间，以毫秒计算</entry>
    </row>
    <row>
     <entry><structfield>blk_write_time</></entry>
     <entry><type>double precision</></entry>
     <!-- 
     <entry>Time spent writing data file blocks by backends in this database,
      in milliseconds</entry>
      -->
     <entry>在这个数据库中通过后端写入数据文件块花费的时间，以毫秒计算</entry>
    </row>
    <row>
     <entry><structfield>stats_reset</></entry>
     <entry><type>timestamp with time zone</></entry>
     <!-- 
     <entry>Time at which these statistics were last reset</entry>
     -->
     <entry>这些统计信息上次被重置的时间</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <!-- 
  <para>
   The <structname>pg_stat_database</structname> view will contain one row
   for each database in the cluster, showing database-wide statistics.
  </para>
  -->
  <para>
   <structname>pg_stat_database</structname>视图将为集簇中的每一个数据库包含有一行，
   显示数据库范围的统计信息。
  </para>

  <table id="pg-stat-database-conflicts-view" xreflabel="pg_stat_database_conflicts">
   <!-- 
   <title><structname>pg_stat_database_conflicts</structname> View</title>
   -->
   <title><structname>pg_stat_database_conflicts</structname>视图</title>
   <tgroup cols="3">
    <thead>
    <row>
      <!-- 
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
      -->
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>datid</></entry>
     <entry><type>oid</></entry>
     <!-- 
     <entry>OID of a database</entry>
     -->
     <entry>数据库的 OID</entry>
    </row>
    <row>
     <entry><structfield>datname</></entry>
     <entry><type>name</></entry>
     <!-- 
     <entry>Name of this database</entry>
     -->
     <entry>这个数据库的名称</entry>
    </row>
    <row>
     <entry><structfield>confl_tablespace</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of queries in this database that have been canceled due to
      dropped tablespaces</entry>
      -->
     <entry>在这个数据库中由于已删除表空间而被取消的查询数量</entry>
    </row>
    <row>
     <entry><structfield>confl_lock</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of queries in this database that have been canceled due to
      lock timeouts</entry>
      -->
     <entry>在这个数据库中由于锁超时而被取消的查询数量</entry>
    </row>
    <row>
     <entry><structfield>confl_snapshot</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of queries in this database that have been canceled due to
      old snapshots</entry>
      -->
     <entry>在这个数据库中由于老旧快照而被取消的查询数量</entry>
    </row>
    <row>
     <entry><structfield>confl_bufferpin</></entry>
     <entry><type>bigint</></entry>
     <!--
     <entry>Number of queries in this database that have been canceled due to
      pinned buffers</entry>
      -->
     <entry>在这个数据库中由于被占用的缓冲区而被取消的查询数量</entry>
    </row>
    <row>
     <entry><structfield>confl_deadlock</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of queries in this database that have been canceled due to
      deadlocks</entry>
      -->
     <entry>在这个数据库中由于死锁而被取消的查询数量</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <!-- 
  <para>
   The <structname>pg_stat_database_conflicts</structname> view will contain
   one row per database, showing database-wide statistics about
   query cancels occurring due to conflicts with recovery on standby servers.
   This view will only contain information on standby servers, since
   conflicts do not occur on master servers.
  </para>
  -->
  <para>
   <structname>pg_stat_database_conflicts</structname>视图将为每一个数据库包含一行，
   该行显示数据库范围发生的由于与后备服务器上的恢复冲突而取消的查询相关的统计信息。
   这个视图将只包含在后备服务器上的信息，因为在主服务器上不会发生冲突。
  </para>
  
  <table id="pg-stat-all-tables-view" xreflabel="pg_stat_all_tables">
   <!-- 
   <title><structname>pg_stat_all_tables</structname> View</title>
   -->
   <title><structname>pg_stat_all_tables</structname>视图</title>
   <tgroup cols="3">
    <thead>
    <row>
      <!-- 
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
      -->
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>relid</></entry>
     <entry><type>oid</></entry>
     <!-- 
     <entry>OID of a table</entry>
     -->
     <entry>表的 OID</entry>
    </row>
    <row>
     <entry><structfield>schemaname</></entry>
     <entry><type>name</></entry>
     <!-- 
     <entry>Name of the schema that this table is in</entry>
     -->
     <entry>这个表所在的模式的名称</entry>
    </row>
    <row>
     <entry><structfield>relname</></entry>
     <entry><type>name</></entry>
     <!-- 
     <entry>Name of this table</entry>
     -->
     <entry>这个表的名称</entry>
    </row>
    <row>
     <entry><structfield>seq_scan</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of sequential scans initiated on this table</entry>
     -->
     <entry>在这个表上发起的顺序扫描的次数</entry>
    </row>
    <row>
     <entry><structfield>seq_tup_read</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of live rows fetched by sequential scans</entry>
     -->
     <entry>顺序扫描取得的活着的行数</entry>
    </row>
    <row>
     <entry><structfield>idx_scan</></entry>
     <entry><type>bigint</></entry>
     <!--
     <entry>Number of index scans initiated on this table</entry>
     -->
     <entry>在这个表上发起的索引扫描的次数</entry>
    </row>
    <row>
     <entry><structfield>idx_tup_fetch</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of live rows fetched by index scans</entry>
     -->
     <entry>索引扫描取得的活着的行数</entry>
    </row>
    <row>
     <entry><structfield>n_tup_ins</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of rows inserted</entry>
     -->
     <entry>插入的行数</entry>
    </row>
    <row>
     <entry><structfield>n_tup_upd</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of rows updated (includes HOT updated rows)</entry>
     -->
     <entry>更新的行数（包括热更新的行）</entry>
    </row>
    <row>
     <entry><structfield>n_tup_del</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of rows deleted</entry>
     -->
     <entry>删除的行数</entry>
    </row>
    <row>
     <entry><structfield>n_tup_hot_upd</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of rows HOT updated (i.e., with no separate index
      update required)</entry>
      -->
     <entry> HOT 更新的行数（即不要求独立索引更新的行更新）</entry>
    </row>
    <row>
     <entry><structfield>n_live_tup</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Estimated number of live rows</entry>
     -->
     <entry>活着的行的估计数量</entry>
    </row>
    <row>
     <entry><structfield>n_dead_tup</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Estimated number of dead rows</entry>
     -->
     <entry>死亡行的估计数量</entry>
    </row>
    <row>
     <entry><structfield>n_mod_since_analyze</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Estimated number of rows modified since this table was last analyzed</entry>
     -->
     <entry>自从这个表最后被分析后，修改的行数的估计</entry>
    </row>
    <row>
     <entry><structfield>last_vacuum</></entry>
     <entry><type>timestamp with time zone</></entry>
     <!-- 
     <entry>Last time at which this table was manually vacuumed
      (not counting <command>VACUUM FULL</>)</entry>
      -->
     <entry>上次这个表被手动清理的时间（不统计<command>VACUUM FULL</>）</entry>
    </row>
    <row>
     <entry><structfield>last_autovacuum</></entry>
     <entry><type>timestamp with time zone</></entry>
     <!-- 
     <entry>Last time at which this table was vacuumed by the autovacuum
      daemon</entry>
      -->
     <entry>上次这个表被自动清理守护进程清理的时间</entry>
    </row>
    <row>
     <entry><structfield>last_analyze</></entry>
     <entry><type>timestamp with time zone</></entry>
     <!-- 
     <entry>Last time at which this table was manually analyzed</entry>
     -->
     <entry>上次这个表被手动分析的时间</entry>
    </row>
    <row>
     <entry><structfield>last_autoanalyze</></entry>
     <entry><type>timestamp with time zone</></entry>
     <!-- 
     <entry>Last time at which this table was analyzed by the autovacuum
      daemon</entry>
      -->
     <entry>上次这个表被自动清理守护进程分析的时间</entry>
    </row>
    <row>
     <entry><structfield>vacuum_count</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of times this table has been manually vacuumed
      (not counting <command>VACUUM FULL</>)</entry>
      -->
     <entry>这个表被手动清理的次数（不统计<command>VACUUM FULL</>）</entry>
    </row>
    <row>
     <entry><structfield>autovacuum_count</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of times this table has been vacuumed by the autovacuum
      daemon</entry>
      -->
     <entry>这个表被自动清理守护进程清理的次数</entry>
    </row>
    <row>
     <entry><structfield>analyze_count</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of times this table has been manually analyzed</entry>
     -->
     <entry>这个表被手动分析的次数</entry>
    </row>
    <row>
     <entry><structfield>autoanalyze_count</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of times this table has been analyzed by the autovacuum
      daemon</entry>
      -->
     <entry>这个表被自动清理守护进程分析的次数</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <!-- 
  <para>
   The <structname>pg_stat_all_tables</structname> view will contain
   one row for each table in the current database (including TOAST
   tables), showing statistics about accesses to that specific table. The
   <structname>pg_stat_user_tables</structname> and
   <structname>pg_stat_sys_tables</structname> views
   contain the same information,
   but filtered to only show user and system tables respectively.
  </para>
  -->
  <para>
   <structname>pg_stat_all_tables</structname>视图将为当前数据库中的每一个表
   （包括 TOAST 表）包含一行，该行显示与对该表的访问相关的统计信息。
   <structname>pg_stat_user_tables</structname>和<structname>pg_stat_sys_tables</structname>
   视图包含相同的信息，但是被过滤得分别只显示用户和系统表。
  </para>

  <table id="pg-stat-all-indexes-view" xreflabel="pg_stat_all_indexes">
   <!-- 
   <title><structname>pg_stat_all_indexes</structname> View</title>
   -->
   <title><structname>pg_stat_all_indexes</structname>视图</title>
   <tgroup cols="3">
    <thead>
    <row>
      <!-- 
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
      -->
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>relid</></entry>
     <entry><type>oid</></entry>
     <!-- 
     <entry>OID of the table for this index</entry>
     -->
     <entry>这个索引的基表的 OID</entry>
    </row>
    <row>
     <entry><structfield>indexrelid</></entry>
     <entry><type>oid</></entry>
     <!-- 
     <entry>OID of this index</entry>
     -->
     <entry>这个索引的 OID</entry>
    </row>
    <row>
     <entry><structfield>schemaname</></entry>
     <entry><type>name</></entry>
     <!-- 
     <entry>Name of the schema this index is in</entry>
     -->
     <entry>这个索引所在的模式的名称</entry>
    </row>
    <row>
     <entry><structfield>relname</></entry>
     <entry><type>name</></entry>
     <!-- 
     <entry>Name of the table for this index</entry>
     -->
     <entry>这个索引的基表的名称</entry>
    </row>
    <row>
     <entry><structfield>indexrelname</></entry>
     <entry><type>name</></entry>
     <!-- 
     <entry>Name of this index</entry>
     -->
     <entry>这个索引的名称</entry>
    </row>
    <row>
     <entry><structfield>idx_scan</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of index scans initiated on this index</entry>
     -->
     <entry>在这个索引上发起的索引扫描次数</entry>
    </row>
    <row>
     <entry><structfield>idx_tup_read</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of index entries returned by scans on this index</entry>
     -->
     <entry>在这个索引上由扫描返回的索引项数量</entry>
    </row>
    <row>
     <entry><structfield>idx_tup_fetch</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of live table rows fetched by simple index scans using this
      index</entry>
      -->
     <entry>被使用这个索引的简单索引扫描取得的活着的表行数量</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <!-- 
  <para>
   The <structname>pg_stat_all_indexes</structname> view will contain
   one row for each index in the current database,
   showing statistics about accesses to that specific index. The
   <structname>pg_stat_user_indexes</structname> and
   <structname>pg_stat_sys_indexes</structname> views
   contain the same information,
   but filtered to only show user and system indexes respectively.
  </para>
  -->
  <para>
   <structname>pg_stat_all_indexes</structname>视图将为当前数据库中的每个索引包含一行，
   该行显示关于对该索引访问的统计信息。<structname>pg_stat_user_indexes</structname>和
   <structname>pg_stat_sys_indexes</structname>视图包含相同的信息，
   但是被过滤得只分别显示用户和系统索引。
  </para>

  <!-- 
  <para>
   Indexes can be used by simple index scans, <quote>bitmap</> index scans,
   and the optimizer.  In a bitmap scan
   the output of several indexes can be combined via AND or OR rules,
   so it is difficult to associate individual heap row fetches
   with specific indexes when a bitmap scan is used.  Therefore, a bitmap
   scan increments the
   <structname>pg_stat_all_indexes</>.<structfield>idx_tup_read</>
   count(s) for the index(es) it uses, and it increments the
   <structname>pg_stat_all_tables</>.<structfield>idx_tup_fetch</>
   count for the table, but it does not affect
   <structname>pg_stat_all_indexes</>.<structfield>idx_tup_fetch</>.
   The optimizer also accesses indexes to check for supplied constants
   whose values are outside the recorded range of the optimizer statistics
   because the optimizer statistics might be stale.
  </para>
  -->
  <para>
   索引可以通过简单索引扫描、<quote>位图</>索引扫描和优化器使用。在一次位图扫描中，
   多个索引的输出可以被通过 AND 或 OR 规则组合，
   因此当使用一次位图扫描时难以将取得的个体堆行与特定的索引关联起来。因此，
   一次位图扫描会增加它使用的索引的<structname>pg_stat_all_indexes</>.<structfield>idx_tup_read</>
   计数，并且为每个表增加<structname>pg_stat_all_tables</>.<structfield>idx_tup_fetch</>计数，
   但是它不影响<structname>pg_stat_all_indexes</>.<structfield>idx_tup_fetch</>。
   优化器还访问索引以检查其值超出优化器统计信息的记录范围的提供的常量，
   因为优化器统计信息可能已过时。
  </para>

  <note>
   <!-- 
   <para>
    The <structfield>idx_tup_read</> and <structfield>idx_tup_fetch</> counts
    can be different even without any use of bitmap scans,
    because <structfield>idx_tup_read</> counts
    index entries retrieved from the index while <structfield>idx_tup_fetch</>
    counts live rows fetched from the table.  The latter will be less if any
    dead or not-yet-committed rows are fetched using the index, or if any
    heap fetches are avoided by means of an index-only scan.
   </para>
   -->
   <para>
    即使不用位图扫描，<structfield>idx_tup_read</>和<structfield>idx_tup_fetch</>
    计数也可能不同，因为<structfield>idx_tup_read</>统计从该索引取得的索引项而
    <structfield>idx_tup_fetch</>统计从表取得的活的行。
    如果使用该索引取得了任何死亡行或还未提交的行，
    或者如果通过一次只用索引扫描的方式避免了任何堆获取，后者将较小。
   </para>
  </note>

  <table id="pg-statio-all-tables-view" xreflabel="pg_statio_all_tables">
   <!-- 
   <title><structname>pg_statio_all_tables</structname> View</title>
   -->
   <title><structname>pg_statio_all_tables</structname>视图</title>
   <tgroup cols="3">
    <thead>
    <row>
      <!-- 
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
      -->
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>relid</></entry>
     <entry><type>oid</></entry>
     <!-- 
     <entry>OID of a table</entry>
     -->
     <entry>一个表的 OID</entry>
    </row>
    <row>
     <entry><structfield>schemaname</></entry>
     <entry><type>name</></entry>
     <!-- 
     <entry>Name of the schema that this table is in</entry>
     -->
     <entry>这个表所在的模式的名称</entry>
    </row>
    <row>
     <entry><structfield>relname</></entry>
     <entry><type>name</></entry>
     <!-- 
     <entry>Name of this table</entry>
     -->
     <entry>这个表的名称</entry>
    </row>
    <row>
     <entry><structfield>heap_blks_read</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of disk blocks read from this table</entry>
     -->
     <entry>从这个表读取的磁盘块数量</entry>
    </row>
    <row>
     <entry><structfield>heap_blks_hit</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of buffer hits in this table</entry>
     -->
     <entry>在这个表中的缓冲区命中数量</entry>
    </row>
    <row>
     <entry><structfield>idx_blks_read</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of disk blocks read from all indexes on this table</entry>
     -->
     <entry>从这个表上所有索引中读取的磁盘块数</entry>
    </row>
    <row>
     <entry><structfield>idx_blks_hit</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of buffer hits in all indexes on this table</entry>
     -->
     <entry>在这个表上的所有索引中的缓冲区命中数量</entry>
    </row>
    <row>
     <entry><structfield>toast_blks_read</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of disk blocks read from this table's TOAST table (if any)</entry>
     -->
     <entry>从这个表的 TOAST 表（如果有）读取的磁盘块数</entry>
    </row>
    <row>
     <entry><structfield>toast_blks_hit</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of buffer hits in this table's TOAST table (if any)</entry>
     -->
     <entry>在这个表的 TOAST 表（如果有）中的缓冲区命中数量</entry>
    </row>
    <row>
     <entry><structfield>tidx_blks_read</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of disk blocks read from this table's TOAST table indexes (if any)</entry>
     -->
     <entry>从这个表的 TOAST 表索引（如果有）中读取的磁盘块数</entry>
    </row>
    <row>
     <entry><structfield>tidx_blks_hit</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of buffer hits in this table's TOAST table indexes (if any)</entry>
     -->
     <entry>在这个表的 TOAST 表索引（如果有）中的缓冲区命中数量</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <!-- 
  <para>
   The <structname>pg_statio_all_tables</structname> view will contain
   one row for each table in the current database (including TOAST
   tables), showing statistics about I/O on that specific table. The
   <structname>pg_statio_user_tables</structname> and
   <structname>pg_statio_sys_tables</structname> views
   contain the same information,
   but filtered to only show user and system tables respectively.
  </para>
  -->
  <para>
   <structname>pg_statio_all_tables</structname>视图将为当前数据库中的每个表
   （包括 TOAST 表）包含一行，该行显示指定表上有关 I/O 的统计信息。
   <structname>pg_statio_user_tables</structname>和
   <structname>pg_statio_sys_tables</structname>视图包含相同的信息，
   但是被过滤得分别只显示用户表和系统表。
  </para>

  <table id="pg-statio-all-indexes-view" xreflabel="pg_statio_all_indexes">
   <!-- 
   <title><structname>pg_statio_all_indexes</structname> View</title>
   -->
   <title><structname>pg_statio_all_indexes</structname>视图</title>
   <tgroup cols="3">
    <thead>
    <row>
      <!-- 
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
      -->
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>relid</></entry>
     <entry><type>oid</></entry>
     <!-- 
     <entry>OID of the table for this index</entry>
     -->
     <entry>这个索引的基表的 OID</entry>
    </row>
    <row>
     <entry><structfield>indexrelid</></entry>
     <entry><type>oid</></entry>
     <!-- 
     <entry>OID of this index</entry>
     -->
     <entry>这个索引的 OID</entry>
    </row>
    <row>
     <entry><structfield>schemaname</></entry>
     <entry><type>name</></entry>
     <!-- 
     <entry>Name of the schema this index is in</entry>
     -->
     <entry>这个索引所在的模式的名称</entry>
    </row>
    <row>
     <entry><structfield>relname</></entry>
     <entry><type>name</></entry>
     <!-- 
     <entry>Name of the table for this index</entry>
     -->
     <entry>这个索引的基表的名称</entry>
    </row>
    <row>
     <entry><structfield>indexrelname</></entry>
     <entry><type>name</></entry>
     <!-- 
     <entry>Name of this index</entry>
     -->
     <entry>这个索引的名称</entry>
    </row>
    <row>
     <entry><structfield>idx_blks_read</></entry>
     <entry><type>bigint</></entry>
     <!--
     <entry>Number of disk blocks read from this index</entry>
     -->
     <entry>从这个索引读取的磁盘块数</entry>
    </row>
    <row>
     <entry><structfield>idx_blks_hit</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of buffer hits in this index</entry>
     -->
     <entry>在这个索引中的缓冲区命中数量</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <!-- 
  <para>
   The <structname>pg_statio_all_indexes</structname> view will contain
   one row for each index in the current database,
   showing statistics about I/O on that specific index. The
   <structname>pg_statio_user_indexes</structname> and
   <structname>pg_statio_sys_indexes</structname> views
   contain the same information,
   but filtered to only show user and system indexes respectively.
  </para>
  -->
  <para>
   <structname>pg_statio_all_indexes</structname>视图将为当前数据库中的每个索引包含一行，
   该行显示指定索引上有关 I/O 的统计信息。<structname>pg_statio_user_indexes</structname>
   和<structname>pg_statio_sys_indexes</structname>视图包含相同的信息，
   但是被过滤得分别只显示用户索引和系统索引。
  </para>

  <table id="pg-statio-all-sequences-view" xreflabel="pg_statio_all_sequences">
   <!-- 
   <title><structname>pg_statio_all_sequences</structname> View</title>
   -->
   <title><structname>pg_statio_all_sequences</structname>视图</title>
   <tgroup cols="3">
    <thead>
    <row>
      <!-- 
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
      -->
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>relid</></entry>
     <entry><type>oid</></entry>
     <!-- 
     <entry>OID of a sequence</entry>
     -->
     <entry>一个序列的 OID</entry>
    </row>
    <row>
     <entry><structfield>schemaname</></entry>
     <entry><type>name</></entry>
     <!-- 
     <entry>Name of the schema this sequence is in</entry>
     -->
     <entry>这个序列所在的模式的名称</entry>
    </row>
    <row>
     <entry><structfield>relname</></entry>
     <entry><type>name</></entry>
     <!-- 
     <entry>Name of this sequence</entry>
     -->
     <entry>这个序列的名称</entry>
    </row>
    <row>
     <entry><structfield>blks_read</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of disk blocks read from this sequence</entry>
     -->
     <entry>从这个序列中读取的磁盘块数</entry>
    </row>
    <row>
     <entry><structfield>blks_hit</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of buffer hits in this sequence</entry>
     -->
     <entry>在这个序列中的缓冲区命中数量</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <!-- 
  <para>
   The <structname>pg_statio_all_sequences</structname> view will contain
   one row for each sequence in the current database,
   showing statistics about I/O on that specific sequence.
  </para>
  -->
  <para>
   <structname>pg_statio_all_sequences</structname>视图将为当前数据库中的每个序列包含一行，
   该行显示在指定序列上有关 I/O 的统计信息。
  </para>

  <table id="pg-stat-user-functions-view" xreflabel="pg_stat_user_functions">
   <!-- 
   <title><structname>pg_stat_user_functions</structname> View</title>
   -->
   <title><structname>pg_stat_user_functions</structname>视图</title>
   <tgroup cols="3">
    <thead>
    <row>
      <!-- 
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
      -->
      <entry>列</entry>
      <entry>类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>funcid</></entry>
     <entry><type>oid</></entry>
     <!-- 
     <entry>OID of a function</entry>
     -->
     <entry>一个函数的 OID</entry>
    </row>
    <row>
     <entry><structfield>schemaname</></entry>
     <entry><type>name</></entry>
     <!-- 
     <entry>Name of the schema this function is in</entry>
     -->
     <entry>这个函数所在的模式的名称</entry>
    </row>
    <row>
     <entry><structfield>funcname</></entry>
     <entry><type>name</></entry>
     <!-- 
     <entry>Name of this function</entry>
     -->
     <entry>这个函数的名称</entry>
    </row>
    <row>
     <entry><structfield>calls</></entry>
     <entry><type>bigint</></entry>
     <!-- 
     <entry>Number of times this function has been called</entry>
     -->
     <entry>这个函数已经被调用的次数</entry>
    </row>
    <row>
     <entry><structfield>total_time</></entry>
     <entry><type>double precision</></entry>
     <!-- 
     <entry>Total time spent in this function and all other functions
     called by it, in milliseconds</entry>
     -->
     <entry>在这个函数以及它所调用的其他函数中花费的总时间，以毫秒计</entry>
    </row>
    <row>
     <entry><structfield>self_time</></entry>
     <entry><type>double precision</></entry>
     <!-- 
     <entry>Total time spent in this function itself, not including
     other functions called by it, in milliseconds</entry>
     -->
     <entry>在这个函数本身花费的总时间，不包括它调用的其他函数，以毫秒计</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <!-- 
  <para>
   The <structname>pg_stat_user_functions</structname> view will contain
   one row for each tracked function, showing statistics about executions of
   that function.  The <xref linkend="guc-track-functions"> parameter
   controls exactly which functions are tracked.
  </para>
  -->
  <para>
   <structname>pg_stat_user_functions</structname>视图将为每一个被追踪的函数包含一行，
   该行显示有关该函数执行的统计信息。<xref linkend="guc-track-functions">
   参数控制到底跟踪哪些函数。
  </para>

 </sect2>

 <sect2 id="monitoring-stats-functions">
  <!-- 
  <title>Statistics Functions</title>
  -->
  <title>统计函数</title>

  <!-- 
  <para>
   Other ways of looking at the statistics can be set up by writing
   queries that use the same underlying statistics access functions used by
   the standard views shown above.  For details such as the functions' names,
   consult the definitions of the standard views.  (For example, in
   <application>psql</> you could issue <literal>\d+ pg_stat_activity</>.)
   The access functions for per-database statistics take a database OID as an
   argument to identify which database to report on.
   The per-table and per-index functions take a table or index OID.
   The functions for per-function statistics take a function OID.
   Note that only tables, indexes, and functions in the current database
   can be seen with these functions.
  </para>
  -->
  <para>
   其他查看统计信息的方法是直接使用查询，这些查询使用上述标准视图用到的底层统计信息访问函数。
   如要了解如函数名等细节，可参考标准视图的定义（例如，在<application>psql</>中你可以发出
   <literal>\d+ pg_stat_activity</>）。针对每一个数据库统计信息的访问函数把一个数据库 OID 
   作为参数来标识要报告哪个数据库。而针对每个表和每个索引的函数要求表或索引 OID。
   针对每个函数统计信息的函数用一个函数 OID。注意只有在当前数据库中的表、
   索引和函数才能被这些函数看到。
  </para>

  <!-- 
  <para>
   Additional functions related to statistics collection are listed in <xref
   linkend="monitoring-stats-funcs-table">.
  </para>
  -->
  <para>
   与统计收集相关的额外函数被列举在<xref linkend="monitoring-stats-funcs-table">中。
  </para>

  <table id="monitoring-stats-funcs-table">
   <!-- 
   <title>Additional Statistics Functions</title>
   -->
   <title>额外统计函数</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
      <entry>Function</entry>
      <entry>Return Type</entry>
      <entry>Description</entry>
      -->
      <entry>函数</entry>
      <entry>返回类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>

     <row>
       <!-- See also the entry for this in func.sgml -->
      <entry><literal><function>pg_backend_pid()</function></literal></entry>
      <entry><type>integer</type></entry>
      <!-- 
      <entry>
       Process ID of the server process handling the current session
      </entry>
      -->
      <entry>
       处理当前会话的服务器进程的进程 ID
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_activity</function>(<type>integer</type>)</literal><indexterm><primary>pg_stat_get_activity</primary></indexterm></entry>
      <entry><type>setof record</type></entry>
      <!-- 
      <entry>
       Returns a record of information about the backend with the specified PID, or
       one record for each active backend in the system if <symbol>NULL</symbol> is
       specified. The fields returned are a subset of those in the
       <structname>pg_stat_activity</structname> view.
      </entry>
      -->
      <entry>
       返回具有指定 PID 的后端相关的一个信息记录，或者在指定<symbol>NULL</symbol>
       的情况下为系统中每一个活动后端返回一个记录。被返回的域是
       <structname>pg_stat_activity</structname>视图中的那些域的一个子集。
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_snapshot_timestamp()</function></literal><indexterm><primary>pg_stat_get_snapshot_timestamp</primary></indexterm></entry>
      <entry><type>timestamp with time zone</type></entry>
      <!-- 
      <entry>
       Returns the timestamp of the current statistics snapshot
      </entry>
      -->
      <entry>
       返回当前统计快照的时间戳
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_clear_snapshot()</function></literal><indexterm><primary>pg_stat_clear_snapshot</primary></indexterm></entry>
      <entry><type>void</type></entry>
      <!-- 
      <entry>
       Discard the current statistics snapshot
      </entry>
      -->
      <entry>
       抛弃当前的统计快照
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_reset()</function></literal><indexterm><primary>pg_stat_reset</primary></indexterm></entry>
      <entry><type>void</type></entry>
      <!-- 
      <entry>
       Reset all statistics counters for the current database to zero
       (requires superuser privileges)
      </entry>
      -->
      <entry>
       把用于当前数据库的所有统计计数器重置为零（要求超级用户权限）
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_reset_shared</function>(text)</literal><indexterm><primary>pg_stat_reset_shared</primary></indexterm></entry>
      <entry><type>void</type></entry>
      <!-- 
      <entry>
       Reset some cluster-wide statistics counters to zero, depending on the
       argument (requires superuser privileges).
       Calling <literal>pg_stat_reset_shared('bgwriter')</> will zero all the
       counters shown in the <structname>pg_stat_bgwriter</> view.
       Calling <literal>pg_stat_reset_shared('archiver')</> will zero all the
       counters shown in the <structname>pg_stat_archiver</> view.
      </entry>
      -->
      <entry>
       把某些集簇范围的统计计数器重置为零，具体哪些取决于参数（要求超级用户权限）。
       调用<literal>pg_stat_reset_shared('bgwriter')</>把<structname>pg_stat_bgwriter</>
       视图中显示的所有计数器清零。调用<literal>pg_stat_reset_shared('archiver')</>
       将会把<structname>pg_stat_archiver</>视图中展示的所有计数器清零。
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_reset_single_table_counters</function>(oid)</literal><indexterm><primary>pg_stat_reset_single_table_counters</primary></indexterm></entry>
      <entry><type>void</type></entry>
      <!-- 
      <entry>
       Reset statistics for a single table or index in the current database to
       zero (requires superuser privileges)
      </entry>
      -->
      <entry>
       把当前数据库中用于单个表或索引的统计数据重置为零（要求超级用户权限）
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_reset_single_function_counters</function>(oid)</literal><indexterm><primary>pg_stat_reset_single_function_counters</primary></indexterm></entry>
      <entry><type>void</type></entry>
      <!-- 
      <entry>
       Reset statistics for a single function in the current database to
       zero (requires superuser privileges)
      </entry>
      -->
      <entry>
       把当前数据库中用于单个函数的统计信息重置为零（要求超级用户权限）
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   <!-- 
   <function>pg_stat_get_activity</function>, the underlying function of
   the <structname>pg_stat_activity</> view, returns a set of records
   containing all the available information about each backend process.
   Sometimes it may be more convenient to obtain just a subset of this
   information.  In such cases, an older set of per-backend statistics
   access functions can be used; these are shown in <xref
   linkend="monitoring-stats-backend-funcs-table">.
   These access functions use a backend ID number, which ranges from one
   to the number of currently active backends.
   The function <function>pg_stat_get_backend_idset</function> provides a
   convenient way to generate one row for each active backend for
   invoking these functions.  For example, to show the <acronym>PID</>s and
   current queries of all backends:
   -->
   <function>pg_stat_get_activity</function>是<structname>pg_stat_activity</>视图的底层函数，
   它返回一个行集合，其中包含有关每个后端进程所有可用的信息。
   有时只获得该信息的一个子集可能会更方便。在那些情况中，
   可以使用一组更老的针对每个后端的统计访问函数，这些显示在
   <xref linkend="monitoring-stats-backend-funcs-table">中。这些访问函数使用一个后端 ID 号，
   范围从 1 到当前活动后端数目。函数<function>pg_stat_get_backend_idset</function>
   提供了一种方便的方法为每个活动后端产生一行来调用这些函数。例如，要显示
   <acronym>PID</>以及所有后端当前的查询：

<programlisting>
SELECT pg_stat_get_backend_pid(s.backendid) AS pid,
       pg_stat_get_backend_activity(s.backendid) AS query
    FROM (SELECT pg_stat_get_backend_idset() AS backendid) AS s;
</programlisting>
  </para>

  <table id="monitoring-stats-backend-funcs-table">
   <!-- 
   <title>Per-Backend Statistics Functions</title>
   -->
   <title>针对每个后端的统计函数</title>

   <tgroup cols="3">
    <thead>
     <row>
      <!-- 
      <entry>Function</entry>
      <entry>Return Type</entry>
      <entry>Description</entry>
      -->
      <entry>函数</entry>
      <entry>返回类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry><literal><function>pg_stat_get_backend_idset()</function></literal></entry>
      <entry><type>setof integer</type></entry>
      <!-- 
      <entry>Set of currently active backend ID numbers (from 1 to the
       number of active backends)</entry>
       -->
      <entry>当前活动后端 ID 号的集合（从 1 到活动后端数目）</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_activity(integer)</function></literal></entry>
      <entry><type>text</type></entry>
      <!--
      <entry>Text of this backend's most recent query</>
      -->
      <entry>这个后端最近查询的文本</>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_activity_start(integer)</function></literal></entry>
      <entry><type>timestamp with time zone</type></entry>
      <!-- 
      <entry>Time when the most recent query was started</entry>
      -->
      <entry>最近查询被开始的时间</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_client_addr(integer)</function></literal></entry>
      <entry><type>inet</type></entry>
      <!-- 
      <entry>IP address of the client connected to this backend</entry>
      -->
      <entry>连接到这个后端的客户端 IP 地址</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_client_port(integer)</function></literal></entry>
      <entry><type>integer</type></entry>
      <!-- 
      <entry>TCP port number that the client is using for communication</entry>
      -->
      <entry>该客户端用来通信的 TCP 端口号</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_dbid(integer)</function></literal></entry>
      <entry><type>oid</type></entry>
      <!-- 
      <entry>OID of the database this backend is connected to</entry>
      -->
      <entry>这个后端连接到的数据库的 OID</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_pid(integer)</function></literal></entry>
      <entry><type>integer</type></entry>
      <!-- 
      <entry>Process ID of this backend</entry>
      -->
      <entry>这个后端的进程 ID</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_start(integer)</function></literal></entry>
      <entry><type>timestamp with time zone</type></entry>
      <!-- 
      <entry>Time when this process was started</entry>
      -->
      <entry>这个进程开始的时间</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_userid(integer)</function></literal></entry>
      <entry><type>oid</type></entry>
      <!-- 
      <entry>OID of the user logged into this backend</entry>
      -->
      <entry>登录到这个后端的用户的 OID</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_waiting(integer)</function></literal></entry>
      <entry><type>boolean</type></entry>
      <!-- 
      <entry>True if this backend is currently waiting on a lock</entry>
      -->
      <entry>如果这个后端当前正在等待一个锁，则为真</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_xact_start(integer)</function></literal></entry>
      <entry><type>timestamp with time zone</type></entry>
      <!-- 
      <entry>Time when the current transaction was started</entry>
      -->
      <entry>当前事务开始的时间</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect2>
 </sect1>

 <sect1 id="monitoring-locks">
  <!-- 
  <title>Viewing Locks</title>
  -->
  <title>查看锁</title>

  <indexterm zone="monitoring-locks">
   <primary>lock</primary>
   <secondary>monitoring</secondary>
  </indexterm>

  <para>
   <!-- 
   Another useful tool for monitoring database activity is the
   <structname>pg_locks</structname> system table.  It allows the
   database administrator to view information about the outstanding
   locks in the lock manager. For example, this capability can be used
   to:
   -->
   监控数据库活动的另外一个有用的工具是<structname>pg_locks</structname>系统表。
   这样就允许数据库管理员查看在锁管理器里面未解决的锁的信息。例如，这个功能可以用于：

   <itemizedlist>
    <listitem>
     <!-- 
     <para>
      View all the locks currently outstanding, all the locks on
      relations in a particular database, all the locks on a
      particular relation, or all the locks held by a particular
      <productname>PostgreSQL</productname> session.
     </para>
     -->
     <para>
      查看当前所有未解决的锁、在一个特定数据库中的关系上所有的锁、在一个特定关系上的所有锁，
      或者由一个特定<productname>PostgreSQL</productname>会话持有的所有锁。
     </para>
    </listitem>

    <listitem>
     <!-- 
     <para>
      Determine the relation in the current database with the most
      ungranted locks (which might be a source of contention among
      database clients).
     </para>
     -->
     <para>
      判断当前数据库中带有最多未授予锁的关系（它很可能是数据库客户端的竞争源）。
     </para>
    </listitem>

    <listitem>
     <!-- 
     <para>
      Determine the effect of lock contention on overall database
      performance, as well as the extent to which contention varies
      with overall database traffic.
     </para>
     -->
     <para>
      判断锁竞争给数据库总体性能带来的影响，以及锁竞争随着整个数据库流量的变化范围。
     </para>
    </listitem>
   </itemizedlist>

   <!-- 
   Details of the <structname>pg_locks</structname> view appear in
   <xref linkend="view-pg-locks">.
   For more information on locking and managing concurrency with
   <productname>PostgreSQL</productname>, refer to <xref linkend="mvcc">.
   -->
   <structname>pg_locks</structname>视图的细节在<xref linkend="view-pg-locks">中。
   更多有关<productname>PostgreSQL</productname>的锁和管理并发性的信息，请参考<xref linkend="mvcc">。
  </para>
 </sect1>

 <sect1 id="dynamic-trace">
  <!-- 
  <title>Dynamic Tracing</title>
  -->
  <title>动态追踪</title>

 <indexterm zone="dynamic-trace">
  <primary>DTrace</primary>
 </indexterm>

  <!-- 
  <para>
   <productname>PostgreSQL</productname> provides facilities to support
   dynamic tracing of the database server. This allows an external
   utility to be called at specific points in the code and thereby trace
   execution.
  </para>
  -->
  <para>
   <productname>PostgreSQL</productname>提供了工具来支持数据库服务器的动态追踪。
   这样就允许在代码中的特定点上调用外部工具来追踪执行过程。
  </para>

  <!-- 
  <para>
   A number of probes or trace points are already inserted into the source
   code. These probes are intended to be used by database developers and
   administrators. By default the probes are not compiled into
   <productname>PostgreSQL</productname>; the user needs to explicitly tell
   the configure script to make the probes available.
  </para>
  -->
  <para>
   一些探针或追踪点已经被插入在源代码中。这些探针的目的是被数据库开发者和管理员使用。
   默认情况下，探针不被编译到<productname>PostgreSQL</productname>中；
   用户需要明确告诉配置脚本使得探针可用。
  </para>

  <!-- 
  <para>
   Currently, the
   <ulink url="https://en.wikipedia.org/wiki/DTrace">DTrace</ulink>
   utility is supported, which, at the time of this writing, is available
   on Solaris, OS X, FreeBSD, NetBSD, and Oracle Linux.  The
   <ulink url="http://sourceware.org/systemtap/">SystemTap</ulink> project
   for Linux provides a DTrace equivalent and can also be used.  Supporting other dynamic
   tracing utilities is theoretically possible by changing the definitions for
   the macros in <filename>src/include/utils/probes.h</>.
  </para>
  -->
  <para>
   目前，在写本文当时<ulink url="https://en.wikipedia.org/wiki/DTrace">DTrace</ulink>已被支持，
   它在 Solaris、OS X、FreeBSD、NetBSD 和 Oracle Linux 上可用。Linux 的
   <ulink url="http://sourceware.org/systemtap/">SystemTap</ulink>
   项目提供了一种可用的 DTrace 等价物。支持其他动态追踪工具在理论上可以通过改变
   <filename>src/include/utils/probes.h</>中的宏定义实现。
  </para>

  <sect2 id="compiling-for-trace">
   <!-- 
   <title>Compiling for Dynamic Tracing</title>
   -->
   <title>动态追踪的编译</title>

  <!-- 
  <para>
   By default, probes are not available, so you will need to
   explicitly tell the configure script to make the probes available
   in <productname>PostgreSQL</productname>. To include DTrace support
   specify <option>&minus;-enable-dtrace</> to configure.  See <xref
   linkend="install-procedure"> for further information.
  </para>
  -->
  <para>
   默认情况下，探针是不可用的，因此你将需要明确告诉配置脚本让探针在
   <productname>PostgreSQL</productname>中可用。要包括 DTrace 支持，
   在配置时指定<option>--enable-dtrace</>。更多信息请见<xref linkend="install-procedure">。
  </para>
  </sect2>

  <sect2 id="trace-points">
   <!-- 
   <title>Built-in Probes</title>
   -->
   <title>内建探针</title>

  <!-- 
  <para>
   A number of standard probes are provided in the source code,
   as shown in <xref linkend="dtrace-probe-point-table">;
   <xref linkend="typedefs-table">
   shows the types used in the probes.  More probes can certainly be
   added to enhance <productname>PostgreSQL</>'s observability.
  </para>
  -->
  <para>
   如<xref linkend="dtrace-probe-point-table">所示，源代码中提供了一些标准探针。
   <xref linkend="typedefs-table">显式了在探针中使用的类型。当然，
   可以增加更多探针来增强<productname>PostgreSQL</>的可观测性。
  </para>

 <table id="dtrace-probe-point-table">
  <!-- 
  <title>Built-in DTrace Probes</title>
  -->
  <title>内建 DTrace 探针</title>
  <tgroup cols="3">
   <thead>
    <row>
     <!-- 
     <entry>Name</entry>
     <entry>Parameters</entry>
     <entry>Description</entry>
     -->
     <entry>名称</entry>
     <entry>参数</entry>
     <entry>描述</entry>
    </row>
   </thead>

   <tbody>

    <row>
     <entry>transaction-start</entry>
     <entry>(LocalTransactionId)</entry>
     <!-- 
     <entry>Probe that fires at the start of a new transaction.
      arg0 is the transaction ID.</entry>
      -->
     <entry>在一个新事务开始时触发的探针。arg0 是事务 ID。</entry>
    </row>
    <row>
     <entry>transaction-commit</entry>
     <entry>(LocalTransactionId)</entry>
     <!-- 
     <entry>Probe that fires when a transaction completes successfully.
      arg0 is the transaction ID.</entry>
      -->
     <entry>在一个事务成功完成时触发的探针。arg0 是事务 ID。</entry>
    </row>
    <row>
     <entry>transaction-abort</entry>
     <entry>(LocalTransactionId)</entry>
     <!-- 
     <entry>Probe that fires when a transaction completes unsuccessfully.
      arg0 is the transaction ID.</entry>
      -->
     <entry>当一个事务失败完成时触发的探针。arg0 是事务 ID。</entry>
    </row>
    <row>
     <entry>query-start</entry>
     <entry>(const char *)</entry>
     <!-- 
     <entry>Probe that fires when the processing of a query is started.
      arg0 is the query string.</entry>
      -->
     <entry>当开始一个查询的处理时触发的探针。arg0 是查询字符串。</entry>
    </row>
    <row>
     <entry>query-done</entry>
     <entry>(const char *)</entry>
     <!-- 
     <entry>Probe that fires when the processing of a query is complete.
      arg0 is the query string.</entry>
      -->
     <entry>当一个查询的处理完成时触发的探针。arg0 是查询字符串。</entry>
    </row>
    <row>
     <entry>query-parse-start</entry>
     <entry>(const char *)</entry>
     <!--
     <entry>Probe that fires when the parsing of a query is started.
      arg0 is the query string.</entry>
      -->
     <entry>当开始一个查询的解析时触发的探针。arg0 是查询字符串。</entry>
    </row>
    <row>
     <entry>query-parse-done</entry>
     <entry>(const char *)</entry>
     <!-- 
     <entry>Probe that fires when the parsing of a query is complete.
      arg0 is the query string.</entry>
      -->
     <entry>当完成一个查询的解析触发的探针。arg0 是查询字符串。</entry>
    </row>
    <row>
     <entry>query-rewrite-start</entry>
     <entry>(const char *)</entry>
     <!-- 
     <entry>Probe that fires when the rewriting of a query is started.
      arg0 is the query string.</entry>
      -->
     <entry>当开始一个查询的重写时触发的探针。arg0 是查询字符串。</entry>
    </row>
    <row>
     <entry>query-rewrite-done</entry>
     <entry>(const char *)</entry>
     <!-- 
     <entry>Probe that fires when the rewriting of a query is complete.
      arg0 is the query string.</entry>
      -->
     <entry>当完成一个查询的重写时触发的探针。arg0 是查询字符串。</entry>
    </row>
    <row>
     <entry>query-plan-start</entry>
     <entry>()</entry>
     <!-- 
     <entry>Probe that fires when the planning of a query is started.</entry>
     -->
     <entry>当开始一个查询的规划时触发的探针。</entry>
    </row>
    <row>
     <entry>query-plan-done</entry>
     <entry>()</entry>
     <!-- 
     <entry>Probe that fires when the planning of a query is complete.</entry>
     -->
     <entry>当一个查询的规划完成时触发的探针。</entry>
    </row>
    <row>
     <entry>query-execute-start</entry>
     <entry>()</entry>
     <!-- 
     <entry>Probe that fires when the execution of a query is started.</entry>
     -->
     <entry>当一个查询的执行开始时触发的探针。</entry>
    </row>
    <row>
     <entry>query-execute-done</entry>
     <entry>()</entry>
     <!-- 
     <entry>Probe that fires when the execution of a query is complete.</entry>
     -->
     <entry>当一个查询的执行完成时触发的探针。</entry>
    </row>
    <row>
     <entry>statement-status</entry>
     <entry>(const char *)</entry>
     <!-- 
     <entry>Probe that fires anytime the server process updates its
      <structname>pg_stat_activity</>.<structfield>status</>.
      arg0 is the new status string.</entry>
      -->
     <entry>任何时候当服务器进程更新它的<structname>pg_stat_activity</>.<structfield>status</>
     时触发的探针。arg0 是新的状态字符串。</entry>
    </row>
    <row>
     <entry>checkpoint-start</entry>
     <entry>(int)</entry>
     <!-- 
     <entry>Probe that fires when a checkpoint is started.
      arg0 holds the bitwise flags used to distinguish different checkpoint
      types, such as shutdown, immediate or force.</entry>
      -->
     <entry>当一个检查点开始时触发的探针。arg0 保持逐位标志来区分不同的检查点类型，
     例如关闭（shutdown）、立即（immediate）或强制（force）。</entry>
    </row>
    <row>
     <entry>checkpoint-done</entry>
     <entry>(int, int, int, int, int)</entry>
     <!-- 
     <entry>Probe that fires when a checkpoint is complete.
      (The probes listed next fire in sequence during checkpoint processing.)
      arg0 is the number of buffers written. arg1 is the total number of
      buffers. arg2, arg3 and arg4 contain the number of xlog file(s) added,
      removed and recycled respectively.</entry>
      -->
     <entry>当一个检查点完成时触发的探针（检查点处理过程中序列中列出的下一个触发的探针）。
     arg0 是要写的缓冲区数量。arg1 是缓冲区的总数。arg2、arg3 和 arg4 分别包含了增加、
     删除和循环回收的 xlog 文件的数量。</entry>
    </row>
    <row>
     <entry>clog-checkpoint-start</entry>
     <entry>(bool)</entry>
     <!-- 
     <entry>Probe that fires when the CLOG portion of a checkpoint is started.
      arg0 is true for normal checkpoint, false for shutdown
      checkpoint.</entry>
      -->
     <entry>当一个检查点的 CLOG 部分开始时触发的探针。arg0 为真表示正常检查点，
     为假表示关闭检查点。</entry>
    </row>
    <row>
     <entry>clog-checkpoint-done</entry>
     <entry>(bool)</entry>
     <!-- 
     <entry>Probe that fires when the CLOG portion of a checkpoint is
      complete. arg0 has the same meaning as for clog-checkpoint-start.</entry>
      -->
     <entry>当一个检查点的 CLOG 部分完成时触发的探针。arg0 的含义与 clog-checkpoint-start 相同。</entry>
    </row>
    <row>
     <entry>subtrans-checkpoint-start</entry>
     <entry>(bool)</entry>
     <!-- 
     <entry>Probe that fires when the SUBTRANS portion of a checkpoint is
      started.
      arg0 is true for normal checkpoint, false for shutdown
      checkpoint.</entry>
      -->
     <entry>当一个检查点的 SUBTRANS 部分开始时触发的探针。arg0 为真表示正常检查点，
     为假表示关闭检查点。</entry>
    </row>
    <row>
     <entry>subtrans-checkpoint-done</entry>
     <entry>(bool)</entry>
     <!-- 
     <entry>Probe that fires when the SUBTRANS portion of a checkpoint is
      complete. arg0 has the same meaning as for
      subtrans-checkpoint-start.</entry>
      -->
     <entry>当一个检查点的 SUBTRANS 部分完成时触发的探针。arg0 的含义与 subtrans-checkpoint-start 相同。</entry>
    </row>
    <row>
     <entry>multixact-checkpoint-start</entry>
     <entry>(bool)</entry>
     <!-- 
     <entry>Probe that fires when the MultiXact portion of a checkpoint is
      started.
      arg0 is true for normal checkpoint, false for shutdown
      checkpoint.</entry>
      -->
     <entry>当一个检查点的 MultiXact 部分开始时触发的探针。arg0 为真表示正常检查点，
     为假表示关闭检查点。</entry>
    </row>
    <row>
     <entry>multixact-checkpoint-done</entry>
     <entry>(bool)</entry>
     <!-- 
     <entry>Probe that fires when the MultiXact portion of a checkpoint is
      complete. arg0 has the same meaning as for
      multixact-checkpoint-start.</entry>
      -->
     <entry>当一个检查点的 MultiXact 部分完成时触发的探针。
     arg0 的含义与 multixact-checkpoint-start 相同。</entry>
    </row>
    <row>
     <entry>buffer-checkpoint-start</entry>
     <entry>(int)</entry>
     <!-- 
     <entry>Probe that fires when the buffer-writing portion of a checkpoint
      is started.
      arg0 holds the bitwise flags used to distinguish different checkpoint
      types, such as shutdown, immediate or force.</entry>
      -->
     <entry>当一个检查点的写缓冲区部分开始时触发的探针。arg0 保持逐位标志来区分不同的检查点类型，
     例如关闭（shutdown）、立即（immediate）或强制（force）。</entry>
    </row>
    <row>
     <entry>buffer-sync-start</entry>
     <entry>(int, int)</entry>
     <!-- 
     <entry>Probe that fires when we begin to write dirty buffers during
      checkpoint (after identifying which buffers must be written).
      arg0 is the total number of buffers.
      arg1 is the number that are currently dirty and need to be written.</entry>
      -->
     <entry>当我们在检查点期间开始写脏缓冲区时（在标识哪些缓冲区必须被写之后）触发的探针。
     arg0 是缓冲区总数，arg1 是当前为脏并且需要被写的缓冲区数量。</entry>
    </row>
    <row>
     <entry>buffer-sync-written</entry>
     <entry>(int)</entry>
     <!-- 
     <entry>Probe that fires after each buffer is written during checkpoint.
      arg0 is the ID number of the buffer.</entry>
      -->
     <entry>在检查点期间当每个缓冲区被写完之后触发的探针。arg0 是缓冲区的 ID。</entry>
    </row>
    <row>
     <entry>buffer-sync-done</entry>
     <entry>(int, int, int)</entry>
     <!-- 
     <entry>Probe that fires when all dirty buffers have been written.
      arg0 is the total number of buffers.
      arg1 is the number of buffers actually written by the checkpoint process.
      arg2 is the number that were expected to be written (arg1 of
      buffer-sync-start); any difference reflects other processes flushing
      buffers during the checkpoint.</entry>
      -->
     <entry>当所有脏缓冲区被写之后触发的探针。arg0 是缓冲区总数。
     arg1 是检查点进程实际写的缓冲区数量。arg2 是期望写的数目（buffer-sync-start 的 arg1）；
     arg1 和 arg2 的任何的不同反映在该检查点期间有其他进程刷写了缓冲区。</entry>
    </row>
    <row>
     <entry>buffer-checkpoint-sync-start</entry>
     <entry>()</entry>
     <!-- 
     <entry>Probe that fires after dirty buffers have been written to the
      kernel, and before starting to issue fsync requests.</entry>
      -->
     <entry>在脏缓冲区被写入到内核之后并且在开始发出 fsync 请求之前触发的探针。</entry>
    </row>
    <row>
     <entry>buffer-checkpoint-done</entry>
     <entry>()</entry>
     <!-- 
     <entry>Probe that fires when syncing of buffers to disk is
      complete.</entry>
      -->
     <entry>当同步缓冲区到磁盘完成时触发的探针。</entry>
    </row>
    <row>
     <entry>twophase-checkpoint-start</entry>
     <entry>()</entry>
     <!-- 
     <entry>Probe that fires when the two-phase portion of a checkpoint is
      started.</entry>
      -->
     <entry>当一个检查点的两阶段部分被开始时触发的探针。</entry>
    </row>
    <row>
     <entry>twophase-checkpoint-done</entry>
     <entry>()</entry>
     <!-- 
     <entry>Probe that fires when the two-phase portion of a checkpoint is
      complete.</entry>
      -->
     <entry>当一个检查点的两阶段部分完成时触发的探针。</entry>
    </row>
    <row>
     <entry>buffer-read-start</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool)</entry>
     <!-- 
     <entry>Probe that fires when a buffer read is started.
      arg0 and arg1 contain the fork and block numbers of the page (but
      arg1 will be -1 if this is a relation extension request).
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the ID of the backend which created the temporary relation for a
      local buffer, or InvalidBackendId (-1) for a shared buffer.
      arg6 is true for a relation extension request, false for normal
      read.</entry>
      -->
     <entry>当一次缓冲区读被开始时触发的探针。arg0 和 arg1 包含该页的分叉号和块号
     （如果这是一次关系扩展请求，arg1 为 -1）。arg2、arg3 和 arg4 包含表空间、
     数据库和关系 OID 用以识别该关系。
     arg5 是为本地缓冲区创建临时关系的后端的 ID，或者对共享缓冲区是 InvalidBackendId（-1）。
     arg6 为真表示一次关系扩展请求，为假表示正常读。</entry>
    </row>
    <row>
     <entry>buffer-read-done</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool, bool)</entry>
     <!-- 
     <entry>Probe that fires when a buffer read is complete.
      arg0 and arg1 contain the fork and block numbers of the page (if this
      is a relation extension request, arg1 now contains the block number
      of the newly added block).
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the ID of the backend which created the temporary relation for a
      local buffer, or InvalidBackendId (-1) for a shared buffer.
      arg6 is true for a relation extension request, false for normal
      read.
      arg7 is true if the buffer was found in the pool, false if not.</entry>
      -->
     <entry>当一次缓冲区读完成时触发的探测器。arg0 和 arg1 包含该页的分叉号和块号
     （如果这是一次关系扩展请求，arg1 现在包含新增加块的块号）。arg2、arg3 和 arg4 包含表空间、
     数据库和关系 OID 用以识别该关系。arg5 是为本地缓冲区创建临时关系的后端的 ID，
     或者对共享缓冲区是 InvalidBackendId（-1）。
     arg6 为真表示一次关系扩展请求，为假表示正常读。arg7 为真表示在池中找到该缓冲区，
     为假表示没有找到。</entry>
    </row>
    <row>
     <entry>buffer-flush-start</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid)</entry>
     <!-- 
     <entry>Probe that fires before issuing any write request for a shared
      buffer.
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.</entry>
      -->
     <entry>在发出对一个共享缓冲区的任意写请求之前触发的探针。arg0 和 arg1 包含该页的分叉号和块号。
     arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。</entry>
    </row>
    <row>
     <entry>buffer-flush-done</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid)</entry>
     <!-- 
     <entry>Probe that fires when a write request is complete.  (Note
      that this just reflects the time to pass the data to the kernel;
      it's typically not actually been written to disk yet.)
      The arguments are the same as for buffer-flush-start.</entry>
      -->
     <entry>当一个写请求完成时触发的探针（注意这只反映传递数据给内核的时间，
     它通常没有实际写入到磁盘）。这个参数与 buffer-flush-start 相同。</entry>
    </row>
    <row>
     <entry>buffer-write-dirty-start</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid)</entry>
     <!-- 
     <entry>Probe that fires when a server process begins to write a dirty
      buffer.  (If this happens often, it implies that
      <xref linkend="guc-shared-buffers"> is too
      small or the bgwriter control parameters need adjustment.)
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.</entry>
      -->
     <entry>当一个服务器进程开始写一个脏缓冲区时触发的探针（如果这经常发生，
     表示<xref linkend="guc-shared-buffers">太小，或需要调整 bgwriter 的控制参数）。
     arg0 和 arg1 包含该页的分叉号和块号。arg2、arg3 和 arg4 包含表空间、
     数据库和关系 OID 用以识别该关系。</entry>
    </row>
    <row>
     <entry>buffer-write-dirty-done</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid)</entry>
     <!-- 
     <entry>Probe that fires when a dirty-buffer write is complete.
      The arguments are the same as for buffer-write-dirty-start.</entry>
      -->
     <entry>当一次脏缓冲区写完成时触发的探针。参数与 buffer-write-dirty-start 相同。</entry>
    </row>
    <row>
     <entry>wal-buffer-write-dirty-start</entry>
     <entry>()</entry>
     <!-- 
     <entry>Probe that fires when a server process begins to write a
      dirty WAL buffer because no more WAL buffer space is available.
      (If this happens often, it implies that
      <xref linkend="guc-wal-buffers"> is too small.)</entry>
      -->
     <entry>当一个服务器进程因为没有可用 WAL 缓冲区空间开始写一个脏 WAL 缓冲区时触发的探针
     （如果这经常发生，表示<xref linkend="guc-wal-buffers">太小）。</entry>
    </row>
    <row>
     <entry>wal-buffer-write-dirty-done</entry>
     <entry>()</entry>
     <!-- 
     <entry>Probe that fires when a dirty WAL buffer write is complete.</entry>
     -->
     <entry>当一次脏 WAL 缓冲区写完成时触发的探针。</entry>
    </row>
    <row>
     <entry>xlog-insert</entry>
     <entry>(unsigned char, unsigned char)</entry>
     <!-- 
     <entry>Probe that fires when a WAL record is inserted.
      arg0 is the resource manager (rmid) for the record.
      arg1 contains the info flags.</entry>
      -->
     <entry>当一个 WAL 记录被插入时触发的探针。arg0 是该记录的资源管理者（rmid）。
     arg1 包含 info 标志。</entry>
    </row>
    <row>
     <entry>xlog-switch</entry>
     <entry>()</entry>
     <!-- 
     <entry>Probe that fires when a WAL segment switch is requested.</entry>
     -->
     <entry>当请求一次 WAL 段切换时触发的探针。</entry>
    </row>
    <row>
     <entry>smgr-md-read-start</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid, int)</entry>
     <!-- 
     <entry>Probe that fires when beginning to read a block from a relation.
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the ID of the backend which created the temporary relation for a
      local buffer, or InvalidBackendId (-1) for a shared buffer.</entry>
      -->
     <entry>当开始从一个关系读取一块时触发的探针。arg0 和 arg1 包含该页的分叉号和块号。
     arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。对一个本地缓冲区，
     arg5 是创建临时关系的后端的 ID；对于一个共享缓冲区，arg5 是 InvalidBackendId（-1）。</entry>
    </row>
    <row>
     <entry>smgr-md-read-done</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int)</entry>
     <!-- 
     <entry>Probe that fires when a block read is complete.
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the ID of the backend which created the temporary relation for a
      local buffer, or InvalidBackendId (-1) for a shared buffer.
      arg6 is the number of bytes actually read, while arg7 is the number
      requested (if these are different it indicates trouble).</entry>
      -->
     <entry>当一次块读取完成时触发的探针。arg0 和 arg1 包含该页的分叉号和块号。
     arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。对一个本地缓冲区，
     arg5 是创建临时关系的后端的 ID；对于一个共享缓冲区，arg5 是 InvalidBackendId（-1）。
     arg6 是实际读取的字节数，而 arg7 是请求读取的字节数（如果两者不同就意味着麻烦）。</entry>
    </row>
    <row>
     <entry>smgr-md-write-start</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid, int)</entry>
     <!-- 
     <entry>Probe that fires when beginning to write a block to a relation.
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the ID of the backend which created the temporary relation for a
      local buffer, or InvalidBackendId (-1) for a shared buffer.</entry>
      -->
     <entry>当开始向一个关系中写入一个块时触发的探针。arg0 和 arg1 包含该页的分叉号和块号。
     arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。对一个本地缓冲区，
     arg5 是创建临时关系的后端的 ID；对于一个共享缓冲区，arg5 是 InvalidBackendId（-1）。</entry>
    </row>
    <row>
     <entry>smgr-md-write-done</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int)</entry>
     <!-- 
     <entry>Probe that fires when a block write is complete.
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the ID of the backend which created the temporary relation for a
      local buffer, or InvalidBackendId (-1) for a shared buffer.
      arg6 is the number of bytes actually written, while arg7 is the number
      requested (if these are different it indicates trouble).</entry>
      -->
     <entry>当一个块写操作完成时触发的探针。arg0 和 arg1 包含该页的分叉号和块号。
     arg2、arg3和arg4 包含表空间、数据库和关系 OID来标识该关系。对于一个本地缓冲区，
     arg5 是创建临时关系的后端 ID；对于一个共享缓冲区，arg5 是 InvalidBackendId（-1）。
     arg6 是实际写的字节数，而 arg7 是要求写的字节数（如果这两者不同，则意味着麻烦）。</entry>
    </row>
    <row>
     <entry>sort-start</entry>
     <entry>(int, bool, int, int, bool)</entry>
     <!-- 
     <entry>Probe that fires when a sort operation is started.
      arg0 indicates heap, index or datum sort.
      arg1 is true for unique-value enforcement.
      arg2 is the number of key columns.
      arg3 is the number of kilobytes of work memory allowed.
      arg4 is true if random access to the sort result is required.</entry>
      -->
     <entry>当一次排序操作开始时触发的探针。arg0 指示是堆排序、索引排序或数据排序。
     arg1 为真表示强制唯一值。arg2 是键列的数目。arg3 是允许使用的工作内存数（以千字节计）。
     如果要求随机访问排序结果，那么 arg4 为真。</entry>
    </row>
    <row>
     <entry>sort-done</entry>
     <entry>(bool, long)</entry>
     <!--
     <entry>Probe that fires when a sort is complete.
      arg0 is true for external sort, false for internal sort.
      arg1 is the number of disk blocks used for an external sort,
      or kilobytes of memory used for an internal sort.</entry>
      -->
     <entry>当一次排序完成时触发的探针。arg0 为真表示外部排序，为假表示内部排序。
     arg1 是用于一次外部排序的磁盘块的数目，或用于一次内部排序的以千字节计的内存数。</entry>
    </row>
    <row>
     <entry>lwlock-acquire</entry>
     <entry>(char *, int, LWLockMode)</entry>
     <!-- 
     <entry>Probe that fires when an LWLock has been acquired.
      arg0 is the LWLock's tranche.
      arg1 is the LWLock's offset within its tranche.
      arg2 is the requested lock mode, either exclusive or shared.</entry>
      -->
     <entry>当成功获得一个 LWLock 时触发的探针。
      arg0 是该 LWLock 所在的分支。
      arg1 是该 LWLock 在其所在分支中的偏移量。
      arg2 是请求的锁模式，是排他或共享。</entry>
    </row>
    <row>
     <entry>lwlock-release</entry>
     <entry>(char *, int)</entry>
     <!-- 
     <entry>Probe that fires when an LWLock has been released (but note
      that any released waiters have not yet been awakened).
      arg0 is the LWLock's tranche.
      arg1 is the LWLock's offset within its tranche.</entry>
      -->
     <entry>当一个 LWLock 被释放时（但是注意还没有唤醒任何一个被释放的等待者）触发的探针。
     arg0 是该 LWLock 所在的分支。
     arg1 是该 LWLock 在其所在分支中的偏移量。</entry>
    </row>
    <row>
     <entry>lwlock-wait-start</entry>
     <entry>(char *, int, LWLockMode)</entry>
     <!-- 
     <entry>Probe that fires when an LWLock was not immediately available and
      a server process has begun to wait for the lock to become available.
      arg0 is the LWLock's tranche.
      arg1 is the LWLock's offset within its tranche.
      arg2 is the requested lock mode, either exclusive or shared.</entry>
      -->
     <entry>当一个 LWLock不是当即可用并且一个服务器进程因此开始等待该锁变为可用时触发的探针。
     arg0 是该 LWLock 所在的分支。
      arg1 是该 LWLock 在其所在分支中的偏移量。
      arg2 是请求的锁模式，是排他或共享。</entry>
    </row>
    <row>
     <entry>lwlock-wait-done</entry>
     <entry>(char *, int, LWLockMode)</entry>
     <!-- 
     <entry>Probe that fires when a server process has been released from its
      wait for an LWLock (it does not actually have the lock yet).
      arg0 is the LWLock's tranche.
      arg1 is the LWLock's offset within its tranche.
      arg2 is the requested lock mode, either exclusive or shared.</entry>
      -->
     <entry>当一个服务器进程从对 LWLock 的等待中被释放时（它实际还没有得到该锁）时触发的探针。
     arg0 是该 LWLock 所在的分支。
      arg1 是该 LWLock 在其所在分支中的偏移量。
      arg2 是请求的锁模式，是排他或共享。</entry>
    </row>
    <row>
     <entry>lwlock-condacquire</entry>
     <entry>(char *, int, LWLockMode)</entry>
     <!-- 
     <entry>Probe that fires when an LWLock was successfully acquired when the
      caller specified no waiting.
      arg0 is the LWLock's tranche.
      arg1 is the LWLock's offset within its tranche.
      arg2 is the requested lock mode, either exclusive or shared.</entry>
      -->
     <entry>当调用者指定无需等待而成功获得一个 LWLock 时触发的探针。
     arg0 是该 LWLock 所在的分支。
      arg1 是该 LWLock 在其所在分支中的偏移量。
      arg2 是请求的锁模式，是排他或共享。</entry>
    </row>
    <row>
     <entry>lwlock-condacquire-fail</entry>
     <entry>(char *, int, LWLockMode)</entry>
     <!-- 
     <entry>Probe that fires when an LWLock was not successfully acquired when
      the caller specified no waiting.
      arg0 is the LWLock's tranche.
      arg1 is the LWLock's offset within its tranche.
      arg2 is the requested lock mode, either exclusive or shared.</entry>
      -->
     <entry>当调用者指定无需等待而没有成功获得一个 LWLock 时触发的探针。
     arg0 是该 LWLock 所在的分支。
      arg1 是该 LWLock 在其所在分支中的偏移量。
      arg2 是请求的锁模式，是排他或共享。</entry>
    </row>
    <row>
     <entry>lock-wait-start</entry>
     <entry>(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, LOCKMODE)</entry>
     <!-- 
     <entry>Probe that fires when a request for a heavyweight lock (lmgr lock)
      has begun to wait because the lock is not available.
      arg0 through arg3 are the tag fields identifying the object being
      locked.  arg4 indicates the type of object being locked.
      arg5 indicates the lock type being requested.</entry>
      -->
     <entry>当一个重量级锁（lmgr锁）的请求由于锁不可用开始等待时触发的探针。
     arg0 到 arg3 是标识被锁定对象的标签域。arg4 指示被锁对象的类型。arg5 表示被请求的锁类型。</entry>
    </row>
    <row>
     <entry>lock-wait-done</entry>
     <entry>(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, LOCKMODE)</entry>
     <!-- 
     <entry>Probe that fires when a request for a heavyweight lock (lmgr lock)
      has finished waiting (i.e., has acquired the lock).
      The arguments are the same as for lock-wait-start.</entry>
      -->
     <entry>当一个重量级锁（lmgr 锁）的请求结束等待时（即已经得到锁）触发的探针。
     参数与 lock-wait-start 一样。</entry>
    </row>
    <row>
     <entry>deadlock-found</entry>
     <entry>()</entry>
     <!-- 
     <entry>Probe that fires when a deadlock is found by the deadlock
      detector.</entry>
      -->
     <entry>当死锁检测器发现死锁时触发的探针。</entry>
    </row>

   </tbody>
   </tgroup>
  </table>

 <table id="typedefs-table">
  <!-- 
  <title>Defined Types Used in Probe Parameters</title>
  -->
  <title>定义用在探针参数中的类型</title>
  <tgroup cols="2">
   <thead>
    <row>
     <!-- 
     <entry>Type</entry>
     <entry>Definition</entry>
     -->
     <entry>类型</entry>
     <entry>定义</entry>
    </row>
   </thead>

   <tbody>

    <row>
     <entry>LocalTransactionId</entry>
     <entry>unsigned int</entry>
    </row>
    <row>
     <entry>LWLockMode</entry>
     <entry>int</entry>
    </row>
    <row>
     <entry>LOCKMODE</entry>
     <entry>int</entry>
    </row>
    <row>
     <entry>BlockNumber</entry>
     <entry>unsigned int</entry>
    </row>
    <row>
     <entry>Oid</entry>
     <entry>unsigned int</entry>
    </row>
    <row>
     <entry>ForkNumber</entry>
     <entry>int</entry>
    </row>
    <row>
     <entry>bool</entry>
     <entry>char</entry>
    </row>

   </tbody>
   </tgroup>
  </table>


  </sect2>

  <sect2 id="using-trace-points">
   <!-- 
   <title>Using Probes</title>
   -->
   <title>使用探针</title>

  <para>
   <!-- 
   The example below shows a DTrace script for analyzing transaction
   counts in the system, as an alternative to snapshotting
   <structname>pg_stat_database</> before and after a performance test:
   -->
   下面的例子展示了一个系统中分析事务计数的 DTrace 脚本，
   可以用来代替性能测试之前和之后的<structname>pg_stat_database</>快照：
<programlisting>
#!/usr/sbin/dtrace -qs

postgresql$1:::transaction-start
{
      @start["Start"] = count();
      self->ts  = timestamp;
}

postgresql$1:::transaction-abort
{
      @abort["Abort"] = count();
}

postgresql$1:::transaction-commit
/self->ts/
{
      @commit["Commit"] = count();
      @time["Total time (ns)"] = sum(timestamp - self->ts);
      self->ts=0;
}
</programlisting>
   <!--  
   When executed, the example D script gives output such as:
   -->
   当被执行时，该例子 D 脚本给出这样的输出：
<screen>
# ./txn_count.d `pgrep -n postgres` or ./txn_count.d &lt;PID&gt;
^C

Start                                          71
Commit                                         70
Total time (ns)                        2312105013
</screen>
  </para>

  <note>
   <!-- 
   <para>
    SystemTap uses a different notation for trace scripts than DTrace does,
    even though the underlying trace points are compatible.  One point worth
    noting is that at this writing, SystemTap scripts must reference probe
    names using double underscores in place of hyphens.  This is expected to
    be fixed in future SystemTap releases.
   </para>
   -->
   <para>
    SystemTap 为追踪脚本使用一个不同于 DTrace 的标记，但是底层的探针是兼容的。
    值得注意的是，在这样写的时候，SystemTap 脚本必须使用双下划线代替连字符来引用探针名。
    在未来的 SystemTap 发行中这很可能会被修复。
   </para>
  </note>

  <!-- 
  <para>
   You should remember that DTrace scripts need to be carefully written and
   debugged, otherwise the trace information collected might
   be meaningless. In most cases where problems are found it is the
   instrumentation that is at fault, not the underlying system. When
   discussing information found using dynamic tracing, be sure to enclose
   the script used to allow that too to be checked and discussed.
  </para>
  -->
  <para>
   你应该记住，DTrace 脚本需要细心地编写和调试，否则被收集的追踪信息可能会毫无意义。
   大多数问题是由于外部跟踪程序错误导致的而不是底层系统。
   当讨论使用动态跟踪找到的信息时，请务必附上用于允许检查和讨论的脚本。
  </para>

  </sect2>

  <sect2 id="defining-trace-points">
   <!-- 
   <title>Defining New Probes</title>
   -->
   <title>定义新探针</title>

  <!-- 
  <para>
   New probes can be defined within the code wherever the developer
   desires, though this will require a recompilation. Below are the steps
   for inserting new probes:
  </para>
  -->
  <para>
   开发者可以在代码中任意位置定义新的探针，当然这要重新编译之后才能生效。下面是插入新探针的步骤：
  </para>

  <procedure>
   <step>
    <!-- 
    <para>
     Decide on probe names and data to be made available through the probes
    </para>
    -->
    <para>
     决定探针名称以及探针可用的数据
    </para>
   </step>

   <step>
    <!-- 
    <para>
     Add the probe definitions to <filename>src/backend/utils/probes.d</>
    </para>
    -->
    <para>
     把该探针定义加入到<filename>src/backend/utils/probes.d</>
    </para>
   </step>

   <step>
    <!-- 
    <para>
     Include <filename>pg_trace.h</> if it is not already present in the
     module(s) containing the probe points, and insert
     <literal>TRACE_POSTGRESQL</> probe macros at the desired locations
     in the source code
    </para>
    -->
    <para>
     如果<filename>pg_trace.h</>还不存在于包含该探针点的模块中，包括它，
     并且在源代码中期望的位置插入<literal>TRACE_POSTGRESQL</>探针宏
    </para>
   </step>

   <step>
    <!-- 
    <para>
     Recompile and verify that the new probes are available
    </para>
    -->
    <para>
     重新编译并验证新探针是可用的
    </para>
   </step>
  </procedure>

  <formalpara>
   <!-- 
   <title>Example:</title>
   -->
   <title>例子：</title>
   <!-- 
   <para>
    Here is an example of how you would add a probe to trace all new
    transactions by transaction ID.
   </para>
   -->
   <para>
    这里是一个如何增加一个探针来用事务 ID 追踪所有新事务的例子。
   </para>
  </formalpara>

  <procedure>
   <step>
    <!-- 
    <para>
     Decide that the probe will be named <literal>transaction-start</> and
     requires a parameter of type LocalTransactionId
    </para>
    -->
    <para>
     决定探针将被命名为<literal>transaction-start</>并且需要一个 LocalTransactionId 类型的参数
    </para>
   </step>

   <step>
    <para>
     <!-- 
     Add the probe definition to <filename>src/backend/utils/probes.d</>:
     -->
     将该探针定义加入到<filename>src/backend/utils/probes.d</>：
<programlisting>
probe transaction__start(LocalTransactionId);
</programlisting>
     <!-- 
     Note the use of the double underline in the probe name. In a DTrace
     script using the probe, the double underline needs to be replaced with a
     hyphen, so <literal>transaction-start</> is the name to document for
     users.
     -->
     注意探针名字中双下划线的使用。在一个使用探针的 DTrace 脚本中，
     双下划线需要被替换为一个连字符，因此 ，对用户而言<literal>transaction-start</>是文档名。
    </para>
   </step>

   <step>
    <para>
     <!-- 
     At compile time, <literal>transaction__start</> is converted to a macro
     called <literal>TRACE_POSTGRESQL_TRANSACTION_START</> (notice the
     underscores are single here), which is available by including
     <filename>pg_trace.h</>.  Add the macro call to the appropriate location
     in the source code.  In this case, it looks like the following:
     -->
     在编译时，<literal>transaction__start</>被转换成一个宏调用
     <literal>TRACE_POSTGRESQL_TRANSACTION_START</>（注意这里是单下划线），
     可以通过包括头文件<filename>pg_trace.h</>获得。将宏调用加入到源代码中的合适位置。
     在这种情况下，看起来类似：

<programlisting>
TRACE_POSTGRESQL_TRANSACTION_START(vxid.localTransactionId);
</programlisting>
    </para>
   </step>

   <step>
    <para>
     <!-- 
     After recompiling and running the new binary, check that your newly added
     probe is available by executing the following DTrace command.  You
     should see similar output:
     -->
     在重新编译和运行新的二进制文件之后，通过运行下面的 DTrace 命令来检查新增的探针是否可用。
     你应该看到类似下面的输出：
<screen>
# dtrace -ln transaction-start
   ID    PROVIDER          MODULE           FUNCTION NAME
18705 postgresql49878     postgres     StartTransactionCommand transaction-start
18755 postgresql49877     postgres     StartTransactionCommand transaction-start
18805 postgresql49876     postgres     StartTransactionCommand transaction-start
18855 postgresql49875     postgres     StartTransactionCommand transaction-start
18986 postgresql49873     postgres     StartTransactionCommand transaction-start
</screen>
    </para>
   </step>
  </procedure>

  <para>
   <!-- 
   There are a few things to be careful about when adding trace macros
   to the C code:
   -->
   向C代码中添加追踪宏时，有一些事情需要注意：

   <itemizedlist>
    <listitem>
     <!-- 
     <para>
      You should take care that the data types specified for a probe's
      parameters match the data types of the variables used in the macro.
      Otherwise, you will get compilation errors.
     </para>
     -->
     <para>
      需要小心的是，为探针参数指定的数据类型要匹配宏中使用的变量的数据类型，否则会发生编译错误。
     </para>
    </listitem>


    <listitem>
     <para>
      <!-- 
      On most platforms, if <productname>PostgreSQL</productname> is
      built with <option>-&#045;enable-dtrace</>, the arguments to a trace
      macro will be evaluated whenever control passes through the
      macro, <emphasis>even if no tracing is being done</>.  This is
      usually not worth worrying about if you are just reporting the
      values of a few local variables.  But beware of putting expensive
      function calls into the arguments.  If you need to do that,
      consider protecting the macro with a check to see if the trace
      is actually enabled:
      -->
      在大多数平台上，如果用<option>--enable-dtrace</>编译了<productname>PostgreSQL</productname>，
      无论何时当控制经过一个追踪宏时，都会评估该宏的参数，<emphasis>即使没有进行追踪也会这样做</>。
      通常不需要担心你是否只在报告一些局部变量的值。但要注意将开销大的函数调用放置在这些参数中。
      如果你需要这样做，考虑通过检查追踪是否真的被启用来保护该宏：

<programlisting>
if (TRACE_POSTGRESQL_TRANSACTION_START_ENABLED())
    TRACE_POSTGRESQL_TRANSACTION_START(some_function(...));
</programlisting>

      <!-- 
      Each trace macro has a corresponding <literal>ENABLED</> macro.
      -->
      每个追踪宏有一个对应的<literal>ENABLED</>宏。
     </para>
    </listitem>
   </itemizedlist>

  </para>

  </sect2>

 </sect1>

</chapter>
