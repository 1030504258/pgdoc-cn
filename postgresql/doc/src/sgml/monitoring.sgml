<!-- doc/src/sgml/monitoring.sgml -->

<chapter id="monitoring">
<!--==========================orignal english content==========================
 <title>Monitoring Database Activity</title>
____________________________________________________________________________-->
 <title>监控数据库活动</title>

<!--==========================orignal english content==========================
 <indexterm zone="monitoring">
  <primary>monitoring</primary>
  <secondary>database activity</secondary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="monitoring">
  <primary>监控</primary>
  <secondary>数据库活动</secondary>
 </indexterm>

<!--==========================orignal english content==========================
 <indexterm zone="monitoring">
  <primary>database activity</primary>
  <secondary>monitoring</secondary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="monitoring">
  <primary>数据库活动</primary>
  <secondary>监控</secondary>
 </indexterm>

<!--==========================orignal english content==========================
 <para>
  A database administrator frequently wonders, <quote>What is the system
  doing right now?</quote>
  This chapter discusses how to find that out.
 </para>
____________________________________________________________________________-->
 <para>
  一个数据库管理员常常会疑惑，<quote>系统现在正在做什么？</quote>这一章会讨论如何搞清楚这个问题。
 </para>

<!--==========================orignal english content==========================
  <para>
   Several tools are available for monitoring database activity and
   analyzing performance.  Most of this chapter is devoted to describing
   <productname>PostgreSQL</productname>'s statistics collector,
   but one should not neglect regular Unix monitoring programs such as
   <command>ps</command>, <command>top</command>, <command>iostat</command>, and <command>vmstat</command>.
   Also, once one has identified a
   poorly-performing query, further investigation might be needed using
   <productname>PostgreSQL</productname>'s <link linkend="sql-explain"><command>EXPLAIN</command></link> command.
   <xref linkend="using-explain"/> discusses <command>EXPLAIN</command>
   and other methods for understanding the behavior of an individual
   query.
  </para>
____________________________________________________________________________-->
  <para>
   一些工具可以用来监控数据库活动并且分析性能。
   这一章的大部分都致力于描述<productname>PostgreSQL</productname>的统计收集器，但是我们也不能忽视常规的 Unix 监控程序，如<command>ps</command>、<command>top</command>、<command>iostat</command>和<command>vmstat</command>。
   另外，一旦我们发现了一个性能差的查询，可能需要<productname>PostgreSQL</productname>的<link linkend="sql-explain"><command>EXPLAIN</command></link>命令来进行进一步的调查。
   <xref linkend="using-explain"/>会讨论<command>EXPLAIN</command>以及其他用来理解个体查询行为的方法。
  </para>

 <sect1 id="monitoring-ps">
<!--==========================orignal english content==========================
  <title>Standard Unix Tools</title>
____________________________________________________________________________-->
  <title>标准 Unix 工具</title>

<!--==========================orignal english content==========================
  <indexterm zone="monitoring-ps">
   <primary>ps</primary>
   <secondary>to monitor activity</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="monitoring-ps">
   <primary>ps</primary>
   <secondary>to monitor activity</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   On most Unix platforms, <productname>PostgreSQL</productname> modifies its
   command title as reported by <command>ps</command>, so that individual server
   processes can readily be identified.  A sample display is

<screen>
$ ps auxww | grep ^postgres
postgres  15551  0.0  0.1  57536  7132 pts/0    S    18:02   0:00 postgres -i
postgres  15554  0.0  0.0  57536  1184 ?        Ss   18:02   0:00 postgres: background writer
postgres  15555  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: checkpointer
postgres  15556  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: walwriter
postgres  15557  0.0  0.0  58504  2244 ?        Ss   18:02   0:00 postgres: autovacuum launcher
postgres  15558  0.0  0.0  17512  1068 ?        Ss   18:02   0:00 postgres: stats collector
postgres  15582  0.0  0.0  58772  3080 ?        Ss   18:04   0:00 postgres: joe runbug 127.0.0.1 idle
postgres  15606  0.0  0.0  58772  3052 ?        Ss   18:07   0:00 postgres: tgl regression [local] SELECT waiting
postgres  15610  0.0  0.0  58772  3056 ?        Ss   18:07   0:00 postgres: tgl regression [local] idle in transaction
</screen>

   (The appropriate invocation of <command>ps</command> varies across different
   platforms, as do the details of what is shown.  This example is from a
   recent Linux system.)  The first process listed here is the
   primary server process.  The command arguments
   shown for it are the same ones used when it was launched.  The next five
   processes are background worker processes automatically launched by the
   primary process.  (The <quote>stats collector</quote> process will not be present
   if you have set the system not to start the statistics collector; likewise
   the <quote>autovacuum launcher</quote> process can be disabled.)
   Each of the remaining
   processes is a server process handling one client connection.  Each such
   process sets its command line display in the form

<screen>
postgres: <replaceable>user</replaceable> <replaceable>database</replaceable> <replaceable>host</replaceable> <replaceable>activity</replaceable>
</screen>

  The user, database, and (client) host items remain the same for
  the life of the client connection, but the activity indicator changes.
  The activity can be <literal>idle</literal> (i.e., waiting for a client command),
  <literal>idle in transaction</literal> (waiting for client inside a <command>BEGIN</command> block),
  or a command type name such as <literal>SELECT</literal>.  Also,
  <literal>waiting</literal> is appended if the server process is presently waiting
  on a lock held by another session.  In the above example we can infer
  that process 15606 is waiting for process 15610 to complete its transaction
  and thereby release some lock.  (Process 15610 must be the blocker, because
  there is no other active session.  In more complicated cases it would be
  necessary to look into the
  <link linkend="view-pg-locks"><structname>pg_locks</structname></link>
  system view to determine who is blocking whom.)
  </para>
____________________________________________________________________________-->
  <para>
   在大部分 Unix 平台上，<productname>PostgreSQL</productname>会修改由<command>ps</command>报告的命令标题，这样个体服务器进程可以被标识。一个显示样例是

<screen>
$ ps auxww | grep ^postgres
postgres  15551  0.0  0.1  57536  7132 pts/0    S    18:02   0:00 postgres -i
postgres  15554  0.0  0.0  57536  1184 ?        Ss   18:02   0:00 postgres: background writer
postgres  15555  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: checkpointer
postgres  15556  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: walwriter
postgres  15557  0.0  0.0  58504  2244 ?        Ss   18:02   0:00 postgres: autovacuum launcher
postgres  15558  0.0  0.0  17512  1068 ?        Ss   18:02   0:00 postgres: stats collector
postgres  15582  0.0  0.0  58772  3080 ?        Ss   18:04   0:00 postgres: joe runbug 127.0.0.1 idle
postgres  15606  0.0  0.0  58772  3052 ?        Ss   18:07   0:00 postgres: tgl regression [local] SELECT waiting
postgres  15610  0.0  0.0  58772  3056 ?        Ss   18:07   0:00 postgres: tgl regression [local] idle in transaction
</screen>

   （<command>ps</command>的调用方式随不同的平台而变，但是显示的细节都差不多。这个例子来自于一个最近的 Linux 系统）。列在这里的第一个进程是主服务器进程。为它显示的命令参数是当它被启动时使用的那些。接下来的五个进程是由主进程自动启动的后台工作者进程（如果你已经设置系统为不启动统计收集器，<quote>统计收集器</quote>进程将不会出现；同样<quote>自动清理发动</quote>进程也可以被禁用）。剩余的每一个进程都是一个处理一个客户端连接的服务器进程。每个这种进程都会把它的命令行显示设置为这种形式

<screen>
postgres: <replaceable>user</replaceable> <replaceable>database</replaceable> <replaceable>host</replaceable> <replaceable>activity</replaceable>
</screen>

  在该客户端连接的生命期中，用户、数据库以及（客户端）主机项保持不变，但是活动指示器会改变。活动可以是<literal>闲置</literal>（即等待一个客户端命令）、<literal>在事务中闲置</literal>（在一个<command>BEGIN</command>块里等待客户端）或者一个命令类型名，例如<literal>SELECT</literal>。还有，如果服务器进程正在等待一个其它会话持有的锁， <literal>等待中</literal>会被追加到上述信息中。在上面的例子中，我们可以推断：进程 15606 正在等待进程 15610 完成其事务并且因此释放一些锁（进程 15610 必定是阻塞者，因为没有其他活动会话。在更复杂的情况中，可能需要查看<link linkend="view-pg-locks"><structname>pg_locks</structname></link>系统视图来决定谁阻塞了谁）。
  </para>

<!--==========================orignal english content==========================
  <para>
   If <xref linkend="guc-cluster-name"/> has been configured the
   cluster name will also be shown in <command>ps</command> output:
<screen>
$ psql -c 'SHOW cluster_name'
 cluster_name
-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 server1
(1 row)

$ ps aux|grep server1
postgres   27093  0.0  0.0  30096  2752 ?        Ss   11:34   0:00 postgres: server1: background writer
...
</screen>
  </para>
____________________________________________________________________________-->
  <para>
   如果配置了<xref linkend="guc-cluster-name"/>，则集簇的名字
   也将会显示在<command>ps</command>的输出中：
<screen>
$ psql -c 'SHOW cluster_name'
 cluster_name
--------------
 server1
(1 row)

$ ps aux|grep server1
postgres   27093  0.0  0.0  30096  2752 ?        Ss   11:34   0:00 postgres: server1: background writer
...
</screen>
  </para>

<!--==========================orignal english content==========================
  <para>
   If you have turned off <xref linkend="guc-update-process-title"/> then the
   activity indicator is not updated; the process title is set only once
   when a new process is launched.  On some platforms this saves a measurable
   amount of per-command overhead;  on others it's insignificant.
  </para>
____________________________________________________________________________-->
  <para>
   如果你已经关闭了<xref linkend="guc-update-process-title"/>，那么活动指示器将不会被更新，进程标题仅在新进程被启动的时候设置一次。 在某些平台上这样做可以为每个命令节省可观的开销，但在其它平台上却不明显。
  </para>

  <tip>
<!--==========================orignal english content==========================
  <para>
  <productname>Solaris</productname> requires special handling. You must
  use <command>/usr/ucb/ps</command>, rather than
  <command>/bin/ps</command>. You also must use two <option>w</option>
  flags, not just one. In addition, your original invocation of the
  <command>postgres</command> command must have a shorter
  <command>ps</command> status display than that provided by each
  server process.  If you fail to do all three things, the <command>ps</command>
  output for each server process will be the original <command>postgres</command>
  command line.
  </para>
____________________________________________________________________________-->
  <para>
  <productname>Solaris</productname>需要特别的处理。你必需使用<command>/usr/ucb/ps</command>而不是<command>/bin/ps</command>。 你还必需使用两个<option>w</option>标志，而不是一个。另外，你对<command>postgres</command>命令的最初调用必须用一个比服务器进程提供的短的<command>ps</command>状态显示。如果你没有满足全部三个要求，每个服务器进程的<command>ps</command>输出将是原始的<command>postgres</command>命令行。
  command line.
  </para>
  </tip>
 </sect1>

 <sect1 id="monitoring-stats">
<!--==========================orignal english content==========================
  <title>The Statistics Collector</title>
____________________________________________________________________________-->
  <title>统计收集器</title>

<!--==========================orignal english content==========================
  <indexterm zone="monitoring-stats">
   <primary>statistics</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="monitoring-stats">
   <primary>statistics</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname>'s <firstterm>statistics collector</firstterm>
   is a subsystem that supports collection and reporting of information about
   server activity.  Presently, the collector can count accesses to tables
   and indexes in both disk-block and individual-row terms.  It also tracks
   the total number of rows in each table, and information about vacuum and
   analyze actions for each table.  It can also count calls to user-defined
   functions and the total time spent in each one.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>的<firstterm>统计收集器</firstterm>是一个支持收集和报告服务器活动信息的子系统。 目前，这个收集器可以对表和索引的访问计数，计数可以按磁盘块和个体行来进行。它还跟踪每个表中的总行数、每个表的清理和分析动作的信息。它也统计调用用户定义函数的次数以及在每次调用中花费的总时间。
  </para>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname> also supports reporting dynamic
   information about exactly what is going on in the system right now, such as
   the exact command currently being executed by other server processes, and
   which other connections exist in the system.  This facility is independent
   of the collector process.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>也支持报告有关系统正在干什么的
   动态信息，例如当前正在被其他服务器进程执行的命令以及系统中存在哪些其他连接。
   这个功能是独立于收集器进程存在的。
  </para>

 <sect2 id="monitoring-stats-setup">
<!--==========================orignal english content==========================
  <title>Statistics Collection Configuration</title>
____________________________________________________________________________-->
  <title>统计收集配置</title>

<!--==========================orignal english content==========================
  <para>
   Since collection of statistics adds some overhead to query execution,
   the system can be configured to collect or not collect information.
   This is controlled by configuration parameters that are normally set in
   <filename>postgresql.conf</filename>.  (See <xref linkend="runtime-config"/> for
   details about setting configuration parameters.)
  </para>
____________________________________________________________________________-->
  <para>
   因为统计收集给查询执行增加了一些负荷，系统可以被配置为收集或不收集信息。这由配置参数控制，它们通常在<filename>postgresql.conf</filename>中设置（关于设置配置参数的细节请见<xref linkend="runtime-config"/>）。
  </para>

<!--==========================orignal english content==========================
  <para>
   The parameter <xref linkend="guc-track-activities"/> enables monitoring
   of the current command being executed by any server process.
  </para>
____________________________________________________________________________-->
  <para>
   参数<xref linkend="guc-track-activities"/>允许监控当前被任意服务器进程执行的命令。
  </para>

<!--==========================orignal english content==========================
  <para>
   The parameter <xref linkend="guc-track-counts"/> controls whether
   statistics are collected about table and index accesses.
  </para>
____________________________________________________________________________-->
  <para>
   参数<xref linkend="guc-track-counts"/>控制是否收集关于表和索引访问的统计信息。
  </para>

<!--==========================orignal english content==========================
  <para>
   The parameter <xref linkend="guc-track-functions"/> enables tracking of
   usage of user-defined functions.
  </para>
____________________________________________________________________________-->
  <para>
   参数<xref linkend="guc-track-functions"/>启用对用户定义函数使用的跟踪。
  </para>

<!--==========================orignal english content==========================
  <para>
   The parameter <xref linkend="guc-track-io-timing"/> enables monitoring
   of block read and write times.
  </para>
____________________________________________________________________________-->
  <para>
   参数<xref linkend="guc-track-io-timing"/>启用对块读写次数的监控。
  </para>

<!--==========================orignal english content==========================
  <para>
   The parameter <xref linkend="guc-track-wal-io-timing"/> enables monitoring
   of WAL write times.
  </para>
____________________________________________________________________________-->
  <para>
   参数 <xref linkend="guc-track-wal-io-timing"/> 启用WAL写时间的监控。
  </para>

<!--==========================orignal english content==========================
  <para>
   Normally these parameters are set in <filename>postgresql.conf</filename> so
   that they apply to all server processes, but it is possible to turn
   them on or off in individual sessions using the <xref
   linkend="sql-set"/> command. (To prevent
   ordinary users from hiding their activity from the administrator,
   only superusers are allowed to change these parameters with
   <command>SET</command>.)
  </para>
____________________________________________________________________________-->
  <para>
   通常这些参数被设置在<filename>postgresql.conf</filename>中，这样它们会应用于所有服务器进程，但是可以在单个会话中使用<xref linkend="sql-set"/>命令打开或关闭它们（为了阻止普通用户对管理员隐藏他们的活动，只有超级用户被允许使用<command>SET</command>来改变这些参数）。
  </para>

<!--==========================orignal english content==========================
  <para>
   The statistics collector transmits the collected information to other
   <productname>PostgreSQL</productname> processes through temporary files.
   These files are stored in the directory named by the
   <xref linkend="guc-stats-temp-directory"/> parameter,
   <filename>pg_stat_tmp</filename> by default.
   For better performance, <varname>stats_temp_directory</varname> can be
   pointed at a RAM-based file system, decreasing physical I/O requirements.
   When the server shuts down cleanly, a permanent copy of the statistics
   data is stored in the <filename>pg_stat</filename> subdirectory, so that
   statistics can be retained across server restarts.  When recovery is
   performed at server start (e.g., after immediate shutdown, server crash,
   and point-in-time recovery), all statistics counters are reset.
  </para>
____________________________________________________________________________-->
  <para>
   统计收集器通过临时文件将收集到的信息传送给其他<productname>PostgreSQL</productname>进程。这些文件被存储在名字由<xref linkend="guc-stats-temp-directory"/>参数指定的目录中，默认是<filename>pg_stat_tmp</filename>。为了得到更好的性能，<varname>stats_temp_directory</varname>可以被指向一个基于 RAM 的文件系统来降低物理 I/O 需求。当服务器被干净地关闭时，一份统计数据的永久拷贝被存储在<filename>pg_stat</filename>子目录中，这样在服务器重启后统计信息能被保持。当在服务器启动时执行恢复时（例如立即关闭、服务器崩溃以及时间点恢复之后），所有统计计数器会被重置。
  </para>

 </sect2>

 <sect2 id="monitoring-stats-views">
<!--==========================orignal english content==========================
  <title>Viewing Statistics</title>
____________________________________________________________________________-->
  <title>查看统计信息</title>

<!--==========================orignal english content==========================
  <para>
   Several predefined views, listed in <xref
   linkend="monitoring-stats-dynamic-views-table"/>, are available to show
   the current state of the system. There are also several other
   views, listed in <xref
   linkend="monitoring-stats-views-table"/>, available to show the results
   of statistics collection.  Alternatively, one can
   build custom views using the underlying statistics functions, as discussed
   in <xref linkend="monitoring-stats-functions"/>.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="monitoring-stats-dynamic-views-table"/>中列出了一些预定义视图
   可以用来显示系统的当前状态。
   <xref linkend="monitoring-stats-views-table"/>中列出了另一些视图可以
   显示统计收集的结果。你也可以使用底层统计函数（在
   <xref linkend="monitoring-stats-functions"/>中讨论）来建立自定义的视图。
  </para>

<!--==========================orignal english content==========================
  <para>
   When using the statistics to monitor collected data, it is important
   to realize that the information does not update instantaneously.
   Each individual server process transmits new statistical counts to
   the collector just before going idle; so a query or transaction still in
   progress does not affect the displayed totals.  Also, the collector itself
   emits a new report at most once per <varname>PGSTAT_STAT_INTERVAL</varname>
   milliseconds (500 ms unless altered while building the server).  So the
   displayed information lags behind actual activity.  However, current-query
   information collected by <varname>track_activities</varname> is
   always up-to-date.
  </para>
____________________________________________________________________________-->
  <para>
   在使用统计信息监控收集到的数据时，你必须了解这些信息并非是实时更新的。每个独立的服务器进程只在进入闲置状态之前才向收集器传送新的统计计数；因此正在进行的查询或事务并不影响显示出来的总数。同样，收集器本身也最多每<varname>PGSTAT_STAT_INTERVAL</varname>毫秒（缺省为 500ms，除非在编译服务器的时候修改过）发送一 次新的报告。因此显示的信息总是落后于实际活动。但是由<varname>track_activities</varname>收集的当前查询信息总是最新的。
  </para>

<!--==========================orignal english content==========================
  <para>
   Another important point is that when a server process is asked to display
   any of these statistics, it first fetches the most recent report emitted by
   the collector process and then continues to use this snapshot for all
   statistical views and functions until the end of its current transaction.
   So the statistics will show static information as long as you continue the
   current transaction.  Similarly, information about the current queries of
   all sessions is collected when any such information is first requested
   within a transaction, and the same information will be displayed throughout
   the transaction.
   This is a feature, not a bug, because it allows you to perform several
   queries on the statistics and correlate the results without worrying that
   the numbers are changing underneath you.  But if you want to see new
   results with each query, be sure to do the queries outside any transaction
   block.  Alternatively, you can invoke
   <function>pg_stat_clear_snapshot</function>(), which will discard the
   current transaction's statistics snapshot (if any).  The next use of
   statistical information will cause a new snapshot to be fetched.
  </para>
____________________________________________________________________________-->
  <para>
   另一个重点是当一个服务器进程被要求显示任何这些统计信息时，它首先取得收集器进程最近发出的报告并且接着为所有统计视图和函数使用这个快照，直到它的当前事务的结尾。因此只要你继续当前事务，统计数据将会一直显示静态信息。相似地，当任何关于所有会话的当前查询的信息在一个事务中第一次被请求时，这样的信息将被收集。并且在整个事务期间将显示相同的信息。这是一种特性而非缺陷，因为它允许你在该统计信息上执行多个查询并且关联结果而不用担心那些数字会在你不知情的情况下改变。但是如果你希望用每个查询都看到新结果，要确保在任何事务块之外做那些查询。或者，你可以调用<function>pg_stat_clear_snapshot</function>()，那将丢弃当前事务的统计快照（如果有）。下一次对统计性信息的使用将导致获取一个新的快照。
  </para>

<!--==========================orignal english content==========================
  <para>
   A transaction can also see its own statistics (as yet untransmitted to the
   collector) in the views <structname>pg_stat_xact_all_tables</structname>,
   <structname>pg_stat_xact_sys_tables</structname>,
   <structname>pg_stat_xact_user_tables</structname>, and
   <structname>pg_stat_xact_user_functions</structname>.  These numbers do not act as
   stated above; instead they update continuously throughout the transaction.
  </para>
____________________________________________________________________________-->
  <para>
   一个事务也可以在视图<structname>pg_stat_xact_all_tables</structname>、<structname>pg_stat_xact_sys_tables</structname>、<structname>pg_stat_xact_user_tables</structname>和<structname>pg_stat_xact_user_functions</structname>中看到它自己的统计信息（还没有被传送给收集器）。这些数字并不像上面所述的那样行动，相反它们在事务期间持续被更新。
  </para>

<!--==========================orignal english content==========================
  <para>
   Some of the information in the dynamic statistics views shown in <xref
   linkend="monitoring-stats-dynamic-views-table"/> is security restricted.
   Ordinary users can only see all the information about their own sessions
   (sessions belonging to a role that they are a member of).  In rows about
   other sessions, many columns will be null.  Note, however, that the
   existence of a session and its general properties such as its sessions user
   and database are visible to all users.  Superusers and members of the
   built-in role <literal>pg_read_all_stats</literal> (see also <xref
   linkend="predefined-roles"/>) can see all the information about all sessions.
  </para>
____________________________________________________________________________-->
  <para>
   <xref linkend="monitoring-stats-dynamic-views-table"/>中显示的动态统计视图中的一些信息是有安全限制的。
   普通用户只能看到关于他们自己的会话的所有信息（属于他们是成员的角色的会话）。
   在关于其他会话的行中，许多列将为空。
   但是，请注意，一个会话的存在和它的一般属性，例如会话用户和数据库，对所有用户都是可见的。
   超级用户和内置角色<literal>pg_read_all_stats</literal>的成员（参见<xref linkend="predefined-roles"/>）可以看到所有会话的所有信息。
  </para>

  <table id="monitoring-stats-dynamic-views-table">
<!--==========================orignal english content==========================
   <title>Dynamic Statistics Views</title>
____________________________________________________________________________-->
   <title>动态统计视图</title>

   <tgroup cols="2">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>View Name</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>视图名称</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry>
       <structname>pg_stat_activity</structname>
       <indexterm><primary>pg_stat_activity</primary></indexterm>
      </entry>
      <entry>
       One row per server process, showing information related to
       the current activity of that process, such as state and current query.
       See <link linkend="monitoring-pg-stat-activity-view">
       <structname>pg_stat_activity</structname></link> for details.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>
       <structname>pg_stat_activity</structname>
       <indexterm><primary>pg_stat_activity</primary></indexterm>
      </entry>
      <entry>
       每个服务器进程一行，显示与那个进程的当前活动相关的信息，例如状态和当前查询。详见<link linkend="monitoring-pg-stat-activity-view"><structname>pg_stat_activity</structname></link> 。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_replication</structname><indexterm><primary>pg_stat_replication</primary></indexterm></entry>
      <entry>One row per WAL sender process, showing statistics about
       replication to that sender's connected standby server.
       See <link linkend="monitoring-pg-stat-replication-view">
       <structname>pg_stat_replication</structname></link> for details.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_replication</structname><indexterm><primary>pg_stat_replication</primary></indexterm></entry>
      <entry>每一个 WAL 发送进程一行，显示有关到该发送进程连接的后备服务器的复制的统计信息。
       详见<link linkend="monitoring-pg-stat-replication-view"><structname>pg_stat_replication</structname></link>.
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_wal_receiver</structname><indexterm><primary>pg_stat_wal_receiver</primary></indexterm></entry>
      <entry>Only one row, showing statistics about the WAL receiver from
       that receiver's connected server.
       See <link linkend="monitoring-pg-stat-wal-receiver-view">
       <structname>pg_stat_wal_receiver</structname></link> for details.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_wal_receiver</structname><indexterm><primary>pg_stat_wal_receiver</primary></indexterm></entry>
      <entry>只有一行，显示来自 WAL 接收器所连接服务器的有关该接收器的统计信息。详见<link linkend="monitoring-pg-stat-wal-receiver-view">
       <structname>pg_stat_wal_receiver</structname></link>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_subscription</structname><indexterm><primary>pg_stat_subscription</primary></indexterm></entry>
      <entry>At least one row per subscription, showing information about
       the subscription workers.
       See <link linkend="monitoring-pg-stat-subscription">
       <structname>pg_stat_subscription</structname></link> for details.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_subscription</structname><indexterm><primary>pg_stat_subscription</primary></indexterm></entry>
      <entry>每个订阅至少一行，显示有关该订阅的工作者的信息。详见<link linkend="monitoring-pg-stat-subscription">
       <structname>pg_stat_subscription</structname></link>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_ssl</structname><indexterm><primary>pg_stat_ssl</primary></indexterm></entry>
      <entry>One row per connection (regular and replication), showing information about
       SSL used on this connection.
       See <link linkend="monitoring-pg-stat-ssl-view">
       <structname>pg_stat_ssl</structname></link> for details.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_ssl</structname><indexterm><primary>pg_stat_ssl</primary></indexterm></entry>
      <entry>每个连接（常规的或者复制）一行，显示在这个连接上使用的SSL的信息。详见<link linkend="monitoring-pg-stat-ssl-view">
       <structname>pg_stat_ssl</structname></link>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_gssapi</structname><indexterm><primary>pg_stat_gssapi</primary></indexterm></entry>
      <entry>One row per connection (regular and replication), showing information about
       GSSAPI authentication and encryption used on this connection.
       See <link linkend="monitoring-pg-stat-gssapi-view">
       <structname>pg_stat_gssapi</structname></link> for details.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_gssapi</structname><indexterm><primary>pg_stat_gssapi</primary></indexterm></entry>
      <entry>每个连接（常规和复制）有一行，显示关于GSSAPI验证和加密的信息。详情请参阅 <link linkend="monitoring-pg-stat-gssapi-view">
       <structname>pg_stat_gssapi</structname></link>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_progress_analyze</structname><indexterm><primary>pg_stat_progress_analyze</primary></indexterm></entry>
      <entry>One row for each backend (including autovacuum worker processes) running
       <command>ANALYZE</command>, showing current progress.
       See <xref linkend='analyze-progress-reporting'/>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_progress_analyze</structname><indexterm><primary>pg_stat_progress_analyze</primary></indexterm></entry>
      <entry>每个运行<command>ANALYZE</command>的后端(包括自动清理工作者进程)的行，显示当前进度。参见<xref linkend='analyze-progress-reporting'/>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_progress_create_index</structname><indexterm><primary>pg_stat_progress_create_index</primary></indexterm></entry>
      <entry>One row for each backend running <command>CREATE INDEX</command> or <command>REINDEX</command>, showing
      current progress.
      See <xref linkend='create-index-progress-reporting'/>.
     </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_progress_create_index</structname><indexterm><primary>pg_stat_progress_create_index</primary></indexterm></entry>
      <entry>每个后台运行<command>CREATE INDEX</command>或<command>REINDEX</command>的后端都有一行，显示当前的进度。参见<xref linkend='create-index-progress-reporting'/>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_progress_vacuum</structname><indexterm><primary>pg_stat_progress_vacuum</primary></indexterm></entry>
      <entry>One row for each backend (including autovacuum worker processes) running
       <command>VACUUM</command>, showing current progress.
       See <xref linkend='vacuum-progress-reporting'/>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_progress_vacuum</structname><indexterm><primary>pg_stat_progress_vacuum</primary></indexterm></entry>
      <entry>每个运行着<command>VACUUM</command>的后端（包括autovacuum工作者进程）一行，显示当前的进度。详见<xref linkend='vacuum-progress-reporting'/>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_progress_cluster</structname><indexterm><primary>pg_stat_progress_cluster</primary></indexterm></entry>
      <entry>One row for each backend running
       <command>CLUSTER</command> or <command>VACUUM FULL</command>, showing current progress.
       See <xref linkend='cluster-progress-reporting'/>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_progress_cluster</structname><indexterm><primary>pg_stat_progress_cluster</primary></indexterm></entry>
      <entry>每个运行着<command>CLUSTER</command>或<command>VACUUM FULL</command>的后端一行，显示当前进度。参见 <xref linkend='cluster-progress-reporting'/>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_progress_basebackup</structname><indexterm><primary>pg_stat_progress_basebackup</primary></indexterm></entry>
      <entry>One row for each WAL sender process streaming a base backup,
       showing current progress.
       See <xref linkend='basebackup-progress-reporting'/>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_progress_basebackup</structname><indexterm><primary>pg_stat_progress_basebackup</primary></indexterm></entry>
      <entry>每一个WAL发送者进程的行显示一个基础备份，显示当前进度。参见<xref linkend='basebackup-progress-reporting'/>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_progress_copy</structname><indexterm><primary>pg_stat_progress_copy</primary></indexterm></entry>
      <entry>One row for each backend running <command>COPY</command>, showing current progress.
       See <xref linkend='copy-progress-reporting'/>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_progress_copy</structname><indexterm><primary>pg_stat_progress_copy</primary></indexterm></entry>
      <entry>对每个后端运行<command>COPY</command>的行, 显示当前进度。
       参见 <xref linkend='copy-progress-reporting'/>。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table id="monitoring-stats-views-table">
<!--==========================orignal english content==========================
   <title>Collected Statistics Views</title>
____________________________________________________________________________-->
   <title>已收集统计信息的视图</title>

   <tgroup cols="2">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>View Name</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>视图名称</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_archiver</structname><indexterm><primary>pg_stat_archiver</primary></indexterm></entry>
      <entry>One row only, showing statistics about the
       WAL archiver process's activity. See
       <link linkend="monitoring-pg-stat-archiver-view">
       <structname>pg_stat_archiver</structname></link> for details.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_archiver</structname><indexterm><primary>pg_stat_archiver</primary></indexterm></entry>
      <entry>只有一行，显示有关 WAL 归档进程活动的统计信息。详见<link linkend="monitoring-pg-stat-archiver-view">
       <structname>pg_stat_archiver</structname></link>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_bgwriter</structname><indexterm><primary>pg_stat_bgwriter</primary></indexterm></entry>
      <entry>One row only, showing statistics about the
       background writer process's activity. See
       <link linkend="monitoring-pg-stat-bgwriter-view">
       <structname>pg_stat_bgwriter</structname></link> for details.
     </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_bgwriter</structname><indexterm><primary>pg_stat_bgwriter</primary></indexterm></entry>
      <entry>只有一行，显示有关后台写进程的活动的统计信息。详见<link linkend="monitoring-pg-stat-bgwriter-view">
       <structname>pg_stat_bgwriter</structname></link>。
     </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_wal</structname><indexterm><primary>pg_stat_wal</primary></indexterm></entry>
      <entry>One row only, showing statistics about WAL activity. See
       <link linkend="monitoring-pg-stat-wal-view">
       <structname>pg_stat_wal</structname></link> for details.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_wal</structname><indexterm><primary>pg_stat_wal</primary></indexterm></entry>
      <entry>仅一行，显示WAL活动的统计信息。
       详请参见 <link linkend="monitoring-pg-stat-wal-view"> <structname>pg_stat_wal</structname></link> 。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_database</structname><indexterm><primary>pg_stat_database</primary></indexterm></entry>
      <entry>One row per database, showing database-wide statistics. See
       <link linkend="monitoring-pg-stat-database-view">
       <structname>pg_stat_database</structname></link> for details.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_database</structname><indexterm><primary>pg_stat_database</primary></indexterm></entry>
      <entry>每个数据库一行，显示数据库范围的统计信息。详见<link linkend="monitoring-pg-stat-database-view">
       <structname>pg_stat_database</structname></link>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_database_conflicts</structname><indexterm><primary>pg_stat_database_conflicts</primary></indexterm></entry>
      <entry>
       One row per database, showing database-wide statistics about
       query cancels due to conflict with recovery on standby servers.
       See <link linkend="monitoring-pg-stat-database-conflicts-view">
       <structname>pg_stat_database_conflicts</structname></link> for details.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_database_conflicts</structname><indexterm><primary>pg_stat_database_conflicts</primary></indexterm></entry>
      <entry>
       每个数据库一行，显示数据库范围的统计信息，
       这些信息的内容是关于由于与后备服务器的恢复过程
       发生冲突而被取消的查询。详见<link linkend="monitoring-pg-stat-database-conflicts-view">
       <structname>pg_stat_database_conflicts</structname></link>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_all_tables</structname><indexterm><primary>pg_stat_all_tables</primary></indexterm></entry>
      <entry>
       One row for each table in the current database, showing statistics
       about accesses to that specific table.
       See <link linkend="monitoring-pg-stat-all-tables-view">
       <structname>pg_stat_all_tables</structname></link> for details.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_all_tables</structname><indexterm><primary>pg_stat_all_tables</primary></indexterm></entry>
      <entry>
       当前数据库中每个表一行，显示有关访问指定表的统计信息。详见<link linkend="monitoring-pg-stat-all-tables-view">
       <structname>pg_stat_all_tables</structname></link>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_sys_tables</structname><indexterm><primary>pg_stat_sys_tables</primary></indexterm></entry>
      <entry>Same as <structname>pg_stat_all_tables</structname>, except that only
      system tables are shown.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_sys_tables</structname><indexterm><primary>pg_stat_sys_tables</primary></indexterm></entry>
      <entry>和<structname>pg_stat_all_tables</structname>一样，但只显示系统表。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_user_tables</structname><indexterm><primary>pg_stat_user_tables</primary></indexterm></entry>
      <entry>Same as <structname>pg_stat_all_tables</structname>, except that only user
      tables are shown.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_user_tables</structname><indexterm><primary>pg_stat_user_tables</primary></indexterm></entry>
      <entry>和<structname>pg_stat_all_tables</structname>一样，但只显示用户表。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_xact_all_tables</structname><indexterm><primary>pg_stat_xact_all_tables</primary></indexterm></entry>
      <entry>Similar to <structname>pg_stat_all_tables</structname>, but counts actions
      taken so far within the current transaction (which are <emphasis>not</emphasis>
      yet included in <structname>pg_stat_all_tables</structname> and related views).
      The columns for numbers of live and dead rows and vacuum and
      analyze actions are not present in this view.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_xact_all_tables</structname><indexterm><primary>pg_stat_xact_all_tables</primary></indexterm></entry>
      <entry>和<structname>pg_stat_all_tables</structname>相似，但计数动作只在当前事务内发生（还<emphasis>没有</emphasis>被包括在<structname>pg_stat_all_tables</structname>和相关视图中）。用于生存和死亡行数量的列以及清理和分析动作在此视图中不出现。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_xact_sys_tables</structname><indexterm><primary>pg_stat_xact_sys_tables</primary></indexterm></entry>
      <entry>Same as <structname>pg_stat_xact_all_tables</structname>, except that only
      system tables are shown.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_xact_sys_tables</structname><indexterm><primary>pg_stat_xact_sys_tables</primary></indexterm></entry>
      <entry>和<structname>pg_stat_xact_all_tables</structname>一样，但只显示系统表。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_xact_user_tables</structname><indexterm><primary>pg_stat_xact_user_tables</primary></indexterm></entry>
      <entry>Same as <structname>pg_stat_xact_all_tables</structname>, except that only
      user tables are shown.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_xact_user_tables</structname><indexterm><primary>pg_stat_xact_user_tables</primary></indexterm></entry>
      <entry>和<structname>pg_stat_xact_all_tables</structname>一样，但只显示用户表。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_all_indexes</structname><indexterm><primary>pg_stat_all_indexes</primary></indexterm></entry>
      <entry>
       One row for each index in the current database, showing statistics
       about accesses to that specific index.
       See <link linkend="monitoring-pg-stat-all-indexes-view">
       <structname>pg_stat_all_indexes</structname></link> for details.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_all_indexes</structname><indexterm><primary>pg_stat_all_indexes</primary></indexterm></entry>
      <entry>
       当前数据库中的每个索引一行，显示：表OID、索引OID、模式名、表名、索引名、 使用了该索引的索引扫描总数、索引扫描返回的索引记录数、使用该索引的简 单索引扫描抓取的活表(livetable)中数据行数。
       当前数据库中的每个索引一行，显示与访问指定索引有关的统计信息。详见<link linkend="monitoring-pg-stat-all-indexes-view">
       <structname>pg_stat_all_indexes</structname></link>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_sys_indexes</structname><indexterm><primary>pg_stat_sys_indexes</primary></indexterm></entry>
      <entry>Same as <structname>pg_stat_all_indexes</structname>, except that only
      indexes on system tables are shown.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_sys_indexes</structname><indexterm><primary>pg_stat_sys_indexes</primary></indexterm></entry>
      <entry>和<structname>pg_stat_all_indexes</structname>一样，但只显示系统表上的索引。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_user_indexes</structname><indexterm><primary>pg_stat_user_indexes</primary></indexterm></entry>
      <entry>Same as <structname>pg_stat_all_indexes</structname>, except that only
      indexes on user tables are shown.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_user_indexes</structname><indexterm><primary>pg_stat_user_indexes</primary></indexterm></entry>
      <entry>和<structname>pg_stat_all_indexes</structname>一样，但只显示用户表上的索引。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_statio_all_tables</structname><indexterm><primary>pg_statio_all_tables</primary></indexterm></entry>
      <entry>
       One row for each table in the current database, showing statistics
       about I/O on that specific table.
       See <link linkend="monitoring-pg-statio-all-tables-view">
       <structname>pg_statio_all_tables</structname></link> for details.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_statio_all_tables</structname><indexterm><primary>pg_statio_all_tables</primary></indexterm></entry>
      <entry>
       当前数据库中每个表一行(包括TOAST表)，显示：表OID、模式名、表名、 从该表中读取的磁盘块总数、缓冲区命中次数、该表上所有索引的磁盘块读取总数、 该表上所有索引的缓冲区命中总数、在该表的辅助TOAST表(如果存在)上的磁盘块读取总数、 在该表的辅助TOAST表(如果存在)上的缓冲区命中总数、TOAST表的索引的磁盘块读 取总数、TOAST表的索引的缓冲区命中总数。
       当前数据库中的每个表一行，显示有关在指定表上 I/O 的统计信息。详见<link linkend="monitoring-pg-statio-all-tables-view">
       <structname>pg_statio_all_tables</structname></link>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_statio_sys_tables</structname><indexterm><primary>pg_statio_sys_tables</primary></indexterm></entry>
      <entry>Same as <structname>pg_statio_all_tables</structname>, except that only
      system tables are shown.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_statio_sys_tables</structname><indexterm><primary>pg_statio_sys_tables</primary></indexterm></entry>
      <entry>和<structname>pg_statio_all_tables</structname>一样，但只显示系统表。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_statio_user_tables</structname><indexterm><primary>pg_statio_user_tables</primary></indexterm></entry>
      <entry>Same as <structname>pg_statio_all_tables</structname>, except that only
      user tables are shown.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_statio_user_tables</structname><indexterm><primary>pg_statio_user_tables</primary></indexterm></entry>
      <entry>和<structname>pg_statio_all_tables</structname>一样，但只显示用户表。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_statio_all_indexes</structname><indexterm><primary>pg_statio_all_indexes</primary></indexterm></entry>
      <entry>
       One row for each index in the current database,
       showing statistics about I/O on that specific index.
       See <link linkend="monitoring-pg-statio-all-indexes-view">
       <structname>pg_statio_all_indexes</structname></link> for details.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_statio_all_indexes</structname><indexterm><primary>pg_statio_all_indexes</primary></indexterm></entry>
      <entry>
       当前数据库中每个索引一行，显示：表OID、索引OID、模式名、 表名、索引名、该索引的磁盘块读取总数、该索引的缓冲区命中总数。
       当前数据库中的每个索引一行，显示与指定索引上的 I/O 有关的统计信息。详见<link linkend="monitoring-pg-statio-all-indexes-view">
       <structname>pg_statio_all_indexes</structname></link>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_statio_sys_indexes</structname><indexterm><primary>pg_statio_sys_indexes</primary></indexterm></entry>
      <entry>Same as <structname>pg_statio_all_indexes</structname>, except that only
      indexes on system tables are shown.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_statio_sys_indexes</structname><indexterm><primary>pg_statio_sys_indexes</primary></indexterm></entry>
      <entry>和<structname>pg_statio_all_indexes</structname>一样，但只显示系统表上的索引。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_statio_user_indexes</structname><indexterm><primary>pg_statio_user_indexes</primary></indexterm></entry>
      <entry>Same as <structname>pg_statio_all_indexes</structname>, except that only
      indexes on user tables are shown.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_statio_user_indexes</structname><indexterm><primary>pg_statio_user_indexes</primary></indexterm></entry>
      <entry>和<structname>pg_statio_all_indexes</structname>一样，但只显示用户表上的索引。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_statio_all_sequences</structname><indexterm><primary>pg_statio_all_sequences</primary></indexterm></entry>
     <entry>
       One row for each sequence in the current database,
       showing statistics about I/O on that specific sequence.
       See <link linkend="monitoring-pg-statio-all-sequences-view">
       <structname>pg_statio_all_sequences</structname></link> for details.
     </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_statio_all_sequences</structname><indexterm><primary>pg_statio_all_sequences</primary></indexterm></entry>
     <entry>
       当前数据库中每个序列对象一行，显示：序列OID、模式名、序列名、序列的磁盘读取总数、序列的缓冲区命中总数。
       当前数据库中的每个序列一行，显示与指定序列上的 I/O 有关的统计信息。详见<link linkend="monitoring-pg-statio-all-sequences-view">
       <structname>pg_statio_all_sequences</structname></link>。
     </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_statio_sys_sequences</structname><indexterm><primary>pg_statio_sys_sequences</primary></indexterm></entry>
      <entry>Same as <structname>pg_statio_all_sequences</structname>, except that only
      system sequences are shown.  (Presently, no system sequences are defined,
      so this view is always empty.)</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_statio_sys_sequences</structname><indexterm><primary>pg_statio_sys_sequences</primary></indexterm></entry>
      <entry>和<structname>pg_statio_all_sequences</structname>一样，但只显示系统序列（目前没有定义系统序列，因此这个视图总是为空）。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_statio_user_sequences</structname><indexterm><primary>pg_statio_user_sequences</primary></indexterm></entry>
      <entry>Same as <structname>pg_statio_all_sequences</structname>, except that only
      user sequences are shown.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_statio_user_sequences</structname><indexterm><primary>pg_statio_user_sequences</primary></indexterm></entry>
      <entry>和<structname>pg_statio_all_sequences</structname>一样，但只显示用户序列。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_user_functions</structname><indexterm><primary>pg_stat_user_functions</primary></indexterm></entry>
      <entry>
       One row for each tracked function, showing statistics
       about executions of that function. See
       <link linkend="monitoring-pg-stat-user-functions-view">
       <structname>pg_stat_user_functions</structname></link> for details.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_user_functions</structname><indexterm><primary>pg_stat_user_functions</primary></indexterm></entry>
      <entry>
       对于所有跟踪功能，函数的OID，模式，名称，数量 通话总时间，和自我的时间。自我时间是 在函数本身所花费的时间量，总时间包括 它调用函数所花费的时间。时间值以毫秒为单位。
       每一个被跟踪的函数一行，显示与执行该函数有关的统计信息。详见<link linkend="monitoring-pg-stat-user-functions-view">
       <structname>pg_stat_user_functions</structname></link>。
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_xact_user_functions</structname><indexterm><primary>pg_stat_xact_user_functions</primary></indexterm></entry>
      <entry>Similar to <structname>pg_stat_user_functions</structname>, but counts only
      calls during the current transaction (which are <emphasis>not</emphasis>
      yet included in <structname>pg_stat_user_functions</structname>).</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_xact_user_functions</structname><indexterm><primary>pg_stat_xact_user_functions</primary></indexterm></entry>
      <entry>和<structname>pg_stat_user_functions</structname>相似，但是只统计在当前事务期间的调用（还<emphasis>没有</emphasis>被包括在<structname>pg_stat_user_functions</structname>中）。</entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_slru</structname><indexterm><primary>pg_stat_slru</primary></indexterm></entry>
      <entry>One row per SLRU, showing statistics of operations. See
       <link linkend="monitoring-pg-stat-slru-view">
       <structname>pg_stat_slru</structname></link> for details.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_slru</structname><indexterm><primary>pg_stat_slru</primary></indexterm></entry>
      <entry>每个SLRU一行, 显示操作的统计信息。参见<link linkend="monitoring-pg-stat-slru-view">
       <structname>pg_stat_slru</structname></link> for details.
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry><structname>pg_stat_replication_slots</structname><indexterm><primary>pg_stat_replication_slots</primary></indexterm></entry>
      <entry>One row per replication slot, showing statistics about the
       replication slot's usage. See
       <link linkend="monitoring-pg-stat-replication-slots-view">
       <structname>pg_stat_replication_slots</structname></link> for details.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><structname>pg_stat_replication_slots</structname><indexterm><primary>pg_stat_replication_slots</primary></indexterm></entry>
      <entry>每个复制槽一行，显示关于复制槽的利用率的统计信息。
       详请参见<link linkend="monitoring-pg-stat-replication-slots-view"> <structname>pg_stat_replication_slots</structname></link>。
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   The per-index statistics are particularly useful to determine which
   indexes are being used and how effective they are.
  </para>
____________________________________________________________________________-->
  <para>
   针对每个索引的统计信息对于判断哪个索引正被使用以及它们的效果特别有用。
  </para>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_statio_</structname> views are primarily useful to
   determine the effectiveness of the buffer cache.  When the number
   of actual disk reads is much smaller than the number of buffer
   hits, then the cache is satisfying most read requests without
   invoking a kernel call. However, these statistics do not give the
   entire story: due to the way in which <productname>PostgreSQL</productname>
   handles disk I/O, data that is not in the
   <productname>PostgreSQL</productname> buffer cache might still reside in the
   kernel's I/O cache, and might therefore still be fetched without
   requiring a physical read. Users interested in obtaining more
   detailed information on <productname>PostgreSQL</productname> I/O behavior are
   advised to use the <productname>PostgreSQL</productname> statistics collector
   in combination with operating system utilities that allow insight
   into the kernel's handling of I/O.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_statio_</structname>系列视图主要用于判断缓冲区的效果。当实际磁盘读取数远小于缓冲区命中时，这个缓冲能满足大部分读请求而无需进行内核调用。但是，这些统计信息并没有给出所有的事情：由于<productname>PostgreSQL</productname>处理磁盘 I/O 的方式，不在<productname>PostgreSQL</productname>缓冲区中的数据库仍然驻留在内核的 I/O 缓存中，并且因此可以被再次读取而不需要物理磁盘读取。我们建议希望了解<productname>PostgreSQL</productname> I/O 行为更多细节的用户将<productname>PostgreSQL</productname>统计收集器和操作系统中允许观察内核处理 I/O 的工具一起使用。
  </para>

 </sect2>

 <sect2 id="monitoring-pg-stat-activity-view">
<!--==========================orignal english content==========================
  <title><structname>pg_stat_activity</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_stat_activity</structname></title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>pg_stat_activity</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>pg_stat_activity</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_stat_activity</structname> view will have one row
   per server process, showing information related to
   the current activity of that process.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_stat_activity</structname>视图每个服务器进程将有一行，显示与该进程当前活动相关的信息。
  </para>

  <table id="pg-stat-activity-view" xreflabel="pg_stat_activity">
<!--==========================orignal english content==========================
   <title><structname>pg_stat_activity</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_stat_activity</structname> 视图</title>
   <tgroup cols="1">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the database this backend is connected to
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datid</structfield> <type>oid</type>
      </para>
      <para>
       这个后端连接到的数据库的OID
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datname</structfield> <type>name</type>
      </para>
      <para>
       Name of the database this backend is connected to
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datname</structfield> <type>name</type>
      </para>
      <para>
       这个后端连接到的数据库的名称
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       Process ID of this backend
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       这个后端的进程 ID
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>leader_pid</structfield> <type>integer</type>
      </para>
      <para>
       Process ID of the parallel group leader, if this process is a
       parallel query worker.  <literal>NULL</literal> if this process is a
       parallel group leader or does not participate in parallel query.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>leader_pid</structfield> <type>integer</type>
      </para>
      <para>
       并行组组长的进程ID，如果该进程是并行查询工作者。如果该进程是一个并行组的组长或不参与并行查询，则为<literal>NULL</literal>。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>usesysid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the user logged into this backend
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>usesysid</structfield> <type>oid</type>
      </para>
      <para>
       登录到这个后端的用户的 OID
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>usename</structfield> <type>name</type>
      </para>
      <para>
       Name of the user logged into this backend
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>usename</structfield> <type>name</type>
      </para>
      <para>
       登录到这个后端的用户的 OID
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>application_name</structfield> <type>text</type>
      </para>
      <para>
       Name of the application that is connected
       to this backend
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>application_name</structfield> <type>text</type>
      </para>
      <para>
       连接到这个后端的应用的名称
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>client_addr</structfield> <type>inet</type>
      </para>
      <para>
       IP address of the client connected to this backend.
       If this field is null, it indicates either that the client is
       connected via a Unix socket on the server machine or that this is an
       internal process such as autovacuum.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>client_addr</structfield> <type>inet</type>
      </para>
      <para>
       连接到这个后端的客户端的 IP 地址。如果这个字段为空，它表示客户端通过服务器机器上的一个 Unix 套接字连接或者这是一个内部进程，如自动清理。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>client_hostname</structfield> <type>text</type>
      </para>
      <para>
       Host name of the connected client, as reported by a
       reverse DNS lookup of <structfield>client_addr</structfield>. This field will
       only be non-null for IP connections, and only when <xref linkend="guc-log-hostname"/> is enabled.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>client_hostname</structfield> <type>text</type>
      </para>
      <para>
       已连接的客户端的主机名，由<structfield>client_addr</structfield>的反向 DNS 查找报告。
	   这个字段将只对 IP 连接非空，并且只有 <xref linkend="guc-log-hostname"/>被启用时才会非空。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>client_port</structfield> <type>integer</type>
      </para>
      <para>
       TCP port number that the client is using for communication
       with this backend, or <literal>-1</literal> if a Unix socket is used.
       If this field is null, it indicates that this is an internal server process.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>client_port</structfield> <type>integer</type>
      </para>
      <para>
       客户端用于与此后端通信的TCP端口号，如果使用Unix套接字，则为<literal>-1</literal>。如果该字段为空，它表示这是一个内部服务器进程。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>backend_start</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Time when this process was started.  For client backends,
       this is the time the client connected to the server.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>backend_start</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       这个进程被启动的时间。对客户端后端来说，这就是客户端连接到服务器的时间。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>xact_start</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Time when this process' current transaction was started, or null
       if no transaction is active. If the current
       query is the first of its transaction, this column is equal to the
       <structfield>query_start</structfield> column.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>xact_start</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       这个进程的当前事务被启动的时间，如果没有活动事务则为空。
       如果当前查询是它的第一个事务，这一列等于<structfield>query_start</structfield>列。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>query_start</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Time when the currently active query was started, or if
       <structfield>state</structfield> is not <literal>active</literal>, when the last query
       was started
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>query_start</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       当前活动查询被开始的时间，如果<structfield>state</structfield>不是<literal>active</literal>，则为上一个查询开始的时间
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>state_change</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Time when the <structfield>state</structfield> was last changed
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>state_change</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       <structfield>state</structfield>上一次被改变的时间
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wait_event_type</structfield> <type>text</type>
      </para>
      <para>
       The type of event for which the backend is waiting, if any;
       otherwise NULL.  See <xref linkend="wait-event-table"/>.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wait_event_type</structfield> <type>text</type>
      </para>
      <para>
       后端等待的事件类型，如果有的话;否则NULL。参见<xref linkend="wait-event-table"/>。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wait_event</structfield> <type>text</type>
      </para>
      <para>
       Wait event name if backend is currently waiting, otherwise NULL.
       See <xref linkend="wait-event-activity-table"/> through
       <xref linkend="wait-event-timeout-table"/>.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wait_event</structfield> <type>text</type>
      </para>
      <para>
       如果后端当前正在等待，则等待事件名称，否则为NULL。参见<xref linkend="wait-event-activity-table"/> 到
       <xref linkend="wait-event-timeout-table"/>。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>state</structfield> <type>text</type>
      </para>
      <para>
       Current overall state of this backend.
       Possible values are:
       <itemizedlist>
        <listitem>
        <para>
          <literal>active</literal>: The backend is executing a query.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>idle</literal>: The backend is waiting for a new client command.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>idle in transaction</literal>: The backend is in a transaction,
          but is not currently executing a query.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>idle in transaction (aborted)</literal>: This state is similar to
          <literal>idle in transaction</literal>, except one of the statements in
          the transaction caused an error.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>fastpath function call</literal>: The backend is executing a
          fast-path function.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>disabled</literal>: This state is reported if <xref linkend="guc-track-activities"/> is disabled in this backend.
         </para>
       </listitem>
       </itemizedlist>
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>state</structfield> <type>text</type>
      </para>
      <para>
       这个后端的当前总体状态。可能的值为：
       <itemizedlist>
        <listitem>
        <para>
          <literal>active</literal>: 后端正在执行一个查询。
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>idle</literal>: 后端正在等待一个新的客户端命令。
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>idle in transaction</literal>: 后端在一个事务中，但是当前没有正在执行一个查询。
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>idle in transaction (aborted)</literal>: 这个状态与
          <literal>idle in transaction</literal>相似，除了在该事务中的一个语句导致了一个错误。
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>fastpath function call</literal>: 后端正在执行一个 fast-path 函数。
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>disabled</literal>: 如果在这个后端中<xref linkend="guc-track-activities"/>被禁用，则报告这个状态。
         </para>
       </listitem>
       </itemizedlist>
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>backend_xid</structfield> <type>xid</type>
      </para>
      <para>
       Top-level transaction identifier of this backend, if any.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>backend_xid</structfield> <type>xid</type>
      </para>
      <para>
       这个后端的顶层事务标识符，如果存在。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>backend_xmin</structfield> <type>xid</type>
      </para>
      <para>
       The current backend's <literal>xmin</literal> horizon.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>backend_xmin</structfield> <type>xid</type>
      </para>
      <para>
       当前后端的<literal>xmin</literal>范围。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>query_id</structfield> <type>bigint</type>
     </para>
     <para>
      Identifier of this backend's most recent query. If
      <structfield>state</structfield> is <literal>active</literal> this
      field shows the identifier of the currently executing query. In
      all other states, it shows the identifier of last query that was
      executed.  Query identifiers are not computed by default so this
      field will be null unless <xref linkend="guc-compute-query-id"/>
      parameter is enabled or a third-party module that computes query
      identifiers is configured.
     </para></entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry role="catalog_table_entry"><para role="column_definition">
      <structfield>query_id</structfield> <type>bigint</type>
     </para>
     <para>
      这个后端的最近查询的标识符。
      如果<structfield>state</structfield>是<literal>active</literal>，这个字段显示当前正在执行的查询的标识符。
      在所有其他状态，它显示执行的最后一个查询的标识符。
      默认不计算查询标识符，因此该字段将为空，除非启用<xref linkend="guc-compute-query-id"/>参数或配置了计算查询标识符的第三方模块。
     </para></entry>
    </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>query</structfield> <type>text</type>
      </para>
      <para>
       Text of this backend's most recent query. If
       <structfield>state</structfield> is <literal>active</literal> this field shows the
       currently executing query. In all other states, it shows the last query
       that was executed. By default the query text is truncated at 1024
       bytes; this value can be changed via the parameter
       <xref linkend="guc-track-activity-query-size"/>.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>query</structfield> <type>text</type>
      </para>
      <para>
       这个后端最近查询的文本。如果<structfield>state</structfield>为<literal>active</literal>，这个字段显示当前正在执行的查询。
       在所有其他状态下，它显示上一个被执行的查询。默认情况下，查询文本会被截断至1024个字节，这个值可以通过参数<xref linkend="guc-track-activity-query-size"/>更改。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>backend_type</structfield> <type>text</type>
      </para>
      <para>
       Type of current backend. Possible types are
       <literal>autovacuum launcher</literal>, <literal>autovacuum worker</literal>,
       <literal>logical replication launcher</literal>,
       <literal>logical replication worker</literal>,
       <literal>parallel worker</literal>, <literal>background writer</literal>,
       <literal>client backend</literal>, <literal>checkpointer</literal>,
       <literal>archiver</literal>,
       <literal>startup</literal>, <literal>walreceiver</literal>,
       <literal>walsender</literal> and <literal>walwriter</literal>.
       In addition, background workers registered by extensions may have
       additional types.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>backend_type</structfield> <type>text</type>
      </para>
      <para>
       当前后端的类型。可能的类型为
       <literal>autovacuum launcher</literal>, <literal>autovacuum worker</literal>,
       <literal>logical replication launcher</literal>,
       <literal>logical replication worker</literal>,
       <literal>parallel worker</literal>, <literal>background writer</literal>,
       <literal>client backend</literal>, <literal>checkpointer</literal>,
       <literal>archiver</literal>,
       <literal>startup</literal>, <literal>walreceiver</literal>,
       <literal>walsender</literal> and <literal>walwriter</literal>.
       除此以外，由扩展注册的后台Worker可能有额外的类型。
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
<!--==========================orignal english content==========================
   <para>
    The <structfield>wait_event</structfield> and <structfield>state</structfield> columns are
    independent.  If a backend is in the <literal>active</literal> state,
    it may or may not be <literal>waiting</literal> on some event.  If the state
    is <literal>active</literal> and <structfield>wait_event</structfield> is non-null, it
    means that a query is being executed, but is being blocked somewhere
    in the system.
   </para>
____________________________________________________________________________-->
   <para>
    <structfield>wait_event</structfield>和<structfield>state</structfield>列是独立的。如果一个后端处于<literal>active</literal>状态，它可能是也可能不是某个事件上的<literal>waiting</literal>。如果状态是<literal>active</literal>并且<structfield>wait_event</structfield>为非空，它意味着一个查询正在被执行，但是它被阻塞在系统中某处。
   </para>
  </note>

  <table id="wait-event-table">
<!--==========================orignal english content==========================
   <title>Wait Event Types</title>
____________________________________________________________________________-->
   <title>等待事件类型</title>
   <tgroup cols="2">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Wait Event Type</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>等待事件类型</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>Activity</literal></entry>
      <entry>The server process is idle.  This event type indicates a process
       waiting for activity in its main processing loop.
       <literal>wait_event</literal> will identify the specific wait point;
       see <xref linkend="wait-event-activity-table"/>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>Activity</literal></entry>
      <entry>服务器进程空闲。此事件类型表示在其主处理循环中等待活动的进程。
       <literal>wait_event</literal>将识别特定的等待点;参见<xref linkend="wait-event-activity-table"/>。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>BufferPin</literal></entry>
      <entry>The server process is waiting for exclusive access to
       a data buffer.  Buffer pin waits can be protracted if
       another process holds an open cursor that last read data from the
       buffer in question. See <xref linkend="wait-event-bufferpin-table"/>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>BufferPin</literal></entry>
      <entry>服务器进程正在等待对数据缓冲的独占访问。
       如果另一个进程持有一个打开的游标，该游标最后一次从相关缓冲区读取数据，则缓冲区销等待可能是漫长的。
       参见<xref linkend="wait-event-bufferpin-table"/>。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>Client</literal></entry>
      <entry>The server process is waiting for activity on a socket
       connected to a user application.  Thus, the server expects something
       to happen that is independent of its internal processes.
       <literal>wait_event</literal> will identify the specific wait point;
       see <xref linkend="wait-event-client-table"/>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>Client</literal></entry>
      <entry>服务器进程正在等待连接到用户应用程序的套接字上的活动。
       因此，服务器预计发生一些独立于其内部进程的事情。<literal>wait_event</literal>将识别特定的等待点；参见<xref linkend="wait-event-client-table"/>。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>Extension</literal></entry>
      <entry>The server process is waiting for some condition defined by an
       extension module.
       See <xref linkend="wait-event-extension-table"/>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>Extension</literal></entry>
      <entry>服务器进程正在等待扩展模块定义的某个条件。参见<xref linkend="wait-event-extension-table"/>。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>IO</literal></entry>
      <entry>The server process is waiting for an I/O operation to complete.
       <literal>wait_event</literal> will identify the specific wait point;
       see <xref linkend="wait-event-io-table"/>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>IO</literal></entry>
      <entry>服务器进程正在等待一个I/O操作完成。<literal>wait_event</literal>将识别特定的等待点；参见<xref linkend="wait-event-io-table"/>。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>IPC</literal></entry>
      <entry>The server process is waiting for some interaction with
       another server process.  <literal>wait_event</literal> will
       identify the specific wait point;
       see <xref linkend="wait-event-ipc-table"/>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>IPC</literal></entry>
      <entry>服务器进程正在等待与另一个服务器进程进行交互。<literal>wait_event</literal>将识别特定的等待点;参见<xref linkend="wait-event-ipc-table"/>。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>Lock</literal></entry>
      <entry>The server process is waiting for a heavyweight lock.
       Heavyweight locks, also known as lock manager locks or simply locks,
       primarily protect SQL-visible objects such as tables.  However,
       they are also used to ensure mutual exclusion for certain internal
       operations such as relation extension.  <literal>wait_event</literal>
       will identify the type of lock awaited;
       see <xref linkend="wait-event-lock-table"/>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>Lock</literal></entry>
      <entry>服务器进程正在等待一个重量级锁。重量级锁，也称为锁管理器锁或简单锁，主要保护表等SQL可见对象。
       然而，它们也用于确保某些内部操作的互斥，例如关系扩展。<literal>wait_event</literal>将识别等待的锁的类型；参见<xref linkend="wait-event-lock-table"/>。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>LWLock</literal></entry>
      <entry> The server process is waiting for a lightweight lock.
       Most such locks protect a particular data structure in shared memory.
       <literal>wait_event</literal> will contain a name identifying the purpose
       of the lightweight lock.  (Some locks have specific names; others
       are part of a group of locks each with a similar purpose.)
       See <xref linkend="wait-event-lwlock-table"/>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>LWLock</literal></entry>
      <entry> 服务器进程正在等待一个轻量级锁。大多数这样的锁保护共享内存中的特定数据结构。
       <literal>wait_event</literal>将包含标识轻量级锁用途的名称。
       (有些锁有特定的名称；其他锁是一组锁的一部分，每个锁具有类似的目的。)参见<xref linkend="wait-event-lwlock-table"/>。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>Timeout</literal></entry>
      <entry>The server process is waiting for a timeout
       to expire.  <literal>wait_event</literal> will identify the specific wait
       point; see <xref linkend="wait-event-timeout-table"/>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>Timeout</literal></entry>
      <entry>服务器进程正在等待超时过期。<literal>wait_event</literal>将识别特定的等待点；参见<xref linkend="wait-event-timeout-table"/>。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table id="wait-event-activity-table">
<!--==========================orignal english content==========================
   <title>Wait Events of Type <literal>Activity</literal></title>
____________________________________________________________________________-->
   <title><literal>Activity</literal>类型的等待事件</title>
   <tgroup cols="2">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>Activity</literal> Wait Event</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>Activity</literal> 等待事件</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>ArchiverMain</literal></entry>
      <entry>Waiting in main loop of archiver process.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ArchiverMain</literal></entry>
      <entry>在归档进程的主循环中等待。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>AutoVacuumMain</literal></entry>
      <entry>Waiting in main loop of autovacuum launcher process.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>AutoVacuumMain</literal></entry>
      <entry>在自动清理启动过程的主循环中等待。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>BgWriterHibernate</literal></entry>
      <entry>Waiting in background writer process, hibernating.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>BgWriterHibernate</literal></entry>
      <entry>在后台写进程中等待，休眠状态。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>BgWriterMain</literal></entry>
      <entry>Waiting in main loop of background writer process.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>BgWriterMain</literal></entry>
      <entry>在后台写进程主循环中等待。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>CheckpointerMain</literal></entry>
      <entry>Waiting in main loop of checkpointer process.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>CheckpointerMain</literal></entry>
      <entry>在校验指针进程的主循环中等待。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>LogicalApplyMain</literal></entry>
      <entry>Waiting in main loop of logical replication apply process.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>LogicalApplyMain</literal></entry>
      <entry>在逻辑复制应用进程的主循环中等待。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>LogicalLauncherMain</literal></entry>
      <entry>Waiting in main loop of logical replication launcher process.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>LogicalLauncherMain</literal></entry>
      <entry>在逻辑复制启动器进程的主循环中等待。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>PgStatMain</literal></entry>
      <entry>Waiting in main loop of statistics collector process.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>PgStatMain</literal></entry>
      <entry>在统计收集器进程的主循环中等待。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>RecoveryWalStream</literal></entry>
      <entry>Waiting in main loop of startup process for WAL to arrive, during
       streaming recovery.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>RecoveryWalStream</literal></entry>
      <entry>流恢复期间，在启动进程主循环等待WAL到达。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>SysLoggerMain</literal></entry>
      <entry>Waiting in main loop of syslogger process.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>SysLoggerMain</literal></entry>
      <entry>在syslogger进程的主循环中等待。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>WalReceiverMain</literal></entry>
      <entry>Waiting in main loop of WAL receiver process.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>WalReceiverMain</literal></entry>
      <entry>在WAL接收器进程的主循环中等待。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>WalSenderMain</literal></entry>
      <entry>Waiting in main loop of WAL sender process.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>WalSenderMain</literal></entry>
      <entry>在WAL发送者进程的主循环中等待。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>WalWriterMain</literal></entry>
      <entry>Waiting in main loop of WAL writer process.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>WalWriterMain</literal></entry>
      <entry>在WAL写入进程的主循环中等待。</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table id="wait-event-bufferpin-table">
<!--==========================orignal english content==========================
   <title>Wait Events of Type <literal>BufferPin</literal></title>
____________________________________________________________________________-->
   <title><literal>BufferPin</literal>类型的等待事件</title>
   <tgroup cols="2">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>BufferPin</literal> Wait Event</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>BufferPin</literal> 等待事件</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>BufferPin</literal></entry>
      <entry>Waiting to acquire an exclusive pin on a buffer.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>BufferPin</literal></entry>
      <entry>等待获得缓冲区上的独占销。</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table id="wait-event-client-table">
<!--==========================orignal english content==========================
   <title>Wait Events of Type <literal>Client</literal></title>
____________________________________________________________________________-->
   <title><literal>Client</literal>类型的等待事件</title>
   <tgroup cols="2">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>Client</literal> Wait Event</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>Client</literal> 等待事件</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>ClientRead</literal></entry>
      <entry>Waiting to read data from the client.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ClientRead</literal></entry>
      <entry>等待从客户端读取数据。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>ClientWrite</literal></entry>
      <entry>Waiting to write data to the client.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ClientWrite</literal></entry>
      <entry>等待写入数据到客户端。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>GSSOpenServer</literal></entry>
      <entry>Waiting to read data from the client while establishing a GSSAPI
       session.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>GSSOpenServer</literal></entry>
      <entry>在建立GSSAPI会话时等待从客户端读取数据。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>LibPQWalReceiverConnect</literal></entry>
      <entry>Waiting in WAL receiver to establish connection to remote
       server.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>LibPQWalReceiverConnect</literal></entry>
      <entry>在WAL接收器等待与远程服务器建立连接。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>LibPQWalReceiverReceive</literal></entry>
      <entry>Waiting in WAL receiver to receive data from remote server.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>LibPQWalReceiverReceive</literal></entry>
      <entry>在WAL接收器中等待从远程服务器接收数据。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>SSLOpenServer</literal></entry>
      <entry>Waiting for SSL while attempting connection.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>SSLOpenServer</literal></entry>
      <entry>在尝试连接时等待SSL。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>WalSenderWaitForWAL</literal></entry>
      <entry>Waiting for WAL to be flushed in WAL sender process.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>WalSenderWaitForWAL</literal></entry>
      <entry>在WAL发送器进程中等待WAL被刷新。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>WalSenderWriteData</literal></entry>
      <entry>Waiting for any activity when processing replies from WAL
       receiver in WAL sender process.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>WalSenderWriteData</literal></entry>
      <entry>在WAL发送器进程中处理WAL接收器的回复时，等待任何活动。</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table id="wait-event-extension-table">
<!--==========================orignal english content==========================
   <title>Wait Events of Type <literal>Extension</literal></title>
____________________________________________________________________________-->
   <title><literal>Extension</literal>类型的等待事件</title>
   <tgroup cols="2">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>Extension</literal> Wait Event</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>Extension</literal> 等待事件</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>Extension</literal></entry>
      <entry>Waiting in an extension.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>Extension</literal></entry>
      <entry>在扩展中等待。</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table id="wait-event-io-table">
<!--==========================orignal english content==========================
   <title>Wait Events of Type <literal>IO</literal></title>
____________________________________________________________________________-->
   <title><literal>IO</literal>类型的等待事件</title>
   <tgroup cols="2">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>IO</literal> Wait Event</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>IO</literal> 等待事件</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>BaseBackupRead</literal></entry>
      <entry>Waiting for base backup to read from a file.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>BaseBackupRead</literal></entry>
      <entry>等待基础备份从文件中读取。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>BufFileRead</literal></entry>
      <entry>Waiting for a read from a buffered file.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>BufFileRead</literal></entry>
      <entry>等待从缓冲文件中读取。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>BufFileWrite</literal></entry>
      <entry>Waiting for a write to a buffered file.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>BufFileWrite</literal></entry>
      <entry>等待对缓冲文件的写入。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>BufFileTruncate</literal></entry>
      <entry>Waiting for a buffered file to be truncated.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>BufFileTruncate</literal></entry>
      <entry>等待一个缓冲文件被截断。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>ControlFileRead</literal></entry>
      <entry>Waiting for a read from the <filename>pg_control</filename>
       file.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ControlFileRead</literal></entry>
      <entry>等待读取<filename>pg_control</filename>文件。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>ControlFileSync</literal></entry>
      <entry>Waiting for the <filename>pg_control</filename> file to reach
       durable storage.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ControlFileSync</literal></entry>
      <entry>等待<filename>pg_control</filename>文件到达持久存储。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>ControlFileSyncUpdate</literal></entry>
      <entry>Waiting for an update to the <filename>pg_control</filename> file
       to reach durable storage.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ControlFileSyncUpdate</literal></entry>
      <entry>等待更新<filename>pg_control</filename>文件以达到持久存储。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>ControlFileWrite</literal></entry>
      <entry>Waiting for a write to the <filename>pg_control</filename>
       file.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ControlFileWrite</literal></entry>
      <entry>等待写入<filename>pg_control</filename>文件。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>ControlFileWriteUpdate</literal></entry>
      <entry>Waiting for a write to update the <filename>pg_control</filename>
       file.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ControlFileWriteUpdate</literal></entry>
      <entry>等待写入更新<filename>pg_control</filename>文件。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>CopyFileRead</literal></entry>
      <entry>Waiting for a read during a file copy operation.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>CopyFileRead</literal></entry>
      <entry>在文件复制操作期间等待读取。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>CopyFileWrite</literal></entry>
      <entry>Waiting for a write during a file copy operation.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>CopyFileWrite</literal></entry>
      <entry>在文件拷贝操作期间等待写入。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>DSMFillZeroWrite</literal></entry>
      <entry>Waiting to fill a dynamic shared memory backing file with
       zeroes.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>DSMFillZeroWrite</literal></entry>
      <entry>等待用零填充动态共享内存备份(backing)文件。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>DataFileExtend</literal></entry>
      <entry>Waiting for a relation data file to be extended.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>DataFileExtend</literal></entry>
      <entry>等待关系数据文件被扩展。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>DataFileFlush</literal></entry>
      <entry>Waiting for a relation data file to reach durable storage.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>DataFileFlush</literal></entry>
      <entry>等待关系数据文件达到持久存储。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>DataFileImmediateSync</literal></entry>
      <entry>Waiting for an immediate synchronization of a relation data file to
       durable storage.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>DataFileImmediateSync</literal></entry>
      <entry>等待关系数据文件到持久存储的立即同步。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>DataFilePrefetch</literal></entry>
      <entry>Waiting for an asynchronous prefetch from a relation data
       file.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>DataFilePrefetch</literal></entry>
      <entry>等待关系数据文件的异步预取。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>DataFileRead</literal></entry>
      <entry>Waiting for a read from a relation data file.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>DataFileRead</literal></entry>
      <entry>等待对关系数据文件的读取。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>DataFileSync</literal></entry>
      <entry>Waiting for changes to a relation data file to reach durable storage.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>DataFileSync</literal></entry>
      <entry>等待对关系数据文件的更改达到持久存储。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>DataFileTruncate</literal></entry>
      <entry>Waiting for a relation data file to be truncated.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>DataFileTruncate</literal></entry>
      <entry>等待关系数据文件被截断。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>DataFileWrite</literal></entry>
      <entry>Waiting for a write to a relation data file.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>DataFileWrite</literal></entry>
      <entry>等待对关系数据文件的写入。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>LockFileAddToDataDirRead</literal></entry>
      <entry>Waiting for a read while adding a line to the data directory lock
       file.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>LockFileAddToDataDirRead</literal></entry>
      <entry>在向数据目录锁文件中添加一行时等待读取。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>LockFileAddToDataDirSync</literal></entry>
      <entry>Waiting for data to reach durable storage while adding a line to the
       data directory lock file.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>LockFileAddToDataDirSync</literal></entry>
      <entry>等待数据到达持久存储，同时向数据目录锁文件添加一行。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>LockFileAddToDataDirWrite</literal></entry>
      <entry>Waiting for a write while adding a line to the data directory
       lock file.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>LockFileAddToDataDirWrite</literal></entry>
      <entry>在向数据目录锁文件中添加一行时等待写操作。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>LockFileCreateRead</literal></entry>
      <entry>Waiting to read while creating the data directory lock
       file.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>LockFileCreateRead</literal></entry>
      <entry>创建数据目录锁文件时等待读取。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>LockFileCreateSync</literal></entry>
      <entry>Waiting for data to reach durable storage while creating the data
       directory lock file.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>LockFileCreateSync</literal></entry>
      <entry>在创建数据目录锁文件时等待数据到达持久存储。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>LockFileCreateWrite</literal></entry>
      <entry>Waiting for a write while creating the data directory lock
       file.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>LockFileCreateWrite</literal></entry>
      <entry>在创建数据目录锁文件时等待写操作。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>LockFileReCheckDataDirRead</literal></entry>
      <entry>Waiting for a read during recheck of the data directory lock
       file.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>LockFileReCheckDataDirRead</literal></entry>
      <entry>在重新检查数据目录锁文件期间等待读取。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>LogicalRewriteCheckpointSync</literal></entry>
      <entry>Waiting for logical rewrite mappings to reach durable storage
       during a checkpoint.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>LogicalRewriteCheckpointSync</literal></entry>
      <entry>等待逻辑重写映射到在检查点到达持久存储。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>LogicalRewriteMappingSync</literal></entry>
      <entry>Waiting for mapping data to reach durable storage during a logical
       rewrite.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>LogicalRewriteMappingSync</literal></entry>
      <entry>在逻辑重写期间等待映射数据到达持久存储</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>LogicalRewriteMappingWrite</literal></entry>
      <entry>Waiting for a write of mapping data during a logical
       rewrite.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>LogicalRewriteMappingWrite</literal></entry>
      <entry>在逻辑重写期间等待映射数据的写入。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>LogicalRewriteSync</literal></entry>
      <entry>Waiting for logical rewrite mappings to reach durable
       storage.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>LogicalRewriteSync</literal></entry>
      <entry>等待逻辑重写映射到达持久存储。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>LogicalRewriteTruncate</literal></entry>
      <entry>Waiting for truncate of mapping data during a logical
       rewrite.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>LogicalRewriteTruncate</literal></entry>
      <entry>等待在逻辑重写期间截断映射数据。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>LogicalRewriteWrite</literal></entry>
      <entry>Waiting for a write of logical rewrite mappings.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>LogicalRewriteWrite</literal></entry>
      <entry>等待逻辑重写映射的写入。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>RelationMapRead</literal></entry>
      <entry>Waiting for a read of the relation map file.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>RelationMapRead</literal></entry>
      <entry>等待关系映射文件的读取。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>RelationMapSync</literal></entry>
      <entry>Waiting for the relation map file to reach durable storage.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>RelationMapSync</literal></entry>
      <entry>等待关系映射文件到达持久存储。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>RelationMapWrite</literal></entry>
      <entry>Waiting for a write to the relation map file.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>RelationMapWrite</literal></entry>
      <entry>等待对关系映射文件的写入。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>ReorderBufferRead</literal></entry>
      <entry>Waiting for a read during reorder buffer management.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ReorderBufferRead</literal></entry>
      <entry>在重新排序缓冲区管理期间等待读取。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>ReorderBufferWrite</literal></entry>
      <entry>Waiting for a write during reorder buffer management.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ReorderBufferWrite</literal></entry>
      <entry>在重新排序缓冲区管理期间等待写操作。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>ReorderLogicalMappingRead</literal></entry>
      <entry>Waiting for a read of a logical mapping during reorder buffer
       management.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ReorderLogicalMappingRead</literal></entry>
      <entry>在重新排序缓冲区管理期间等待读取逻辑映射。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>ReplicationSlotRead</literal></entry>
      <entry>Waiting for a read from a replication slot control file.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ReplicationSlotRead</literal></entry>
      <entry>等待从复制槽位控制文件读取。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>ReplicationSlotRestoreSync</literal></entry>
      <entry>Waiting for a replication slot control file to reach durable storage
       while restoring it to memory.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ReplicationSlotRestoreSync</literal></entry>
      <entry>等待复制槽控制文件到达持久存储，同时将其恢复到内存中。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>ReplicationSlotSync</literal></entry>
      <entry>Waiting for a replication slot control file to reach durable
       storage.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ReplicationSlotSync</literal></entry>
      <entry>等待复制槽控制文件到达持久存储。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>ReplicationSlotWrite</literal></entry>
      <entry>Waiting for a write to a replication slot control file.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ReplicationSlotWrite</literal></entry>
      <entry>等待对复制槽控制文件的写入。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>SLRUFlushSync</literal></entry>
      <entry>Waiting for SLRU data to reach durable storage during a checkpoint
       or database shutdown.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>SLRUFlushSync</literal></entry>
      <entry>在检查点或数据库关闭期间等待SLRU数据到达持久存储。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>SLRURead</literal></entry>
      <entry>Waiting for a read of an SLRU page.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>SLRURead</literal></entry>
      <entry>等待读取SLRU页面。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>SLRUSync</literal></entry>
      <entry>Waiting for SLRU data to reach durable storage following a page
       write.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>SLRUSync</literal></entry>
      <entry>在写页面后等待SLRU数据到达持久存储。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>SLRUWrite</literal></entry>
      <entry>Waiting for a write of an SLRU page.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>SLRUWrite</literal></entry>
      <entry>等待SLRU页面的写入。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>SnapbuildRead</literal></entry>
      <entry>Waiting for a read of a serialized historical catalog
       snapshot.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>SnapbuildRead</literal></entry>
      <entry>等待读取序列化的历史目录快照。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>SnapbuildSync</literal></entry>
      <entry>Waiting for a serialized historical catalog snapshot to reach
       durable storage.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>SnapbuildSync</literal></entry>
      <entry>等待序列化历史目录快照到达持久存储。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>SnapbuildWrite</literal></entry>
      <entry>Waiting for a write of a serialized historical catalog
       snapshot.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>SnapbuildWrite</literal></entry>
      <entry>等待串行历史目录快照的写入。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>TimelineHistoryFileSync</literal></entry>
      <entry>Waiting for a timeline history file received via streaming
       replication to reach durable storage.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>TimelineHistoryFileSync</literal></entry>
      <entry>等待通过流复制接收的时间线历史文件到达持久存储。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>TimelineHistoryFileWrite</literal></entry>
      <entry>Waiting for a write of a timeline history file received via
       streaming replication.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>TimelineHistoryFileWrite</literal></entry>
      <entry>等待通过流复制接收的时间线历史文件的写入。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>TimelineHistoryRead</literal></entry>
      <entry>Waiting for a read of a timeline history file.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>TimelineHistoryRead</literal></entry>
      <entry>等待读取时间线历史文件。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>TimelineHistorySync</literal></entry>
      <entry>Waiting for a newly created timeline history file to reach durable
       storage.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>TimelineHistorySync</literal></entry>
      <entry>等待新创建的时间线历史文件到达持久存储。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>TimelineHistoryWrite</literal></entry>
      <entry>Waiting for a write of a newly created timeline history
       file.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>TimelineHistoryWrite</literal></entry>
      <entry>等待写入新创建的时间线历史文件。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>TwophaseFileRead</literal></entry>
      <entry>Waiting for a read of a two phase state file.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>TwophaseFileRead</literal></entry>
      <entry>等待读取两阶段状态文件。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>TwophaseFileSync</literal></entry>
      <entry>Waiting for a two phase state file to reach durable storage.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>TwophaseFileSync</literal></entry>
      <entry>等待两阶段状态文件到达持久存储。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>TwophaseFileWrite</literal></entry>
      <entry>Waiting for a write of a two phase state file.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>TwophaseFileWrite</literal></entry>
      <entry>等待对两阶段状态文件的写入。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>WALBootstrapSync</literal></entry>
      <entry>Waiting for WAL to reach durable storage during
       bootstrapping.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>WALBootstrapSync</literal></entry>
      <entry>在引导过程中等待WAL达到持久存储。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>WALBootstrapWrite</literal></entry>
      <entry>Waiting for a write of a WAL page during bootstrapping.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>WALBootstrapWrite</literal></entry>
      <entry>在引导过程中等待WAL页面的写入。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>WALCopyRead</literal></entry>
      <entry>Waiting for a read when creating a new WAL segment by copying an
       existing one.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>WALCopyRead</literal></entry>
      <entry>通过复制一个已有WAL段来创建一个新的WAL段时等待读取。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>WALCopySync</literal></entry>
      <entry>Waiting for a new WAL segment created by copying an existing one to
       reach durable storage.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>WALCopySync</literal></entry>
      <entry>等待通过复制一个已有WAL段到持久存储来创建一个新的WAL段。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>WALCopyWrite</literal></entry>
      <entry>Waiting for a write when creating a new WAL segment by copying an
       existing one.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>WALCopyWrite</literal></entry>
      <entry>通过复制一个已有WAL段来创建一个新的WAL段时等待写入。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>WALInitSync</literal></entry>
      <entry>Waiting for a newly initialized WAL file to reach durable
       storage.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>WALInitSync</literal></entry>
      <entry>等待一个新初始化的WAL文件到持久存储。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>WALInitWrite</literal></entry>
      <entry>Waiting for a write while initializing a new WAL file.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>WALInitWrite</literal></entry>
      <entry>在初始化一个新的WAL文件时等待写入。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>WALRead</literal></entry>
      <entry>Waiting for a read from a WAL file.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>WALRead</literal></entry>
      <entry>等待WAL文件的读取。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>WALSenderTimelineHistoryRead</literal></entry>
      <entry>Waiting for a read from a timeline history file during a walsender
       timeline command.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>WALSenderTimelineHistoryRead</literal></entry>
      <entry>在walsender时间线命令期间等待从时间线历史文件读取。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>WALSync</literal></entry>
      <entry>Waiting for a WAL file to reach durable storage.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>WALSync</literal></entry>
      <entry>等待WAL文件到达持久存储。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>WALSyncMethodAssign</literal></entry>
      <entry>Waiting for data to reach durable storage while assigning a new
       WAL sync method.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>WALSyncMethodAssign</literal></entry>
      <entry>等待数据到达持久存储，同时分配一个新的WAL同步方法。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>WALWrite</literal></entry>
      <entry>Waiting for a write to a WAL file.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>WALWrite</literal></entry>
      <entry>等待写入WAL文件。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>LogicalChangesRead</literal></entry>
      <entry>Waiting for a read from a logical changes file.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>LogicalChangesRead</literal></entry>
      <entry>等待从逻辑更改文件中读取。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>LogicalChangesWrite</literal></entry>
      <entry>Waiting for a write to a logical changes file.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>LogicalChangesWrite</literal></entry>
      <entry>等待向逻辑更改文件中写入。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>LogicalSubxactRead</literal></entry>
      <entry>Waiting for a read from a logical subxact file.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>LogicalSubxactRead</literal></entry>
      <entry>等待从逻辑subxact文件中读取</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>LogicalSubxactWrite</literal></entry>
      <entry>Waiting for a write to a logical subxact file.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>LogicalSubxactWrite</literal></entry>
      <entry>等待向逻辑subxact文件中写入。</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table id="wait-event-ipc-table">
<!--==========================orignal english content==========================
   <title>Wait Events of Type <literal>IPC</literal></title>
____________________________________________________________________________-->
   <title><literal>IPC</literal>类型的等待事件</title>
   <tgroup cols="2">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>IPC</literal> Wait Event</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>IPC</literal> 等待事件</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>AppendReady</literal></entry>
      <entry>Waiting for subplan nodes of an <literal>Append</literal> plan
       node to be ready.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>AppendReady</literal></entry>
      <entry>等待 <literal>Append</literal> 计划节点的子计划节点准备好。</entry>
     </row>
<!--==========================orignal english content==========================
    <row>
      <entry><literal>BackendTermination</literal></entry>
      <entry>Waiting for the termination of another backend.</entry>
     </row>
____________________________________________________________________________-->
    <row>
      <entry><literal>BackendTermination</literal></entry>
      <entry>等待另一个后端终止。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>BackupWaitWalArchive</literal></entry>
      <entry>Waiting for WAL files required for a backup to be successfully
       archived.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>BackupWaitWalArchive</literal></entry>
      <entry>等待备份所需的WAL文件成功存档。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>BgWorkerShutdown</literal></entry>
      <entry>Waiting for background worker to shut down.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>BgWorkerShutdown</literal></entry>
      <entry>等待后台工作者关闭。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>BgWorkerStartup</literal></entry>
      <entry>Waiting for background worker to start up.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>BgWorkerStartup</literal></entry>
      <entry>等待后台工作者启动。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>BtreePage</literal></entry>
      <entry>Waiting for the page number needed to continue a parallel B-tree
       scan to become available.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>BtreePage</literal></entry>
      <entry>正等待继续并行B-树扫描所需的页号变得可用。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>BufferIO</literal></entry>
      <entry>Waiting for buffer I/O to complete.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>BufferIO</literal></entry>
      <entry>等待缓冲I/O结束。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>CheckpointDone</literal></entry>
      <entry>Waiting for a checkpoint to complete.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>CheckpointDone</literal></entry>
      <entry>等待检查点完成。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>CheckpointStart</literal></entry>
      <entry>Waiting for a checkpoint to start.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>CheckpointStart</literal></entry>
      <entry>等待检查点开始。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>ExecuteGather</literal></entry>
      <entry>Waiting for activity from a child process while
       executing a <literal>Gather</literal> plan node.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ExecuteGather</literal></entry>
      <entry>在执行<literal>Gather</literal> 计划节点时，等待子进程的活动。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>HashBatchAllocate</literal></entry>
      <entry>Waiting for an elected Parallel Hash participant to allocate a hash
       table.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>HashBatchAllocate</literal></entry>
      <entry>等待一个选定的并行哈希参与者分配哈希表。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>HashBatchElect</literal></entry>
      <entry>Waiting to elect a Parallel Hash participant to allocate a hash
       table.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>HashBatchElect</literal></entry>
      <entry>等待选择一个并行哈希参与者来分配哈希表。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>HashBatchLoad</literal></entry>
      <entry>Waiting for other Parallel Hash participants to finish loading a
       hash table.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>HashBatchLoad</literal></entry>
      <entry>等待其他并行哈希参与者完成哈希表的加载。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>HashBuildAllocate</literal></entry>
      <entry>Waiting for an elected Parallel Hash participant to allocate the
       initial hash table.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>HashBuildAllocate</literal></entry>
      <entry>等待一个选定的并行哈希参与者分配初始哈希表。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>HashBuildElect</literal></entry>
      <entry>Waiting to elect a Parallel Hash participant to allocate the
       initial hash table.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>HashBuildElect</literal></entry>
      <entry>等待选择一个并行哈希参与者来分配初始哈希表。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>HashBuildHashInner</literal></entry>
      <entry>Waiting for other Parallel Hash participants to finish hashing the
       inner relation.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>HashBuildHashInner</literal></entry>
      <entry>等待其他并行哈希参与者完成内部关系的散列。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>HashBuildHashOuter</literal></entry>
      <entry>Waiting for other Parallel Hash participants to finish partitioning
       the outer relation.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>HashBuildHashOuter</literal></entry>
      <entry>等待其他Parallel 哈希参与者完成对外部关系的分区。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>HashGrowBatchesAllocate</literal></entry>
      <entry>Waiting for an elected Parallel Hash participant to allocate more
       batches.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>HashGrowBatchesAllocate</literal></entry>
      <entry>等待选定的并行哈希参与者分配更多批处理。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>HashGrowBatchesDecide</literal></entry>
      <entry>Waiting to elect a Parallel Hash participant to decide on future
       batch growth.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>HashGrowBatchesDecide</literal></entry>
      <entry>等待选择一个并行哈希参与者来决定未来的批处理增长。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>HashGrowBatchesElect</literal></entry>
      <entry>Waiting to elect a Parallel Hash participant to allocate more
       batches.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>HashGrowBatchesElect</literal></entry>
      <entry>等待选择一个Parallel 哈希参与者来分配更多批处理。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>HashGrowBatchesFinish</literal></entry>
      <entry>Waiting for an elected Parallel Hash participant to decide on
       future batch growth.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>HashGrowBatchesFinish</literal></entry>
      <entry>Waiting for an elected Parallel Hash participant to decide on
       future batch growth.</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>HashGrowBatchesRepartition</literal></entry>
      <entry>Waiting for other Parallel Hash participants to finish
       repartitioning.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>HashGrowBatchesRepartition</literal></entry>
      <entry>等待一个选定的并行哈希参与者决定未来的批处理增长。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>HashGrowBucketsAllocate</literal></entry>
      <entry>Waiting for an elected Parallel Hash participant to finish
       allocating more buckets.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>HashGrowBucketsAllocate</literal></entry>
      <entry>等待选定的并行哈希参与者完成更多bucket的分配。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>HashGrowBucketsElect</literal></entry>
      <entry>Waiting to elect a Parallel Hash participant to allocate more
       buckets.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>HashGrowBucketsElect</literal></entry>
      <entry>等待选择一个并行哈希参与者来分配更多的buckets。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>HashGrowBucketsReinsert</literal></entry>
      <entry>Waiting for other Parallel Hash participants to finish inserting
       tuples into new buckets.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>HashGrowBucketsReinsert</literal></entry>
      <entry>等待其他Parallel 哈希参与者完成将元组插入到新buckets中。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>LogicalSyncData</literal></entry>
      <entry>Waiting for a logical replication remote server to send data for
       initial table synchronization.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>LogicalSyncData</literal></entry>
      <entry>等待逻辑复制远程服务器发送用于初始表同步的数据。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>LogicalSyncStateChange</literal></entry>
      <entry>Waiting for a logical replication remote server to change
       state.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>LogicalSyncStateChange</literal></entry>
      <entry>等待逻辑复制远程服务器更改状态。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>MessageQueueInternal</literal></entry>
      <entry>Waiting for another process to be attached to a shared message
       queue.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>MessageQueueInternal</literal></entry>
      <entry>等待另一个进程附加到共享消息队列。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>MessageQueuePutMessage</literal></entry>
      <entry>Waiting to write a protocol message to a shared message queue.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>MessageQueuePutMessage</literal></entry>
      <entry>等待将协议消息写入共享消息队列。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>MessageQueueReceive</literal></entry>
      <entry>Waiting to receive bytes from a shared message queue.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>MessageQueueReceive</literal></entry>
      <entry>等待从共享消息队列接收字节。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>MessageQueueSend</literal></entry>
      <entry>Waiting to send bytes to a shared message queue.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>MessageQueueSend</literal></entry>
      <entry>等待将字节发送到共享消息队列。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>ParallelBitmapScan</literal></entry>
      <entry>Waiting for parallel bitmap scan to become initialized.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ParallelBitmapScan</literal></entry>
      <entry>等待并行位图扫描被初始化。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>ParallelCreateIndexScan</literal></entry>
      <entry>Waiting for parallel <command>CREATE INDEX</command> workers to
       finish heap scan.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ParallelCreateIndexScan</literal></entry>
      <entry>等待并行<command>CREATE INDEX</command> 工作者完成堆扫描。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>ParallelFinish</literal></entry>
      <entry>Waiting for parallel workers to finish computing.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ParallelFinish</literal></entry>
      <entry>等待并行工作人员完成计算。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>ProcArrayGroupUpdate</literal></entry>
      <entry>Waiting for the group leader to clear the transaction ID at
       end of a parallel operation.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ProcArrayGroupUpdate</literal></entry>
      <entry>等待组领导在并行操作结束时清除事务ID。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>ProcSignalBarrier</literal></entry>
      <entry>Waiting for a barrier event to be processed by all
       backends.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ProcSignalBarrier</literal></entry>
      <entry>等待屏障事件被所有后端处理。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>Promote</literal></entry>
      <entry>Waiting for standby promotion.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>Promote</literal></entry>
      <entry>等待备用系统提升。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>RecoveryConflictSnapshot</literal></entry>
      <entry>Waiting for recovery conflict resolution for a vacuum
       cleanup.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>RecoveryConflictSnapshot</literal></entry>
      <entry>等待vacuum清理的恢复冲突解决。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>RecoveryConflictTablespace</literal></entry>
      <entry>Waiting for recovery conflict resolution for dropping a
       tablespace.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>RecoveryConflictTablespace</literal></entry>
      <entry>等待恢复冲突解决删除表空间。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>RecoveryPause</literal></entry>
      <entry>Waiting for recovery to be resumed.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>RecoveryPause</literal></entry>
      <entry>等待恢复继续进行。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>ReplicationOriginDrop</literal></entry>
      <entry>Waiting for a replication origin to become inactive so it can be
       dropped.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ReplicationOriginDrop</literal></entry>
      <entry>等待复制源变为非活动状态，以便可以删除它。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>ReplicationSlotDrop</literal></entry>
      <entry>Waiting for a replication slot to become inactive so it can be
       dropped.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ReplicationSlotDrop</literal></entry>
      <entry>等待复制槽变为非活动状态，以便可以删除它。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>SafeSnapshot</literal></entry>
      <entry>Waiting to obtain a valid snapshot for a <literal>READ ONLY
       DEFERRABLE</literal> transaction.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>SafeSnapshot</literal></entry>
      <entry>等待获取<literal>READ ONLY DEFERRABLE</literal>事务的有效快照。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>SyncRep</literal></entry>
      <entry>Waiting for confirmation from a remote server during synchronous
       replication.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>SyncRep</literal></entry>
      <entry>在同步复制期间等待远程服务器的确认。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>WalReceiverExit</literal></entry>
      <entry>Waiting for the WAL receiver to exit.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>WalReceiverExit</literal></entry>
      <entry>等待WAL接收器退出。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>WalReceiverWaitStart</literal></entry>
      <entry>Waiting for startup process to send initial data for streaming
       replication.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>WalReceiverWaitStart</literal></entry>
      <entry>等待启动进程为流复制发送初始数据。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>XactGroupUpdate</literal></entry>
      <entry>Waiting for the group leader to update transaction status at
       end of a parallel operation.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>XactGroupUpdate</literal></entry>
      <entry>等待分组组长在并行操作结束时更新事务状态。</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table id="wait-event-lock-table">
<!--==========================orignal english content==========================
   <title>Wait Events of Type <literal>Lock</literal></title>
____________________________________________________________________________-->
   <title><literal>Lock</literal>类型的等待事件</title>
   <tgroup cols="2">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>Lock</literal> Wait Event</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>Lock</literal> 等待事件</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>advisory</literal></entry>
      <entry>Waiting to acquire an advisory user lock.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>advisory</literal></entry>
      <entry>等待获得一个建议用户锁。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>extend</literal></entry>
      <entry>Waiting to extend a relation.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>extend</literal></entry>
      <entry>等待扩展一个关系。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>frozenid</literal></entry>
      <entry>Waiting to
       update <structname>pg_database</structname>.<structfield>datfrozenxid</structfield>
       and <structname>pg_database</structname>.<structfield>datminmxid</structfield>.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>frozenid</literal></entry>
      <entry>等待升级 <structname>pg_database</structname>.<structfield>datfrozenxid</structfield>
       和 <structname>pg_database</structname>.<structfield>datminmxid</structfield>.</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>object</literal></entry>
      <entry>Waiting to acquire a lock on a non-relation database object.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>object</literal></entry>
      <entry>等待获取非关系数据库对象上的锁。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>page</literal></entry>
      <entry>Waiting to acquire a lock on a page of a relation.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>page</literal></entry>
      <entry>等待获取一个关系页面上的锁。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>relation</literal></entry>
      <entry>Waiting to acquire a lock on a relation.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>relation</literal></entry>
      <entry>等待获得一个关系的锁。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>spectoken</literal></entry>
      <entry>Waiting to acquire a speculative insertion lock.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>spectoken</literal></entry>
      <entry>等待获取推测的插入锁。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>transactionid</literal></entry>
      <entry>Waiting for a transaction to finish.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>transactionid</literal></entry>
      <entry>等待事务完成。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>tuple</literal></entry>
      <entry>Waiting to acquire a lock on a tuple.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>tuple</literal></entry>
      <entry>等待获取元组上的锁。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>userlock</literal></entry>
      <entry>Waiting to acquire a user lock.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>userlock</literal></entry>
      <entry>等待获取用户锁。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>virtualxid</literal></entry>
      <entry>Waiting to acquire a virtual transaction ID lock.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>virtualxid</literal></entry>
      <entry>等待获取虚拟事务ID锁。</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table id="wait-event-lwlock-table">
<!--==========================orignal english content==========================
   <title>Wait Events of Type <literal>LWLock</literal></title>
____________________________________________________________________________-->
   <title><literal>LWLock</literal>类型的等待事件</title>
   <tgroup cols="2">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>LWLock</literal> Wait Event</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>LWLock</literal> 等待事件</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>AddinShmemInit</literal></entry>
      <entry>Waiting to manage an extension's space allocation in shared
       memory.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>AddinShmemInit</literal></entry>
      <entry>等待管理共享内存中的扩展空间分配。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>AutoFile</literal></entry>
      <entry>Waiting to update the <filename>postgresql.auto.conf</filename>
       file.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>AutoFile</literal></entry>
      <entry>等待更新<filename>postgresql.auto.conf</filename>文件。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>Autovacuum</literal></entry>
      <entry>Waiting to read or update the current state of autovacuum
       workers.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>Autovacuum</literal></entry>
      <entry>等待读取或更新自动清理工作者的当前状态。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>AutovacuumSchedule</literal></entry>
      <entry>Waiting to ensure that a table selected for autovacuum
       still needs vacuuming.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>AutovacuumSchedule</literal></entry>
      <entry>等待确保选择为自动清理的表仍然需要清理。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>BackgroundWorker</literal></entry>
      <entry>Waiting to read or update background worker state.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>BackgroundWorker</literal></entry>
      <entry>等待读取或更新后台工作者状态。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>BtreeVacuum</literal></entry>
      <entry>Waiting to read or update vacuum-related information for a
       B-tree index.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>BtreeVacuum</literal></entry>
      <entry>等待读取或更新b-树索引的清理相关信息。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>BufferContent</literal></entry>
      <entry>Waiting to access a data page in memory.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>BufferContent</literal></entry>
      <entry>等待访问内存中的数据页。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>BufferMapping</literal></entry>
      <entry>Waiting to associate a data block with a buffer in the buffer
       pool.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>BufferMapping</literal></entry>
      <entry>等待将数据块与缓冲池中的缓冲区关联。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>CheckpointerComm</literal></entry>
      <entry>Waiting to manage fsync requests.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>CheckpointerComm</literal></entry>
      <entry>等待管理fsync请求。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>CommitTs</literal></entry>
      <entry>Waiting to read or update the last value set for a
       transaction commit timestamp.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>CommitTs</literal></entry>
      <entry>等待读取或更新事务提交时间戳的最后一个值集。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>CommitTsBuffer</literal></entry>
      <entry>Waiting for I/O on a commit timestamp SLRU buffer.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>CommitTsBuffer</literal></entry>
      <entry>在提交时间戳SLRU缓冲区上等待I/O。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>CommitTsSLRU</literal></entry>
      <entry>Waiting to access the commit timestamp SLRU cache.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>CommitTsSLRU</literal></entry>
      <entry>等待访问提交时间戳SLRU缓存。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>ControlFile</literal></entry>
      <entry>Waiting to read or update the <filename>pg_control</filename>
       file or create a new WAL file.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ControlFile</literal></entry>
      <entry>等待读取或更新<filename>pg_control</filename>文件或创建一个新的WAL文件。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>DynamicSharedMemoryControl</literal></entry>
      <entry>Waiting to read or update dynamic shared memory allocation
       information.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>DynamicSharedMemoryControl</literal></entry>
      <entry>等待读取或更新动态共享内存分配信息。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>LockFastPath</literal></entry>
      <entry>Waiting to read or update a process' fast-path lock
       information.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>LockFastPath</literal></entry>
      <entry>等待读取或更新进程的快速路径锁信息。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>LockManager</literal></entry>
      <entry>Waiting to read or update information
       about <quote>heavyweight</quote> locks.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>LockManager</literal></entry>
      <entry>等待读取或更新关于<quote>heavyweight</quote>锁。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>LogicalRepWorker</literal></entry>
      <entry>Waiting to read or update the state of logical replication
       workers.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>LogicalRepWorker</literal></entry>
      <entry>等待读取或更新逻辑复制工作器的状态。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>MultiXactGen</literal></entry>
      <entry>Waiting to read or update shared multixact state.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>MultiXactGen</literal></entry>
      <entry>等待读取或更新共享的multixact状态。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>MultiXactMemberBuffer</literal></entry>
      <entry>Waiting for I/O on a multixact member SLRU buffer.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>MultiXactMemberBuffer</literal></entry>
      <entry>在multixact成员SLRU缓冲区上等待I/O。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>MultiXactMemberSLRU</literal></entry>
      <entry>Waiting to access the multixact member SLRU cache.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>MultiXactMemberSLRU</literal></entry>
      <entry>等待访问multixact成员SLRU缓存。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>MultiXactOffsetBuffer</literal></entry>
      <entry>Waiting for I/O on a multixact offset SLRU buffer.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>MultiXactOffsetBuffer</literal></entry>
      <entry>在multixact 偏移 SLRU缓冲区上等待I/O。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>MultiXactOffsetSLRU</literal></entry>
      <entry>Waiting to access the multixact offset SLRU cache.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>MultiXactOffsetSLRU</literal></entry>
      <entry>等待访问multixact 偏移 SLRU缓存。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>MultiXactTruncation</literal></entry>
      <entry>Waiting to read or truncate multixact information.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>MultiXactTruncation</literal></entry>
      <entry>等待读取或截断multixact信息。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>NotifyBuffer</literal></entry>
      <entry>Waiting for I/O on a <command>NOTIFY</command> message SLRU
       buffer.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>NotifyBuffer</literal></entry>
      <entry>在<command>NOTIFY</command> 消息 SLRU缓冲区上等待I/O。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>NotifyQueue</literal></entry>
      <entry>Waiting to read or update <command>NOTIFY</command> messages.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>NotifyQueue</literal></entry>
      <entry>等待读取或更新<command>NOTIFY</command> 消息。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>NotifyQueueTail</literal></entry>
      <entry>Waiting to update limit on <command>NOTIFY</command> message
       storage.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>NotifyQueueTail</literal></entry>
      <entry>等待<command>NOTIFY</command>消息存储上的更新限制。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>NotifySLRU</literal></entry>
      <entry>Waiting to access the <command>NOTIFY</command> message SLRU
       cache.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>NotifySLRU</literal></entry>
      <entry>等待访问<command>NOTIFY</command>消息SLRU缓存。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>OidGen</literal></entry>
      <entry>Waiting to allocate a new OID.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>OidGen</literal></entry>
      <entry>等待分配一个新的OID。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>OldSnapshotTimeMap</literal></entry>
      <entry>Waiting to read or update old snapshot control information.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>OldSnapshotTimeMap</literal></entry>
      <entry>等待读取或更新旧的快照控制信息。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>ParallelAppend</literal></entry>
      <entry>Waiting to choose the next subplan during Parallel Append plan
       execution.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ParallelAppend</literal></entry>
      <entry>在并行附加计划执行期间等待选择下一个子计划。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>ParallelHashJoin</literal></entry>
      <entry>Waiting to synchronize workers during Parallel Hash Join plan
       execution.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ParallelHashJoin</literal></entry>
      <entry>在并行哈希连接计划执行期间等待同步工作器。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>ParallelQueryDSA</literal></entry>
      <entry>Waiting for parallel query dynamic shared memory allocation.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ParallelQueryDSA</literal></entry>
      <entry>等待并行查询动态共享内存分配。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>PerSessionDSA</literal></entry>
      <entry>Waiting for parallel query dynamic shared memory allocation.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>PerSessionDSA</literal></entry>
      <entry>等待并行查询动态共享内存分配。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>PerSessionRecordType</literal></entry>
      <entry>Waiting to access a parallel query's information about composite
       types.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>PerSessionRecordType</literal></entry>
      <entry>等待访问有关复合类型的并行查询信息。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>PerSessionRecordTypmod</literal></entry>
      <entry>Waiting to access a parallel query's information about type
       modifiers that identify anonymous record types.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>PerSessionRecordTypmod</literal></entry>
      <entry>等待访问有关标识匿名记录类型的类型修饰符的并行查询信息。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>PerXactPredicateList</literal></entry>
      <entry>Waiting to access the list of predicate locks held by the current
       serializable transaction during a parallel query.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>PerXactPredicateList</literal></entry>
      <entry>在并行查询期间等待访问当前可序列化事务持有的谓词锁列表。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>PredicateLockManager</literal></entry>
      <entry>Waiting to access predicate lock information used by
       serializable transactions.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>PredicateLockManager</literal></entry>
      <entry>等待访问可序列化事务使用的谓词锁信息。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>ProcArray</literal></entry>
      <entry>Waiting to access the shared per-process data structures
       (typically, to get a snapshot or report a session's transaction
       ID).</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ProcArray</literal></entry>
      <entry>等待访问每个进程共享的数据结构(通常情况，是获取快照或报告会话的事务ID)。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>RelationMapping</literal></entry>
      <entry>Waiting to read or update
       a <filename>pg_filenode.map</filename> file (used to track the
       filenode assignments of certain system catalogs).</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>RelationMapping</literal></entry>
      <entry>等待读取或更新<filename>pg_filenode.map</filename>文件(用于跟踪某些系统目录的文件节点分配)。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>RelCacheInit</literal></entry>
      <entry>Waiting to read or update a <filename>pg_internal.init</filename>
       relation cache initialization file.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>RelCacheInit</literal></entry>
      <entry>等待读取或更新<filename>pg_internal.init</filename>关系缓存初始化文件。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>ReplicationOrigin</literal></entry>
      <entry>Waiting to create, drop or use a replication origin.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ReplicationOrigin</literal></entry>
      <entry>等待创建、删除或使用复制源。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>ReplicationOriginState</literal></entry>
      <entry>Waiting to read or update the progress of one replication
       origin.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ReplicationOriginState</literal></entry>
      <entry>等待读取或更新一个复制源的进度。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>ReplicationSlotAllocation</literal></entry>
      <entry>Waiting to allocate or free a replication slot.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ReplicationSlotAllocation</literal></entry>
      <entry>等待分配或释放复制槽。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>ReplicationSlotControl</literal></entry>
      <entry>Waiting to read or update replication slot state.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ReplicationSlotControl</literal></entry>
      <entry>等待读取或更新复制槽状态。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>ReplicationSlotIO</literal></entry>
      <entry>Waiting for I/O on a replication slot.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ReplicationSlotIO</literal></entry>
      <entry>在复制槽位上等待I/O。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>SerialBuffer</literal></entry>
      <entry>Waiting for I/O on a serializable transaction conflict SLRU
       buffer.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>SerialBuffer</literal></entry>
      <entry>在可串行事务冲突的SLRU缓冲区上等待I/O。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>SerializableFinishedList</literal></entry>
      <entry>Waiting to access the list of finished serializable
       transactions.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>SerializableFinishedList</literal></entry>
      <entry>等待访问已完成的可序列化事务列表。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>SerializablePredicateList</literal></entry>
      <entry>Waiting to access the list of predicate locks held by
       serializable transactions.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>SerializablePredicateList</literal></entry>
      <entry>等待访问可序列化事务持有的谓词锁列表。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>SerializableXactHash</literal></entry>
      <entry>Waiting to read or update information about serializable
       transactions.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>SerializableXactHash</literal></entry>
      <entry>等待读取或更新关于可序列化事务的信息。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>SerialSLRU</literal></entry>
      <entry>Waiting to access the serializable transaction conflict SLRU
       cache.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>SerialSLRU</literal></entry>
      <entry>等待访问可序列化事务冲突SLRU缓存。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>SharedTidBitmap</literal></entry>
      <entry>Waiting to access a shared TID bitmap during a parallel bitmap
       index scan.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>SharedTidBitmap</literal></entry>
      <entry>在并行位图索引扫描期间等待访问共享的TID位图。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>SharedTupleStore</literal></entry>
      <entry>Waiting to access a shared tuple store during parallel
       query.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>SharedTupleStore</literal></entry>
      <entry>在并行查询期间等待访问共享元组存储。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>ShmemIndex</literal></entry>
      <entry>Waiting to find or allocate space in shared memory.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>ShmemIndex</literal></entry>
      <entry>等待在共享内存中找到或分配空间。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>SInvalRead</literal></entry>
      <entry>Waiting to retrieve messages from the shared catalog invalidation
       queue.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>SInvalRead</literal></entry>
      <entry>等待从共享目录失效队列中检索消息。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>SInvalWrite</literal></entry>
      <entry>Waiting to add a message to the shared catalog invalidation
      queue.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>SInvalWrite</literal></entry>
      <entry>等待向共享编目失效队列添加消息。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>SubtransBuffer</literal></entry>
      <entry>Waiting for I/O on a sub-transaction SLRU buffer.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>SubtransBuffer</literal></entry>
      <entry>在子事务SLRU缓冲区上等待I/O。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>SubtransSLRU</literal></entry>
      <entry>Waiting to access the sub-transaction SLRU cache.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>SubtransSLRU</literal></entry>
      <entry>等待访问子事务SLRU缓存。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>SyncRep</literal></entry>
      <entry>Waiting to read or update information about the state of
       synchronous replication.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>SyncRep</literal></entry>
      <entry>等待读取或更新有关同步复制状态的信息。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>SyncScan</literal></entry>
      <entry>Waiting to select the starting location of a synchronized table
       scan.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>SyncScan</literal></entry>
      <entry>等待选择同步表扫描的起始位置。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>TablespaceCreate</literal></entry>
      <entry>Waiting to create or drop a tablespace.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>TablespaceCreate</literal></entry>
      <entry>等待创建或删除表空间。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>TwoPhaseState</literal></entry>
      <entry>Waiting to read or update the state of prepared transactions.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>TwoPhaseState</literal></entry>
      <entry>等待读取或更新已准备事务的状态。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>WALBufMapping</literal></entry>
      <entry>Waiting to replace a page in WAL buffers.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>WALBufMapping</literal></entry>
      <entry>等待在WAL缓冲区中替换一个页面。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>WALInsert</literal></entry>
      <entry>Waiting to insert WAL data into a memory buffer.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>WALInsert</literal></entry>
      <entry>等待将WAL数据插入内存缓冲区。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>WALWrite</literal></entry>
      <entry>Waiting for WAL buffers to be written to disk.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>WALWrite</literal></entry>
      <entry>等待WAL缓冲区写入磁盘。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>WrapLimitsVacuum</literal></entry>
      <entry>Waiting to update limits on transaction id and multixact
       consumption.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>WrapLimitsVacuum</literal></entry>
      <entry>等待更新事务id和multixact消费的限制。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>XactBuffer</literal></entry>
      <entry>Waiting for I/O on a transaction status SLRU buffer.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>XactBuffer</literal></entry>
      <entry>在事务状态的SLRU缓冲区上等待I/O。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>XactSLRU</literal></entry>
      <entry>Waiting to access the transaction status SLRU cache.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>XactSLRU</literal></entry>
      <entry>等待访问事务状态的SLRU缓存。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>XactTruncation</literal></entry>
      <entry>Waiting to execute <function>pg_xact_status</function> or update
       the oldest transaction ID available to it.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>XactTruncation</literal></entry>
      <entry>等待执行<function>pg_xact_status</function>或更新它可用的最早的事务ID。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>XidGen</literal></entry>
      <entry>Waiting to allocate a new transaction ID.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>XidGen</literal></entry>
      <entry>等待分配新的事务ID。</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

   <note>
<!--==========================orignal english content==========================
    <para>
     Extensions can add <literal>LWLock</literal> types to the list shown in
     <xref linkend="wait-event-lwlock-table"/>.  In some cases, the name
     assigned by an extension will not be available in all server processes;
     so an <literal>LWLock</literal> wait event might be reported as
     just <quote><literal>extension</literal></quote> rather than the
     extension-assigned name.
    </para>
____________________________________________________________________________-->
    <para>
     扩展可以将<literal>LWLock</literal>类型添加到<xref linkend="wait-event-lwlock-table"/>所示的列表中。
     在某些情况下，扩展名分配的名称不能在所有服务器进程中使用;因此<literal>LWLock</literal>等待事件可能只被报告为<quote><literal>extension</literal></quote>，而不是扩展名分配的名称。
    </para>
   </note>

  <table id="wait-event-timeout-table">
<!--==========================orignal english content==========================
   <title>Wait Events of Type <literal>Timeout</literal></title>
____________________________________________________________________________-->
   <title> <literal>Timeout</literal>类型的等待事件</title>
   <tgroup cols="2">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>Timeout</literal> Wait Event</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>Timeout</literal> 等待事件</entry>
      <entry>描述</entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>BaseBackupThrottle</literal></entry>
      <entry>Waiting during base backup when throttling activity.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>BaseBackupThrottle</literal></entry>
      <entry>当有限流活动时在基础备份期间等待。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>PgSleep</literal></entry>
      <entry>Waiting due to a call to <function>pg_sleep</function> or
       a sibling function.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>PgSleep</literal></entry>
      <entry>由于调用<function>pg_sleep</function>或同类函数而等待。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>RecoveryApplyDelay</literal></entry>
      <entry>Waiting to apply WAL during recovery because of a delay
       setting.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>RecoveryApplyDelay</literal></entry>
      <entry>由于延迟设置，在恢复期间等待应用WAL。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>RecoveryRetrieveRetryInterval</literal></entry>
      <entry>Waiting during recovery when WAL data is not available from any
       source (<filename>pg_wal</filename>, archive or stream).</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>RecoveryRetrieveRetryInterval</literal></entry>
      <entry>当WAL数据无法从任何来源(<filename>pg_wal</filename>，存档或流)获得时，在恢复期间等待。</entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>VacuumDelay</literal></entry>
      <entry>Waiting in a cost-based vacuum delay point.</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>VacuumDelay</literal></entry>
      <entry>在一个基于代价的清理延迟点。</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
   <para>
     Here is an example of how wait events can be viewed:

<programlisting>
SELECT pid, wait_event_type, wait_event FROM pg_stat_activity WHERE wait_event is NOT NULL;
 pid  | wait_event_type | wait_event 
-&minus;-&minus;-&minus;+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;-+-&minus;-&minus;-&minus;-&minus;-&minus;-&minus;
 2540 | Lock            | relation
 6644 | LWLock          | ProcArray
(2 rows)
</programlisting>
   </para>
____________________________________________________________________________-->
   <para>
     下面的例子展示了如何查看等待事件：

<programlisting>
SELECT pid, wait_event_type, wait_event FROM pg_stat_activity WHERE wait_event is NOT NULL;
 pid  | wait_event_type | wait_event 
------+-----------------+------------
 2540 | Lock            | relation
 6644 | LWLock          | ProcArray
(2 rows)
</programlisting>
   </para>

 </sect2>

 <sect2 id="monitoring-pg-stat-replication-view">
<!--==========================orignal english content==========================
  <title><structname>pg_stat_replication</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_stat_replication</structname></title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>pg_stat_replication</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>pg_stat_replication</primary>
  </indexterm>

<!--==========================orignal english content==========================
   <para>
   The <structname>pg_stat_replication</structname> view will contain one row
   per WAL sender process, showing statistics about replication to that
   sender's connected standby server.  Only directly connected standbys are
   listed; no information is available about downstream standby servers.
  </para>
____________________________________________________________________________-->
   <para>
   <structname>pg_stat_replication</structname>视图将在每个WAL发送方进程中包含一行，显示关于复制到发送方连接的备用服务器的统计信息。
   只有直接连接的备用设备被列出;没有关于下游备用服务器的信息。
  </para>

  <table id="pg-stat-replication-view" xreflabel="pg_stat_replication">
<!--==========================orignal english content==========================
   <title><structname>pg_stat_replication</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_stat_replication</structname> 视图</title>
   <tgroup cols="1">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       Process ID of a WAL sender process
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       一个 WAL 发送进程的进程 ID
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>usesysid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the user logged into this WAL sender process
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>usesysid</structfield> <type>oid</type>
      </para>
      <para>
       登录到这个 WAL 发送进程的用户的 OID
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>usename</structfield> <type>name</type>
      </para>
      <para>
       Name of the user logged into this WAL sender process
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>usename</structfield> <type>name</type>
      </para>
      <para>
       登录到这个 WAL 发送进程的用户的名称
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>application_name</structfield> <type>text</type>
      </para>
      <para>
       Name of the application that is connected
       to this WAL sender
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>application_name</structfield> <type>text</type>
      </para>
      <para>
       连接到这个 WAL 发送进程的应用的名称
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>client_addr</structfield> <type>inet</type>
      </para>
      <para>
       IP address of the client connected to this WAL sender.
       If this field is null, it indicates that the client is
       connected via a Unix socket on the server machine.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>client_addr</structfield> <type>inet</type>
      </para>
      <para>
       连接到这个 WAL 发送进程的客户端的 IP 地址。
       如果这个域为空，它表示该客户端通过服务器机器上的一个Unix 套接字连接。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>client_hostname</structfield> <type>text</type>
      </para>
      <para>
       Host name of the connected client, as reported by a
       reverse DNS lookup of <structfield>client_addr</structfield>. This field will
       only be non-null for IP connections, and only when <xref linkend="guc-log-hostname"/> is enabled.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>client_hostname</structfield> <type>text</type>
      </para>
      <para>
       连接上的客户端的主机名，由一次对<structfield>client_addr</structfield>的逆向 DNS 查找报告。
       这个域将只对 IP 连接非空，并且只有在 <xref linkend="guc-log-hostname"/>被启用时非空。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>client_port</structfield> <type>integer</type>
      </para>
      <para>
       TCP port number that the client is using for communication
       with this WAL sender, or <literal>-1</literal> if a Unix socket is used
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>client_port</structfield> <type>integer</type>
      </para>
      <para>
       客户端用来与这个 WAL 发送进程通讯的 TCP 端口号，如果使用 Unix 套接字则为<literal>-1</literal>
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>backend_start</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Time when this process was started, i.e., when the
       client connected to this WAL sender
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>backend_start</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       这个进程开始的时间，即客户端是何时连接到这个WAL 发送进程的。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>backend_xmin</structfield> <type>xid</type>
      </para>
      <para>
       This standby's <literal>xmin</literal> horizon reported
       by <xref linkend="guc-hot-standby-feedback"/>.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>backend_xmin</structfield> <type>xid</type>
      </para>
      <para>
       由<xref linkend="guc-hot-standby-feedback"/>报告的这个后备机的<literal>xmin</literal>水平线。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>state</structfield> <type>text</type>
      </para>
      <para>
       Current WAL sender state.
       Possible values are:
       <itemizedlist>
        <listitem>
         <para>
          <literal>startup</literal>: This WAL sender is starting up.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>catchup</literal>: This WAL sender's connected standby is
          catching up with the primary.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>streaming</literal>: This WAL sender is streaming changes
          after its connected standby server has caught up with the primary.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>backup</literal>: This WAL sender is sending a backup.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>stopping</literal>: This WAL sender is stopping.
         </para>
        </listitem>
       </itemizedlist>
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>state</structfield> <type>text</type>
      </para>
      <para>
       当前的 WAL 发送进程状态。
       可能的值是：
       <itemizedlist>
        <listitem>
         <para>
          <literal>startup</literal>: 这个WAL发送器正在启动。
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>catchup</literal>: 这个WAL发送者连接的备用服务器正在赶上主服务器。
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>streaming</literal>: 在其连接的备用服务器赶上主服务器之后，这个WAL发送方正在流化变化。
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>backup</literal>: 这个WAL发送器正在发送一个备份。
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>stopping</literal>: 这个WAL发送器正在停止。
         </para>
        </listitem>
       </itemizedlist>
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sent_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       Last write-ahead log location sent on this connection
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sent_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       在这个连接上发送的最后一个预写式日志的位置
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>write_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       Last write-ahead log location written to disk by this standby
       server
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>write_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       被这个后备服务器写入到磁盘的最后一个预写式日志的位置
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>flush_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       Last write-ahead log location flushed to disk by this standby
       server
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>flush_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       被这个后备服务器刷入到磁盘的最后一个预写式日志的位置
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>replay_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       Last write-ahead log location replayed into the database on this
       standby server
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>replay_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       被重放到这个后备服务器上的数据库中的最后一个预写式日志的位置
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>write_lag</structfield> <type>interval</type>
      </para>
      <para>
       Time elapsed between flushing recent WAL locally and receiving
       notification that this standby server has written it (but not yet
       flushed it or applied it).  This can be used to gauge the delay that
       <literal>synchronous_commit</literal> level
       <literal>remote_write</literal> incurred while committing if this
       server was configured as a synchronous standby.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>write_lag</structfield> <type>interval</type>
      </para>
      <para>
       从本地刷新近期的WAL与接收到此备用服务器已写入WAL的通知(但尚未刷新或应用它)之间的时间经过。
       如果将此服务器配置为同步备用服务器，则可以使用此参数来衡量在提交时<literal>synchronous_commit</literal>级别<literal>remote_write</literal>所导致的延迟。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>flush_lag</structfield> <type>interval</type>
      </para>
      <para>
       Time elapsed between flushing recent WAL locally and receiving
       notification that this standby server has written and flushed it
       (but not yet applied it).  This can be used to gauge the delay that
       <literal>synchronous_commit</literal> level
       <literal>on</literal> incurred while committing if this
       server was configured as a synchronous standby.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>flush_lag</structfield> <type>interval</type>
      </para>
      <para>
       在本地刷写近期的WAL与接收到后备服务器已经写入并且刷写它（但还没有应用）的通知之间流逝的时间。
       如果这台服务器被配置为一个同步后备，这可以用来计量在提交时<literal>synchronous_commit</literal>的级别<literal>on</literal>所导致的延迟。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>replay_lag</structfield> <type>interval</type>
      </para>
      <para>
       Time elapsed between flushing recent WAL locally and receiving
       notification that this standby server has written, flushed and
       applied it.  This can be used to gauge the delay that
       <literal>synchronous_commit</literal> level
       <literal>remote_apply</literal> incurred while committing if this
       server was configured as a synchronous standby.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>replay_lag</structfield> <type>interval</type>
      </para>
      <para>
       在本地刷写近期的WAL与接收到后备服务器已经写入它、刷写它并且应用它的通知之间流逝的时间。
       如果这台服务器被配置为一个同步后备，这可以用来计量在提交时<literal>synchronous_commit</literal>的级别<literal>remote_apply</literal>所导致的延迟。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sync_priority</structfield> <type>integer</type>
      </para>
      <para>
       Priority of this standby server for being chosen as the
       synchronous standby in a priority-based synchronous replication.
       This has no effect in a quorum-based synchronous replication.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sync_priority</structfield> <type>integer</type>
      </para>
      <para>
       在基于优先的同步复制中，这台后备服务器被选为同步后备的优先级。在基于规定数量的同步复制中，这个值没有效果。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sync_state</structfield> <type>text</type>
      </para>
      <para>
       Synchronous state of this standby server.
       Possible values are:
       <itemizedlist>
        <listitem>
         <para>
          <literal>async</literal>: This standby server is asynchronous.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>potential</literal>: This standby server is now asynchronous,
          but can potentially become synchronous if one of current
          synchronous ones fails.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>sync</literal>: This standby server is synchronous.
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>quorum</literal>: This standby server is considered as a candidate
          for quorum standbys.
         </para>
        </listitem>
       </itemizedlist>
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sync_state</structfield> <type>text</type>
      </para>
      <para>
       这一台后备服务器的同步状态。
       可能的值是：
       <itemizedlist>
        <listitem>
         <para>
          <literal>async</literal>: 这台后备服务器是异步的。
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>potential</literal>: 这台后备服务器现在是异步的，但可能在当前的同步后备失效时变成同步的。
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>sync</literal>: 这台后备服务器是同步的。
         </para>
        </listitem>
        <listitem>
         <para>
          <literal>quorum</literal>: 这台后备服务器被当做规定数量后备服务器的候选。
         </para>
        </listitem>
       </itemizedlist>
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>reply_time</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Send time of last reply message received from standby server
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>reply_time</structfield> <type>带时区的时间戳</type>
      </para>
      <para>
       从备用服务器收到的最后一条回复信息的发送时间
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   The lag times reported in the <structname>pg_stat_replication</structname>
   view are measurements of the time taken for recent WAL to be written,
   flushed and replayed and for the sender to know about it.  These times
   represent the commit delay that was (or would have been) introduced by each
   synchronous commit level, if the remote server was configured as a
   synchronous standby.  For an asynchronous standby, the
   <structfield>replay_lag</structfield> column approximates the delay
   before recent transactions became visible to queries.  If the standby
   server has entirely caught up with the sending server and there is no more
   WAL activity, the most recently measured lag times will continue to be
   displayed for a short time and then show NULL.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_stat_replication</structname>视图中报告的滞后时间近期的WAL被写入、刷写并且重放以及发送器知道这一切所花的时间的度量。如果远程服务器被配置为一台同步后备，这些时间表示由每一种同步提交级别所带来（或者是可能带来）的提交延迟。对于一台异步后备，<structfield>replay_lag</structfield>列是最近的事务变得对查询可见的延迟时间的近似值。如果后备服务器已经完全追上了发送服务器并且没有WAL活动，在短时间内将继续显示最近测到的滞后时间，再然后就会显示为NULL。
  </para>

<!--==========================orignal english content==========================
  <para>
   Lag times work automatically for physical replication. Logical decoding
   plugins may optionally emit tracking messages; if they do not, the tracking
   mechanism will simply display NULL lag.
  </para>
____________________________________________________________________________-->
  <para>
   对于物理复制会自动测量滞后时间。逻辑解码插件可能会选择性地发出跟踪消息，如果它们没有这样做，跟踪机制将把滞后显示为NULL。
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    The reported lag times are not predictions of how long it will take for
    the standby to catch up with the sending server assuming the current
    rate of replay.  Such a system would show similar times while new WAL is
    being generated, but would differ when the sender becomes idle.  In
    particular, when the standby has caught up completely,
    <structname>pg_stat_replication</structname> shows the time taken to
    write, flush and replay the most recent reported WAL location rather than
    zero as some users might expect.  This is consistent with the goal of
    measuring synchronous commit and transaction visibility delays for
    recent write transactions.
    To reduce confusion for users expecting a different model of lag, the
    lag columns revert to NULL after a short time on a fully replayed idle
    system. Monitoring systems should choose whether to represent this
    as missing data, zero or continue to display the last known value.
   </para>
____________________________________________________________________________-->
   <para>
    报告的滞后时间并非按照当前的重放速率该后备还有多久才能追上发送服务器的预测。在新的WAL被生成期间，这样一种系统将显示类似的时间，但是当发送器变为闲置时会显示不同的值。特别是当后备服务器完全追上时，<structname>pg_stat_replication</structname>显示的是写入、刷写及重放最近报告的WAL位置所花的时间而不是一些用户可能预期的零。这种做法与为近期的写事务测量同步提交和事务可见性延迟的目的一致。为了降低用户预期一种不同的滞后模型带来的混淆，在一个完全重放完的闲置系统上，lag列会在一段比较短的时间后回复成NULL。监控系统应该选择将这种情况表示为缺失数据、零或者继续显示最近的已知值。
   </para>
  </note>

 </sect2>

 <sect2 id="monitoring-pg-stat-replication-slots-view">
<!--==========================orignal english content==========================
  <title><structname>pg_stat_replication_slots</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_stat_replication_slots</structname></title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>pg_stat_replication_slots</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>pg_stat_replication_slots</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_stat_replication_slots</structname> view will contain
   one row per logical replication slot, showing statistics about its usage.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_stat_replication_slots</structname>视图将包含每个逻辑复制槽的一行，显示关于其使用情况的统计信息。
  </para>

  <table id="pg-stat-replication-slots-view" xreflabel="pg_stat_replication_slots">
<!--==========================orignal english content==========================
   <title><structname>pg_stat_replication_slots</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_stat_replication_slots</structname> View</title>
   <tgroup cols="1">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        Column Type
       </para>
       <para>
        Description
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        列类型
       </para>
       <para>
        描述
      </para></entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>slot_name</structfield> <type>text</type>
       </para>
       <para>
        A unique, cluster-wide identifier for the replication slot
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>slot_name</structfield> <type>text</type>
       </para>
       <para>
        唯一的，复制槽的集群范围标识符
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>spill_txns</structfield> <type>bigint</type>
       </para>
       <para>
        Number of transactions spilled to disk once the memory used by
        logical decoding to decode changes from WAL has exceeded
        <literal>logical_decoding_work_mem</literal>. The counter gets
        incremented for both top-level transactions and subtransactions.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>spill_txns</structfield> <type>bigint</type>
       </para>
       <para>
        当逻辑解码在解码来自WAL的更改时所使用的内存超过<literal>logical_decoding_work_mem</literal>，溢出到磁盘的事务数。
        顶级事务和子事务的计数器都是递增的。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>spill_count</structfield> <type>bigint</type>
       </para>
       <para>
        Number of times transactions were spilled to disk while decoding
        changes from WAL for this slot. This counter is incremented each time
        a transaction is spilled, and the same transaction may be spilled
        multiple times.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>spill_count</structfield> <type>bigint</type>
       </para>
       <para>
        在为该槽位解码来自WAL的更改时，事务溢出到磁盘的次数。
        此计数器在每次事务被溢出时递增，并且同一事务可能被溢出多次。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>spill_bytes</structfield> <type>bigint</type>
       </para>
       <para>
        Amount of decoded transaction data spilled to disk while performing
        decoding of changes from WAL for this slot. This and other spill
        counters can be used to gauge the I/O which occurred during logical
        decoding and allow tuning <literal>logical_decoding_work_mem</literal>.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>spill_bytes</structfield> <type>bigint</type>
       </para>
       <para>
        在对来自WAL的更改执行解码时，已解码的事务数据溢出到磁盘的数量。
        这个和其他溢出计数器可用于测量逻辑解码期间发生的I/O，并且允许调优<literal>logical_decoding_work_mem</literal>。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stream_txns</structfield> <type>bigint</type>
       </para>
       <para>
        Number of in-progress transactions streamed to the decoding output
        plugin after the memory used by logical decoding to decode changes
        from WAL for this slot has exceeded
        <literal>logical_decoding_work_mem</literal>. Streaming only
        works with top-level transactions (subtransactions can't be streamed
        independently), so the counter is not incremented for subtransactions.
       </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stream_txns</structfield> <type>bigint</type>
       </para>
       <para>
        在逻辑解码在解码来自该槽位的WAL更改的时候，所使用的内存超过<literal>logical_decoding_work_mem</literal>之后，流到解码输出插件的正在进行的事务数。
        流仅对顶级事务有效(子事务不能独立流)，因此子事务的计数器不会增加。
       </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stream_count</structfield><type>bigint</type>
       </para>
       <para>
        Number of times in-progress transactions were streamed to the decoding
        output plugin while decoding changes from WAL for this slot. This
        counter is incremented each time a transaction is streamed, and the
        same transaction may be streamed multiple times.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stream_count</structfield><type>bigint</type>
       </para>
       <para>
        在为该槽位解码来自WAL的更改时，将正在进行的事务流到解码输出插件的次数。
        此计数器在每次事务流化时递增，并且同一事务可能被流化多次。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stream_bytes</structfield><type>bigint</type>
       </para>
       <para>
        Amount of transaction data decoded for streaming in-progress
        transactions to the decoding output plugin while decoding changes from
        WAL for this slot. This and other streaming counters for this slot can
        be used to tune <literal>logical_decoding_work_mem</literal>.
       </para>
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stream_bytes</structfield><type>bigint</type>
       </para>
       <para>
        在为该槽位解码来自WAL的更改时，为将正在进行的事务流到解码输出插件而解码的事务数据的数量。
        这个和针对此槽位的其他流计数器可用于调优<literal>logical_decoding_work_mem</literal>。
       </para>
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>total_txns</structfield> <type>bigint</type>
       </para>
       <para>
        Number of decoded transactions sent to the decoding output plugin for
        this slot. This counts top-level transactions only, and is not incremented
        for subtransactions. Note that this includes the transactions that are
        streamed and/or spilled.
       </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>total_txns</structfield> <type>bigint</type>
       </para>
       <para>
        针对此槽的，发送到解码输出插件的已解码事务数。
        这只计算顶级事务，对子事务不会增加。
        注意，这包括流化和/或溢出的事务。
       </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>total_bytes</structfield><type>bigint</type>
       </para>
       <para>
        Amount of transaction data decoded for sending transactions to the
        decoding output plugin while decoding changes from WAL for this slot.
        Note that this includes data that is streamed and/or spilled.
       </para>
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>total_bytes</structfield><type>bigint</type>
       </para>
       <para>
        在对此槽位的WAL进行解码时，为将事务发送到解码输出插件而解码的事务数据量。
        注意这包括流和/或溢出的数据。
       </para>
      </entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
       </para>
       <para>
        Time at which these statistics were last reset
       </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
        <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
       </para>
       <para>
        这些统计最后重置的时间
       </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="monitoring-pg-stat-wal-receiver-view">
<!--==========================orignal english content==========================
  <title><structname>pg_stat_wal_receiver</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_stat_wal_receiver</structname></title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>pg_stat_wal_receiver</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>pg_stat_wal_receiver</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_stat_wal_receiver</structname> view will contain only
   one row, showing statistics about the WAL receiver from that receiver's
   connected server.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_stat_wal_receiver</structname>事务只包含一行，它显示了从 WAL 接收器所连接的服务器得到的有关该接收器的统计信息。
  </para>

  <table id="pg-stat-wal-receiver-view" xreflabel="pg_stat_wal_receiver">
<!--==========================orignal english content==========================
   <title><structname>pg_stat_wal_receiver</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_stat_wal_receiver</structname> 视图</title>
   <tgroup cols="1">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       Process ID of the WAL receiver process
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       WAL接收器进程的进程ID
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>status</structfield> <type>text</type>
      </para>
      <para>
       Activity status of the WAL receiver process
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>status</structfield> <type>text</type>
      </para>
      <para>
       WAL接收进程的活动状态
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>receive_start_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       First write-ahead log location used when WAL receiver is
       started
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>receive_start_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       WAL接收器启动时使用的第一个写前日志位置
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>receive_start_tli</structfield> <type>integer</type>
      </para>
      <para>
       First timeline number used when WAL receiver is started
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>receive_start_tli</structfield> <type>integer</type>
      </para>
      <para>
       WAL接收器启动时使用的第一个时间线数字
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>written_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       Last write-ahead log location already received and written to disk,
       but not flushed. This should not be used for data integrity checks.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>written_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       已经接收并写入磁盘的最后一个预写式日志位置，但没有刷入。这不能用于数据完整性检查。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>flushed_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       Last write-ahead log location already received and flushed to
       disk, the initial value of this field being the first log location used
       when WAL receiver is started
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>flushed_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       已经接收并刷入到磁盘的最后一个预写式日志位置，该字段的初始值是启动WAL接收器时使用的第一个日志位置
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>received_tli</structfield> <type>integer</type>
      </para>
      <para>
       Timeline number of last write-ahead log location received and
       flushed to disk, the initial value of this field being the timeline
       number of the first log location used when WAL receiver is started
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>received_tli</structfield> <type>integer</type>
      </para>
      <para>
       接收并刷入到磁盘的最后一个预写式日志位置的时间线数字，该字段的初始值为启动WAL接收器时使用的第一个日志位置的时间线数字
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_msg_send_time</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Send time of last message received from origin WAL sender
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_msg_send_time</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       从源头WAL发送器收到的最后一条信息的发送时间
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_msg_receipt_time</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Receipt time of last message received from origin WAL sender
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_msg_receipt_time</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       从源头WAL发送器收到的最后一条信息的接收时间
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>latest_end_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       Last write-ahead log location reported to origin WAL sender
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>latest_end_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       向源头WAL发送器报告的最后的预写式日志位置
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>latest_end_time</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Time of last write-ahead log location reported to origin WAL sender
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>latest_end_time</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       向源头WAL发送方报告的最后一次写前日志位置的时间
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>slot_name</structfield> <type>text</type>
      </para>
      <para>
       Replication slot name used by this WAL receiver
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>slot_name</structfield> <type>text</type>
      </para>
      <para>
       这个WAL接收器使用的复制槽的名称
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sender_host</structfield> <type>text</type>
      </para>
      <para>
       Host of the <productname>PostgreSQL</productname> instance
       this WAL receiver is connected to. This can be a host name,
       an IP address, or a directory path if the connection is via
       Unix socket.  (The path case can be distinguished because it
       will always be an absolute path, beginning with <literal>/</literal>.)
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sender_host</structfield> <type>text</type>
      </para>
      <para>
       这个WAL接收器连接到的<productname>PostgreSQL</productname>实例的主机。
	   这可以是主机名、IP地址，或者目录路径，如果连接是通过Unix套接字进行的。(路径的情况可以区分，因为它总是以<literal>/</literal>开头的绝对路径。)
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sender_port</structfield> <type>integer</type>
      </para>
      <para>
       Port number of the <productname>PostgreSQL</productname> instance
       this WAL receiver is connected to.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sender_port</structfield> <type>integer</type>
      </para>
      <para>
       这个WAL接收器连接的<productname>PostgreSQL</productname>实例的端口号。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>conninfo</structfield> <type>text</type>
      </para>
      <para>
       Connection string used by this WAL receiver,
       with security-sensitive fields obfuscated.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>conninfo</structfield> <type>text</type>
      </para>
      <para>
       这个WAL接收器使用的连接字符串，对安全敏感的字段进行了模糊处理。
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="monitoring-pg-stat-subscription">
<!--==========================orignal english content==========================
  <title><structname>pg_stat_subscription</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_stat_subscription</structname></title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>pg_stat_subscription</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>pg_stat_subscription</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_stat_subscription</structname> view will contain one
   row per subscription for main worker (with null PID if the worker is
   not running), and additional rows for workers handling the initial data
   copy of the subscribed tables.
  </para>
____________________________________________________________________________-->
  <para>
   每一个订阅的主工作者都在<structname>pg_stat_subscription</structname>视图中有一行（如果工作者没有运行则PID为空），处理被订阅表的初始数据拷贝操作的工作者还会有额外的行。
  </para>

  <table id="pg-stat-subscription" xreflabel="pg_stat_subscription">
<!--==========================orignal english content==========================
   <title><structname>pg_stat_subscription</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_stat_subscription</structname> View</title>
   <tgroup cols="1">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>subid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the subscription
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>subid</structfield> <type>oid</type>
      </para>
      <para>
       订阅的OID
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>subname</structfield> <type>name</type>
      </para>
      <para>
       Name of the subscription
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>subname</structfield> <type>name</type>
      </para>
      <para>
       订阅的名称
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       Process ID of the subscription worker process
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       订阅工作者进程的进程ID
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the relation that the worker is synchronizing; null for the
       main apply worker
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       工作器正在同步的关系的OID;Null用于主应用工作器
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>received_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       Last write-ahead log location received, the initial value of
       this field being 0
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>received_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       接收到的最后一个预写式日志位置，该字段的初始值为0
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_msg_send_time</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Send time of last message received from origin WAL sender
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_msg_send_time</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       从WAL发送器收到的最后一条信息的发送时间
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_msg_receipt_time</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Receipt time of last message received from origin WAL sender
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_msg_receipt_time</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       从WAL发送器收到的最后一条信息的接收时间
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>latest_end_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       Last write-ahead log location reported to origin WAL sender
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>latest_end_lsn</structfield> <type>pg_lsn</type>
      </para>
      <para>
       向WAL发送器报告的最后预写式日志位置
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>latest_end_time</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Time of last write-ahead log location reported to origin WAL
       sender
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>latest_end_time</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       向WAL发送器报告的最后一次预写式日志位置的时间
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="monitoring-pg-stat-ssl-view">
<!--==========================orignal english content==========================
  <title><structname>pg_stat_ssl</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_stat_ssl</structname></title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>pg_stat_ssl</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>pg_stat_ssl</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_stat_ssl</structname> view will contain one row per
   backend or WAL sender process, showing statistics about SSL usage on
   this connection. It can be joined to <structname>pg_stat_activity</structname>
   or <structname>pg_stat_replication</structname> on the
   <structfield>pid</structfield> column to get more details about the
   connection.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_stat_ssl</structname>视图将为每一个后端或者 WAL 发送进程包含一行，用来显示这个连接上的 SSL 使用情况。
   可以把它与<structname>pg_stat_activity</structname>或者<structname>pg_stat_replication</structname>通过<structfield>pid</structfield>列连接来得到更多有关该连接的细节。
  </para>

  <table id="pg-stat-ssl-view" xreflabel="pg_stat_ssl">
<!--==========================orignal english content==========================
   <title><structname>pg_stat_ssl</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_stat_ssl</structname> 视图</title>
   <tgroup cols="1">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       Process ID of a backend or WAL sender process
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       后端或WAL发送器进程ID
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>ssl</structfield> <type>boolean</type>
      </para>
      <para>
       True if SSL is used on this connection
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>ssl</structfield> <type>boolean</type>
      </para>
      <para>
       如果在此连接上使用SSL，则为真
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>version</structfield> <type>text</type>
      </para>
      <para>
       Version of SSL in use, or NULL if SSL is not in use
       on this connection
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>version</structfield> <type>text</type>
      </para>
      <para>
       使用SSL的版本，如果此连接上没有使用SSL则为NULL
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>cipher</structfield> <type>text</type>
      </para>
      <para>
       Name of SSL cipher in use, or NULL if SSL is not in use
       on this connection
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>cipher</structfield> <type>text</type>
      </para>
      <para>
       正在使用的SSL密码的名称，如果此连接上没有使用SSL则为NULL
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>bits</structfield> <type>integer</type>
      </para>
      <para>
       Number of bits in the encryption algorithm used, or NULL
       if SSL is not used on this connection
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>bits</structfield> <type>integer</type>
      </para>
      <para>
       使用的加密算法中的位数，如果此连接上没有使用SSL则为NULL
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>client_dn</structfield> <type>text</type>
      </para>
      <para>
       Distinguished Name (DN) field from the client certificate
       used, or NULL if no client certificate was supplied or if SSL
       is not in use on this connection. This field is truncated if the
       DN field is longer than <symbol>NAMEDATALEN</symbol> (64 characters
       in a standard build).
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>client_dn</structfield> <type>text</type>
      </para>
      <para>
       区别名称(DN，Distinguished Name)字段与使用的客户端证书，如果没有提供客户端证书或在此连接上没有使用SSL，则为NULL。
       如果DN字段长于<symbol>NAMEDATALEN</symbol>(标准构建中为64个字符)，则该字段将被截断。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>client_serial</structfield> <type>numeric</type>
      </para>
      <para>
       Serial number of the client certificate, or NULL if no client
       certificate was supplied or if SSL is not in use on this connection.  The
       combination of certificate serial number and certificate issuer uniquely
       identifies a certificate (unless the issuer erroneously reuses serial
       numbers).
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>client_serial</structfield> <type>numeric</type>
      </para>
      <para>
       客户端证书的序列号，如果没有提供客户端证书或在此连接上没有使用SSL，则为NULL。
       证书序列号和证书颁发者的组合唯一标识一个证书(除非颁发者错误地重用序列号)。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>issuer_dn</structfield> <type>text</type>
      </para>
      <para>
       DN of the issuer of the client certificate, or NULL if no client
       certificate was supplied or if SSL is not in use on this connection.
       This field is truncated like <structfield>client_dn</structfield>.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>issuer_dn</structfield> <type>text</type>
      </para>
      <para>
       客户端证书颁发者的区别名称(DN，Distinguished Name)，如果没有提供客户端证书或在此连接上没有使用SSL，则为NULL。该字段像<structfield>client_dn</structfield>一样被截断。
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="monitoring-pg-stat-gssapi-view">
<!--==========================orignal english content==========================
  <title><structname>pg_stat_gssapi</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_stat_gssapi</structname></title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>pg_stat_gssapi</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>pg_stat_gssapi</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_stat_gssapi</structname> view will contain one row per
   backend, showing information about GSSAPI usage on this connection. It can
   be joined to <structname>pg_stat_activity</structname> or
   <structname>pg_stat_replication</structname> on the
   <structfield>pid</structfield> column to get more details about the
   connection.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_stat_gssapi</structname>视图将包含每一个后端一个行，显示该连接上的GSSAPI使用情况。
   它可以加入到<structname>pg_stat_activity</structname>或<structname>pg_stat_replication</structname>上的<structfield>pid</structfield>列，获取更多关于连接的详细信息。
  </para>

  <table id="pg-stat-gssapi-view" xreflabel="pg_stat_gssapi">
<!--==========================orignal english content==========================
   <title><structname>pg_stat_gssapi</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_stat_gssapi</structname> 视图</title>
   <tgroup cols="1">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       Process ID of a backend
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       后端进程ID
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>gss_authenticated</structfield> <type>boolean</type>
      </para>
      <para>
       True if GSSAPI authentication was used for this connection
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>gss_authenticated</structfield> <type>boolean</type>
      </para>
      <para>
       如果此连接使用了GSSAPI身份验证，则为True
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>principal</structfield> <type>text</type>
      </para>
      <para>
       Principal used to authenticate this connection, or NULL
       if GSSAPI was not used to authenticate this connection.  This
       field is truncated if the principal is longer than
       <symbol>NAMEDATALEN</symbol> (64 characters in a standard build).
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>principal</structfield> <type>text</type>
      </para>
      <para>
       用于验证此连接的主体，如果未使用GSSAPI对此连接进行身份验证，则为NULL。
       如果主体长度超过<symbol>NAMEDATALEN</symbol>(标准构建中为64个字符)，则该字段被截断。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>encrypted</structfield> <type>boolean</type>
      </para>
      <para>
       True if GSSAPI encryption is in use on this connection
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>encrypted</structfield> <type>boolean</type>
      </para>
      <para>
       如果在此连接上使用了GSSAPI加密，则为真
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="monitoring-pg-stat-archiver-view">
<!--==========================orignal english content==========================
  <title><structname>pg_stat_archiver</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_stat_archiver</structname></title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>pg_stat_archiver</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>pg_stat_archiver</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_stat_archiver</structname> view will always have a
   single row, containing data about the archiver process of the cluster.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_stat_archiver</structname>视图总是有一行，其中包含关于集群的存档进程的数据。
  </para>

  <table id="pg-stat-archiver-view" xreflabel="pg_stat_archiver">
<!--==========================orignal english content==========================
   <title><structname>pg_stat_archiver</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_stat_archiver</structname> 视图</title>
   <tgroup cols="1">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>archived_count</structfield> <type>bigint</type>
      </para>
      <para>
       Number of WAL files that have been successfully archived
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>archived_count</structfield> <type>bigint</type>
      </para>
      <para>
       已成功存档的WAL文件数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_archived_wal</structfield> <type>text</type>
      </para>
      <para>
       Name of the last WAL file successfully archived
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_archived_wal</structfield> <type>text</type>
      </para>
      <para>
       最后一个成功存档的WAL文件的名称
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_archived_time</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Time of the last successful archive operation
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_archived_time</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       最后一次成功存档操作的时间
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>failed_count</structfield> <type>bigint</type>
      </para>
      <para>
       Number of failed attempts for archiving WAL files
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>failed_count</structfield> <type>bigint</type>
      </para>
      <para>
       记录WAL文件归档失败次数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_failed_wal</structfield> <type>text</type>
      </para>
      <para>
       Name of the WAL file of the last failed archival operation
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_failed_wal</structfield> <type>text</type>
      </para>
      <para>
       最后一次失败的存档操作的WAL文件的名称
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_failed_time</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Time of the last failed archival operation
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_failed_time</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       上次存档操作失败的时间
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Time at which these statistics were last reset
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       这些统计数据最后一次重置的时间
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="monitoring-pg-stat-bgwriter-view">
<!--==========================orignal english content==========================
  <title><structname>pg_stat_bgwriter</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_stat_bgwriter</structname></title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>pg_stat_bgwriter</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>pg_stat_bgwriter</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_stat_bgwriter</structname> view will always have a
   single row, containing global data for the cluster.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_stat_bgwriter</structname>视图始终只有一行，其中包含集群的全局数据。
  </para>

  <table id="pg-stat-bgwriter-view" xreflabel="pg_stat_bgwriter">
<!--==========================orignal english content==========================
   <title><structname>pg_stat_bgwriter</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_stat_bgwriter</structname> View</title>
   <tgroup cols="1">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>checkpoints_timed</structfield> <type>bigint</type>
      </para>
      <para>
       Number of scheduled checkpoints that have been performed
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>checkpoints_timed</structfield> <type>bigint</type>
      </para>
      <para>
       已执行的预定检查点数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>checkpoints_req</structfield> <type>bigint</type>
      </para>
      <para>
       Number of requested checkpoints that have been performed
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>checkpoints_req</structfield> <type>bigint</type>
      </para>
      <para>
       请求已执行的检查点数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>checkpoint_write_time</structfield> <type>double precision</type>
      </para>
      <para>
       Total amount of time that has been spent in the portion of
       checkpoint processing where files are written to disk, in milliseconds
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>checkpoint_write_time</structfield> <type>double precision</type>
      </para>
      <para>
       检查点处理中将文件写入磁盘的部分所花费的总时间，以毫秒为单位
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>checkpoint_sync_time</structfield> <type>double precision</type>
      </para>
      <para>
       Total amount of time that has been spent in the portion of
       checkpoint processing where files are synchronized to disk, in
       milliseconds
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>checkpoint_sync_time</structfield> <type>double precision</type>
      </para>
      <para>
       检查点处理中将文件同步到磁盘的部分所花费的总时间，以毫秒为单位
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>buffers_checkpoint</structfield> <type>bigint</type>
      </para>
      <para>
       Number of buffers written during checkpoints
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>buffers_checkpoint</structfield> <type>bigint</type>
      </para>
      <para>
       检查点期间写入的缓冲区数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>buffers_clean</structfield> <type>bigint</type>
      </para>
      <para>
       Number of buffers written by the background writer
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>buffers_clean</structfield> <type>bigint</type>
      </para>
      <para>
       后台写入器写入的缓冲区数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>maxwritten_clean</structfield> <type>bigint</type>
      </para>
      <para>
       Number of times the background writer stopped a cleaning
       scan because it had written too many buffers
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>maxwritten_clean</structfield> <type>bigint</type>
      </para>
      <para>
       后台写入器因为写入太多缓冲区而停止清理扫描的次数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>buffers_backend</structfield> <type>bigint</type>
      </para>
      <para>
       Number of buffers written directly by a backend
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>buffers_backend</structfield> <type>bigint</type>
      </para>
      <para>
       后端直接写入的缓冲区数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>buffers_backend_fsync</structfield> <type>bigint</type>
      </para>
      <para>
       Number of times a backend had to execute its own
       <function>fsync</function> call (normally the background writer handles those
       even when the backend does its own write)
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>buffers_backend_fsync</structfield> <type>bigint</type>
      </para>
      <para>
       后端必须执行自己的<function>fsync</function>调用的次数(通常后台写入器处理这些，即使后端执行自己的写入)
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>buffers_alloc</structfield> <type>bigint</type>
      </para>
      <para>
       Number of buffers allocated
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>buffers_alloc</structfield> <type>bigint</type>
      </para>
      <para>
       分配的缓冲区数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Time at which these statistics were last reset
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       这些统计数据最后一次重置的时间
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="monitoring-pg-stat-wal-view">
<!--==========================orignal english content==========================
   <title><structname>pg_stat_wal</structname></title>
____________________________________________________________________________-->
   <title><structname>pg_stat_wal</structname></title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>pg_stat_wal</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>pg_stat_wal</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_stat_wal</structname> view will always have a
   single row, containing data about WAL activity of the cluster.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_stat_wal</structname> 视图一直有一行，包含关于集群的WAL活动的数据。
  </para>

  <table id="pg-stat-wal-view" xreflabel="pg_stat_wal">
<!--==========================orignal english content==========================
   <title><structname>pg_stat_wal</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_stat_wal</structname> View</title>
   <tgroup cols="1">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_records</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of WAL records generated
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_records</structfield> <type>bigint</type>
      </para>
      <para>
       生成的WAL记录的总数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_fpi</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of WAL full page images generated
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_fpi</structfield> <type>bigint</type>
      </para>
      <para>
       生成的WAL全页映像的总数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_bytes</structfield> <type>numeric</type>
      </para>
      <para>
       Total amount of WAL generated in bytes
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_bytes</structfield> <type>numeric</type>
      </para>
      <para>
       生成的WAL总数，以字节计
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_buffers_full</structfield> <type>bigint</type>
      </para>
      <para>
       Number of times WAL data was written to disk because WAL buffers became full
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_buffers_full</structfield> <type>bigint</type>
      </para>
      <para>
       因为缓冲区已满，WAL数据被写入磁盘的次数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_write</structfield> <type>bigint</type>
      </para>
      <para>
       Number of times WAL buffers were written out to disk via
       <function>XLogWrite</function> request.
       See <xref linkend="wal-configuration"/> for more information about
       the internal WAL function <function>XLogWrite</function>.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_write</structfield> <type>bigint</type>
      </para>
      <para>
       通过<function>XLogWrite</function>请求，WAL缓冲区被写入到磁盘的次数。
       有关内部WAL函数<function>XLogWrite</function>的更多信息，请参见<xref linkend="wal-configuration"/>。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_sync</structfield> <type>bigint</type>
      </para>
      <para>
       Number of times WAL files were synced to disk via
       <function>issue_xlog_fsync</function> request
       (if <xref linkend="guc-fsync"/> is <literal>on</literal> and
       <xref linkend="guc-wal-sync-method"/> is either
       <literal>fdatasync</literal>, <literal>fsync</literal> or
       <literal>fsync_writethrough</literal>, otherwise zero).
       See <xref linkend="wal-configuration"/> for more information about
       the internal WAL function <function>issue_xlog_fsync</function>.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_sync</structfield> <type>bigint</type>
      </para>
      <para>
       通过<function>issue_xlog_fsync</function> 请求将WAL文件同步到磁盘的次数(如果<xref linkend="guc-fsync"/> 是 <literal>on</literal>且<xref linkend="guc-wal-sync-method"/>是<literal>fdatasync</literal>, <literal>fsync</literal> 或 <literal>fsync_writethrough</literal>，否则为零)。
       有关内部WAL函数<function>issue_xlog_fsync</function>的更多信息，参见<xref linkend="wal-configuration"/>。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_write_time</structfield> <type>double precision</type>
      </para>
      <para>
       Total amount of time spent writing WAL buffers to disk via
       <function>XLogWrite</function> request, in milliseconds
       (if <xref linkend="guc-track-wal-io-timing"/> is enabled,
       otherwise zero).  This includes the sync time when
       <varname>wal_sync_method</varname> is either
       <literal>open_datasync</literal> or <literal>open_sync</literal>.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_write_time</structfield> <type>double precision</type>
      </para>
      <para>
       通过<function>XLogWrite</function>请求将WAL缓冲区写入磁盘所消耗的总时间，以毫秒计(如果<xref linkend="guc-track-wal-io-timing"/>是启用的，否则为零)。
       这包括当<varname>wal_sync_method</varname>为<literal>open_datasync</literal> 或 <literal>open_sync</literal>时的同步时间。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_sync_time</structfield> <type>double precision</type>
      </para>
      <para>
       Total amount of time spent syncing WAL files to disk via
       <function>issue_xlog_fsync</function> request, in milliseconds
       (if <varname>track_wal_io_timing</varname> is enabled,
       <varname>fsync</varname> is <literal>on</literal>, and
       <varname>wal_sync_method</varname> is either
       <literal>fdatasync</literal>, <literal>fsync</literal> or
       <literal>fsync_writethrough</literal>, otherwise zero).
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>wal_sync_time</structfield> <type>double precision</type>
      </para>
      <para>
       通过<function>issue_xlog_fsync</function>请求将WAL文件同步到磁盘所消耗的总时间，以毫秒计(如果 <varname>track_wal_io_timing</varname> 被启用，<varname>fsync</varname> is <literal>on</literal>, 和 <varname>wal_sync_method</varname> 为 <literal>fdatasync</literal>, <literal>fsync</literal> 或 <literal>fsync_writethrough</literal>, 否则为零).
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Time at which these statistics were last reset
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       这些统计最后重置的时间
      </para></entry>
     </row>
     </tbody>
   </tgroup>
  </table>

</sect2>

 <sect2 id="monitoring-pg-stat-database-view">
<!--==========================orignal english content==========================
  <title><structname>pg_stat_database</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_stat_database</structname></title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>pg_stat_database</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>pg_stat_database</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_stat_database</structname> view will contain one row
   for each database in the cluster, plus one for shared objects, showing
   database-wide statistics.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_stat_database</structname>视图将包含一行用于集群中的每个数据库，加一行用于共享对象，显示数据库范围的统计信息。
  </para>

  <table id="pg-stat-database-view" xreflabel="pg_stat_database">
<!--==========================orignal english content==========================
   <title><structname>pg_stat_database</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_stat_database</structname> 视图</title>
   <tgroup cols="1">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datid</structfield> <type>oid</type>
      </para>
      <para>
       OID of this database, or 0 for objects belonging to a shared
       relation
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datid</structfield> <type>oid</type>
      </para>
      <para>
       该数据库的OID，属于共享关系的对象为0
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datname</structfield> <type>name</type>
      </para>
      <para>
       Name of this database, or <literal>NULL</literal> for shared
       objects.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datname</structfield> <type>name</type>
      </para>
      <para>
       这个数据库的名称，或者共享对象为<literal>NULL</literal>。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>numbackends</structfield> <type>integer</type>
      </para>
      <para>
       Number of backends currently connected to this database, or
       <literal>NULL</literal> for shared objects.  This is the only column
       in this view that returns a value reflecting current state; all other
       columns return the accumulated values since the last reset.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>numbackends</structfield> <type>integer</type>
      </para>
      <para>
       当前连接到此数据库的后端数，对于共享对象则为<literal>NULL</literal>。
       这是该视图中唯一返回反映当前状态的值的列;所有其他列返回自上次重置以来累积的值。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>xact_commit</structfield> <type>bigint</type>
      </para>
      <para>
       Number of transactions in this database that have been
       committed
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>xact_commit</structfield> <type>bigint</type>
      </para>
      <para>
       此数据库中已提交的事务数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>xact_rollback</structfield> <type>bigint</type>
      </para>
      <para>
       Number of transactions in this database that have been
       rolled back
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>xact_rollback</structfield> <type>bigint</type>
      </para>
      <para>
       该数据库中已回滚的事务数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       Number of disk blocks read in this database
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       在该数据库中读取的磁盘块数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       Number of times disk blocks were found already in the buffer
       cache, so that a read was not necessary (this only includes hits in the
       PostgreSQL buffer cache, not the operating system's file system cache)
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       在缓存中发现磁盘块的次数，因此读取不是必需的(这只包括在PostgreSQL缓存中，而不是在操作系统的文件系统缓存中)
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tup_returned</structfield> <type>bigint</type>
      </para>
      <para>
       Number of rows returned by queries in this database
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tup_returned</structfield> <type>bigint</type>
      </para>
      <para>
       这个数据库中查询返回的行数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tup_fetched</structfield> <type>bigint</type>
      </para>
      <para>
       Number of rows fetched by queries in this database
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tup_fetched</structfield> <type>bigint</type>
      </para>
      <para>
       这个数据库中查询获取的行数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tup_inserted</structfield> <type>bigint</type>
      </para>
      <para>
       Number of rows inserted by queries in this database
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tup_inserted</structfield> <type>bigint</type>
      </para>
      <para>
       查询在该数据库中插入的行数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tup_updated</structfield> <type>bigint</type>
      </para>
      <para>
       Number of rows updated by queries in this database
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tup_updated</structfield> <type>bigint</type>
      </para>
      <para>
       这个数据库中查询更新的行数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tup_deleted</structfield> <type>bigint</type>
      </para>
      <para>
       Number of rows deleted by queries in this database
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tup_deleted</structfield> <type>bigint</type>
      </para>
      <para>
       这个数据库中被查询删除的行数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>conflicts</structfield> <type>bigint</type>
      </para>
      <para>
       Number of queries canceled due to conflicts with recovery
       in this database. (Conflicts occur only on standby servers; see
       <link linkend="monitoring-pg-stat-database-conflicts-view">
       <structname>pg_stat_database_conflicts</structname></link> for details.)
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>conflicts</structfield> <type>bigint</type>
      </para>
      <para>
       由于与此数据库中的恢复冲突而取消的查询数。(冲突只发生在备用服务器上;详请参见<link linkend="monitoring-pg-stat-database-conflicts-view">
       <structname>pg_stat_database_conflicts</structname></link>。)
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>temp_files</structfield> <type>bigint</type>
      </para>
      <para>
       Number of temporary files created by queries in this database.
       All temporary files are counted, regardless of why the temporary file
       was created (e.g., sorting or hashing), and regardless of the
       <xref linkend="guc-log-temp-files"/> setting.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>temp_files</structfield> <type>bigint</type>
      </para>
      <para>
       这个数据库中查询创建的临时文件的数量。所有临时文件都将被计数，而不顾及临时文件为什么被创建(例如，排序或散列)，也不考虑<xref linkend="guc-log-temp-files"/>设置。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>temp_bytes</structfield> <type>bigint</type>
      </para>
      <para>
       Total amount of data written to temporary files by queries in
       this database. All temporary files are counted, regardless of why
       the temporary file was created, and
       regardless of the <xref linkend="guc-log-temp-files"/> setting.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>temp_bytes</structfield> <type>bigint</type>
      </para>
      <para>
       这个数据库中的查询写入临时文件的数据总量。所有临时文件都将被计数，而不考虑临时文件为什么被创建，也不考虑<xref linkend="guc-log-temp-files"/>设置。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>deadlocks</structfield> <type>bigint</type>
      </para>
      <para>
       Number of deadlocks detected in this database
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>deadlocks</structfield> <type>bigint</type>
      </para>
      <para>
       在此数据库中检测到的死锁数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>checksum_failures</structfield> <type>bigint</type>
      </para>
      <para>
       Number of data page checksum failures detected in this
       database (or on a shared object), or NULL if data checksums are not
       enabled.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>checksum_failures</structfield> <type>bigint</type>
      </para>
      <para>
       在此数据库(或共享对象)中检测到的数据页校验码失败数，如果没有启用数据校验码则为NULL。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>checksum_last_failure</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Time at which the last data page checksum failure was detected in
       this database (or on a shared object), or NULL if data checksums are not
       enabled.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>checksum_last_failure</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       在此数据库(或共享对象)中检测到最后一个数据页校验码失败的时间，如果没有启用数据校验码则为NULL。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blk_read_time</structfield> <type>double precision</type>
      </para>
      <para>
       Time spent reading data file blocks by backends in this database,
       in milliseconds (if <xref linkend="guc-track-io-timing"/> is enabled,
       otherwise zero)
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blk_read_time</structfield> <type>double precision</type>
      </para>
      <para>
       在这个数据库中通过后端读取数据文件块所花费的时间，以毫秒为单位(如果启用了<xref linkend="guc-track-io-timing"/>，否则为零)
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blk_write_time</structfield> <type>double precision</type>
      </para>
      <para>
       Time spent writing data file blocks by backends in this database,
       in milliseconds (if <xref linkend="guc-track-io-timing"/> is enabled,
       otherwise zero)
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blk_write_time</structfield> <type>double precision</type>
      </para>
      <para>
       在这个数据库中通过后端写数据文件块所花费的时间，以毫秒为单位(如果启用了<xref linkend="guc-track-io-timing"/>，否则为零)
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>session_time</structfield> <type>double precision</type>
      </para>
      <para>
       Time spent by database sessions in this database, in milliseconds
       (note that statistics are only updated when the state of a session
       changes, so if sessions have been idle for a long time, this idle time
       won't be included)
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>session_time</structfield> <type>double precision</type>
      </para>
      <para>
       此数据库中数据库会话所消耗的时间，以毫秒计(注意统计信息仅在会话状态发生变化时更新，因此如果会话空闲很长时间，则不包括此空闲时间)
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>active_time</structfield> <type>double precision</type>
      </para>
      <para>
       Time spent executing SQL statements in this database, in milliseconds
       (this corresponds to the states <literal>active</literal> and
       <literal>fastpath function call</literal> in
       <link linkend="monitoring-pg-stat-activity-view">
       <structname>pg_stat_activity</structname></link>)
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>active_time</structfield> <type>double precision</type>
      </para>
      <para>
       此数据库中执行SQL语句所消耗的时间，以毫秒计(这对应于<link linkend="monitoring-pg-stat-activity-view"> <structname>pg_stat_activity</structname></link>中的 <literal>active</literal> 和 <literal>fastpath function call</literal> 状态)
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idle_in_transaction_time</structfield> <type>double precision</type>
      </para>
      <para>
       Time spent idling while in a transaction in this database, in milliseconds
       (this corresponds to the states <literal>idle in transaction</literal> and
       <literal>idle in transaction (aborted)</literal> in
       <link linkend="monitoring-pg-stat-activity-view">
       <structname>pg_stat_activity</structname></link>)
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idle_in_transaction_time</structfield> <type>double precision</type>
      </para>
      <para>
       此数据库中事务空闲所消耗的时间，以毫秒计(这对应于<link linkend="monitoring-pg-stat-activity-view"> <structname>pg_stat_activity</structname></link>中的 <literal>idle in transaction</literal> 和 <literal>idle in transaction (aborted)</literal> 状态)
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sessions</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of sessions established to this database
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sessions</structfield> <type>bigint</type>
      </para>
      <para>
       此数据库建立的会话总数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sessions_abandoned</structfield> <type>bigint</type>
      </para>
      <para>
       Number of database sessions to this database that were terminated
       because connection to the client was lost
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sessions_abandoned</structfield> <type>bigint</type>
      </para>
      <para>
       此数据库因为到客户端的连接丢失而被终止的数据库会话数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sessions_fatal</structfield> <type>bigint</type>
      </para>
      <para>
       Number of database sessions to this database that were terminated
       by fatal errors
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sessions_fatal</structfield> <type>bigint</type>
      </para>
      <para>
       此数据库因为致命错误而被终止的数据库会话数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sessions_killed</structfield> <type>bigint</type>
      </para>
      <para>
       Number of database sessions to this database that were terminated
       by operator intervention
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sessions_killed</structfield> <type>bigint</type>
      </para>
      <para>
       此数据库因为操作者介入而被终止的数据库会话数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Time at which these statistics were last reset
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       这些统计数据最后一次重置的时间
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="monitoring-pg-stat-database-conflicts-view">
<!--==========================orignal english content==========================
  <title><structname>pg_stat_database_conflicts</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_stat_database_conflicts</structname></title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>pg_stat_database_conflicts</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>pg_stat_database_conflicts</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_stat_database_conflicts</structname> view will contain
   one row per database, showing database-wide statistics about
   query cancels occurring due to conflicts with recovery on standby servers.
   This view will only contain information on standby servers, since
   conflicts do not occur on primary servers.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_stat_database_conflicts</structname>视图为每一个数据库包含一行，用来显示数据库范围内由于与后备服务器上的恢复过程冲突而被取消的查询的统计信息。 
   这个视图将只包含后备服务器上的信息，因为冲突会不发生在主服务器上。
  </para>

  <table id="pg-stat-database-conflicts-view" xreflabel="pg_stat_database_conflicts">
<!--==========================orignal english content==========================
   <title><structname>pg_stat_database_conflicts</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_stat_database_conflicts</structname> 视图</title>
   <tgroup cols="1">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datid</structfield> <type>oid</type>
      </para>
      <para>
       OID of a database
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datid</structfield> <type>oid</type>
      </para>
      <para>
       数据库的OID
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datname</structfield> <type>name</type>
      </para>
      <para>
       Name of this database
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datname</structfield> <type>name</type>
      </para>
      <para>
       数据库的名称
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>confl_tablespace</structfield> <type>bigint</type>
      </para>
      <para>
       Number of queries in this database that have been canceled due to
       dropped tablespaces
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>confl_tablespace</structfield> <type>bigint</type>
      </para>
      <para>
       这个数据库中由于删除表空间而取消的查询的数量
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>confl_lock</structfield> <type>bigint</type>
      </para>
      <para>
       Number of queries in this database that have been canceled due to
       lock timeouts
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>confl_lock</structfield> <type>bigint</type>
      </para>
      <para>
       此数据库中由于锁定超时而被取消的查询数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>confl_snapshot</structfield> <type>bigint</type>
      </para>
      <para>
       Number of queries in this database that have been canceled due to
       old snapshots
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>confl_snapshot</structfield> <type>bigint</type>
      </para>
      <para>
       此数据库中由于旧快照而取消的查询数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>confl_bufferpin</structfield> <type>bigint</type>
      </para>
      <para>
       Number of queries in this database that have been canceled due to
       pinned buffers
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>confl_bufferpin</structfield> <type>bigint</type>
      </para>
      <para>
       此数据库中由于固定缓冲区而被取消的查询数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>confl_deadlock</structfield> <type>bigint</type>
      </para>
      <para>
       Number of queries in this database that have been canceled due to
       deadlocks
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>confl_deadlock</structfield> <type>bigint</type>
      </para>
      <para>
       此数据库中由于死锁而被取消的查询数
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="monitoring-pg-stat-all-tables-view">
<!--==========================orignal english content==========================
  <title><structname>pg_stat_all_tables</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_stat_all_tables</structname></title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>pg_stat_all_tables</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>pg_stat_all_tables</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_stat_all_tables</structname> view will contain
   one row for each table in the current database (including TOAST
   tables), showing statistics about accesses to that specific table. The
   <structname>pg_stat_user_tables</structname> and
   <structname>pg_stat_sys_tables</structname> views
   contain the same information,
   but filtered to only show user and system tables respectively.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_stat_all_tables</structname>视图将为当前数据库中的每一个表（包括 TOAST 表）包含一行，该行显示与对该表的访问相关的统计信息。
   <structname>pg_stat_user_tables</structname>和<structname>pg_stat_sys_tables</structname>视图包含相同的信息，但是被过滤得分别只显示用户和系统表。
  </para>

  <table id="pg-stat-all-tables-view" xreflabel="pg_stat_all_tables">
<!--==========================orignal english content==========================
   <title><structname>pg_stat_all_tables</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_stat_all_tables</structname> 视图</title>
   <tgroup cols="1">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       OID of a table
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       表的OID
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>schemaname</structfield> <type>name</type>
      </para>
      <para>
       Name of the schema that this table is in
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>schemaname</structfield> <type>name</type>
      </para>
      <para>
       该表所在的模式的名称
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relname</structfield> <type>name</type>
      </para>
      <para>
       Name of this table
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relname</structfield> <type>name</type>
      </para>
      <para>
       这个表的名称
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>seq_scan</structfield> <type>bigint</type>
      </para>
      <para>
       Number of sequential scans initiated on this table
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>seq_scan</structfield> <type>bigint</type>
      </para>
      <para>
       在此表上启动的顺序扫描数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>seq_tup_read</structfield> <type>bigint</type>
      </para>
      <para>
       Number of live rows fetched by sequential scans
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>seq_tup_read</structfield> <type>bigint</type>
      </para>
      <para>
       连续扫描获取的实时行数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idx_scan</structfield> <type>bigint</type>
      </para>
      <para>
       Number of index scans initiated on this table
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idx_scan</structfield> <type>bigint</type>
      </para>
      <para>
       对这个表发起的索引扫描数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idx_tup_fetch</structfield> <type>bigint</type>
      </para>
      <para>
       Number of live rows fetched by index scans
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idx_tup_fetch</structfield> <type>bigint</type>
      </para>
      <para>
       索引扫描获取的实时行数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>n_tup_ins</structfield> <type>bigint</type>
      </para>
      <para>
       Number of rows inserted
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>n_tup_ins</structfield> <type>bigint</type>
      </para>
      <para>
       插入的行数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>n_tup_upd</structfield> <type>bigint</type>
      </para>
      <para>
       Number of rows updated (includes HOT updated rows)
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>n_tup_upd</structfield> <type>bigint</type>
      </para>
      <para>
       更新的行数(包括HOT更新的行)
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>n_tup_del</structfield> <type>bigint</type>
      </para>
      <para>
       Number of rows deleted
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>n_tup_del</structfield> <type>bigint</type>
      </para>
      <para>
       删除的行数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>n_tup_hot_upd</structfield> <type>bigint</type>
      </para>
      <para>
       Number of rows HOT updated (i.e., with no separate index
       update required)
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>n_tup_hot_upd</structfield> <type>bigint</type>
      </para>
      <para>
       HOT更新的行数(即，不需要单独的索引更新)
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>n_live_tup</structfield> <type>bigint</type>
      </para>
      <para>
       Estimated number of live rows
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>n_live_tup</structfield> <type>bigint</type>
      </para>
      <para>
       活的行的估计数量
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>n_dead_tup</structfield> <type>bigint</type>
      </para>
      <para>
       Estimated number of dead rows
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>n_dead_tup</structfield> <type>bigint</type>
      </para>
      <para>
       僵死行的估计数量
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>n_mod_since_analyze</structfield> <type>bigint</type>
      </para>
      <para>
       Estimated number of rows modified since this table was last analyzed
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>n_mod_since_analyze</structfield> <type>bigint</type>
      </para>
      <para>
       自上次分析此表以来修改的行的估计数量
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>n_ins_since_vacuum</structfield> <type>bigint</type>
      </para>
      <para>
       Estimated number of rows inserted since this table was last vacuumed
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>n_ins_since_vacuum</structfield> <type>bigint</type>
      </para>
      <para>
       自上次清空此表以来插入的行的估计数量
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_vacuum</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Last time at which this table was manually vacuumed
       (not counting <command>VACUUM FULL</command>)
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_vacuum</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       最后一次手动清理这个表(不包括<command>VACUUM FULL</command>)
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_autovacuum</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Last time at which this table was vacuumed by the autovacuum
       daemon
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_autovacuum</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       这个表最后一次被自动清理守护进程清理的时间
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_analyze</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Last time at which this table was manually analyzed
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_analyze</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       上一次手动分析这个表
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_autoanalyze</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Last time at which this table was analyzed by the autovacuum
       daemon
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>last_autoanalyze</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       自动清理守护进程最后一次分析这个表
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>vacuum_count</structfield> <type>bigint</type>
      </para>
      <para>
       Number of times this table has been manually vacuumed
       (not counting <command>VACUUM FULL</command>)
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>vacuum_count</structfield> <type>bigint</type>
      </para>
      <para>
       这个表被手动清理的次数(<command>VACUUM FULL</command>不计数)
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>autovacuum_count</structfield> <type>bigint</type>
      </para>
      <para>
       Number of times this table has been vacuumed by the autovacuum
       daemon
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>autovacuum_count</structfield> <type>bigint</type>
      </para>
      <para>
       这个表被autovacuum守护进程清理的次数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>analyze_count</structfield> <type>bigint</type>
      </para>
      <para>
       Number of times this table has been manually analyzed
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>analyze_count</structfield> <type>bigint</type>
      </para>
      <para>
       手动分析这个表的次数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>autoanalyze_count</structfield> <type>bigint</type>
      </para>
      <para>
       Number of times this table has been analyzed by the autovacuum
       daemon
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>autoanalyze_count</structfield> <type>bigint</type>
      </para>
      <para>
       这个表被autovacuum守护进程分析的次数
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="monitoring-pg-stat-all-indexes-view">
<!--==========================orignal english content==========================
  <title><structname>pg_stat_all_indexes</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_stat_all_indexes</structname></title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>pg_stat_all_indexes</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>pg_stat_all_indexes</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_stat_all_indexes</structname> view will contain
   one row for each index in the current database,
   showing statistics about accesses to that specific index. The
   <structname>pg_stat_user_indexes</structname> and
   <structname>pg_stat_sys_indexes</structname> views
   contain the same information,
   but filtered to only show user and system indexes respectively.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_stat_all_indexes</structname>视图将为当前数据库中的每个索引包含一行，该行显示关于对该索引访问的统计信息。<structname>pg_stat_user_indexes</structname>和<structname>pg_stat_sys_indexes</structname>视图包含相同的信息，但是被过滤得只分别显示用户和系统索引。
  </para>

  <table id="pg-stat-all-indexes-view" xreflabel="pg_stat_all_indexes">
<!--==========================orignal english content==========================
   <title><structname>pg_stat_all_indexes</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_stat_all_indexes</structname> 视图</title>
   <tgroup cols="1">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the table for this index
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       对于此索引的表的OID
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>indexrelid</structfield> <type>oid</type>
      </para>
      <para>
       OID of this index
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>indexrelid</structfield> <type>oid</type>
      </para>
      <para>
       这个索引的OID
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>schemaname</structfield> <type>name</type>
      </para>
      <para>
       Name of the schema this index is in
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>schemaname</structfield> <type>name</type>
      </para>
      <para>
       这个索引所在的模式名称
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relname</structfield> <type>name</type>
      </para>
      <para>
       Name of the table for this index
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relname</structfield> <type>name</type>
      </para>
      <para>
       这个索引的表的名称
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>indexrelname</structfield> <type>name</type>
      </para>
      <para>
       Name of this index
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>indexrelname</structfield> <type>name</type>
      </para>
      <para>
       这个索引的名称
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idx_scan</structfield> <type>bigint</type>
      </para>
      <para>
       Number of index scans initiated on this index
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idx_scan</structfield> <type>bigint</type>
      </para>
      <para>
       在这个索引上开启的索引扫描的数量
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idx_tup_read</structfield> <type>bigint</type>
      </para>
      <para>
       Number of index entries returned by scans on this index
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idx_tup_read</structfield> <type>bigint</type>
      </para>
      <para>
       扫描此索引返回的索引项数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idx_tup_fetch</structfield> <type>bigint</type>
      </para>
      <para>
       Number of live table rows fetched by simple index scans using this
       index
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idx_tup_fetch</structfield> <type>bigint</type>
      </para>
      <para>
       使用此索引进行简单索引扫描获取的活动表行数
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

<!--==========================orignal english content==========================
  <para>
   Indexes can be used by simple index scans, <quote>bitmap</quote> index scans,
   and the optimizer.  In a bitmap scan
   the output of several indexes can be combined via AND or OR rules,
   so it is difficult to associate individual heap row fetches
   with specific indexes when a bitmap scan is used.  Therefore, a bitmap
   scan increments the
   <structname>pg_stat_all_indexes</structname>.<structfield>idx_tup_read</structfield>
   count(s) for the index(es) it uses, and it increments the
   <structname>pg_stat_all_tables</structname>.<structfield>idx_tup_fetch</structfield>
   count for the table, but it does not affect
   <structname>pg_stat_all_indexes</structname>.<structfield>idx_tup_fetch</structfield>.
   The optimizer also accesses indexes to check for supplied constants
   whose values are outside the recorded range of the optimizer statistics
   because the optimizer statistics might be stale.
  </para>
____________________________________________________________________________-->
  <para>
   索引可以被简单索引扫描、<quote>位图</quote>索引扫描以及优化器使用。在一次位图扫描中，多个索引的输出可以被通过 AND 或 OR 规则组合，因此当使用一次位图扫描时难以将取得的个体堆行与特定的索引关联起来。因此，一次位图扫描会增加它使用的索引的<structname>pg_stat_all_indexes</structname>.<structfield>idx_tup_read</structfield>计数，并且为每个表增加<structname>pg_stat_all_tables</structname>.<structfield>idx_tup_fetch</structfield>计数，但是它不影响<structname>pg_stat_all_indexes</structname>.<structfield>idx_tup_fetch</structfield>。如果所提供的常量值不在优化器统计信息记录的范围之内，优化器也会访问索引来检查，因为优化器统计信息可能已经“不新鲜”了。
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    The <structfield>idx_tup_read</structfield> and <structfield>idx_tup_fetch</structfield> counts
    can be different even without any use of bitmap scans,
    because <structfield>idx_tup_read</structfield> counts
    index entries retrieved from the index while <structfield>idx_tup_fetch</structfield>
    counts live rows fetched from the table.  The latter will be less if any
    dead or not-yet-committed rows are fetched using the index, or if any
    heap fetches are avoided by means of an index-only scan.
   </para>
____________________________________________________________________________-->
   <para>
    即使不用位图扫描，<structfield>idx_tup_read</structfield>和<structfield>idx_tup_fetch</structfield>计数也可能不同，因为<structfield>idx_tup_read</structfield>统计从该索引取得的索引项而<structfield>idx_tup_fetch</structfield>统计从表取得的活着的行。如果使用该索引取得了任何死亡行或还未提交的行，或者如果通过一次只用索引扫描的方式避免了任何堆获取，后者将较小。
   </para>
  </note>

 </sect2>

 <sect2 id="monitoring-pg-statio-all-tables-view">
<!--==========================orignal english content==========================
  <title><structname>pg_statio_all_tables</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_statio_all_tables</structname></title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>pg_statio_all_tables</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>pg_statio_all_tables</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_statio_all_tables</structname> view will contain
   one row for each table in the current database (including TOAST
   tables), showing statistics about I/O on that specific table. The
   <structname>pg_statio_user_tables</structname> and
   <structname>pg_statio_sys_tables</structname> views
   contain the same information,
   but filtered to only show user and system tables respectively.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_statio_all_tables</structname>视图将为当前数据库中的每个表（包括 TOAST 表）包含一行，该行显示指定表上有关 I/O 的统计信息。<structname>pg_statio_user_tables</structname>和<structname>pg_statio_sys_tables</structname>视图包含相同的信息，但是被过滤得分别只显示用户表和系统表。
  </para>

  <table id="pg-statio-all-tables-view" xreflabel="pg_statio_all_tables">
<!--==========================orignal english content==========================
   <title><structname>pg_statio_all_tables</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_statio_all_tables</structname> 视图</title>
   <tgroup cols="1">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       OID of a table
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       表的OID
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>schemaname</structfield> <type>name</type>
      </para>
      <para>
       Name of the schema that this table is in
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>schemaname</structfield> <type>name</type>
      </para>
      <para>
       该表所在的模式名
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relname</structfield> <type>name</type>
      </para>
      <para>
       Name of this table
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relname</structfield> <type>name</type>
      </para>
      <para>
       这个表的名称
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       Number of disk blocks read from this table
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       从该表中读取的磁盘块的数量
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       Number of buffer hits in this table
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       该表中的缓冲区命中数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idx_blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       Number of disk blocks read from all indexes on this table
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idx_blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       从这个表上所有索引读取的磁盘块数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idx_blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       Number of buffer hits in all indexes on this table
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idx_blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       这个表上所有索引中的缓冲区命中数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>toast_blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       Number of disk blocks read from this table's TOAST table (if any)
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>toast_blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       从这个表的TOAST表中读取的磁盘块的数量(如果有的话)
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>toast_blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       Number of buffer hits in this table's TOAST table (if any)
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>toast_blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       这个表的TOAST表中的缓冲区命中数(如果有的话)
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tidx_blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       Number of disk blocks read from this table's TOAST table indexes (if any)
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tidx_blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       从这个表的TOAST表索引中读取的磁盘块的数量(如果有的话)
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tidx_blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       Number of buffer hits in this table's TOAST table indexes (if any)
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tidx_blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       这个表的TOAST表索引中的缓冲区命中数(如果有的话)
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="monitoring-pg-statio-all-indexes-view">
<!--==========================orignal english content==========================
  <title><structname>pg_statio_all_indexes</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_statio_all_indexes</structname></title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>pg_statio_all_indexes</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>pg_statio_all_indexes</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_statio_all_indexes</structname> view will contain
   one row for each index in the current database,
   showing statistics about I/O on that specific index. The
   <structname>pg_statio_user_indexes</structname> and
   <structname>pg_statio_sys_indexes</structname> views
   contain the same information,
   but filtered to only show user and system indexes respectively.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_statio_all_indexes</structname>视图将为当前数据库中的每个索引包含一行，该行显示指定索引上有关 I/O 的统计信息。
   <structname>pg_statio_user_indexes</structname>和<structname>pg_statio_sys_indexes</structname>视图包含相同的信息，但是被过滤得分别只显示用户索引和系统索引。
  </para>

  <table id="pg-statio-all-indexes-view" xreflabel="pg_statio_all_indexes">
<!--==========================orignal english content==========================
   <title><structname>pg_statio_all_indexes</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_statio_all_indexes</structname> 视图</title>
   <tgroup cols="1">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the table for this index
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       对这个索引的表的OID
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>indexrelid</structfield> <type>oid</type>
      </para>
      <para>
       OID of this index
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>indexrelid</structfield> <type>oid</type>
      </para>
      <para>
       这个索引的OID
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>schemaname</structfield> <type>name</type>
      </para>
      <para>
       Name of the schema this index is in
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>schemaname</structfield> <type>name</type>
      </para>
      <para>
       索引所在的模式名称
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relname</structfield> <type>name</type>
      </para>
      <para>
       Name of the table for this index
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relname</structfield> <type>name</type>
      </para>
      <para>
       此索引的表的名称
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>indexrelname</structfield> <type>name</type>
      </para>
      <para>
       Name of this index
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>indexrelname</structfield> <type>name</type>
      </para>
      <para>
       这个索引的名称
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idx_blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       Number of disk blocks read from this index
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idx_blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       从此索引中读取的磁盘块的数量
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idx_blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       Number of buffer hits in this index
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>idx_blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       此索引中的缓冲区命中数
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="monitoring-pg-statio-all-sequences-view">
<!--==========================orignal english content==========================
  <title><structname>pg_statio_all_sequences</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_statio_all_sequences</structname></title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>pg_statio_all_sequences</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>pg_statio_all_sequences</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_statio_all_sequences</structname> view will contain
   one row for each sequence in the current database,
   showing statistics about I/O on that specific sequence.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_statio_all_sequences</structname>视图将为当前数据库中的每个序列包含一行，该行显示在指定序列上有关 I/O 的统计信息。
  </para>

  <table id="pg-statio-all-sequences-view" xreflabel="pg_statio_all_sequences">
<!--==========================orignal english content==========================
   <title><structname>pg_statio_all_sequences</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_statio_all_sequences</structname> 视图</title>
   <tgroup cols="1">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       OID of a sequence
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       序列的OID
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>schemaname</structfield> <type>name</type>
      </para>
      <para>
       Name of the schema this sequence is in
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>schemaname</structfield> <type>name</type>
      </para>
      <para>
       此序列所在的模式的名称
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relname</structfield> <type>name</type>
      </para>
      <para>
       Name of this sequence
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relname</structfield> <type>name</type>
      </para>
      <para>
       此序列的名称
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       Number of disk blocks read from this sequence
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       从这个序列中读取的磁盘块的数量
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       Number of buffer hits in this sequence
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       在此序列中的缓冲区命中数
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="monitoring-pg-stat-user-functions-view">
<!--==========================orignal english content==========================
  <title><structname>pg_stat_user_functions</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_stat_user_functions</structname></title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>pg_stat_user_functions</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>pg_stat_user_functions</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The <structname>pg_stat_user_functions</structname> view will contain
   one row for each tracked function, showing statistics about executions of
   that function.  The <xref linkend="guc-track-functions"/> parameter
   controls exactly which functions are tracked.
  </para>
____________________________________________________________________________-->
  <para>
   <structname>pg_stat_user_functions</structname>视图将为每一个被追踪的函数包含一行，该行显示有关该函数执行的统计信息。
   <xref linkend="guc-track-functions"/>参数控制到底哪些函数被跟踪。
  </para>

  <table id="pg-stat-user-functions-view" xreflabel="pg_stat_user_functions">
<!--==========================orignal english content==========================
   <title><structname>pg_stat_user_functions</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_stat_user_functions</structname> 视图</title>
   <tgroup cols="1">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>funcid</structfield> <type>oid</type>
      </para>
      <para>
       OID of a function
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>funcid</structfield> <type>oid</type>
      </para>
      <para>
       函数的OID
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>schemaname</structfield> <type>name</type>
      </para>
      <para>
       Name of the schema this function is in
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>schemaname</structfield> <type>name</type>
      </para>
      <para>
       这个函数所在的模式的名称
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>funcname</structfield> <type>name</type>
      </para>
      <para>
       Name of this function
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>funcname</structfield> <type>name</type>
      </para>
      <para>
       这个函数的名称
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>calls</structfield> <type>bigint</type>
      </para>
      <para>
       Number of times this function has been called
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>calls</structfield> <type>bigint</type>
      </para>
      <para>
       这个函数已经被调用的次数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>total_time</structfield> <type>double precision</type>
      </para>
      <para>
       Total time spent in this function and all other functions
       called by it, in milliseconds
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>total_time</structfield> <type>double precision</type>
      </para>
      <para>
       在这个函数以及它所调用的其他函数中花费的总时间，以毫秒计
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>self_time</structfield> <type>double precision</type>
      </para>
      <para>
       Total time spent in this function itself, not including
       other functions called by it, in milliseconds
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>self_time</structfield> <type>double precision</type>
      </para>
      <para>
       在这个函数本身花费的总时间，不包括被它调用的其他函数，以毫秒计
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="monitoring-pg-stat-slru-view">
<!--==========================orignal english content==========================
  <title><structname>pg_stat_slru</structname></title>
____________________________________________________________________________-->
  <title><structname>pg_stat_slru</structname></title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>SLRU</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>SLRU</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>pg_stat_slru</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>pg_stat_slru</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname> accesses certain on-disk information
   via <firstterm>SLRU</firstterm> (simple least-recently-used) caches.
   The <structname>pg_stat_slru</structname> view will contain
   one row for each tracked SLRU cache, showing statistics about access
   to cached pages.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>通过<firstterm>SLRU</firstterm>(simple least-recently-used，简单的最近-最少-使用)缓存访问某些磁盘上的信息。
   <structname>pg_stat_slru</structname>视图将为每个被跟踪的SLRU缓存包含一行，显示关于访问缓存页面的统计信息。
  </para>

  <table id="pg-stat-slru-view" xreflabel="pg_stat_slru">
<!--==========================orignal english content==========================
   <title><structname>pg_stat_slru</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_stat_slru</structname> 视图</title>
   <tgroup cols="1">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>name</structfield> <type>text</type>
      </para>
      <para>
       Name of the SLRU
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>name</structfield> <type>text</type>
      </para>
      <para>
       SLRU的名称
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_zeroed</structfield> <type>bigint</type>
      </para>
      <para>
       Number of blocks zeroed during initializations
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_zeroed</structfield> <type>bigint</type>
      </para>
      <para>
       初始化期间被置零的块数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       Number of times disk blocks were found already in the SLRU,
       so that a read was not necessary (this only includes hits in the
       SLRU, not the operating system's file system cache)
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_hit</structfield> <type>bigint</type>
      </para>
      <para>
       已经在SLRU中的磁盘块被发现的次数，因此不需要读取(这只包括SLRU中的命中，而不是操作系统的文件系统缓存)
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       Number of disk blocks read for this SLRU
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_read</structfield> <type>bigint</type>
      </para>
      <para>
       为这个SLRU读取的磁盘块数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_written</structfield> <type>bigint</type>
      </para>
      <para>
       Number of disk blocks written for this SLRU
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_written</structfield> <type>bigint</type>
      </para>
      <para>
       为这个SLRU写入的磁盘块数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_exists</structfield> <type>bigint</type>
      </para>
      <para>
       Number of blocks checked for existence for this SLRU
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blks_exists</structfield> <type>bigint</type>
      </para>
      <para>
       为这个SLRU检查是否存在的块数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>flushes</structfield> <type>bigint</type>
      </para>
      <para>
       Number of flushes of dirty data for this SLRU
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>flushes</structfield> <type>bigint</type>
      </para>
      <para>
       此SLRU的脏数据刷新数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>truncates</structfield> <type>bigint</type>
      </para>
      <para>
       Number of truncates for this SLRU
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>truncates</structfield> <type>bigint</type>
      </para>
      <para>
       这个SLRU的截断数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       Time at which these statistics were last reset
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>stats_reset</structfield> <type>timestamp with time zone</type>
      </para>
      <para>
       这些统计数据最后一次重置的时间
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="monitoring-stats-functions">
<!--==========================orignal english content==========================
  <title>Statistics Functions</title>
____________________________________________________________________________-->
  <title>Statistics Functions</title>

<!--==========================orignal english content==========================
  <para>
   Other ways of looking at the statistics can be set up by writing
   queries that use the same underlying statistics access functions used by
   the standard views shown above.  For details such as the functions' names,
   consult the definitions of the standard views.  (For example, in
   <application>psql</application> you could issue <literal>\d+ pg_stat_activity</literal>.)
   The access functions for per-database statistics take a database OID as an
   argument to identify which database to report on.
   The per-table and per-index functions take a table or index OID.
   The functions for per-function statistics take a function OID.
   Note that only tables, indexes, and functions in the current database
   can be seen with these functions.
  </para>
____________________________________________________________________________-->
  <para>
   其他查看统计信息的方法是直接使用查询，这些查询使用上述标准视图用到的底层统计信息访问函数。
   如要了解如函数名等细节，可参考标准视图的定义（例如，在<application>psql</application>中你可以发出<literal>\d+ pg_stat_activity</literal>）。
   针对每一个数据库统计信息的访问函数把一个数据库 OID 作为参数来标识要报告哪个数据库。而针对每个表和每个索引的函数要求表或索引 OID。
   针对每个函数统计信息的函数用一个函数 OID。注意只有在当前数据库中的表、索引和函数才能被这些函数看到。
  </para>

<!--==========================orignal english content==========================
  <para>
   Additional functions related to statistics collection are listed in <xref
   linkend="monitoring-stats-funcs-table"/>.
  </para>
____________________________________________________________________________-->
  <para>
   更多统计集合的函数列在 <xref linkend="monitoring-stats-funcs-table"/>中.
  </para>

   <table id="monitoring-stats-funcs-table">
<!--==========================orignal english content==========================
    <title>Additional Statistics Functions</title>
____________________________________________________________________________-->
    <title>Additional Statistics Functions</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <!-&minus; See also the entry for this in func.sgml -&minus;>
       <entry role="func_table_entry"><para role="func_signature">
        <function>pg_backend_pid</function> ()
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the process ID of the server process attached to the current
        session.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <!-- See also the entry for this in func.sgml -->
       <entry role="func_table_entry"><para role="func_signature">
        <function>pg_backend_pid</function> ()
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回附加到当前会话的服务器进程的进程ID。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_activity</primary>
        </indexterm>
        <function>pg_stat_get_activity</function> ( <type>integer</type> )
        <returnvalue>setof record</returnvalue>
       </para>
       <para>
        Returns a record of information about the backend with the specified
        process ID, or one record for each active backend in the system
        if <literal>NULL</literal> is specified.  The fields returned are a
        subset of those in the <structname>pg_stat_activity</structname> view.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_activity</primary>
        </indexterm>
        <function>pg_stat_get_activity</function> ( <type>integer</type> )
        <returnvalue>setof record</returnvalue>
       </para>
       <para>
        使用指定的进程ID返回有关后端信息的记录，如果指定了<literal>NULL</literal>，则返回系统中每个活动后端的一条记录。
        返回的字段是<structname>pg_stat_activity</structname>视图中字段的子集。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_snapshot_timestamp</primary>
        </indexterm>
        <function>pg_stat_get_snapshot_timestamp</function> ()
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        Returns the timestamp of the current statistics snapshot.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_snapshot_timestamp</primary>
        </indexterm>
        <function>pg_stat_get_snapshot_timestamp</function> ()
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        返回当前统计快照的时间戳。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_clear_snapshot</primary>
        </indexterm>
        <function>pg_stat_clear_snapshot</function> ()
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Discards the current statistics snapshot.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_clear_snapshot</primary>
        </indexterm>
        <function>pg_stat_clear_snapshot</function> ()
        <returnvalue>void</returnvalue>
       </para>
       <para>
        丢弃当前的统计快照。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_reset</primary>
        </indexterm>
        <function>pg_stat_reset</function> ()
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Resets all statistics counters for the current database to zero.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_reset</primary>
        </indexterm>
        <function>pg_stat_reset</function> ()
        <returnvalue>void</returnvalue>
       </para>
       <para>
        将当前数据库的所有统计计数器重置为零。
       </para>
       <para>
        默认情况下该函数仅限于超级用户，但是其他用户可以被授予EXECUTE来运行此函数。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_reset_shared</primary>
        </indexterm>
        <function>pg_stat_reset_shared</function> ( <type>text</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Resets some cluster-wide statistics counters to zero, depending on the
        argument.  The argument can be <literal>bgwriter</literal> to reset
        all the counters shown in
        the <structname>pg_stat_bgwriter</structname>
        view, <literal>archiver</literal> to reset all the counters shown in
        the <structname>pg_stat_archiver</structname> view or <literal>wal</literal>
        to reset all the counters shown in the <structname>pg_stat_wal</structname> view.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_reset_shared</primary>
        </indexterm>
        <function>pg_stat_reset_shared</function> ( <type>text</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        根据参数的不同，将一些集群范围的统计计数器重置为零。
        参数可以是<literal>bgwriter</literal>来重置<structname>pg_stat_bgwriter</structname>视图中显示的所有计数器，或者<literal>archiver</literal>来重置<structname>pg_stat_archiver</structname>视图中显示的所有计数器，或者<literal>wal</literal>重置<structname>pg_stat_wal</structname> 视图中显示的所有计数器。
       </para>
       <para>
        默认情况下该函数仅限于超级用户，但是其他用户可以被授予EXECUTE来运行此函数。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_reset_single_table_counters</primary>
        </indexterm>
        <function>pg_stat_reset_single_table_counters</function> ( <type>oid</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Resets statistics for a single table or index in the current database
        to zero.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_reset_single_table_counters</primary>
        </indexterm>
        <function>pg_stat_reset_single_table_counters</function> ( <type>oid</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        将当前数据库中单个表或索引的统计信息重置为零。
       </para>
       <para>
        默认情况下该函数仅限于超级用户，但是其他用户可以被授予EXECUTE来运行此函数。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_reset_single_function_counters</primary>
        </indexterm>
        <function>pg_stat_reset_single_function_counters</function> ( <type>oid</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Resets statistics for a single function in the current database to
        zero.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_reset_single_function_counters</primary>
        </indexterm>
        <function>pg_stat_reset_single_function_counters</function> ( <type>oid</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        将当前数据库中单个函数的统计信息重置为零。
       </para>
       <para>
        默认情况下该函数仅限于超级用户，但是其他用户可以被授予EXECUTE来运行此函数。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_reset_slru</primary>
        </indexterm>
        <function>pg_stat_reset_slru</function> ( <type>text</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Resets statistics to zero for a single SLRU cache, or for all SLRUs in
        the cluster.  If the argument is NULL, all counters shown in
        the <structname>pg_stat_slru</structname> view for all SLRU caches are
        reset.  The argument can be one of
        <literal>CommitTs</literal>,
        <literal>MultiXactMember</literal>,
        <literal>MultiXactOffset</literal>,
        <literal>Notify</literal>,
        <literal>Serial</literal>,
        <literal>Subtrans</literal>, or
        <literal>Xact</literal>
        to reset the counters for only that entry.
        If the argument is <literal>other</literal> (or indeed, any
        unrecognized name), then the counters for all other SLRU caches, such
        as extension-defined caches, are reset.
       </para>
       <para>
        This function is restricted to superusers by default, but other users
        can be granted EXECUTE to run the function.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_reset_slru</primary>
        </indexterm>
        <function>pg_stat_reset_slru</function> ( <type>text</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        将单个SLRU缓存或集群中所有SLRU的统计信息重置为零。
        如果该参数为NULL，则所有SLRU缓存的<structname>pg_stat_slru</structname>视图中显示的计数器将被重置。
        参数可以是<literal>CommitTs</literal>、<literal>MultiXactMember</literal>、<literal>MultiXactOffset</literal>、<literal>Notify</literal>、
        <literal>Serial</literal>、<literal>Subtrans</literal>、 或<literal>Xact</literal>中的一个，以便只重置该条目的计数器。
        如果参数是<literal>other</literal>(或实际上，任何无法识别的名称)，那么所有其他SLRU缓存的计数器，如扩展定义的缓存，将被重置。
       </para>
       <para>
        默认情况下该函数仅限于超级用户，但是其他用户可以被授予EXECUTE来运行此函数。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
          <primary>pg_stat_reset_replication_slot</primary>
        </indexterm>
        <function>pg_stat_reset_replication_slot</function> ( <type>text</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        Resets statistics of the replication slot defined by the argument. If
        the argument is <literal>NULL</literal>, resets statistics for all
        the replication slots.
       </para>
       <para>
         This function is restricted to superusers by default, but other users
         can be granted EXECUTE to run the function.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
          <primary>pg_stat_reset_replication_slot</primary>
        </indexterm>
        <function>pg_stat_reset_replication_slot</function> ( <type>text</type> )
        <returnvalue>void</returnvalue>
       </para>
       <para>
        重置由参数定义的复制槽的统计信息。
        如果参数为<literal>NULL</literal>，则重置所有复制槽的统计信息。
       </para>
       <para>
         该函数默认仅限于超级用户，但可以授予其他用户EXECUTE权限来运行该函数。
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

<!--==========================orignal english content==========================
  <para>
   <function>pg_stat_get_activity</function>, the underlying function of
   the <structname>pg_stat_activity</structname> view, returns a set of records
   containing all the available information about each backend process.
   Sometimes it may be more convenient to obtain just a subset of this
   information.  In such cases, an older set of per-backend statistics
   access functions can be used; these are shown in <xref
   linkend="monitoring-stats-backend-funcs-table"/>.
   These access functions use a backend ID number, which ranges from one
   to the number of currently active backends.
   The function <function>pg_stat_get_backend_idset</function> provides a
   convenient way to generate one row for each active backend for
   invoking these functions.  For example, to show the <acronym>PID</acronym>s and
   current queries of all backends:

<programlisting>
SELECT pg_stat_get_backend_pid(s.backendid) AS pid,
       pg_stat_get_backend_activity(s.backendid) AS query
    FROM (SELECT pg_stat_get_backend_idset() AS backendid) AS s;
</programlisting>
  </para>
____________________________________________________________________________-->
  <para>
   <function>pg_stat_get_activity</function>是<structname>pg_stat_activity</structname>视图的底层函数，
   它返回一个行集合，其中包含有关每个后端进程所有可用的信息。有时只获得该信息的一个子集可能会更方便。
   在那些情况中，可以使用一组更老的针对每个后端的统计访问函数，这些显示在<xref linkend="monitoring-stats-backend-funcs-table"/>中。
   这些访问函数使用一个后端 ID 号，范围从 1 到当前活动后端数目。
   函数<function>pg_stat_get_backend_idset</function>提供了一种方便的方法为每个活动后端产生一行来调用这些函数。
   例如，要显示<acronym>PID</acronym>以及所有后端当前的查询：

<programlisting>
SELECT pg_stat_get_backend_pid(s.backendid) AS pid,
       pg_stat_get_backend_activity(s.backendid) AS query
    FROM (SELECT pg_stat_get_backend_idset() AS backendid) AS s;
</programlisting>
  </para>

   <table id="monitoring-stats-backend-funcs-table">
<!--==========================orignal english content==========================
    <title>Per-Backend Statistics Functions</title>
____________________________________________________________________________-->
    <title>Per-Backend Statistics Functions</title>
    <tgroup cols="1">
     <thead>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        Function
       </para>
       <para>
        Description
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        函数
       </para>
       <para>
        描述
       </para></entry>
      </row>
     </thead>

     <tbody>
<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_idset</primary>
        </indexterm>
        <function>pg_stat_get_backend_idset</function> ()
        <returnvalue>setof integer</returnvalue>
       </para>
       <para>
        Returns the set of currently active backend ID numbers (from 1 to the
        number of active backends).
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_idset</primary>
        </indexterm>
        <function>pg_stat_get_backend_idset</function> ()
        <returnvalue>setof integer</returnvalue>
       </para>
       <para>
        返回当前活动后端ID号的集合(从1到活动后端数)。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_activity</primary>
        </indexterm>
        <function>pg_stat_get_backend_activity</function> ( <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the text of this backend's most recent query.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_activity</primary>
        </indexterm>
        <function>pg_stat_get_backend_activity</function> ( <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        返回此后端最近查询的文本。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_activity_start</primary>
        </indexterm>
        <function>pg_stat_get_backend_activity_start</function> ( <type>integer</type> )
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        Returns the time when the backend's most recent query was started.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_activity_start</primary>
        </indexterm>
        <function>pg_stat_get_backend_activity_start</function> ( <type>integer</type> )
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        返回后端最近一次查询开始的时间。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_client_addr</primary>
        </indexterm>
        <function>pg_stat_get_backend_client_addr</function> ( <type>integer</type> )
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        Returns the IP address of the client connected to this backend.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_client_addr</primary>
        </indexterm>
        <function>pg_stat_get_backend_client_addr</function> ( <type>integer</type> )
        <returnvalue>inet</returnvalue>
       </para>
       <para>
        返回连接到此后端的客户端的IP地址。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_client_port</primary>
        </indexterm>
        <function>pg_stat_get_backend_client_port</function> ( <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the TCP port number that the client is using for communication.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_client_port</primary>
        </indexterm>
        <function>pg_stat_get_backend_client_port</function> ( <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回客户端用于通信的TCP端口号。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_dbid</primary>
        </indexterm>
        <function>pg_stat_get_backend_dbid</function> ( <type>integer</type> )
        <returnvalue>oid</returnvalue>
       </para>
       <para>
        Returns the OID of the database this backend is connected to.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_dbid</primary>
        </indexterm>
        <function>pg_stat_get_backend_dbid</function> ( <type>integer</type> )
        <returnvalue>oid</returnvalue>
       </para>
       <para>
        返回此后端连接的数据库的OID。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_pid</primary>
        </indexterm>
        <function>pg_stat_get_backend_pid</function> ( <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        Returns the process ID of this backend.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_pid</primary>
        </indexterm>
        <function>pg_stat_get_backend_pid</function> ( <type>integer</type> )
        <returnvalue>integer</returnvalue>
       </para>
       <para>
        返回此后端进程ID。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_start</primary>
        </indexterm>
        <function>pg_stat_get_backend_start</function> ( <type>integer</type> )
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        Returns the time when this process was started.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_start</primary>
        </indexterm>
        <function>pg_stat_get_backend_start</function> ( <type>integer</type> )
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        返回该进程开始的时间。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_userid</primary>
        </indexterm>
        <function>pg_stat_get_backend_userid</function> ( <type>integer</type> )
        <returnvalue>oid</returnvalue>
       </para>
       <para>
        Returns the OID of the user logged into this backend.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_userid</primary>
        </indexterm>
        <function>pg_stat_get_backend_userid</function> ( <type>integer</type> )
        <returnvalue>oid</returnvalue>
       </para>
       <para>
        返回登录到此后端的用户的OID。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_wait_event_type</primary>
        </indexterm>
        <function>pg_stat_get_backend_wait_event_type</function> ( <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the wait event type name if this backend is currently waiting,
        otherwise NULL.  See <xref linkend="wait-event-table"/> for details.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_wait_event_type</primary>
        </indexterm>
        <function>pg_stat_get_backend_wait_event_type</function> ( <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        如果后端当前正在等待，返回等待事件类型名称，否则返回NULL。
        详请参见<xref linkend="wait-event-table"/>。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_wait_event</primary>
        </indexterm>
        <function>pg_stat_get_backend_wait_event</function> ( <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        Returns the wait event name if this backend is currently waiting,
        otherwise NULL. See <xref linkend="wait-event-activity-table"/> through
        <xref linkend="wait-event-timeout-table"/>.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_wait_event</primary>
        </indexterm>
        <function>pg_stat_get_backend_wait_event</function> ( <type>integer</type> )
        <returnvalue>text</returnvalue>
       </para>
       <para>
        如果后端当前正在等待，则返回等待事件名称，否则为NULL。
        参见 <xref linkend="wait-event-activity-table"/> 到 <xref linkend="wait-event-timeout-table"/>。
       </para></entry>
      </row>

<!--==========================orignal english content==========================
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_xact_start</primary>
        </indexterm>
        <function>pg_stat_get_backend_xact_start</function> ( <type>integer</type> )
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        Returns the time when the backend's current transaction was started.
       </para></entry>
      </row>
____________________________________________________________________________-->
      <row>
       <entry role="func_table_entry"><para role="func_signature">
        <indexterm>
         <primary>pg_stat_get_backend_xact_start</primary>
        </indexterm>
        <function>pg_stat_get_backend_xact_start</function> ( <type>integer</type> )
        <returnvalue>timestamp with time zone</returnvalue>
       </para>
       <para>
        返回后端当前事务开始的时间。
       </para></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

 </sect2>
 </sect1>

 <sect1 id="monitoring-locks">
<!--==========================orignal english content==========================
  <title>Viewing Locks</title>
____________________________________________________________________________-->
  <title>查看锁</title>

<!--==========================orignal english content==========================
  <indexterm zone="monitoring-locks">
   <primary>lock</primary>
   <secondary>monitoring</secondary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm zone="monitoring-locks">
   <primary>lock</primary>
   <secondary>monitoring</secondary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   Another useful tool for monitoring database activity is the
   <structname>pg_locks</structname> system table.  It allows the
   database administrator to view information about the outstanding
   locks in the lock manager. For example, this capability can be used
   to:

   <itemizedlist>
    <listitem>
     <para>
      View all the locks currently outstanding, all the locks on
      relations in a particular database, all the locks on a
      particular relation, or all the locks held by a particular
      <productname>PostgreSQL</productname> session.
     </para>
    </listitem>

    <listitem>
     <para>
      Determine the relation in the current database with the most
      ungranted locks (which might be a source of contention among
      database clients).
     </para>
    </listitem>

    <listitem>
     <para>
      Determine the effect of lock contention on overall database
      performance, as well as the extent to which contention varies
      with overall database traffic.
     </para>
    </listitem>
   </itemizedlist>

   Details of the <structname>pg_locks</structname> view appear in
   <xref linkend="view-pg-locks"/>.
   For more information on locking and managing concurrency with
   <productname>PostgreSQL</productname>, refer to <xref linkend="mvcc"/>.
  </para>
____________________________________________________________________________-->
  <para>
   监控数据库活动的另外一个有用的工具是<structname>pg_locks</structname>系统表。这样就允许数据库管理员查看在锁管理器里面未解决的锁的信息。例如，这个功能可以被用于：

   <itemizedlist>
    <listitem>
     <para>
      查看当前所有未解决的锁、在一个特定数据库中的关系上所有的锁、在一个特定关系上所有的锁，或者由一个特定<productname>PostgreSQL</productname>会话持有的所有的锁。
     </para>
    </listitem>

    <listitem>
     <para>
      判断当前数据库中带有最多未授予锁的关系（它很可能是数据库客户端的竞争源）。
     </para>
    </listitem>

    <listitem>
     <para>
      判断锁竞争给数据库总体性能带来的影响，以及锁竞争随着整个数据库流量的变化范围。
     </para>
    </listitem>
   </itemizedlist>

   <structname>pg_locks</structname>视图的细节在<xref linkend="view-pg-locks"/>中。更多有关<productname>PostgreSQL</productname>的锁和管理并发性的信息，请参考<xref linkend="mvcc"/>。
  </para>
 </sect1>

 <sect1 id="progress-reporting">
<!--==========================orignal english content==========================
  <title>Progress Reporting</title>
____________________________________________________________________________-->
  <title>Progress Reporting</title>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname> has the ability to report the progress of
   certain commands during command execution.  Currently, the only commands
   which support progress reporting are <command>ANALYZE</command>,
   <command>CLUSTER</command>,
   <command>CREATE INDEX</command>, <command>VACUUM</command>,
   <command>COPY</command>,
   and <xref linkend="protocol-replication-base-backup"/> (i.e., replication
   command that <xref linkend="app-pgbasebackup"/> issues to take
   a base backup).
   This may be expanded in the future.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>具有在命令执行过程中报告某些命令进度的能力。 
   目前，支持进度报告的命令只有<command>ANALYZE</command>,<command>CLUSTER</command>,<command>CREATE INDEX</command>, <command>VACUUM</command>,<command>COPY</command>,
   和 <xref linkend="protocol-replication-base-backup"/>(例如 <xref linkend="app-pgbasebackup"/> 发出的进行基础备份的复制命令)。
   未来可能还会扩展。
  </para>

 <sect2 id="analyze-progress-reporting">
<!--==========================orignal english content==========================
  <title>ANALYZE Progress Reporting</title>
____________________________________________________________________________-->
  <title>ANALYZE Progress Reporting</title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>pg_stat_progress_analyze</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>pg_stat_progress_analyze</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   Whenever <command>ANALYZE</command> is running, the
   <structname>pg_stat_progress_analyze</structname> view will contain a
   row for each backend that is currently running that command.  The tables
   below describe the information that will be reported and provide
   information about how to interpret it.
  </para>
____________________________________________________________________________-->
  <para>
   每当<command>ANALYZE</command>运行时，<structname>pg_stat_progress_analyze</structname>视图将包含当前运行该命令的每个后端的一行。
   下面的表描述了将要报告的信息，并提供了关于如何解释它们的信息。
  </para>

  <table id="pg-stat-progress-analyze-view" xreflabel="pg_stat_progress_analyze">
<!--==========================orignal english content==========================
   <title><structname>pg_stat_progress_analyze</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_stat_progress_analyze</structname> 视图</title>
   <tgroup cols="1">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       Process ID of backend.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       后端的进程ID。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the database to which this backend is connected.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datid</structfield> <type>oid</type>
      </para>
      <para>
       后端连接到的数据库的OID。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datname</structfield> <type>name</type>
      </para>
      <para>
       Name of the database to which this backend is connected.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datname</structfield> <type>name</type>
      </para>
      <para>
       后端连接到的数据库的名称。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the table being analyzed.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       被分析的表的OID。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>phase</structfield> <type>text</type>
      </para>
      <para>
       Current processing phase. See <xref linkend="analyze-phases"/>.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>phase</structfield> <type>text</type>
      </para>
      <para>
       当前处理阶段。参见 <xref linkend="analyze-phases"/>。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sample_blks_total</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of heap blocks that will be sampled.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sample_blks_total</structfield> <type>bigint</type>
      </para>
      <para>
       将被采样的堆块的总数。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sample_blks_scanned</structfield> <type>bigint</type>
      </para>
      <para>
       Number of heap blocks scanned.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>sample_blks_scanned</structfield> <type>bigint</type>
      </para>
      <para>
       扫描的堆块数量。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>ext_stats_total</structfield> <type>bigint</type>
      </para>
      <para>
       Number of extended statistics.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>ext_stats_total</structfield> <type>bigint</type>
      </para>
      <para>
       扩展统计信息的数量。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>ext_stats_computed</structfield> <type>bigint</type>
      </para>
      <para>
       Number of extended statistics computed. This counter only advances
       when the phase is <literal>computing extended statistics</literal>.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>ext_stats_computed</structfield> <type>bigint</type>
      </para>
      <para>
       已经计算的扩展统计的数量. 此计数器仅在 <literal>computing extended statistics</literal>阶段增进。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>child_tables_total</structfield> <type>bigint</type>
      </para>
      <para>
       Number of child tables.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>child_tables_total</structfield> <type>bigint</type>
      </para>
      <para>
       子表的数量。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>child_tables_done</structfield> <type>bigint</type>
      </para>
      <para>
       Number of child tables scanned. This counter only advances when the
       phase is <literal>acquiring inherited sample rows</literal>.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>child_tables_done</structfield> <type>bigint</type>
      </para>
      <para>
       扫描的子表数。此计数器只有在<literal>acquiring inherited sample rows</literal>阶段才会增进。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>current_child_table_relid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the child table currently being scanned. This field is
       only valid when the phase is
       <literal>acquiring inherited sample rows</literal>.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>current_child_table_relid</structfield> <type>oid</type>
      </para>
      <para>
       当前正在扫描的子表的OID。此字段仅在<literal>acquiring inherited sample rows</literal>时有效。
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table id="analyze-phases">
<!--==========================orignal english content==========================
   <title>ANALYZE phases</title>
____________________________________________________________________________-->
   <title>ANALYZE phases</title>
   <tgroup cols="2">
    <colspec colname="col1" colwidth="1*"/>
    <colspec colname="col2" colwidth="2*"/>
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Phase</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>阶段</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>initializing</literal></entry>
      <entry>
       The command is preparing to begin scanning the heap.  This phase is
       expected to be very brief.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>initializing</literal></entry>
      <entry>
       命令正在准备开始扫描堆。这个阶段预计会非常短暂。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>acquiring sample rows</literal></entry>
      <entry>
       The command is currently scanning the table given by
       <structfield>relid</structfield> to obtain sample rows.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>acquiring sample rows</literal></entry>
      <entry>
       该命令当前正在扫描<structfield>relid</structfield>给出的表以获得示例行。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>acquiring inherited sample rows</literal></entry>
      <entry>
       The command is currently scanning child tables to obtain sample rows.
       Columns <structfield>child_tables_total</structfield>,
       <structfield>child_tables_done</structfield>, and
       <structfield>current_child_table_relid</structfield> contain the
       progress information for this phase.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>acquiring inherited sample rows</literal></entry>
      <entry>
       该命令当前正在扫描子表以获得示例行。列<structfield>child_tables_total</structfield>,<structfield>child_tables_done</structfield>, 
       和<structfield>current_child_table_relid</structfield>包含此阶段的进度信息。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>computing statistics</literal></entry>
      <entry>
       The command is computing statistics from the sample rows obtained
       during the table scan.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>computing statistics</literal></entry>
      <entry>
       该命令从表扫描期间获得的样例行计算统计信息。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>computing extended statistics</literal></entry>
      <entry>
       The command is computing extended statistics from the sample rows
       obtained during the table scan.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>computing extended statistics</literal></entry>
      <entry>
       该命令从表扫描期间获得的样例行计算扩展统计信息。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>finalizing analyze</literal></entry>
      <entry>
       The command is updating <structname>pg_class</structname>. When this
       phase is completed, <command>ANALYZE</command> will end.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>finalizing analyze</literal></entry>
      <entry>
       该命令在更新<structname>pg_class</structname>。当此阶段完成时，<command>ANALYZE</command> 将结束。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <note>
<!--==========================orignal english content==========================
   <para>
    Note that when <command>ANALYZE</command> is run on a partitioned table,
    all of its partitions are also recursively analyzed.
    In that case, <command>ANALYZE</command>
    progress is reported first for the parent table, whereby its inheritance
    statistics are collected, followed by that for each partition.
   </para>
____________________________________________________________________________-->
   <para>
    注意当在分区表上运行<command>ANALYZE</command>时，它的所有分区也会被递归分析。
    在这种情况下，首先报告父表的<command>ANALYZE</command>进度，收集它的继承统计信息，然后是每个分区的(继承统计信息)。
   </para>
  </note>
 </sect2>

 <sect2 id="create-index-progress-reporting">
<!--==========================orignal english content==========================
  <title>CREATE INDEX Progress Reporting</title>
____________________________________________________________________________-->
  <title>CREATE INDEX Progress Reporting</title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>pg_stat_progress_create_index</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>pg_stat_progress_create_index</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   Whenever <command>CREATE INDEX</command> or <command>REINDEX</command> is running, the
   <structname>pg_stat_progress_create_index</structname> view will contain
   one row for each backend that is currently creating indexes.  The tables
   below describe the information that will be reported and provide information
   about how to interpret it.
  </para>
____________________________________________________________________________-->
  <para>
   每当运行<command>CREATE INDEX</command>或<command>REINDEX</command>时，<structname>pg_stat_progress_create_index</structname>视图将包含当前正在创建索引的每个后端的一行。
   下面的表描述了将要报告的信息，并提供了关于如何解释它的信息。
  </para>

  <table id="pg-stat-progress-create-index-view" xreflabel="pg_stat_progress_create_index">
<!--==========================orignal english content==========================
   <title><structname>pg_stat_progress_create_index</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_stat_progress_create_index</structname> 视图</title>
   <tgroup cols="1">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       Process ID of backend.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       后端的进程ID。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the database to which this backend is connected.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datid</structfield> <type>oid</type>
      </para>
      <para>
       后端连接到的数据库的OID。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datname</structfield> <type>name</type>
      </para>
      <para>
       Name of the database to which this backend is connected.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datname</structfield> <type>name</type>
      </para>
      <para>
       后端连接到的数据库的名称。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the table on which the index is being created.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       正在创建索引的表的OID。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>index_relid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the index being created or reindexed.  During a
       non-concurrent <command>CREATE INDEX</command>, this is 0.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>index_relid</structfield> <type>oid</type>
      </para>
      <para>
       正在创建或重建索引的OID。在非并发 <command>CREATE INDEX</command>的时候，此为 0。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>command</structfield> <type>text</type>
      </para>
      <para>
       The command that is running: <literal>CREATE INDEX</literal>,
       <literal>CREATE INDEX CONCURRENTLY</literal>,
       <literal>REINDEX</literal>, or <literal>REINDEX CONCURRENTLY</literal>.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>command</structfield> <type>text</type>
      </para>
      <para>
       在运行的命令: <literal>CREATE INDEX</literal>,<literal>CREATE INDEX CONCURRENTLY</literal>,
       <literal>REINDEX</literal>, 或 <literal>REINDEX CONCURRENTLY</literal>.
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>phase</structfield> <type>text</type>
      </para>
      <para>
       Current processing phase of index creation.  See <xref linkend="create-index-phases"/>.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>phase</structfield> <type>text</type>
      </para>
      <para>
       索引创建的当前处理阶段。 参见 <xref linkend="create-index-phases"/>。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>lockers_total</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of lockers to wait for, when applicable.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>lockers_total</structfield> <type>bigint</type>
      </para>
      <para>
       在适用的情况下，需要等待的储物柜总数
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>lockers_done</structfield> <type>bigint</type>
      </para>
      <para>
       Number of lockers already waited for.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>lockers_done</structfield> <type>bigint</type>
      </para>
      <para>
       已经等待的储物柜数量。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>current_locker_pid</structfield> <type>bigint</type>
      </para>
      <para>
       Process ID of the locker currently being waited for.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>current_locker_pid</structfield> <type>bigint</type>
      </para>
      <para>
       目前正在等待的储物柜的进程ID。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blocks_total</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of blocks to be processed in the current phase.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blocks_total</structfield> <type>bigint</type>
      </para>
      <para>
       本阶段要处理的区块总数。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blocks_done</structfield> <type>bigint</type>
      </para>
      <para>
       Number of blocks already processed in the current phase.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>blocks_done</structfield> <type>bigint</type>
      </para>
      <para>
       当前阶段已经处理的区块数量。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tuples_total</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of tuples to be processed in the current phase.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tuples_total</structfield> <type>bigint</type>
      </para>
      <para>
       当前阶段要处理的元组总数。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tuples_done</structfield> <type>bigint</type>
      </para>
      <para>
       Number of tuples already processed in the current phase.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tuples_done</structfield> <type>bigint</type>
      </para>
      <para>
       在当前阶段已经处理的元组数量。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>partitions_total</structfield> <type>bigint</type>
      </para>
      <para>
       When creating an index on a partitioned table, this column is set to
       the total number of partitions on which the index is to be created.
       This field is <literal>0</literal> during a <literal>REINDEX</literal>.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>partitions_total</structfield> <type>bigint</type>
      </para>
      <para>
       在分区表上创建索引时，该列被设置为要在其上创建索引的分区总数。
       在<literal>REINDEX</literal>期间，此字段为<literal>0</literal>。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>partitions_done</structfield> <type>bigint</type>
      </para>
      <para>
       When creating an index on a partitioned table, this column is set to
       the number of partitions on which the index has been created.
       This field is <literal>0</literal> during a <literal>REINDEX</literal>.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>partitions_done</structfield> <type>bigint</type>
      </para>
      <para>
       当在分区表上创建索引时，该列被设置为在其上建立索引的分区数。
       在<literal>REINDEX</literal>期间，此字段为<literal>0</literal>。
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table id="create-index-phases">
<!--==========================orignal english content==========================
   <title>CREATE INDEX Phases</title>
____________________________________________________________________________-->
   <title>CREATE INDEX 的阶段</title>
   <tgroup cols="2">
    <colspec colname="col1" colwidth="1*"/>
    <colspec colname="col2" colwidth="2*"/>
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Phase</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>阶段</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>initializing</literal></entry>
      <entry>
       <command>CREATE INDEX</command> or <command>REINDEX</command> is preparing to create the index.  This
       phase is expected to be very brief.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>初始化</literal></entry>
      <entry>
       <command>CREATE INDEX</command>或<command>REINDEX</command>正在准备创建索引。 这个阶段预计会非常短暂。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>waiting for writers before build</literal></entry>
      <entry>
       <command>CREATE INDEX CONCURRENTLY</command> or <command>REINDEX CONCURRENTLY</command> is waiting for transactions
       with write locks that can potentially see the table to finish.
       This phase is skipped when not in concurrent mode.
       Columns <structname>lockers_total</structname>, <structname>lockers_done</structname>
       and <structname>current_locker_pid</structname> contain the progress
       information for this phase.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>构建前等待读写器</literal></entry>
      <entry>
       <command>CREATE INDEX CONCURRENTLY</command>或<command>REINDEX CONCURRENTLY</command>正在等待有可能看到表的写锁的事务完成。 当不在并发模式时，这个阶段会被跳过。<structname>lockers_total</structname>、 <structname>lockers_done</structname> 和 <structname>current_locker_pid</structname> 列包含了这个阶段的进度信息。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>building index</literal></entry>
      <entry>
       The index is being built by the access method-specific code.  In this phase,
       access methods that support progress reporting fill in their own progress data,
       and the subphase is indicated in this column.  Typically,
       <structname>blocks_total</structname> and <structname>blocks_done</structname>
       will contain progress data, as well as potentially
       <structname>tuples_total</structname> and <structname>tuples_done</structname>.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>新建索引</literal></entry>
      <entry>
       索引是由访问方法专用代码建立的。 在这一阶段，支持进度报告的访问方法填写自己的进度数据，子阶段在这一栏中表示。 通常情况下，<structname>blocks_total</structname>和<structname>blocks_done</structname>将包含进度数据，也可能包含<structname>tuples_total</structname>和<structname>tuples_done</structname>。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>waiting for writers before validation</literal></entry>
      <entry>
       <command>CREATE INDEX CONCURRENTLY</command> or <command>REINDEX CONCURRENTLY</command> is waiting for transactions
       with write locks that can potentially write into the table to finish.
       This phase is skipped when not in concurrent mode.
       Columns <structname>lockers_total</structname>, <structname>lockers_done</structname>
       and <structname>current_locker_pid</structname> contain the progress
       information for this phase.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>在验证前等待读写器</literal></entry>
      <entry>
       <command>CREATE INDEX CONCURRENTLY</command>或<command>REINDEX CONCURRENTLY</command>正在等待有可能写入表的事务完成写锁的事务。当不在并发模式时，这个阶段会被跳过。<structname>lockers_total</structname>、 <structname>lockers_done</structname> 和 <structname>current_locker_pid</structname> 列包含了这个阶段的进度信息。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>index validation: scanning index</literal></entry>
      <entry>
       <command>CREATE INDEX CONCURRENTLY</command> is scanning the index searching
       for tuples that need to be validated.
       This phase is skipped when not in concurrent mode.
       Columns <structname>blocks_total</structname> (set to the total size of the index)
       and <structname>blocks_done</structname> contain the progress information for this phase.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>索引验证：扫描索引</literal></entry>
      <entry>
       <command>CREATE INDEX CONCURRENTLY</command>正在扫描索引，搜索需要验证的图元组。如果不是在并发模式下，这个阶段会被跳过。列 <structname>blocks_total</structname>（设置为索引的总大小）和 <structname>blocks_done</structname>包含了这个阶段的进度信息。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>index validation: sorting tuples</literal></entry>
      <entry>
       <command>CREATE INDEX CONCURRENTLY</command> is sorting the output of the
       index scanning phase.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>指数验证：排序元组</literal></entry>
      <entry>
       <command>CREATE INDEX CONCURRENTLY</command>正在对索引扫描阶段的输出进行排序。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>index validation: scanning table</literal></entry>
      <entry>
       <command>CREATE INDEX CONCURRENTLY</command> is scanning the table
       to validate the index tuples collected in the previous two phases.
       This phase is skipped when not in concurrent mode.
       Columns <structname>blocks_total</structname> (set to the total size of the table)
       and <structname>blocks_done</structname> contain the progress information for this phase.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>索引验证：扫描表</literal></entry>
      <entry>
       <command>CREATE INDEX CONCURRENTLY</command>正在扫描表，以验证前两个阶段收集的索引图元。当不在并发模式时，这个阶段被跳过。<structname>blocks_total</structname>列（设置为表的总大小）和<structname>blocks_done</structname>列包含这个阶段的进度信息。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>waiting for old snapshots</literal></entry>
      <entry>
       <command>CREATE INDEX CONCURRENTLY</command> or <command>REINDEX CONCURRENTLY</command> is waiting for transactions
       that can potentially see the table to release their snapshots.  This
       phase is skipped when not in concurrent mode.
       Columns <structname>lockers_total</structname>, <structname>lockers_done</structname>
       and <structname>current_locker_pid</structname> contain the progress
       information for this phase.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>等待旧照</literal></entry>
      <entry>
       <command>CREATE INDEX CONCURRENTLY</command>或<command>REINDEX CONCURRENTLY</command>正在等待可能看到表的事务释放快照。 当不处于并发模式时，这个阶段会被跳过。 <structname>lockers_total</structname>、<structname>lockers_done</structname> 和 <structname>current_locker_pid</structname> 列包含了这个阶段的进度信息。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>waiting for readers before marking dead</literal></entry>
      <entry>
       <command>REINDEX CONCURRENTLY</command> is waiting for transactions
       with read locks on the table to finish, before marking the old index dead.
       This phase is skipped when not in concurrent mode.
       Columns <structname>lockers_total</structname>, <structname>lockers_done</structname>
       and <structname>current_locker_pid</structname> contain the progress
       information for this phase.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>标记 dead之前等待readers</literal></entry>
      <entry>
       <command>REINDEX CONCURRENTLY</command>等待表上有读锁的事务完成后，再将旧索引标记为死索引。当不在并发模式时，这个阶段被跳过。<structname>lockers_total</structname>、<structname>lockers_done</structname> 和 <structname>current_locker_pid</structname> 列包含了这个阶段的进度信息。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>waiting for readers before dropping</literal></entry>
      <entry>
       <command>REINDEX CONCURRENTLY</command> is waiting for transactions
       with read locks on the table to finish, before dropping the old index.
       This phase is skipped when not in concurrent mode.
       Columns <structname>lockers_total</structname>, <structname>lockers_done</structname>
       and <structname>current_locker_pid</structname> contain the progress
       information for this phase.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>在 dropping之前等待readers</literal></entry>
      <entry>
       <command>REINDEX CONCURRENTLY</command>等待表上有读锁的事务完成后，再丢弃旧索引。当不在并发模式时，这个阶段被跳过。列 <structname>lockers_total</structname>、<structname>lockers_done</structname> 和 <structname>current_locker_pid</structname>包含了这个阶段的进度信息。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="vacuum-progress-reporting">
<!--==========================orignal english content==========================
  <title>VACUUM Progress Reporting</title>
____________________________________________________________________________-->
  <title>VACUUM进度报告</title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>pg_stat_progress_vacuum</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>pg_stat_progress_vacuum</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   Whenever <command>VACUUM</command> is running, the
   <structname>pg_stat_progress_vacuum</structname> view will contain
   one row for each backend (including autovacuum worker processes) that is
   currently vacuuming.  The tables below describe the information
   that will be reported and provide information about how to interpret it.
   Progress for <command>VACUUM FULL</command> commands is reported via
   <structname>pg_stat_progress_cluster</structname>
   because both <command>VACUUM FULL</command> and <command>CLUSTER</command>
   rewrite the table, while regular <command>VACUUM</command> only modifies it
   in place. See <xref linkend='cluster-progress-reporting'/>.
  </para>
____________________________________________________________________________-->
  <para>
   只要<command>VACUUM</command>正在运行，每一个当前正在清理的后端（包括autovacuum工作者进程）在<structname>pg_stat_progress_vacuum</structname>视图中都会有一行。下面的表描述了将被报告的信息并且提供了如何解释它们的信息。<command>VACUUM FULL</command>命令的进度是通过<structname>pg_stat_progress_cluster</structname>报告的，因为<command>VACUUM FULL</command>和<command>CLUSTER</command>都是重写表，而普通的<command>VACUUM</command>只是原地修改表。见<xref linkend='cluster-progress-reporting'/>.
  </para>

  <table id="pg-stat-progress-vacuum-view" xreflabel="pg_stat_progress_vacuum">
<!--==========================orignal english content==========================
   <title><structname>pg_stat_progress_vacuum</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_stat_progress_vacuum</structname> 视图</title>
   <tgroup cols="1">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       Process ID of backend.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       后端的进程ID。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the database to which this backend is connected.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datid</structfield> <type>oid</type>
      </para>
      <para>
       这个后端连接的数据库的OID。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datname</structfield> <type>name</type>
      </para>
      <para>
       Name of the database to which this backend is connected.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datname</structfield> <type>name</type>
      </para>
      <para>
       这个后端连接的数据库的名称。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the table being vacuumed.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       被vacuum的表的OID。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>phase</structfield> <type>text</type>
      </para>
      <para>
       Current processing phase of vacuum.  See <xref linkend="vacuum-phases"/>.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>phase</structfield> <type>text</type>
      </para>
      <para>
       vacuum的当前处理阶段。参见 <xref linkend="vacuum-phases"/>。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_blks_total</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of heap blocks in the table.  This number is reported
       as of the beginning of the scan; blocks added later will not be (and
       need not be) visited by this <command>VACUUM</command>.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_blks_total</structfield> <type>bigint</type>
      </para>
      <para>
       该表中堆块的总数。这个数字在扫描开始时报告，之后增加的块将不会（并且不需要）被这个<command>VACUUM</command>访问。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_blks_scanned</structfield> <type>bigint</type>
      </para>
      <para>
       Number of heap blocks scanned.  Because the
       <link linkend="storage-vm">visibility map</link> is used to optimize scans,
       some blocks will be skipped without inspection; skipped blocks are
       included in this total, so that this number will eventually become
       equal to <structfield>heap_blks_total</structfield> when the vacuum is complete.
       This counter only advances when the phase is <literal>scanning heap</literal>.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_blks_scanned</structfield> <type>bigint</type>
      </para>
      <para>
       被扫描的堆块数量。由于<link linkend="storage-vm">visibility map</link>被用来优化扫描，一些块将被跳过而不做检查，
       被跳过的块会被包括在这个总数中，因此当清理完成时这个数字最终将会等于<structfield>heap_blks_total</structfield>。
       仅当处于<literal>扫描堆</literal>阶段时这个计数器才会前进。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_blks_vacuumed</structfield> <type>bigint</type>
      </para>
      <para>
       Number of heap blocks vacuumed.  Unless the table has no indexes, this
       counter only advances when the phase is <literal>vacuuming heap</literal>.
       Blocks that contain no dead tuples are skipped, so the counter may
       sometimes skip forward in large increments.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_blks_vacuumed</structfield> <type>bigint</type>
      </para>
      <para>
       被清理的堆块数量。除非表没有索引，这个计数器仅在处于<literal>清理堆</literal>阶段时才会前进。
       不包含死亡元组的块会被跳过，因此这个计数器可能有时会向前跳跃一个比较大的增量。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>index_vacuum_count</structfield> <type>bigint</type>
      </para>
      <para>
       Number of completed index vacuum cycles.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>index_vacuum_count</structfield> <type>bigint</type>
      </para>
      <para>
       已完成的索引清理周期数。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>max_dead_tuples</structfield> <type>bigint</type>
      </para>
      <para>
       Number of dead tuples that we can store before needing to perform
       an index vacuum cycle, based on
       <xref linkend="guc-maintenance-work-mem"/>.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>max_dead_tuples</structfield> <type>bigint</type>
      </para>
      <para>
       在需要执行一个索引清理周期之前我们可以存储的死亡元组数，取决于<xref linkend="guc-maintenance-work-mem"/>。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>num_dead_tuples</structfield> <type>bigint</type>
      </para>
      <para>
       Number of dead tuples collected since the last index vacuum cycle.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>num_dead_tuples</structfield> <type>bigint</type>
      </para>
      <para>
       从上一个索引清理周期以来收集的死亡元组数。
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table id="vacuum-phases">
<!--==========================orignal english content==========================
   <title>VACUUM Phases</title>
____________________________________________________________________________-->
   <title>VACUUM的阶段</title>
   <tgroup cols="2">
    <colspec colname="col1" colwidth="1*"/>
    <colspec colname="col2" colwidth="2*"/>
    <thead>
<!--==========================orignal english content==========================
    <row>
      <entry>Phase</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
    <row>
      <entry>阶段</entry>
      <entry>描述</entry>
     </row>
    </thead>

   <tbody>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>initializing</literal></entry>
     <entry>
       <command>VACUUM</command> is preparing to begin scanning the heap.  This
       phase is expected to be very brief.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>初始化</literal></entry>
     <entry>
       <command>VACUUM</command>正在准备开始扫描堆。这个阶段应该很简短。
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>scanning heap</literal></entry>
     <entry>
       <command>VACUUM</command> is currently scanning the heap.  It will prune and
       defragment each page if required, and possibly perform freezing
       activity.  The <structfield>heap_blks_scanned</structfield> column can be used
       to monitor the progress of the scan.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>扫描堆</literal></entry>
     <entry>
       <command>VACUUM</command>正在扫描堆。如果需要，它将会对每个页面进行修建以及碎片整理，并且可能会执行冻结动作。<structfield>heap_blks_scanned</structfield>列可以用来监控扫描的进度。
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>vacuuming indexes</literal></entry>
     <entry>
       <command>VACUUM</command> is currently vacuuming the indexes.  If a table has
       any indexes, this will happen at least once per vacuum, after the heap
       has been completely scanned.  It may happen multiple times per vacuum
       if <xref linkend="guc-maintenance-work-mem"/> (or, in the case of autovacuum,
       <xref linkend="guc-autovacuum-work-mem"/> if set) is insufficient to store
       the number of dead tuples found.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>清理索引</literal></entry>
     <entry>
       <command>VACUUM</command>当前正在清理索引。
       如果一个表拥有索引，那么每次清理时这个阶段会在堆扫描完成后至少发生一次。
       如果<xref linkend="guc-maintenance-work-mem"/>不足以存放找到的死亡元组(或者, 在autovacuum情况下，如果设置了<xref linkend="guc-autovacuum-work-mem"/>) ，则每次清理时会多次清理索引。
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>vacuuming heap</literal></entry>
     <entry>
       <command>VACUUM</command> is currently vacuuming the heap.  Vacuuming the heap
       is distinct from scanning the heap, and occurs after each instance of
       vacuuming indexes.  If <structfield>heap_blks_scanned</structfield> is less than
       <structfield>heap_blks_total</structfield>, the system will return to scanning
       the heap after this phase is completed; otherwise, it will begin
       cleaning up indexes after this phase is completed.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>清理堆</literal></entry>
     <entry>
       <command>VACUUM</command>当前正在清理堆。清理堆与扫描堆不是同一个概念，清理堆发生在每一次清理索引的实例之后。如果<structfield>heap_blks_scanned</structfield>小于<structfield>heap_blks_total</structfield>，系统将在这个阶段完成之后回去扫描堆；否则，系统将在这个阶段完成后开始清理索引。
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>cleaning up indexes</literal></entry>
     <entry>
       <command>VACUUM</command> is currently cleaning up indexes.  This occurs after
       the heap has been completely scanned and all vacuuming of the indexes
       and the heap has been completed.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>清除索引</literal></entry>
     <entry>
       <command>VACUUM</command>当前正在清除索引。这个阶段发生在堆被完全扫描并且对堆和索引的所有清理都已经完成以后。
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>truncating heap</literal></entry>
     <entry>
       <command>VACUUM</command> is currently truncating the heap so as to return
       empty pages at the end of the relation to the operating system.  This
       occurs after cleaning up indexes.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>截断堆</literal></entry>
     <entry>
       <command>VACUUM</command>正在截断堆，以便把关系尾部的空页面返还给操作系统。这个阶段发生在清除完索引之后。
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>performing final cleanup</literal></entry>
     <entry>
       <command>VACUUM</command> is performing final cleanup.  During this phase,
       <command>VACUUM</command> will vacuum the free space map, update statistics
       in <literal>pg_class</literal>, and report statistics to the statistics
       collector.  When this phase is completed, <command>VACUUM</command> will end.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>执行最后的清除</literal></entry>
     <entry>
       <command>VACUUM</command>在执行最终的清除。在这个阶段中，<command>VACUUM</command>将清理空闲空间映射、更新<literal>pg_class</literal>中的统计信息并且将统计信息报告给统计收集器。当这个阶段完成时，<command>VACUUM</command>也就结束了。
     </entry>
    </row>
   </tbody>
   </tgroup>
  </table>
 </sect2>

 <sect2 id="cluster-progress-reporting">
<!--==========================orignal english content==========================
  <title>CLUSTER Progress Reporting</title>
____________________________________________________________________________-->
  <title>CLUSTER进度报告</title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>pg_stat_progress_cluster</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>pg_stat_progress_cluster</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   Whenever <command>CLUSTER</command> or <command>VACUUM FULL</command> is
   running, the <structname>pg_stat_progress_cluster</structname> view will
   contain a row for each backend that is currently running either command.
   The tables below describe the information that will be reported and
   provide information about how to interpret it.
  </para>
____________________________________________________________________________-->
  <para>
   每当<command>CLUSTER</command>或<command>VACUUM FULL</command>运行时，<structname>pg_stat_progress_cluster</structname>视图将包含当前正在运行的每一个后台的记录。下面的表格描述了将被报告的信息，并提供了关于如何解释这些信息的信息。
  </para>

  <table id="pg-stat-progress-cluster-view" xreflabel="pg_stat_progress_cluster">
<!--==========================orignal english content==========================
   <title><structname>pg_stat_progress_cluster</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_stat_progress_cluster</structname> 视图</title>
   <tgroup cols="1">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       Process ID of backend.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       后台的进程ID。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the database to which this backend is connected.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datid</structfield> <type>oid</type>
      </para>
      <para>
       该后端连接的数据库的OID。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datname</structfield> <type>name</type>
      </para>
      <para>
       Name of the database to which this backend is connected.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datname</structfield> <type>name</type>
      </para>
      <para>
       与此后端连接的数据库的名称。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the table being clustered.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       被集群的表的OID。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>command</structfield> <type>text</type>
      </para>
      <para>
       The command that is running. Either <literal>CLUSTER</literal> or <literal>VACUUM FULL</literal>.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>command</structfield> <type>text</type>
      </para>
      <para>
       正在运行的命令。<literal>CLUSTER</literal>或<literal>VACUUM FULL</literal>。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>phase</structfield> <type>text</type>
      </para>
      <para>
       Current processing phase. See <xref linkend="cluster-phases"/>.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>phase</structfield> <type>text</type>
      </para>
      <para>
       当前处理阶段。参见<xref linkend='cluster-phases' />。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>cluster_index_relid</structfield> <type>oid</type>
      </para>
      <para>
       If the table is being scanned using an index, this is the OID of the
       index being used; otherwise, it is zero.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>cluster_index_relid</structfield> <type>oid</type>
      </para>
      <para>
       如果正在使用索引对表进行扫描，这就是正在使用的索引的OID；否则为0。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_tuples_scanned</structfield> <type>bigint</type>
      </para>
      <para>
       Number of heap tuples scanned.
       This counter only advances when the phase is
       <literal>seq scanning heap</literal>,
       <literal>index scanning heap</literal>
       or <literal>writing new heap</literal>.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_tuples_scanned</structfield> <type>bigint</type>
      </para>
      <para>
       扫描的堆元组数。
       这个计数器只有在阶段为<literal>seq scanning heap</literal>,<literal>index scanning heap</literal>
       或 <literal>writing new heap</literal>时才会增进。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_tuples_written</structfield> <type>bigint</type>
      </para>
      <para>
       Number of heap tuples written.
       This counter only advances when the phase is
       <literal>seq scanning heap</literal>,
       <literal>index scanning heap</literal>
       or <literal>writing new heap</literal>.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_tuples_written</structfield> <type>bigint</type>
      </para>
      <para>
       写入的堆元组的数量。这个计数器只有在阶段为<literal>seq scanning heap</literal>,<literal>index scanning heap</literal>
       或 <literal>writing new heap</literal>时才会前进。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_blks_total</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of heap blocks in the table.  This number is reported
       as of the beginning of <literal>seq scanning heap</literal>.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_blks_total</structfield> <type>bigint</type>
      </para>
      <para>
       表中的堆块总数。 这个数字是在<literal>seq scanning heap</literal>的开始时报告的。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_blks_scanned</structfield> <type>bigint</type>
      </para>
      <para>
       Number of heap blocks scanned.  This counter only advances when the
       phase is <literal>seq scanning heap</literal>.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>heap_blks_scanned</structfield> <type>bigint</type>
      </para>
      <para>
       扫描的堆块数量。 这个计数器只有在阶段为<literal>seq scanning heap</literal>时才会增进。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>index_rebuild_count</structfield> <type>bigint</type>
      </para>
      <para>
       Number of indexes rebuilt.  This counter only advances when the phase
       is <literal>rebuilding index</literal>.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>index_rebuild_count</structfield> <type>bigint</type>
      </para>
      <para>
       重建的索引数。 该计数器仅在<literal>重建索引</literal>阶段时才会增进。
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table id="cluster-phases">
<!--==========================orignal english content==========================
   <title>CLUSTER and VACUUM FULL Phases</title>
____________________________________________________________________________-->
   <title>CLUSTER 和 VACUUM FULL 阶段</title>
   <tgroup cols="2">
    <colspec colname="col1" colwidth="1*"/>
    <colspec colname="col2" colwidth="2*"/>
    <thead>
<!--==========================orignal english content==========================
    <row>
      <entry>Phase</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
    <row>
      <entry>阶段</entry>
      <entry>描述</entry>
     </row>
    </thead>

   <tbody>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>initializing</literal></entry>
     <entry>
       The command is preparing to begin scanning the heap.  This phase is
       expected to be very brief.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>初始化</literal></entry>
     <entry>
       该命令准备开始扫描堆栈。 这个阶段预计会非常短暂。
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>seq scanning heap</literal></entry>
     <entry>
       The command is currently scanning the table using a sequential scan.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>seq扫描堆</literal></entry>
     <entry>
       该命令目前采用顺序扫描的方式对表进行扫描。
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>index scanning heap</literal></entry>
     <entry>
       <command>CLUSTER</command> is currently scanning the table using an index scan.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>索引扫描堆</literal></entry>
     <entry>
       <command>CLUSTER</command>目前正在使用索引扫描表。
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>sorting tuples</literal></entry>
     <entry>
       <command>CLUSTER</command> is currently sorting tuples.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>元组排序</literal></entry>
     <entry>
       <command>CLUSTER</command>目前正在对元组进行排序。
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>writing new heap</literal></entry>
     <entry>
       <command>CLUSTER</command> is currently writing the new heap.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>新写入堆</literal></entry>
     <entry>
       <command>CLUSTER</command>目前正在编写新的堆。
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>swapping relation files</literal></entry>
     <entry>
       The command is currently swapping newly-built files into place.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>交换关系文件</literal></entry>
     <entry>
       目前，该命令正在将新建立的文件调换到位。
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>rebuilding index</literal></entry>
     <entry>
       The command is currently rebuilding an index.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>重建索引</literal></entry>
     <entry>
       该命令目前正在重建一个索引。
     </entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>performing final cleanup</literal></entry>
     <entry>
       The command is performing final cleanup.  When this phase is
       completed, <command>CLUSTER</command>
       or <command>VACUUM FULL</command> will end.
     </entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>清理</literal></entry>
     <entry>
       该命令正在执行最后的清理工作。 当此阶段完成后，<command>CLUSTER</command>或<command>VACUUM FULL</command>将结束。
     </entry>
    </row>
   </tbody>
   </tgroup>
  </table>
 </sect2>

 <sect2 id="basebackup-progress-reporting">
<!--==========================orignal english content==========================
  <title>Base Backup Progress Reporting</title>
____________________________________________________________________________-->
  <title>基础备份进度报告</title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>pg_stat_progress_basebackup</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>pg_stat_progress_basebackup</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   Whenever an application like <application>pg_basebackup</application>
   is taking a base backup, the
   <structname>pg_stat_progress_basebackup</structname>
   view will contain a row for each WAL sender process that is currently
   running the <command>BASE_BACKUP</command> replication command
   and streaming the backup. The tables below describe the information
   that will be reported and provide information about how to interpret it.
  </para>
____________________________________________________________________________-->
  <para>
   每当像<application>pg_basebackup</application>这样的应用程序进行基本备份时，
   <structname>pg_stat_progress_basebackup</structname>视图将包含当前运行<command>BASE_BACKUP</command>复制命令和流备份的每个WAL发送进程的一行。
   下面的表描述了将要报告的信息，并提供了关于如何解释它的信息。
  </para>

  <table id="pg-stat-progress-basebackup-view" xreflabel="pg_stat_progress_basebackup">
<!--==========================orignal english content==========================
   <title><structname>pg_stat_progress_basebackup</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_stat_progress_basebackup</structname> 视图</title>
   <tgroup cols="1">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       Process ID of a WAL sender process.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       WAL发送方进程ID。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>phase</structfield> <type>text</type>
      </para>
      <para>
       Current processing phase. See <xref linkend="basebackup-phases"/>.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>phase</structfield> <type>text</type>
      </para>
      <para>
       目前的处理阶段。 参见 <xref linkend="basebackup-phases"/>。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>backup_total</structfield> <type>bigint</type>
      </para>
      <para>
       Total amount of data that will be streamed. This is estimated and
       reported as of the beginning of
       <literal>streaming database files</literal> phase. Note that
       this is only an approximation since the database
       may change during <literal>streaming database files</literal> phase
       and WAL log may be included in the backup later. This is always
       the same value as <structfield>backup_streamed</structfield>
       once the amount of data streamed exceeds the estimated
       total size. If the estimation is disabled in
       <application>pg_basebackup</application>
       (i.e., <literal>-&minus;no-estimate-size</literal> option is specified),
       this is <literal>NULL</literal>.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>backup_total</structfield> <type>bigint</type>
      </para>
      <para>
       将被流输送的数据总量。这是在<literal>streaming database files</literal>阶段开始时的估计和报告。
       注意，这只是一个近似值，因为在<literal>streaming database files</literal>阶段，数据库可能会改变，而WAL日志可能会在稍后的备份中包含。
       一旦流数据量超过了估计的总大小，该值始终与<structfield>backup_streamed</structfield>相同。
       如果在<application>pg_basebackup</application>中禁用估算(也就是说，指定了<literal>--no-estimate-size</literal>选项)，这为<literal>NULL</literal>。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>backup_streamed</structfield> <type>bigint</type>
      </para>
      <para>
       Amount of data streamed. This counter only advances
       when the phase is <literal>streaming database files</literal> or
       <literal>transferring wal files</literal>.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>backup_streamed</structfield> <type>bigint</type>
      </para>
      <para>
       数据流的总量。这个计数器只在<literal>streaming database files</literal>阶段或<literal>transferring wal files</literal>时增进。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tablespaces_total</structfield> <type>bigint</type>
      </para>
      <para>
       Total number of tablespaces that will be streamed.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tablespaces_total</structfield> <type>bigint</type>
      </para>
      <para>
       要流输送的表空间总数。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tablespaces_streamed</structfield> <type>bigint</type>
      </para>
      <para>
       Number of tablespaces streamed. This counter only
       advances when the phase is <literal>streaming database files</literal>.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tablespaces_streamed</structfield> <type>bigint</type>
      </para>
      <para>
       流输送的表空间数。此计数器仅在<literal>streaming database files</literal>阶段增进。
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <table id="basebackup-phases">
<!--==========================orignal english content==========================
   <title>Base backup phases</title>
____________________________________________________________________________-->
   <title>基础备份阶段</title>
   <tgroup cols="2">
    <colspec colname="col1" colwidth="1*"/>
    <colspec colname="col2" colwidth="2*"/>
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry>Phase</entry>
      <entry>Description</entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry>阶段</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>initializing</literal></entry>
      <entry>
       The WAL sender process is preparing to begin the backup.
       This phase is expected to be very brief.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>initializing</literal></entry>
      <entry>
       WAL发送器进程正在准备开始备份。这个阶段预计会非常短暂。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>waiting for checkpoint to finish</literal></entry>
      <entry>
       The WAL sender process is currently performing
       <function>pg_start_backup</function> to prepare to
       take a base backup, and waiting for the start-of-backup
       checkpoint to finish.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>waiting for checkpoint to finish</literal></entry>
      <entry>
       WAL发送器进程目前正在执行<function>pg_start_backup</function>以准备进行基础备份，并等待启动备份检查点完成。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>estimating backup size</literal></entry>
      <entry>
       The WAL sender process is currently estimating the total amount
       of database files that will be streamed as a base backup.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>estimating backup size</literal></entry>
      <entry>
       WAL发送程序目前正在估计将作为基础备份流传输的数据库文件的总量。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>streaming database files</literal></entry>
      <entry>
       The WAL sender process is currently streaming database files
       as a base backup.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>streaming database files</literal></entry>
      <entry>
       WAL发送器当前正在流数据库文件作为基础备份。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>waiting for wal archiving to finish</literal></entry>
      <entry>
       The WAL sender process is currently performing
       <function>pg_stop_backup</function> to finish the backup,
       and waiting for all the WAL files required for the base backup
       to be successfully archived.
       If either <literal>-&minus;wal-method=none</literal> or
       <literal>-&minus;wal-method=stream</literal> is specified in
       <application>pg_basebackup</application>, the backup will end
       when this phase is completed.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>waiting for wal archiving to finish</literal></entry>
      <entry>
       WAL发送方进程目前正在执行<function>pg_stop_backup</function>以完成备份，并等待基础备份所需的所有WAL文件成功存档。
       如果在<application>pg_basebackup</application>中指定了<literal>--wal-method=none</literal>或<literal>--wal-method=stream</literal>，则备份将在此阶段完成后结束。
      </entry>
     </row>
<!--==========================orignal english content==========================
     <row>
      <entry><literal>transferring wal files</literal></entry>
      <entry>
       The WAL sender process is currently transferring all WAL logs
       generated during the backup. This phase occurs after
       <literal>waiting for wal archiving to finish</literal> phase if
       <literal>-&minus;wal-method=fetch</literal> is specified in
       <application>pg_basebackup</application>. The backup will end
       when this phase is completed.
      </entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry><literal>transferring wal files</literal></entry>
      <entry>
       WAL发送器进程正在传输备份过程中产生的所有WAL日志。
       如果<application>pg_basebackup</application>中指定了<literal>--wal-method=fetch</literal>，
       则该阶段发生在<literal>waiting for wal archiving to finish</literal>阶段之后。当此阶段完成时备份将结束。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

 </sect2>

 <sect2 id="copy-progress-reporting">
<!--==========================orignal english content==========================
  <title>COPY Progress Reporting</title>
____________________________________________________________________________-->
  <title>COPY Progress Reporting</title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>pg_stat_progress_copy</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>pg_stat_progress_copy</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   Whenever <command>COPY</command> is running, the
   <structname>pg_stat_progress_copy</structname> view will contain one row
   for each backend that is currently running a <command>COPY</command> command.
   The table below describes the information that will be reported and provides
   information about how to interpret it.
  </para>
____________________________________________________________________________-->
  <para>
   当<command>COPY</command>正在运行时，<structname>pg_stat_progress_copy</structname>视图将包含一行,为了当前正在运行<command>COPY</command>命令的每个后端。
   下表描述了将被报告的信息，并提供了如何解释它的信息。
  </para>

  <table id="pg-stat-progress-copy-view" xreflabel="pg_stat_progress_copy">
<!--==========================orignal english content==========================
   <title><structname>pg_stat_progress_copy</structname> View</title>
____________________________________________________________________________-->
   <title><structname>pg_stat_progress_copy</structname> View</title>
   <tgroup cols="1">
    <thead>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       Column Type
      </para>
      <para>
       Description
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       列类型
      </para>
      <para>
       描述
      </para></entry>
     </row>
    </thead>

    <tbody>
<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       Process ID of backend.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>pid</structfield> <type>integer</type>
      </para>
      <para>
       后端的进程ID。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the database to which this backend is connected.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datid</structfield> <type>oid</type>
      </para>
      <para>
       此后端所连接的数据库的OID。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datname</structfield> <type>name</type>
      </para>
      <para>
       Name of the database to which this backend is connected.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>datname</structfield> <type>name</type>
      </para>
      <para>
       此后端所连接的数据库的名称。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       OID of the table on which the <command>COPY</command> command is
       executed. It is set to <literal>0</literal> if copying from a
       <command>SELECT</command> query.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>relid</structfield> <type>oid</type>
      </para>
      <para>
       执行<command>COPY</command>命令的表的OID。
       如果从<command>SELECT</command>查询中复制，它被设置为<literal>0</literal>。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>command</structfield> <type>text</type>
      </para>
      <para>
       The command that is running: <literal>COPY FROM</literal>, or
       <literal>COPY TO</literal>.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>command</structfield> <type>text</type>
      </para>
      <para>
       正在运行的命令: <literal>COPY FROM</literal>, 或 <literal>COPY TO</literal>。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>type</structfield> <type>text</type>
      </para>
      <para>
       The io type that the data is read from or written to:
       <literal>FILE</literal>, <literal>PROGRAM</literal>,
       <literal>PIPE</literal> (for <command>COPY FROM STDIN</command> and
       <command>COPY TO STDOUT</command>), or <literal>CALLBACK</literal>
       (used for example during the initial table synchronization in
       logical replication).
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>type</structfield> <type>text</type>
      </para>
      <para>
       数据被读取或写入的io类型:<literal>FILE</literal>, <literal>PROGRAM</literal>, <literal>PIPE</literal> (对于<command>COPY FROM STDIN</command> 和 <command>COPY TO STDOUT</command>)，或 <literal>CALLBACK</literal>(例如在逻辑复制中初始表同步期间使用)。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>bytes_processed</structfield> <type>bigint</type>
      </para>
      <para>
       Number of bytes already processed by <command>COPY</command> command.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>bytes_processed</structfield> <type>bigint</type>
      </para>
      <para>
       已经被<command>COPY</command>命令处理的字节数。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>bytes_total</structfield> <type>bigint</type>
      </para>
      <para>
       Size of source file for <command>COPY FROM</command> command in bytes.
       It is set to <literal>0</literal> if not available.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>bytes_total</structfield> <type>bigint</type>
      </para>
      <para>
       <command>COPY FROM</command>命令的源文件大小，以字节计。
       如果不可用则设置为<literal>0</literal>。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tuples_processed</structfield> <type>bigint</type>
      </para>
      <para>
       Number of tuples already processed by <command>COPY</command> command.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tuples_processed</structfield> <type>bigint</type>
      </para>
      <para>
       已经被<command>COPY</command>命令处理的元组数。
      </para></entry>
     </row>

<!--==========================orignal english content==========================
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tuples_excluded</structfield> <type>bigint</type>
      </para>
      <para>
       Number of tuples not processed because they were excluded by the
       <command>WHERE</command> clause of the <command>COPY</command> command.
      </para></entry>
     </row>
____________________________________________________________________________-->
     <row>
      <entry role="catalog_table_entry"><para role="column_definition">
       <structfield>tuples_excluded</structfield> <type>bigint</type>
      </para>
      <para>
       没有处理的元组数，因为它们被<command>COPY</command>命令的<command>WHERE</command>子句所排除。
      </para></entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </sect2>

 </sect1>

 <sect1 id="dynamic-trace">
<!--==========================orignal english content==========================
  <title>Dynamic Tracing</title>
____________________________________________________________________________-->
  <title>动态追踪</title>

<!--==========================orignal english content==========================
 <indexterm zone="dynamic-trace">
  <primary>DTrace</primary>
 </indexterm>
____________________________________________________________________________-->
 <indexterm zone="dynamic-trace">
  <primary>DTrace</primary>
 </indexterm>

<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname> provides facilities to support
   dynamic tracing of the database server. This allows an external
   utility to be called at specific points in the code and thereby trace
   execution.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname>提供了功能来支持数据库服务器的动态追踪。这样就允许在代码中的特 定点上调用外部工具来追踪执行过程。
  </para>

<!--==========================orignal english content==========================
  <para>
   A number of probes or trace points are already inserted into the source
   code. These probes are intended to be used by database developers and
   administrators. By default the probes are not compiled into
   <productname>PostgreSQL</productname>; the user needs to explicitly tell
   the configure script to make the probes available.
  </para>
____________________________________________________________________________-->
  <para>
   一些探针或追踪点已经被插入在源代码中。这些探针的目的是被数据库开发者和管理员使用。默认情况下，探针不被编译到<productname>PostgreSQL</productname>中；用户需要显式地告诉配置脚本使得探针可用。
  </para>

<!--==========================orignal english content==========================
  <para>
   Currently, the
   <ulink url="https://en.wikipedia.org/wiki/DTrace">DTrace</ulink>
   utility is supported, which, at the time of this writing, is available
   on Solaris, macOS, FreeBSD, NetBSD, and Oracle Linux.  The
   <ulink url="https://sourceware.org/systemtap/">SystemTap</ulink> project
   for Linux provides a DTrace equivalent and can also be used.  Supporting other dynamic
   tracing utilities is theoretically possible by changing the definitions for
   the macros in <filename>src/include/utils/probes.h</filename>.
  </para>
____________________________________________________________________________-->
  <para>
   目前，在写本文当时<ulink url="https://en.wikipedia.org/wiki/DTrace">DTrace</ulink>已被支持，它在 Solaris、macOS、FreeBSD、NetBSD 和 Oracle Linux 上可用。
   Linux 的<ulink url="https://sourceware.org/systemtap/">SystemTap</ulink>项目提供了一种可用的 DTrace 等价物。支持其他动态追踪工具在理论上可以通过改变<filename>src/include/utils/probes.h</filename>中的宏定义实现。
  </para>

  <sect2 id="compiling-for-trace">
<!--==========================orignal english content==========================
   <title>Compiling for Dynamic Tracing</title>
____________________________________________________________________________-->
   <title>动态追踪的编译</title>

<!--==========================orignal english content==========================
  <para>
   By default, probes are not available, so you will need to
   explicitly tell the configure script to make the probes available
   in <productname>PostgreSQL</productname>. To include DTrace support
   specify <option>-&minus;enable-dtrace</option> to configure.  See <xref
   linkend="install-procedure"/> for further information.
  </para>
____________________________________________________________________________-->
  <para>
   默认情况下，探针是不可用的，因此你将需要显式地告诉配置脚本让探针在<productname>PostgreSQL</productname>中可用。要包括 DTrace 支持，在配置时指定<option>--enable-dtrace</option>。更多信息请见<xref linkend="install-procedure"/>。
  </para>
  </sect2>

  <sect2 id="trace-points">
<!--==========================orignal english content==========================
   <title>Built-in Probes</title>
____________________________________________________________________________-->
   <title>内建探针</title>

<!--==========================orignal english content==========================
  <para>
   A number of standard probes are provided in the source code,
   as shown in <xref linkend="dtrace-probe-point-table"/>;
   <xref linkend="typedefs-table"/>
   shows the types used in the probes.  More probes can certainly be
   added to enhance <productname>PostgreSQL</productname>'s observability.
  </para>
____________________________________________________________________________-->
  <para>
   如<xref linkend="dtrace-probe-point-table"/>所示，源代码中提供了一些标准探针。<xref linkend="typedefs-table"/>显式了在探针中使用的类型。当然，可以增加更多探针来增强<productname>PostgreSQL</productname>的可观测性。
  </para>

 <table id="dtrace-probe-point-table">
<!--==========================orignal english content==========================
  <title>Built-in DTrace Probes</title>
____________________________________________________________________________-->
  <title>内建 DTrace 探针</title>
  <tgroup cols="3">
   <colspec colname="col1" colwidth="2*"/>
   <colspec colname="col2" colwidth="3*"/>
   <colspec colname="col3" colwidth="3*"/>
   <thead>
<!--==========================orignal english content==========================
    <row>
     <entry>Name</entry>
     <entry>Parameters</entry>
     <entry>Description</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry>名称</entry>
     <entry>参数</entry>
     <entry>描述</entry>
    </row>
   </thead>

   <tbody>

<!--==========================orignal english content==========================
    <row>
     <entry><literal>transaction-start</literal></entry>
     <entry><literal>(LocalTransactionId)</literal></entry>
     <entry>Probe that fires at the start of a new transaction.
      arg0 is the transaction ID.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>transaction-start</literal></entry>
     <entry><literal>(LocalTransactionId)</literal></entry>
     <entry>在一个新事务开始时触发的探针。arg0 是事务 ID。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>transaction-commit</literal></entry>
     <entry><literal>(LocalTransactionId)</literal></entry>
     <entry>Probe that fires when a transaction completes successfully.
      arg0 is the transaction ID.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>transaction-commit</literal></entry>
     <entry><literal>(LocalTransactionId)</literal></entry>
     <entry>在一个事务成功完成时触发的探针。arg0 是事务 ID。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>transaction-abort</literal></entry>
     <entry><literal>(LocalTransactionId)</literal></entry>
     <entry>Probe that fires when a transaction completes unsuccessfully.
      arg0 is the transaction ID.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>transaction-abort</literal></entry>
     <entry><literal>(LocalTransactionId)</literal></entry>
     <entry>当一个事务失败完成时触发的探针。arg0 是事务 ID。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>query-start</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>Probe that fires when the processing of a query is started.
      arg0 is the query string.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>query-start</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>当一个查询的处理被开始时触发的探针。arg0 是查询字符串。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>query-done</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>Probe that fires when the processing of a query is complete.
      arg0 is the query string.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>query-done</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>当一个查询的处理完成时触发的探针。arg0 是查询字符串。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>query-parse-start</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>Probe that fires when the parsing of a query is started.
      arg0 is the query string.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>query-parse-start</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>当一个查询的解析被开始时触发的探针。arg0 是查询字符串。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>query-parse-done</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>Probe that fires when the parsing of a query is complete.
      arg0 is the query string.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>query-parse-done</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>当一个查询的解析完成时触发的探针。arg0 是查询字符串。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>query-rewrite-start</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>Probe that fires when the rewriting of a query is started.
      arg0 is the query string.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>query-rewrite-start</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>当一个查询的重写被开始时触发的探针。arg0 是查询字符串。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>query-rewrite-done</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>Probe that fires when the rewriting of a query is complete.
      arg0 is the query string.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>query-rewrite-done</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>当一个查询的重写完成时触发的探针。arg0 是查询字符串。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>query-plan-start</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when the planning of a query is started.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>query-plan-start</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>当一个查询的规划被开始时触发的探针。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>query-plan-done</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when the planning of a query is complete.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>query-plan-done</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>当一个查询的规划完成时触发的探针。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>query-execute-start</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when the execution of a query is started.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>query-execute-start</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>当一个查询的执行被开始时触发的探针。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>query-execute-done</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when the execution of a query is complete.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>query-execute-done</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>当一个查询的执行完成时触发的探针。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>statement-status</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>Probe that fires anytime the server process updates its
      <structname>pg_stat_activity</structname>.<structfield>status</structfield>.
      arg0 is the new status string.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>statement-status</literal></entry>
     <entry><literal>(const char *)</literal></entry>
     <entry>任何时候当服务器进程更新它的<structname>pg_stat_activity</structname>.<structfield>status</structfield>时触发的探针。arg0 是新的状态字符串。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>checkpoint-start</literal></entry>
     <entry><literal>(int)</literal></entry>
     <entry>Probe that fires when a checkpoint is started.
      arg0 holds the bitwise flags used to distinguish different checkpoint
      types, such as shutdown, immediate or force.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>checkpoint-start</literal></entry>
     <entry><literal>(int)</literal></entry>
     <entry>当一个检查点被开始时触发的探针。arg0 传递位标志来区分不同的检查点类型，例如关闭（shutdown）、立即（immediate）或强制（force）。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>checkpoint-done</literal></entry>
     <entry><literal>(int, int, int, int, int)</literal></entry>
     <entry>Probe that fires when a checkpoint is complete.
      (The probes listed next fire in sequence during checkpoint processing.)
      arg0 is the number of buffers written. arg1 is the total number of
      buffers. arg2, arg3 and arg4 contain the number of WAL files added,
      removed and recycled respectively.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>checkpoint-done</literal></entry>
     <entry><literal>(int, int, int, int, int)</literal></entry>
     <entry>当一个检查点完成时触发的探针（检查点处理过程中序列中列出的下一个触发的探针）。arg0 是要写的缓冲区数量。arg1 是缓冲区的总数。arg2、arg3 和 arg4 分别包含了增加、删除和循环回收的 WAL 文件的数量。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>clog-checkpoint-start</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>Probe that fires when the CLOG portion of a checkpoint is started.
      arg0 is true for normal checkpoint, false for shutdown
      checkpoint.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>clog-checkpoint-start</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>当一个检查点的 CLOG 部分被开始时触发的探针。arg0 为真表示正常检查点，为假表示关闭检查点。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>clog-checkpoint-done</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>Probe that fires when the CLOG portion of a checkpoint is
      complete. arg0 has the same meaning as for <literal>clog-checkpoint-start</literal>.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>clog-checkpoint-done</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>当一个检查点的 CLOG 部分完成时触发的探针。arg0 的含义与<literal>clog-checkpoint-start</literal>中相同。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>subtrans-checkpoint-start</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>Probe that fires when the SUBTRANS portion of a checkpoint is
      started.
      arg0 is true for normal checkpoint, false for shutdown
      checkpoint.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>subtrans-checkpoint-start</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>当一个检查点的 SUBTRANS 部分被开始时触发的探针。arg0 为真表示正常检查点，为假表示关闭检查点。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>subtrans-checkpoint-done</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>Probe that fires when the SUBTRANS portion of a checkpoint is
      complete. arg0 has the same meaning as for
      <literal>subtrans-checkpoint-start</literal>.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>subtrans-checkpoint-done</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>当一个检查点的 SUBTRANS 部分完成时触发的探针。arg0 的含义与<literal>subtrans-checkpoint-start</literal>中相同。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>multixact-checkpoint-start</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>Probe that fires when the MultiXact portion of a checkpoint is
      started.
      arg0 is true for normal checkpoint, false for shutdown
      checkpoint.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>multixact-checkpoint-start</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>当一个检查点的 MultiXact 部分被开始时触发的探针。arg0 为真表示正常检查点，为假表示关闭检查点。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>multixact-checkpoint-done</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>Probe that fires when the MultiXact portion of a checkpoint is
      complete. arg0 has the same meaning as for
      <literal>multixact-checkpoint-start</literal>.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>multixact-checkpoint-done</literal></entry>
     <entry><literal>(bool)</literal></entry>
     <entry>当一个检查点的 MultiXact 部分完成时触发的探针。arg0 的含义与<literal>multixact-checkpoint-start</literal>中相同。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>buffer-checkpoint-start</literal></entry>
     <entry><literal>(int)</literal></entry>
     <entry>Probe that fires when the buffer-writing portion of a checkpoint
      is started.
      arg0 holds the bitwise flags used to distinguish different checkpoint
      types, such as shutdown, immediate or force.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>buffer-checkpoint-start</literal></entry>
     <entry><literal>(int)</literal></entry>
     <entry>当一个检查点的写缓冲区部分被开始时触发的探针。arg0 传递位标志来区分不同的检查点类型，例如关闭（shutdown）、立即（immediate）或强制（force）。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>buffer-sync-start</literal></entry>
     <entry><literal>(int, int)</literal></entry>
     <entry>Probe that fires when we begin to write dirty buffers during
      checkpoint (after identifying which buffers must be written).
      arg0 is the total number of buffers.
      arg1 is the number that are currently dirty and need to be written.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>buffer-sync-start</literal></entry>
     <entry><literal>(int, int)</literal></entry>
     <entry>当我们在检查点期间开始写脏缓冲区时（在标识哪些缓冲区必须被写之后）触发的探针。arg0 是缓冲区总数，arg1 是当前为脏并且需要被写的缓冲区数量。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>buffer-sync-written</literal></entry>
     <entry><literal>(int)</literal></entry>
     <entry>Probe that fires after each buffer is written during checkpoint.
      arg0 is the ID number of the buffer.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>buffer-sync-written</literal></entry>
     <entry><literal>(int)</literal></entry>
     <entry>在检查点期间当每个缓冲区被写完之后触发的探针。arg0 是缓冲区的 ID。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>buffer-sync-done</literal></entry>
     <entry><literal>(int, int, int)</literal></entry>
     <entry>Probe that fires when all dirty buffers have been written.
      arg0 is the total number of buffers.
      arg1 is the number of buffers actually written by the checkpoint process.
      arg2 is the number that were expected to be written (arg1 of
      <literal>buffer-sync-start</literal>); any difference reflects other processes flushing
      buffers during the checkpoint.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>buffer-sync-done</literal></entry>
     <entry><literal>(int, int, int)</literal></entry>
     <entry>当所有脏缓冲区被写之后触发的探针。arg0 是缓冲区总数。arg1 是检查点进程实际写的缓冲区数量。arg2 是期望写的数目（<literal>buffer-sync-start</literal>的 arg1）；arg1 和 arg2 的任何的不同反映在该检查点期间有其他进程刷写了缓冲区。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>buffer-checkpoint-sync-start</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires after dirty buffers have been written to the
      kernel, and before starting to issue fsync requests.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>buffer-checkpoint-sync-start</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>在脏缓冲区被写入到内核之后并且在开始发出 fsync 请求之前触发的探针。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>buffer-checkpoint-done</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when syncing of buffers to disk is
      complete.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>buffer-checkpoint-done</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>当同步缓冲区到磁盘完成时触发的探针。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>twophase-checkpoint-start</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when the two-phase portion of a checkpoint is
      started.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>twophase-checkpoint-start</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>当一个检查点的两阶段部分被开始时触发的探针。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>twophase-checkpoint-done</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when the two-phase portion of a checkpoint is
      complete.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>twophase-checkpoint-done</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>当一个检查点的两阶段部分完成时触发的探针。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>buffer-read-start</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool)</literal></entry>
     <entry>Probe that fires when a buffer read is started.
      arg0 and arg1 contain the fork and block numbers of the page (but
      arg1 will be -1 if this is a relation extension request).
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the ID of the backend which created the temporary relation for a
      local buffer, or <symbol>InvalidBackendId</symbol> (-1) for a shared buffer.
      arg6 is true for a relation extension request, false for normal
      read.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>buffer-read-start</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool)</literal></entry>
     <entry>当一次缓冲区读被开始时触发的探针。arg0 和 arg1 包含该页的分叉号和块号（如果这是一次关系扩展请求，arg1 为 -1）。arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。对一个本地缓冲区，arg5 是创建临时关系的后端的 ID；对于一个共享缓冲区，arg5 是 <symbol>InvalidBackendId</symbol>（-1）。arg6 为真表示一次关系扩展请求，为假表示正常读。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>buffer-read-done</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool, bool)</literal></entry>
     <entry>Probe that fires when a buffer read is complete.
      arg0 and arg1 contain the fork and block numbers of the page (if this
      is a relation extension request, arg1 now contains the block number
      of the newly added block).
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the ID of the backend which created the temporary relation for a
      local buffer, or <symbol>InvalidBackendId</symbol> (-1) for a shared buffer.
      arg6 is true for a relation extension request, false for normal
      read.
      arg7 is true if the buffer was found in the pool, false if not.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>buffer-read-done</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool, bool)</literal></entry>
     <entry>当一次缓冲区读完成时触发的探针。arg0 和 arg1 包含该页的分叉号和块号（如果这是一次关系扩展请求，arg1 现在包含新增加块的块号）。arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。对一个本地缓冲区，arg5 是创建临时关系的后端的 ID；对于一个共享缓冲区，arg5 是 <symbol>InvalidBackendId</symbol>（-1）。arg6 为真表示一次关系扩展请求，为假表示正常读。arg7 为真表示在池中找到该缓冲区，为假表示没有找到。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>buffer-flush-start</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
     <entry>Probe that fires before issuing any write request for a shared
      buffer.
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>buffer-flush-start</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
     <entry>在发出对一个共享缓冲区的任意写请求之前触发的探针。arg0 和 arg1 包含该页的分叉号和块号。arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>buffer-flush-done</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
     <entry>Probe that fires when a write request is complete.  (Note
      that this just reflects the time to pass the data to the kernel;
      it's typically not actually been written to disk yet.)
      The arguments are the same as for <literal>buffer-flush-start</literal>.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>buffer-flush-done</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
     <entry>当一个写请求完成时触发的探针（注意这只反映传递数据给内核的时间，它通常并没有实际地被写入到磁盘）。参数和<literal>buffer-flush-start</literal>的相同。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>buffer-write-dirty-start</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
     <entry>Probe that fires when a server process begins to write a dirty
      buffer.  (If this happens often, it implies that
      <xref linkend="guc-shared-buffers"/> is too
      small or the background writer control parameters need adjustment.)
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>buffer-write-dirty-start</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
     <entry>当一个服务器进程开始写一个脏缓冲区时触发的探针（如果这经常发生，表示<xref linkend="guc-shared-buffers"/>太小，或需要调整后台写入器的控制参数）。arg0 和 arg1 包含该页的分叉号和块号。arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>buffer-write-dirty-done</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
     <entry>Probe that fires when a dirty-buffer write is complete.
      The arguments are the same as for <literal>buffer-write-dirty-start</literal>.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>buffer-write-dirty-done</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid)</literal></entry>
     <entry>当一次脏缓冲区写完成时触发的探针。参数与<literal>buffer-write-dirty-start</literal>相同。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>wal-buffer-write-dirty-start</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when a server process begins to write a
      dirty WAL buffer because no more WAL buffer space is available.
      (If this happens often, it implies that
      <xref linkend="guc-wal-buffers"/> is too small.)</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>wal-buffer-write-dirty-start</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>当一个服务器进程因为没有可用 WAL 缓冲区空间开始写一个脏 WAL 缓冲区时触发的探针（如果这经常发生，表示<xref linkend="guc-wal-buffers"/>太小）。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>wal-buffer-write-dirty-done</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when a dirty WAL buffer write is complete.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>wal-buffer-write-dirty-done</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>当一次脏 WAL 缓冲区完成时触发的探针。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>wal-insert</literal></entry>
     <entry><literal>(unsigned char, unsigned char)</literal></entry>
     <entry>Probe that fires when a WAL record is inserted.
      arg0 is the resource manager (rmid) for the record.
      arg1 contains the info flags.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>wal-insert</literal></entry>
     <entry><literal>(unsigned char, unsigned char)</literal></entry>
     <entry>当一个 WAL 记录被插入时触发的探针。arg0 是该记录的资源管理者（rmid）。arg1 包含 info 标志。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>wal-switch</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when a WAL segment switch is requested.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>wal-switch</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>当请求一次 WAL 段切换时触发的探针。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>smgr-md-read-start</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int)</literal></entry>
     <entry>Probe that fires when beginning to read a block from a relation.
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the ID of the backend which created the temporary relation for a
      local buffer, or <symbol>InvalidBackendId</symbol> (-1) for a shared buffer.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>smgr-md-read-start</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int)</literal></entry>
     <entry>当开始从一个关系读取一块时触发的探针。arg0 和 arg1 包含该页的分叉号和块号。arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。对一个本地缓冲区，arg5 是创建临时关系的后端的 ID；对于一个共享缓冲区，arg5 是<symbol>InvalidBackendId</symbol>（-1）。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>smgr-md-read-done</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int)</literal></entry>
     <entry>Probe that fires when a block read is complete.
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the ID of the backend which created the temporary relation for a
      local buffer, or <symbol>InvalidBackendId</symbol> (-1) for a shared buffer.
      arg6 is the number of bytes actually read, while arg7 is the number
      requested (if these are different it indicates trouble).</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>smgr-md-read-done</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int)</literal></entry>
     <entry>当一次块读取完成时触发的探针。arg0 和 arg1 包含该页的分叉号和块号。arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。对一个本地缓冲区，arg5 是创建临时关系的后端的 ID；对于一个共享缓冲区，arg5 是<symbol>InvalidBackendId</symbol>（-1）。arg6 是实际读取的字节数，而 arg7 是请求读取的字节数（如果两者不同就意味着麻烦）。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>smgr-md-write-start</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int)</literal></entry>
     <entry>Probe that fires when beginning to write a block to a relation.
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the ID of the backend which created the temporary relation for a
      local buffer, or <symbol>InvalidBackendId</symbol> (-1) for a shared buffer.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>smgr-md-write-start</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int)</literal></entry>
     <entry>当开始向一个关系中写入一个块时触发的探针。arg0 和 arg1 包含该页的分叉号和块号。arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。对一个本地缓冲区，arg5 是创建临时关系的后端的 ID；对于一个共享缓冲区，arg5 是<symbol>InvalidBackendId</symbol>（-1）。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>smgr-md-write-done</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int)</literal></entry>
     <entry>Probe that fires when a block write is complete.
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the ID of the backend which created the temporary relation for a
      local buffer, or <symbol>InvalidBackendId</symbol> (-1) for a shared buffer.
      arg6 is the number of bytes actually written, while arg7 is the number
      requested (if these are different it indicates trouble).</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>smgr-md-write-done</literal></entry>
     <entry><literal>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int)</literal></entry>
     <entry>当一个块写操作完成时触发的探针。arg0 和 arg1 包含该页的分叉号和块号。arg2、arg3和arg4 包含表空间、数据库和关系 OID来标识该关系。对于一个本地缓冲区，arg5 是创建临时关系的后端 ID；对于一个共享缓冲区，arg5 是<symbol>InvalidBackendId</symbol>（-1）。arg6 是实际写的字节数，而 arg7 是要求写的字节数（如果这两者不同，则意味着麻烦）。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>sort-start</literal></entry>
     <entry><literal>(int, bool, int, int, bool, int)</literal></entry>
     <entry>Probe that fires when a sort operation is started.
      arg0 indicates heap, index or datum sort.
      arg1 is true for unique-value enforcement.
      arg2 is the number of key columns.
      arg3 is the number of kilobytes of work memory allowed.
      arg4 is true if random access to the sort result is required.
      arg5 indicates serial when <literal>0</literal>, parallel worker when
      <literal>1</literal>, or parallel leader when <literal>2</literal>.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>sort-start</literal></entry>
     <entry><literal>(int, bool, int, int, bool, int)</literal></entry>
     <entry>当一次排序操作开始时触发的探针。arg0 指示是堆排序、索引排序或数据排序。arg1 为真表示唯一值强制。arg2 是键列的数目。arg3 是允许使用的工作内存数（以千字节计）。如果要求随机访问排序结果，那么 arg4 为真。arg5为<literal>0</literal>时表示串行，为<literal>1</literal>时表示并行工作者，为<literal>2</literal>时表示并行领袖。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>sort-done</literal></entry>
     <entry><literal>(bool, long)</literal></entry>
     <entry>Probe that fires when a sort is complete.
      arg0 is true for external sort, false for internal sort.
      arg1 is the number of disk blocks used for an external sort,
      or kilobytes of memory used for an internal sort.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>sort-done</literal></entry>
     <entry><literal>(bool, long)</literal></entry>
     <entry>当一次排序完成时触发的探针。arg0 为真表示外排序，为假表示内排序。arg1 是用于一次外排序的磁盘块的数目，或用于一次内排序的以千字节计的内存。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>lwlock-acquire</literal></entry>
     <entry><literal>(char *, LWLockMode)</literal></entry>
     <entry>Probe that fires when an LWLock has been acquired.
      arg0 is the LWLock's tranche.
      arg1 is the requested lock mode, either exclusive or shared.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>lwlock-acquire</literal></entry>
     <entry><literal>(char *, LWLockMode)</literal></entry>
     <entry>当成功获得一个 LWLock 时触发的探针。
      arg0 是该 LWLock 所在的切片（Tranche）。
      arg1 所请求的锁模式，是排他或共享。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>lwlock-release</literal></entry>
     <entry><literal>(char *)</literal></entry>
     <entry>Probe that fires when an LWLock has been released (but note
      that any released waiters have not yet been awakened).
      arg0 is the LWLock's tranche.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>lwlock-release</literal></entry>
     <entry><literal>(char *)</literal></entry>
     <entry>当一个 LWLock 被释放时（但是注意还没有唤醒任何一个被释放的等待者）触发的探针。
     arg0 是该 LWLock 所在的切片（Tranche）。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>lwlock-wait-start</literal></entry>
     <entry><literal>(char *, LWLockMode)</literal></entry>
     <entry>Probe that fires when an LWLock was not immediately available and
      a server process has begun to wait for the lock to become available.
      arg0 is the LWLock's tranche.
      arg1 is the requested lock mode, either exclusive or shared.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>lwlock-wait-start</literal></entry>
     <entry><literal>(char *, LWLockMode)</literal></entry>
     <entry>当一个 LWLock不是当即可用并且一个服务器进程因此开始等待该锁变为可用时触发的探针。
     arg0 是该 LWLock 所在的切片（Tranche）。
      arg1 请求的锁模式，是排他或共享。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>lwlock-wait-done</literal></entry>
     <entry><literal>(char *, LWLockMode)</literal></entry>
     <entry>Probe that fires when a server process has been released from its
      wait for an LWLock (it does not actually have the lock yet).
      arg0 is the LWLock's tranche.
      arg1 is the requested lock mode, either exclusive or shared.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>lwlock-wait-done</literal></entry>
     <entry><literal>(char *, LWLockMode)</literal></entry>
     <entry>当一个进程从对一个 LWLock 的等待中被释放时（它实际还没有得到该锁）时触发的探针。arg0 是该 LWLock 所在的切片（Tranche）。
      arg1 所请求的锁模式，是排他或共享。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>lwlock-condacquire</literal></entry>
     <entry><literal>(char *, LWLockMode)</literal></entry>
     <entry>Probe that fires when an LWLock was successfully acquired when the
      caller specified no waiting.
      arg0 is the LWLock's tranche.
      arg1 is the requested lock mode, either exclusive or shared.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>lwlock-condacquire</literal></entry>
     <entry><literal>(char *, LWLockMode)</literal></entry>
     <entry>当调用者指定无需等待而成功获得一个 LWLock 时触发的探针。arg0 是该 LWLock 所在的切片（Tranche）。
      arg1 所请求的锁模式，是排他或共享。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>lwlock-condacquire-fail</literal></entry>
     <entry><literal>(char *, LWLockMode)</literal></entry>
     <entry>Probe that fires when an LWLock was not successfully acquired when
      the caller specified no waiting.
      arg0 is the LWLock's tranche.
      arg1 is the requested lock mode, either exclusive or shared.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>lwlock-condacquire-fail</literal></entry>
     <entry><literal>(char *, LWLockMode)</literal></entry>
     <entry>当调用者指定无需等待而没有成功获得一个 LWLock 时触发的探针。arg0 是该 LWLock 所在的切片（Tranche）。
      arg1 所请求的锁模式，是排他或共享。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>lock-wait-start</literal></entry>
     <entry><literal>(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, LOCKMODE)</literal></entry>
     <entry>Probe that fires when a request for a heavyweight lock (lmgr lock)
      has begun to wait because the lock is not available.
      arg0 through arg3 are the tag fields identifying the object being
      locked.  arg4 indicates the type of object being locked.
      arg5 indicates the lock type being requested.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>lock-wait-start</literal></entry>
     <entry><literal>(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, LOCKMODE)</literal></entry>
     <entry>当一个重量级锁（lmgr锁）的请求由于锁不可用开始等待时触发的探针。arg0 到 arg3 是标识被锁定对象的标签域。arg4 指示被锁对象的类型。arg5 表示被请求的锁类型。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>lock-wait-done</literal></entry>
     <entry><literal>(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, LOCKMODE)</literal></entry>
     <entry>Probe that fires when a request for a heavyweight lock (lmgr lock)
      has finished waiting (i.e., has acquired the lock).
      The arguments are the same as for <literal>lock-wait-start</literal>.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>lock-wait-done</literal></entry>
     <entry><literal>(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, LOCKMODE)</literal></entry>
     <entry>当一个重量级锁（lmgr 锁）的请求结束等待时（即已经得到锁）触发的探针。参数与<literal>lock-wait-start</literal>一样。</entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><literal>deadlock-found</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>Probe that fires when a deadlock is found by the deadlock
      detector.</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><literal>deadlock-found</literal></entry>
     <entry><literal>()</literal></entry>
     <entry>当死锁检测器发现死锁时触发的探针。</entry>
    </row>

   </tbody>
   </tgroup>
  </table>

 <table id="typedefs-table">
<!--==========================orignal english content==========================
  <title>Defined Types Used in Probe Parameters</title>
____________________________________________________________________________-->
  <title>定义用在探针参数中的类型</title>
  <tgroup cols="2">
   <thead>
<!--==========================orignal english content==========================
    <row>
     <entry>Type</entry>
     <entry>Definition</entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry>类型</entry>
     <entry>定义</entry>
    </row>
   </thead>

   <tbody>

<!--==========================orignal english content==========================
    <row>
     <entry><type>LocalTransactionId</type></entry>
     <entry><type>unsigned int</type></entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><type>LocalTransactionId</type></entry>
     <entry><type>unsigned int</type></entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><type>LWLockMode</type></entry>
     <entry><type>int</type></entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><type>LWLockMode</type></entry>
     <entry><type>int</type></entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><type>LOCKMODE</type></entry>
     <entry><type>int</type></entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><type>LOCKMODE</type></entry>
     <entry><type>int</type></entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><type>BlockNumber</type></entry>
     <entry><type>unsigned int</type></entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><type>BlockNumber</type></entry>
     <entry><type>unsigned int</type></entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><type>Oid</type></entry>
     <entry><type>unsigned int</type></entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><type>Oid</type></entry>
     <entry><type>unsigned int</type></entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><type>ForkNumber</type></entry>
     <entry><type>int</type></entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><type>ForkNumber</type></entry>
     <entry><type>int</type></entry>
    </row>
<!--==========================orignal english content==========================
    <row>
     <entry><type>bool</type></entry>
     <entry><type>unsigned char</type></entry>
    </row>
____________________________________________________________________________-->
    <row>
     <entry><type>bool</type></entry>
     <entry><type>unsigned char</type></entry>
    </row>

   </tbody>
   </tgroup>
  </table>


  </sect2>

  <sect2 id="using-trace-points">
<!--==========================orignal english content==========================
   <title>Using Probes</title>
____________________________________________________________________________-->
   <title>使用探针</title>

<!--==========================orignal english content==========================
  <para>
   The example below shows a DTrace script for analyzing transaction
   counts in the system, as an alternative to snapshotting
   <structname>pg_stat_database</structname> before and after a performance test:
<programlisting>
#!/usr/sbin/dtrace -qs

postgresql$1:::transaction-start
{
      @start["Start"] = count();
      self->ts  = timestamp;
}

postgresql$1:::transaction-abort
{
      @abort["Abort"] = count();
}

postgresql$1:::transaction-commit
/self->ts/
{
      @commit["Commit"] = count();
      @time["Total time (ns)"] = sum(timestamp - self->ts);
      self->ts=0;
}
</programlisting>
   When executed, the example D script gives output such as:
<screen>
# ./txn_count.d `pgrep -n postgres` or ./txn_count.d &lt;PID&gt;
^C

Start                                          71
Commit                                         70
Total time (ns)                        2312105013
</screen>
  </para>
____________________________________________________________________________-->
  <para>
   下面的例子展示了一个分析系统中事务计数的 DTrace 脚本，可以用来代替一次性能测试之前和之后的<structname>pg_stat_database</structname>快照：
<programlisting>
#!/usr/sbin/dtrace -qs

postgresql$1:::transaction-start
{
      @start["Start"] = count();
      self->ts  = timestamp;
}

postgresql$1:::transaction-abort
{
      @abort["Abort"] = count();
}

postgresql$1:::transaction-commit
/self->ts/
{
      @commit["Commit"] = count();
      @time["Total time (ns)"] = sum(timestamp - self->ts);
      self->ts=0;
}
</programlisting>
   当被执行时，该例子 D 脚本给出这样的输出：
<screen>
# ./txn_count.d `pgrep -n postgres` or ./txn_count.d &lt;PID&gt;
^C

Start                                          71
Commit                                         70
Total time (ns)                        2312105013
</screen>
  </para>

  <note>
<!--==========================orignal english content==========================
   <para>
    SystemTap uses a different notation for trace scripts than DTrace does,
    even though the underlying trace points are compatible.  One point worth
    noting is that at this writing, SystemTap scripts must reference probe
    names using double underscores in place of hyphens.  This is expected to
    be fixed in future SystemTap releases.
   </para>
____________________________________________________________________________-->
   <para>
    SystemTap 为追踪脚本使用一个不同于 DTrace 的标记，但是底层的探针是兼容的。值得注意的是，在这样写的时候，SystemTap 脚本必须使用双下划线代替连字符来引用探针名。在未来的 SystemTap 发行中这很可能会被修复。
   </para>
  </note>

<!--==========================orignal english content==========================
  <para>
   You should remember that DTrace scripts need to be carefully written and
   debugged, otherwise the trace information collected might
   be meaningless. In most cases where problems are found it is the
   instrumentation that is at fault, not the underlying system. When
   discussing information found using dynamic tracing, be sure to enclose
   the script used to allow that too to be checked and discussed.
  </para>
____________________________________________________________________________-->
  <para>
   你应该记住，DTrace 脚本需要细心地编写和调试，否则被收集的追踪信息可能会毫无意义。在大部分发现问题的情况中，它就是发生问题的部件，而不是底层系统。当讨论使用动态追踪发现的信息时，一定要附上使用的脚本以便其也被检查和讨论。
  </para>
  </sect2>

  <sect2 id="defining-trace-points">
<!--==========================orignal english content==========================
   <title>Defining New Probes</title>
____________________________________________________________________________-->
   <title>定义新探针</title>

<!--==========================orignal english content==========================
  <para>
   New probes can be defined within the code wherever the developer
   desires, though this will require a recompilation. Below are the steps
   for inserting new probes:
  </para>
____________________________________________________________________________-->
  <para>
   开发者可以在代码中任意位置定义新的探针，当然这要重新编译之后才能生效。下面是插入新探针的步骤：
  </para>

  <procedure>
   <step>
<!--==========================orignal english content==========================
    <para>
     Decide on probe names and data to be made available through the probes
    </para>
____________________________________________________________________________-->
    <para>
     决定探针名称以及探针可用的数据
    </para>
   </step>

   <step>
<!--==========================orignal english content==========================
    <para>
     Add the probe definitions to <filename>src/backend/utils/probes.d</filename>
    </para>
____________________________________________________________________________-->
    <para>
     把该探针定义加入到<filename>src/backend/utils/probes.d</filename>
    </para>
   </step>

   <step>
<!--==========================orignal english content==========================
    <para>
     Include <filename>pg_trace.h</filename> if it is not already present in the
     module(s) containing the probe points, and insert
     <literal>TRACE_POSTGRESQL</literal> probe macros at the desired locations
     in the source code
    </para>
____________________________________________________________________________-->
    <para>
     如果<filename>pg_trace.h</filename>还不存在于包含该探针点的模块中，包括它，并且在源代码中期望的位置插入<literal>TRACE_POSTGRESQL</literal>探针宏
    </para>
   </step>

   <step>
<!--==========================orignal english content==========================
    <para>
     Recompile and verify that the new probes are available
    </para>
____________________________________________________________________________-->
    <para>
     重新编译并验证新探针是可用的
    </para>
   </step>
  </procedure>

  <formalpara>
<!--==========================orignal english content==========================
   <title>Example:</title>
____________________________________________________________________________-->
   <title>例子：</title>
<!--==========================orignal english content==========================
   <para>
    Here is an example of how you would add a probe to trace all new
    transactions by transaction ID.
   </para>
____________________________________________________________________________-->
   <para>
    这里是一个如何增加一个探针来用事务 ID 追踪所有新事务的例子。
   </para>
  </formalpara>

  <procedure>
   <step>
<!--==========================orignal english content==========================
    <para>
     Decide that the probe will be named <literal>transaction-start</literal> and
     requires a parameter of type <type>LocalTransactionId</type>
    </para>
____________________________________________________________________________-->
    <para>
     决定探针将被命名为<literal>transaction-start</literal>并且需要一个<type>LocalTransactionId</type>类型的参数
    </para>
   </step>

   <step>
<!--==========================orignal english content==========================
    <para>
     Add the probe definition to <filename>src/backend/utils/probes.d</filename>:
<programlisting>
probe transaction__start(LocalTransactionId);
</programlisting>
     Note the use of the double underline in the probe name. In a DTrace
     script using the probe, the double underline needs to be replaced with a
     hyphen, so <literal>transaction-start</literal> is the name to document for
     users.
    </para>
____________________________________________________________________________-->
    <para>
     将该探针定义加入到<filename>src/backend/utils/probes.d</filename>：
<programlisting>
probe transaction__start(LocalTransactionId);
</programlisting>
     注意探针名字中双下划线的使用。在一个使用探针的 DTrace 脚本中，双下划线需要被替换为一个连字符，因此 ，对用户而言<literal>transaction-start</literal>是文档名。
    </para>
   </step>

   <step>
<!--==========================orignal english content==========================
    <para>
     At compile time, <literal>transaction__start</literal> is converted to a macro
     called <literal>TRACE_POSTGRESQL_TRANSACTION_START</literal> (notice the
     underscores are single here), which is available by including
     <filename>pg_trace.h</filename>.  Add the macro call to the appropriate location
     in the source code.  In this case, it looks like the following:

<programlisting>
TRACE_POSTGRESQL_TRANSACTION_START(vxid.localTransactionId);
</programlisting>
    </para>
____________________________________________________________________________-->
    <para>
     在编译时，<literal>transaction__start</literal>被转换成一个宏调用<literal>TRACE_POSTGRESQL_TRANSACTION_START</literal>（注意这里是单下划线），可以通过包括头文件<filename>pg_trace.h</filename>获得。将宏调用加入到源代码中的合适位置。在这种情况下，看起来类似：

<programlisting>
TRACE_POSTGRESQL_TRANSACTION_START(vxid.localTransactionId);
</programlisting>
    </para>
   </step>

   <step>
<!--==========================orignal english content==========================
    <para>
     After recompiling and running the new binary, check that your newly added
     probe is available by executing the following DTrace command.  You
     should see similar output:
<screen>
# dtrace -ln transaction-start
   ID    PROVIDER          MODULE           FUNCTION NAME
18705 postgresql49878     postgres     StartTransactionCommand transaction-start
18755 postgresql49877     postgres     StartTransactionCommand transaction-start
18805 postgresql49876     postgres     StartTransactionCommand transaction-start
18855 postgresql49875     postgres     StartTransactionCommand transaction-start
18986 postgresql49873     postgres     StartTransactionCommand transaction-start
</screen>
    </para>
____________________________________________________________________________-->
    <para>
     在重新编译和运行新的二进制文件之后，通过运行下面的 DTrace 命令来检查新增的探针是否可用。你应该看到类似下面的输出：
<screen>
# dtrace -ln transaction-start
   ID    PROVIDER          MODULE           FUNCTION NAME
18705 postgresql49878     postgres     StartTransactionCommand transaction-start
18755 postgresql49877     postgres     StartTransactionCommand transaction-start
18805 postgresql49876     postgres     StartTransactionCommand transaction-start
18855 postgresql49875     postgres     StartTransactionCommand transaction-start
18986 postgresql49873     postgres     StartTransactionCommand transaction-start
</screen>
    </para>
   </step>
  </procedure>

<!--==========================orignal english content==========================
  <para>
   There are a few things to be careful about when adding trace macros
   to the C code:

   <itemizedlist>
    <listitem>
     <para>
      You should take care that the data types specified for a probe's
      parameters match the data types of the variables used in the macro.
      Otherwise, you will get compilation errors.
     </para>
    </listitem>


    <listitem>
     <para>
      On most platforms, if <productname>PostgreSQL</productname> is
      built with <option>-&minus;enable-dtrace</option>, the arguments to a trace
      macro will be evaluated whenever control passes through the
      macro, <emphasis>even if no tracing is being done</emphasis>.  This is
      usually not worth worrying about if you are just reporting the
      values of a few local variables.  But beware of putting expensive
      function calls into the arguments.  If you need to do that,
      consider protecting the macro with a check to see if the trace
      is actually enabled:

<programlisting>
if (TRACE_POSTGRESQL_TRANSACTION_START_ENABLED())
    TRACE_POSTGRESQL_TRANSACTION_START(some_function(...));
</programlisting>

      Each trace macro has a corresponding <literal>ENABLED</literal> macro.
     </para>
    </listitem>
   </itemizedlist>

  </para>
____________________________________________________________________________-->
  <para>
   向C代码中添加追踪宏时，有一些事情需要注意：

   <itemizedlist>
    <listitem>
     <para>
      需要小心的是，为探针参数指定的数据类型要匹配宏中使用的变量的数据类型，否则会发生编译错误。
     </para>
    </listitem>


    <listitem>
     <para>
      在大多数平台上，如果用<option>--enable-dtrace</option>编译了<productname>PostgreSQL</productname>，无论何时当控制经过一个追踪宏时，都会评估该宏的参数，<emphasis>即使没有进行追踪也会这样做</emphasis>。通常不需要担心你是否只在报告一些局部变量的值。但是要注意不要将开销大的函数调用放入参数中。如果你需要这样做，考虑通过检查追踪是否真的被启用来保护该宏：

<programlisting>
if (TRACE_POSTGRESQL_TRANSACTION_START_ENABLED())
    TRACE_POSTGRESQL_TRANSACTION_START(some_function(...));
</programlisting>

      每个追踪宏有一个对应的<literal>ENABLED</literal>宏。
     </para>
    </listitem>
   </itemizedlist>

  </para>

  </sect2>

 </sect1>

</chapter>
