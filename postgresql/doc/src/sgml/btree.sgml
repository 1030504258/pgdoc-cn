<!-- doc/src/sgml/btree.sgml -->

<chapter id="btree">
<!--==========================orignal english content==========================
<title>B-Tree Indexes</title>
____________________________________________________________________________-->
<title>B-树索引</title>

<!--==========================orignal english content==========================
   <indexterm>
    <primary>index</primary>
    <secondary>B-Tree</secondary>
   </indexterm>
____________________________________________________________________________-->
   <indexterm>
    <primary>index</primary>
    <secondary>B-Tree</secondary>
   </indexterm>

<sect1 id="btree-intro">
<!--==========================orignal english content==========================
 <title>Introduction</title>
____________________________________________________________________________-->
 <title>简介</title>

<!--==========================orignal english content==========================
 <para>
  <productname>PostgreSQL</productname> includes an implementation of the
  standard <acronym>btree</acronym> (multi-way balanced tree) index data
  structure.  Any data type that can be sorted into a well-defined linear
  order can be indexed by a btree index.  The only limitation is that an
  index entry cannot exceed approximately one-third of a page (after TOAST
  compression, if applicable).
 </para>
____________________________________________________________________________-->
 <para>
  <productname>PostgreSQL</productname>包括了对标准<acronym>btree</acronym>（多路平衡树）索引数据结构的一个实现。任何能够被排序为良定义线性顺序的数据结构都可以用一个btree来索引。唯一的限制是一个索引项不能超过大约三分之一个页面（如果适用，可以是TOAST压缩后的大小）。
 </para>

<!--==========================orignal english content==========================
 <para>
  Because each btree operator class imposes a sort order on its data type,
  btree operator classes (or, really, operator families) have come to be
  used as <productname>PostgreSQL</productname>'s general representation
  and understanding of sorting semantics.  Therefore, they've acquired
  some features that go beyond what would be needed just to support btree
  indexes, and parts of the system that are quite distant from the
  btree AM make use of them.
 </para>
____________________________________________________________________________-->
 <para>
  因为每一种btree操作符类都会在其数据类型上施加一种排序顺序，btree的操作符类（或者实际上是操作符族）已经被用作<productname>PostgreSQL</productname>对排序语义的一般表达和理解。因此，它们需要一些支持btree索引之外的特性，并且这个系统的一些部分与利用它们的btree访问方法有较大的不同。
 </para>

</sect1>

<sect1 id="btree-behavior">
<!--==========================orignal english content==========================
 <title>Behavior of B-Tree Operator Classes</title>
____________________________________________________________________________-->
 <title>B-树操作符类的行为</title>

<!--==========================orignal english content==========================
 <para>
  As shown in <xref linkend="xindex-btree-strat-table"/>, a btree operator
  class must provide five comparison operators,
  <literal>&lt;</literal>,
  <literal>&lt;=</literal>,
  <literal>=</literal>,
  <literal>&gt;=</literal> and
  <literal>&gt;</literal>.
  One might expect that <literal>&lt;&gt;</literal> should also be part of
  the operator class, but it is not, because it would almost never be
  useful to use a <literal>&lt;&gt;</literal> WHERE clause in an index
  search.  (For some purposes, the planner treats <literal>&lt;&gt;</literal>
  as associated with a btree operator class; but it finds that operator via
  the <literal>=</literal> operator's negator link, rather than
  from <structname>pg_amop</structname>.)
 </para>
____________________________________________________________________________-->
 <para>
  如<xref linkend="xindex-btree-strat-table"/>中所示，一个btree操作符类必须提供五种比较操作符：<literal>&lt;</literal>、<literal>&lt;=</literal>、<literal>=</literal>、<literal>&gt;=</literal>以及<literal>&gt;</literal>。有人可能会想<literal>&lt;&gt;</literal>应该也是操作符类的一部分，但不是这样，因为几乎从不会在索引搜索中使用有<literal>&lt;&gt;</literal>的WHERE子句（出于某种原因，规划器会认为<literal>&lt;&gt;</literal>与一个btree操作符类相关，但它是通过<literal>=</literal>操作符的逆操作符链接来找到这个操作符，而不是从<structname>pg_amop</structname>中查找）。
 </para>

<!--==========================orignal english content==========================
 <para>
  When several data types share near-identical sorting semantics, their
  operator classes can be grouped into an operator family.  Doing so is
  advantageous because it allows the planner to make deductions about
  cross-type comparisons.  Each operator class within the family should
  contain the single-type operators (and associated support functions)
  for its input data type, while cross-type comparison operators and
  support functions are <quote>loose</quote> in the family.  It is
  recommendable that a complete set of cross-type operators be included
  in the family, thus ensuring that the planner can represent any
  comparison conditions that it deduces from transitivity.
 </para>
____________________________________________________________________________-->
 <para>
  当一些数据类型共享近乎相同的排序语义时，它们的操作符类可以被组合成一个操作符族。这样做是有好处的，因为这样就允许规划器对跨类型比较进行推演。在操作符族中的每一种操作符类对其输入数据类型应该包含单一类型的操作符（及其相关的支持函数），而跨类型比较操作符及其支持函数则<quote>松散</quote>地放在操作符族中。推荐在操作符族中包括一套完整的跨类型操作符，这样能确保规划器可以表达它通过传递性推演出的任何比较条件。
 </para>

<!--==========================orignal english content==========================
 <para>
  There are some basic assumptions that a btree operator family must
  satisfy:
 </para>
____________________________________________________________________________-->
 <para>
  这里有一些btree操作符类必须满足的基本假设：
 </para>

 <itemizedlist>
  <listitem>
<!--==========================orignal english content==========================
   <para>
    An <literal>=</literal> operator must be an equivalence relation; that
    is, for all non-null values <replaceable>A</replaceable>,
    <replaceable>B</replaceable>, <replaceable>C</replaceable> of the
    data type:

    <itemizedlist>
     <listitem>
      <para>
       <replaceable>A</replaceable> <literal>=</literal>
       <replaceable>A</replaceable> is true
       (<firstterm>reflexive law</firstterm>)
      </para>
     </listitem>
     <listitem>
      <para>
       if <replaceable>A</replaceable> <literal>=</literal>
       <replaceable>B</replaceable>,
       then <replaceable>B</replaceable> <literal>=</literal>
       <replaceable>A</replaceable>
       (<firstterm>symmetric law</firstterm>)
      </para>
     </listitem>
     <listitem>
      <para>
       if <replaceable>A</replaceable> <literal>=</literal>
       <replaceable>B</replaceable> and <replaceable>B</replaceable>
       <literal>=</literal> <replaceable>C</replaceable>,
       then <replaceable>A</replaceable> <literal>=</literal>
       <replaceable>C</replaceable>
       (<firstterm>transitive law</firstterm>)
      </para>
     </listitem>
    </itemizedlist>
   </para>
____________________________________________________________________________-->
   <para>
    一个<literal>=</literal>操作符必须是一种等值关系。也就是说，对于该数据类型的所有非空值<replaceable>A</replaceable>、<replaceable>B</replaceable>、<replaceable>C</replaceable>：

    <itemizedlist>
     <listitem>
      <para>
       <replaceable>A</replaceable> <literal>=</literal> <replaceable>A</replaceable>为真（<firstterm>自反律</firstterm>）
      </para>
     </listitem>
     <listitem>
      <para>
       如果<replaceable>A</replaceable> <literal>=</literal> <replaceable>B</replaceable>，则有<replaceable>B</replaceable> <literal>=</literal>
       <replaceable>A</replaceable>（<firstterm>对称律</firstterm>）
      </para>
     </listitem>
     <listitem>
      <para>
       如果<replaceable>A</replaceable> <literal>=</literal> <replaceable>B</replaceable>并且<replaceable>B</replaceable> <literal>=</literal> <replaceable>C</replaceable>，则有<replaceable>A</replaceable> <literal>=</literal> <replaceable>C</replaceable>（<firstterm>传递律</firstterm>）
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </listitem>

  <listitem>
<!--==========================orignal english content==========================
   <para>
    A <literal>&lt;</literal> operator must be a strong ordering relation;
    that is, for all non-null values <replaceable>A</replaceable>,
    <replaceable>B</replaceable>, <replaceable>C</replaceable>:

    <itemizedlist>
     <listitem>
      <para>
       <replaceable>A</replaceable> <literal>&lt;</literal>
       <replaceable>A</replaceable> is false
       (<firstterm>irreflexive law</firstterm>)
      </para>
     </listitem>
     <listitem>
      <para>
       if <replaceable>A</replaceable> <literal>&lt;</literal>
       <replaceable>B</replaceable>
       and <replaceable>B</replaceable> <literal>&lt;</literal>
       <replaceable>C</replaceable>,
       then <replaceable>A</replaceable> <literal>&lt;</literal>
       <replaceable>C</replaceable>
       (<firstterm>transitive law</firstterm>)
      </para>
     </listitem>
    </itemizedlist>
   </para>
____________________________________________________________________________-->
   <para>
    一个<literal>&lt;</literal>操作符必须是一种强排序关系。也就是说，对于所有的非空值<replaceable>A</replaceable>、<replaceable>B</replaceable>、<replaceable>C</replaceable>：

    <itemizedlist>
     <listitem>
      <para>
       <replaceable>A</replaceable> <literal>&lt;</literal> <replaceable>A</replaceable>为假（<firstterm>非自反律</firstterm>）
      </para>
     </listitem>
     <listitem>
      <para>
       如果<replaceable>A</replaceable> <literal>&lt;</literal> <replaceable>B</replaceable>以及<replaceable>B</replaceable> <literal>&lt;</literal> <replaceable>C</replaceable>，则有<replaceable>A</replaceable> <literal>&lt;</literal> <replaceable>C</replaceable>（<firstterm>传递律</firstterm>）
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </listitem>

  <listitem>
<!--==========================orignal english content==========================
   <para>
    Furthermore, the ordering is total; that is, for all non-null
    values <replaceable>A</replaceable>, <replaceable>B</replaceable>:

    <itemizedlist>
     <listitem>
      <para>
       exactly one of <replaceable>A</replaceable> <literal>&lt;</literal>
       <replaceable>B</replaceable>, <replaceable>A</replaceable>
       <literal>=</literal> <replaceable>B</replaceable>, and
       <replaceable>B</replaceable> <literal>&lt;</literal>
       <replaceable>A</replaceable> is true
       (<firstterm>trichotomy law</firstterm>)
      </para>
     </listitem>
    </itemizedlist>

    (The trichotomy law justifies the definition of the comparison support
    function, of course.)
   </para>
____________________________________________________________________________-->
   <para>
    此外，该排序是完全的。也就是说，对于所有非空值<replaceable>A</replaceable>、<replaceable>B</replaceable>、<replaceable>C</replaceable>：

    <itemizedlist>
     <listitem>
      <para>
       <replaceable>A</replaceable> <literal>&lt;</literal> <replaceable>B</replaceable>、<replaceable>A</replaceable> <literal>=</literal> <replaceable>B</replaceable>和<replaceable>B</replaceable> <literal>&lt;</literal> <replaceable>A</replaceable>之中恰好有一个为真（<firstterm>三分律</firstterm>）
      </para>
     </listitem>
    </itemizedlist>

    （三分律无疑证明了比较支持函数定义的正确性。）
   </para>
  </listitem>
 </itemizedlist>

<!--==========================orignal english content==========================
 <para>
  The other three operators are defined in terms of <literal>=</literal>
  and <literal>&lt;</literal> in the obvious way, and must act consistently
  with them.
 </para>
____________________________________________________________________________-->
 <para>
  其他三种操作符可以以显而易见的方式用<literal>=</literal>和<literal>&lt;</literal>来定义，并且必须和它们的行为保持一致。
 </para>

<!--==========================orignal english content==========================
 <para>
  For an operator family supporting multiple data types, the above laws must
  hold when <replaceable>A</replaceable>, <replaceable>B</replaceable>,
  <replaceable>C</replaceable> are taken from any data types in the family.
  The transitive laws are the trickiest to ensure, as in cross-type
  situations they represent statements that the behaviors of two or three
  different operators are consistent.
  As an example, it would not work to put <type>float8</type>
  and <type>numeric</type> into the same operator family, at least not with
  the current semantics that <type>numeric</type> values are converted
  to <type>float8</type> for comparison to a <type>float8</type>.  Because
  of the limited accuracy of <type>float8</type>, this means there are
  distinct <type>numeric</type> values that will compare equal to the
  same <type>float8</type> value, and thus the transitive law would fail.
 </para>
____________________________________________________________________________-->
 <para>
  对于一个支持多种数据类型的操作符族来说，当<replaceable>A</replaceable>、<replaceable>B</replaceable>、<replaceable>C</replaceable>取自该族中任意数据类型时，上述定律都必须保持。传递律是最难以保证的，因为在跨类型的情况中，传递律说明两种或者三种不同的操作符的行为是一致的。举个例子，把<type>float8</type>和<type>numeric</type>放在同一个操作符族中是行不通的，至少在当前的语义（为了和一个<type>float8</type>比较，<type>numeric</type>值会被转换成<type>float8</type>）下不行。因为<type>float8</type>有限的精度，这意味着不同的<type>numeric</type>值将被认为等于同一个<type>float8</type>值，因此传递律将被破坏。
 </para>

<!--==========================orignal english content==========================
 <para>
  Another requirement for a multiple-data-type family is that any implicit
  or binary-coercion casts that are defined between data types included in
  the operator family must not change the associated sort ordering.
 </para>
____________________________________________________________________________-->
 <para>
  对于多数据类型操作符族的另一个要求是，其中包括的定义在数据类型之间的任何隐式或者二进制强制造型不能改变相关的排序顺序。
 </para>

<!--==========================orignal english content==========================
 <para>
  It should be fairly clear why a btree index requires these laws to hold
  within a single data type: without them there is no ordering to arrange
  the keys with.  Also, index searches using a comparison key of a
  different data type require comparisons to behave sanely across two
  data types.  The extensions to three or more data types within a family
  are not strictly required by the btree index mechanism itself, but the
  planner relies on them for optimization purposes.
 </para>
____________________________________________________________________________-->
 <para>
  为何一个btree索引要求这些定律在单一数据类型中必须保持的原因应该相对比较清楚：没有这些定律就不存在用于安排键的顺序。此外，使用不同数据类型键的比较的索引搜索也要求比较操作在两种数据类型之间表现得稳定。btree索引机制本身并不严格要求在一个操作符族中扩展到三种或者更多种数据类型，但是规划器依赖于这种扩展来实现其优化的目的。
 </para>

</sect1>

<sect1 id="btree-support-funcs">
<!--==========================orignal english content==========================
 <title>B-Tree Support Functions</title>
____________________________________________________________________________-->
 <title>B-树支持函数</title>

<!--==========================orignal english content==========================
 <para>
  As shown in <xref linkend="xindex-btree-support-table"/>, btree defines
  one required and four optional support functions.  The five
  user-defined methods are:
 </para>
____________________________________________________________________________-->
 <para>
  如<xref linkend="xindex-btree-support-table"/>中所示，btree定义了一种必需的和四种可选的支持函数。这五种用户定义的方法为：
 </para>

 <variablelist>
  <varlistentry>
<!--==========================orignal english content==========================
   <term><function>order</function></term>
____________________________________________________________________________-->
   <term><function>order</function></term>
   <listitem>
<!--==========================orignal english content==========================
    <para>
     For each combination of data types that a btree operator family
     provides comparison operators for, it must provide a comparison
     support function, registered in
     <structname>pg_amproc</structname> with support function number 1
     and
     <structfield>amproclefttype</structfield>/<structfield>amprocrighttype</structfield>
     equal to the left and right data types for the comparison (i.e.,
     the same data types that the matching operators are registered
     with in <structname>pg_amop</structname>).  The comparison
     function must take two non-null values
     <replaceable>A</replaceable> and <replaceable>B</replaceable> and
     return an <type>int32</type> value that is
     <literal>&lt;</literal> <literal>0</literal>,
     <literal>0</literal>, or <literal>&gt;</literal>
     <literal>0</literal> when <replaceable>A</replaceable>
     <literal>&lt;</literal> <replaceable>B</replaceable>,
     <replaceable>A</replaceable> <literal>=</literal>
     <replaceable>B</replaceable>, or <replaceable>A</replaceable>
     <literal>&gt;</literal> <replaceable>B</replaceable>,
     respectively.  A null result is disallowed: all values of the
     data type must be comparable.  See
     <filename>src/backend/access/nbtree/nbtcompare.c</filename> for
     examples.
    </para>
____________________________________________________________________________-->
    <para>
     对于btree操作符族为其提供了比较操作符的每一种数据类型组合，操作符族必须提供一个比较支持函数，在<structname>pg_amproc</structname>中注册：支持函数编号为1，<structfield>amproclefttype</structfield>/<structfield>amprocrighttype</structfield>等于比较的左右数据类型（即匹配的操作符注册在<structname>pg_amop</structname>中的数据类型）。
     比较函数必须接收两个非空值<replaceable>A</replaceable>和<replaceable>B</replaceable>并且返回一个<type>int32</type>值，返回值在<replaceable>A</replaceable> <literal>&lt;</literal> <replaceable>B</replaceable>、<replaceable>A</replaceable> <literal>=</literal> <replaceable>B</replaceable>以及<replaceable>A</replaceable> <literal>&gt;</literal> <replaceable>B</replaceable>时分别为<literal>&lt;</literal> <literal>0</literal>、<literal>0</literal>和<literal>&gt;</literal> <literal>0</literal>。
     不允许空值结果：该数据类型的所有值必须是可比较的。
     例子请见<filename>src/backend/access/nbtree/nbtcompare.c</filename>。
    </para>

<!--==========================orignal english content==========================
    <para>
     If the compared values are of a collatable data type, the
     appropriate collation OID will be passed to the comparison
     support function, using the standard
     <function>PG_GET_COLLATION()</function> mechanism.
    </para>
____________________________________________________________________________-->
    <para>
     如果被比较的值是一种可排序的数据类型，合适的排序规则OID将使用标准的PG_GET_COLLATION()机制被传递给比较支持函数。
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
<!--==========================orignal english content==========================
   <term><function>sortsupport</function></term>
____________________________________________________________________________-->
   <term><function>sortsupport</function></term>
   <listitem>
<!--==========================orignal english content==========================
    <para>
     Optionally, a btree operator family may provide <firstterm>sort
      support</firstterm> function(s), registered under support
     function number 2.  These functions allow implementing
     comparisons for sorting purposes in a more efficient way than
     naively calling the comparison support function.  The APIs
     involved in this are defined in
     <filename>src/include/utils/sortsupport.h</filename>.
    </para>
____________________________________________________________________________-->
    <para>
     可选地，btree操作符族可以提供<firstterm>排序支持</firstterm>函数，它们以支持函数编号2注册。
     这些函数允许以一种比单纯调用比较支持函数更加高效的方式实现排序比较。
     涉及的API在<filename>src/include/utils/sortsupport.h</filename>中定义。
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
<!--==========================orignal english content==========================
   <term><function>in_range</function></term>
____________________________________________________________________________-->
   <term><function>in_range</function></term>
   <listitem>
<!--==========================orignal english content==========================
    <indexterm>
     <primary>in_range support functions</primary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>in_range support functions</primary>
    </indexterm>

<!--==========================orignal english content==========================
    <indexterm>
     <primary>support functions</primary>
     <secondary>in_range</secondary>
    </indexterm>
____________________________________________________________________________-->
    <indexterm>
     <primary>support functions</primary>
     <secondary>in_range</secondary>
    </indexterm>
<!--==========================orignal english content==========================
    <para>
     Optionally, a btree operator family may provide
     <firstterm>in_range</firstterm> support function(s), registered
     under support function number 3.  These are not used during btree
     index operations; rather, they extend the semantics of the
     operator family so that it can support window clauses containing
     the <literal>RANGE</literal> <replaceable>offset</replaceable>
     <literal>PRECEDING</literal> and <literal>RANGE</literal>
     <replaceable>offset</replaceable> <literal>FOLLOWING</literal>
     frame bound types (see <xref
      linkend="syntax-window-functions"/>).  Fundamentally, the extra
     information provided is how to add or subtract an
     <replaceable>offset</replaceable> value in a way that is
     compatible with the family's data ordering.
    </para>
____________________________________________________________________________-->
    <para>
     可选地，btree操作符族可以提供<firstterm>in_range</firstterm>支持函数，它们以支持函数编号3注册。
     在btree索引操作期间不会用到这些函数，它们扩展了操作符族的语义，这样就能支持包含<literal>RANGE</literal> <replaceable>offset</replaceable> <literal>PRECEDING</literal>以及<literal>RANGE</literal> <replaceable>offset</replaceable> <literal>FOLLOWING</literal>窗口帧界类型（见<xref linkend="syntax-window-functions"/>）的窗口子句。
     归根到底，这些函数所提供的额外信息是如何以一种与该操作符族的数据排序相兼容的方式加上或者减去一个<replaceable>offset</replaceable>值。
    </para>

<!--==========================orignal english content==========================
    <para>
     An <function>in_range</function> function must have the signature
<synopsis>
in_range(<replaceable>val</replaceable> type1, <replaceable>base</replaceable> type1, <replaceable>offset</replaceable> type2, <replaceable>sub</replaceable> bool, <replaceable>less</replaceable> bool)
returns bool
</synopsis>
     <replaceable>val</replaceable> and
     <replaceable>base</replaceable> must be of the same type, which
     is one of the types supported by the operator family (i.e., a
     type for which it provides an ordering).  However,
     <replaceable>offset</replaceable> could be of a different type,
     which might be one otherwise unsupported by the family.  An
     example is that the built-in <literal>time_ops</literal> family
     provides an <function>in_range</function> function that has
     <replaceable>offset</replaceable> of type <type>interval</type>.
     A family can provide <function>in_range</function> functions for
     any of its supported types and one or more
     <replaceable>offset</replaceable> types.  Each
     <function>in_range</function> function should be entered in
     <structname>pg_amproc</structname> with
     <structfield>amproclefttype</structfield> equal to
     <type>type1</type> and <structfield>amprocrighttype</structfield>
     equal to <type>type2</type>.
    </para>
____________________________________________________________________________-->
    <para>
     An <function>in_range</function> 函数必须有签名
<synopsis>
in_range(<replaceable>val</replaceable> type1, <replaceable>base</replaceable> type1, <replaceable>offset</replaceable> type2, <replaceable>sub</replaceable> bool, <replaceable>less</replaceable> bool)
returns bool
</synopsis>
     <replaceable>val</replaceable>和<replaceable>base</replaceable>必须是同一种类型，该类型也是操作符族所支持的类型之一（即它提供排序的一种类型）。
     不过，<replaceable>offset</replaceable>可以是一种不同的类型，该类型有可能不被该操作符族所支持。例如内建的<literal>time_ops</literal>族提供了一个<function>in_range</function>函数，其<replaceable>offset</replaceable>是类型<type>interval</type>。
     一个操作符族可以为其所支持的任意类型提供<function>in_range</function>函数以及一个或者更多种<replaceable>offset</replaceable>类型。
     每一个<function>in_range</function>函数在进入到<structname>pg_amproc</structname>时，需要有<structfield>amproclefttype</structfield>等于<type>type1</type>以及<structfield>amprocrighttype</structfield>等于<type>type2</type>。
    </para>

<!--==========================orignal english content==========================
    <para>
     The essential semantics of an <function>in_range</function>
     function depend on the two Boolean flag parameters.  It should
     add or subtract <replaceable>base</replaceable> and
     <replaceable>offset</replaceable>, then compare
     <replaceable>val</replaceable> to the result, as follows:
     <itemizedlist>
      <listitem>
       <para>
        if <literal>!</literal><replaceable>sub</replaceable> and
        <literal>!</literal><replaceable>less</replaceable>, return
        <replaceable>val</replaceable> <literal>&gt;=</literal>
        (<replaceable>base</replaceable> <literal>+</literal>
        <replaceable>offset</replaceable>)
       </para>
      </listitem>
      <listitem>
       <para>
        if <literal>!</literal><replaceable>sub</replaceable> and
        <replaceable>less</replaceable>, return
        <replaceable>val</replaceable> <literal>&lt;=</literal>
        (<replaceable>base</replaceable> <literal>+</literal>
        <replaceable>offset</replaceable>)
       </para>
      </listitem>
      <listitem>
       <para>
        if <replaceable>sub</replaceable> and
        <literal>!</literal><replaceable>less</replaceable>, return
        <replaceable>val</replaceable> <literal>&gt;=</literal>
        (<replaceable>base</replaceable> <literal>-</literal>
        <replaceable>offset</replaceable>)
       </para>
      </listitem>
      <listitem>
       <para>
        if <replaceable>sub</replaceable> and
        <replaceable>less</replaceable>, return
        <replaceable>val</replaceable> <literal>&lt;=</literal>
        (<replaceable>base</replaceable> <literal>-</literal>
        <replaceable>offset</replaceable>)
       </para>
      </listitem>
     </itemizedlist>
     Before doing so, the function should check the sign of
     <replaceable>offset</replaceable>: if it is less than zero, raise
     error
     <literal>ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE</literal>
     (22013) with error text like <quote>invalid preceding or
      following size in window function</quote>.  (This is required by
     the SQL standard, although nonstandard operator families might
     perhaps choose to ignore this restriction, since there seems to
     be little semantic necessity for it.) This requirement is
     delegated to the <function>in_range</function> function so that
     the core code needn't understand what <quote>less than
      zero</quote> means for a particular data type.
    </para>
____________________________________________________________________________-->
    <para>
     <function>in_range</function>函数的本质语义取决于两个布尔标志参数。
	 它应该将<replaceable>base</replaceable>和<replaceable>offset</replaceable>相加或者相减，然后用<replaceable>val</replaceable>与其结果比较：
     <itemizedlist>
      <listitem>
       <para>
        如果<literal>!</literal><replaceable>sub</replaceable>并且<literal>!</literal><replaceable>less</replaceable>，则返回<replaceable>val</replaceable> <literal>&gt;=</literal> (<replaceable>base</replaceable> <literal>+</literal> <replaceable>offset</replaceable>)
       </para>
      </listitem>
      <listitem>
       <para>
        如果<literal>!</literal><replaceable>sub</replaceable>并且<replaceable>less</replaceable>，则返回<replaceable>val</replaceable> <literal>&lt;=</literal> (<replaceable>base</replaceable> <literal>+</literal> <replaceable>offset</replaceable>)
       </para>
      </listitem>
      <listitem>
       <para>
        如果<replaceable>sub</replaceable>并且<literal>!</literal><replaceable>less</replaceable>，则返回<replaceable>val</replaceable> <literal>&gt;=</literal> (<replaceable>base</replaceable> <literal>-</literal> <replaceable>offset</replaceable>)
       </para>
      </listitem>
      <listitem>
       <para>
        如果<replaceable>sub</replaceable>并且<replaceable>less</replaceable>，则返回<replaceable>val</replaceable> <literal>&lt;=</literal> (<replaceable>base</replaceable> <literal>-</literal> <replaceable>offset</replaceable>)
       </para>
      </listitem>
     </itemizedlist>
     在这样做之前，该函数应该检查<replaceable>offset</replaceable>的符号：如果它小于零，则抛出错误<literal>ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE</literal> (22013)外加<quote>invalid preceding or following size in window function</quote>这样的错误文本（这是SQL标准所要求的，不过非标准操作符族可能会选择忽视这一限制，因为似乎其语义必要性很小）。
     这种要求被委托给了<function>in_range</function>函数，这样核心代码不需要理解对一种特定数据类型<quote>less than zero</quote>表示什么。
    </para>

<!--==========================orignal english content==========================
    <para>
     An additional expectation is that <function>in_range</function>
     functions should, if practical, avoid throwing an error if
     <replaceable>base</replaceable> <literal>+</literal>
     <replaceable>offset</replaceable> or
     <replaceable>base</replaceable> <literal>-</literal>
     <replaceable>offset</replaceable> would overflow.  The correct
     comparison result can be determined even if that value would be
     out of the data type's range.  Note that if the data type
     includes concepts such as <quote>infinity</quote> or
     <quote>NaN</quote>, extra care may be needed to ensure that
     <function>in_range</function>'s results agree with the normal
     sort order of the operator family.
    </para>
____________________________________________________________________________-->
    <para>
     一个额外的期望是，如果可行，<function>in_range</function>函数应当在<replaceable>base</replaceable> <literal>+</literal> <replaceable>offset</replaceable>或者<replaceable>base</replaceable> <literal>-</literal> <replaceable>offset</replaceable>溢出时避免抛出错误。
     即便值超过了该数据类型的范围，也可以确定正确的比较结果。
     注意，如果数据类型包括诸如<quote>infinity</quote>或者<quote>NaN</quote>之类的概念，就需要额外的注意确保<function>in_range</function>的结果符合该操作符族的正常排序顺序。
    </para>

<!--==========================orignal english content==========================
    <para>
     The results of the <function>in_range</function> function must be
     consistent with the sort ordering imposed by the operator family.
     To be precise, given any fixed values of
     <replaceable>offset</replaceable> and
     <replaceable>sub</replaceable>, then:
     <itemizedlist>
      <listitem>
       <para>
        If <function>in_range</function> with
        <replaceable>less</replaceable> = true is true for some
        <replaceable>val1</replaceable> and
        <replaceable>base</replaceable>, it must be true for every
        <replaceable>val2</replaceable> <literal>&lt;=</literal>
        <replaceable>val1</replaceable> with the same
        <replaceable>base</replaceable>.
       </para>
      </listitem>
      <listitem>
       <para>
        If <function>in_range</function> with
        <replaceable>less</replaceable> = true is false for some
        <replaceable>val1</replaceable> and
        <replaceable>base</replaceable>, it must be false for every
        <replaceable>val2</replaceable> <literal>&gt;=</literal>
        <replaceable>val1</replaceable> with the same
        <replaceable>base</replaceable>.
       </para>
      </listitem>
      <listitem>
       <para>
        If <function>in_range</function> with
        <replaceable>less</replaceable> = true is true for some
        <replaceable>val</replaceable> and
        <replaceable>base1</replaceable>, it must be true for every
        <replaceable>base2</replaceable> <literal>&gt;=</literal>
        <replaceable>base1</replaceable> with the same
        <replaceable>val</replaceable>.
       </para>
      </listitem>
      <listitem>
       <para>
        If <function>in_range</function> with
        <replaceable>less</replaceable> = true is false for some
        <replaceable>val</replaceable> and
        <replaceable>base1</replaceable>, it must be false for every
        <replaceable>base2</replaceable> <literal>&lt;=</literal>
        <replaceable>base1</replaceable> with the same
        <replaceable>val</replaceable>.
       </para>
      </listitem>
     </itemizedlist>
     Analogous statements with inverted conditions hold when
     <replaceable>less</replaceable> = false.
    </para>
____________________________________________________________________________-->
    <para>
     <function>in_range</function>函数的结果必须与操作符族施加的排序顺序保持一致。
     准确的来说，给定任意固定的<replaceable>offset</replaceable>值以及<replaceable>sub</replaceable>值，那么：
     <itemizedlist>
      <listitem>
       <para>
        如果带有<replaceable>less</replaceable> = true的<function>in_range</function>对某个<replaceable>val1</replaceable>和<replaceable>base</replaceable>为真，则它必须对每一个有相同<replaceable>base</replaceable>的<replaceable>val2</replaceable> <literal>&lt;=</literal> <replaceable>val1</replaceable>为真。
       </para>
      </listitem>
      <listitem>
       <para>
        如果带有<replaceable>less</replaceable> = true的<function>in_range</function>对某个<replaceable>val1</replaceable>和<replaceable>base</replaceable>为假，则它必须对每一个有相同<replaceable>base</replaceable>的<replaceable>val2</replaceable> <literal>&gt;=</literal> <replaceable>val1</replaceable>为假。
       </para>
      </listitem>
      <listitem>
       <para>
        如果带有<replaceable>less</replaceable> = true的<function>in_range</function>对于某些<replaceable>val</replaceable>和<replaceable>base1</replaceable>为真,那么它对于每一个有相同<replaceable>val</replaceable>的<replaceable>base2</replaceable> <literal>&gt;=</literal> <replaceable>base1</replaceable>也必须为真。
       </para>
      </listitem>
      <listitem>
       <para>
        如果带有<replaceable>less</replaceable> = true的<function>in_range</function>对于某些<replaceable>val</replaceable>和<replaceable>base1</replaceable>为假, name它对于每一个有相同<replaceable>val</replaceable>的<replaceable>base2</replaceable> <literal>&lt;=</literal> <replaceable>base1</replaceable>也必须为假。
       </para>
      </listitem>
     </itemizedlist>
     当<replaceable>less</replaceable> = false时，类似的具有相逆条件的语句成立。
    </para>

<!--==========================orignal english content==========================
    <para>
     If the type being ordered (<type>type1</type>) is collatable, the
     appropriate collation OID will be passed to the
     <function>in_range</function> function, using the standard
     PG_GET_COLLATION() mechanism.
    </para>
____________________________________________________________________________-->
    <para>
     如果被排序的类型（<type>type1</type>）是可排序的，合适的排序规则OID将使用标准的PG_GET_COLLATION()机制被传递给<function>in_range</function>函数。
    </para>

<!--==========================orignal english content==========================
    <para>
     <function>in_range</function> functions need not handle NULL
     inputs, and typically will be marked strict.
    </para>
____________________________________________________________________________-->
    <para>
     <function>in_range</function>函数不需要处理NULL输入，并且通常将被标记为strict。
    </para>
   </listitem>
  </varlistentry>

  <varlistentry>
<!--==========================orignal english content==========================
   <term><function>equalimage</function></term>
____________________________________________________________________________-->
   <term><function>equalimage</function></term>
   <listitem>
<!--==========================orignal english content==========================
    <para>
     Optionally, a btree operator family may provide
     <function>equalimage</function> (<quote>equality implies image
      equality</quote>) support functions, registered under support
     function number 4.  These functions allow the core code to
     determine when it is safe to apply the btree deduplication
     optimization.  Currently, <function>equalimage</function>
     functions are only called when building or rebuilding an index.
    </para>
____________________________________________________________________________-->
    <para>
     可选地，btree 操作符系列可以提供<function>equalimage</function>（<quote>equality implies image equality</quote>）支持功能，注册在支持函数 4 下面。
     这些函数允许核心代码确定何时可以安全地应用 btree 重复数据消除进行优化。
     目前，<function>equalimage</function>函数仅在生成或重建索引时调用。
    </para>
<!--==========================orignal english content==========================
    <para>
     An <function>equalimage</function> function must have the
     signature
<synopsis>
equalimage(<replaceable>opcintype</replaceable> <type>oid</type>) returns bool
</synopsis>
     The return value is static information about an operator class
     and collation.  Returning <literal>true</literal> indicates that
     the <function>order</function> function for the operator class is
     guaranteed to only return <literal>0</literal> (<quote>arguments
      are equal</quote>) when its <replaceable>A</replaceable> and
     <replaceable>B</replaceable> arguments are also interchangeable
     without any loss of semantic information.  Not registering an
     <function>equalimage</function> function or returning
     <literal>false</literal> indicates that this condition cannot be
     assumed to hold.
    </para>
____________________________________________________________________________-->
    <para>
     一个 <function>equalimage</function> 函数必须包含签名
<synopsis>
equalimage(<replaceable>opcintype</replaceable> <type>oid</type>) returns bool
</synopsis>
     返回值是有关运算符类和排序规则的静态信息。 
     返回<literal>true</literal>表示运算符类的 <function>order</function> 函数保证仅返回<literal>0</literal> (<quote>arguments are equal</quote>) 时，<replaceable>A</replaceable>和 <replaceable>B</replaceable>参数也可以互换，而不会丢失任何语义信息。 
     不注册<function>equalimage</function>函数或返回<literal>false</literal>表示不能假定此条件成立。
    </para>
<!--==========================orignal english content==========================
    <para>
     The <replaceable>opcintype</replaceable> argument is the
     <literal><structname>pg_type</structname>.oid</literal> of the
     data type that the operator class indexes.  This is a convenience
     that allows reuse of the same underlying
     <function>equalimage</function> function across operator classes.
     If <replaceable>opcintype</replaceable> is a collatable data
     type, the appropriate collation OID will be passed to the
     <function>equalimage</function> function, using the standard
     <function>PG_GET_COLLATION()</function> mechanism.
    </para>
____________________________________________________________________________-->
    <para>
     <replaceable>opcintype</replaceable>参数是操作符类索引的数据类型的<literal><structname>pg_type</structname>.oid</literal>。 
     这提供一种便利，允许在操作符类之间重用相同的底层<function>equalimage</function>函数。
     如果<replaceable>opcintype</replaceable>是可排序数据类型，则相应的排序规则 OID 将传递给 <function>equalimage</function> 函数，使用标准的 <function>PG_GET_COLLATION()</function> 机制。
    </para>
<!--==========================orignal english content==========================
    <para>
     As far as the operator class is concerned, returning
     <literal>true</literal> indicates that deduplication is safe (or
     safe for the collation whose OID was passed to its
     <function>equalimage</function> function).  However, the core
     code will only deem deduplication safe for an index when
     <emphasis>every</emphasis> indexed column uses an operator class
     that registers an <function>equalimage</function> function, and
     each function actually returns <literal>true</literal> when
     called.
    </para>
____________________________________________________________________________-->
    <para>
     就操作符类而言，返回<literal>true</literal>意味着重复数据删除是安全的（或安全排序规则，其OID传递给它的<function>equalimage</function>函数）。
     但是，核心代码只有在<emphasis>every</emphasis> 索引列使用注册了 <function>equalimage</function> 函数的操作符类时，并且每个函数在调用时实际返回 <literal>true</literal> 时，才会认为重复数据删除是安全的。
    </para>
<!--==========================orignal english content==========================
    <para>
     Image equality is <emphasis>almost</emphasis> the same condition
     as simple bitwise equality.  There is one subtle difference: When
     indexing a varlena data type, the on-disk representation of two
     image equal datums may not be bitwise equal due to inconsistent
     application of <acronym>TOAST</acronym> compression on input.
     Formally, when an operator class's
     <function>equalimage</function> function returns
     <literal>true</literal>, it is safe to assume that the
     <literal>datum_image_eq()</literal> C function will always agree
     with the operator class's <function>order</function> function
     (provided that the same collation OID is passed to both the
     <function>equalimage</function> and <function>order</function>
     functions).
    </para>
____________________________________________________________________________-->
    <para>
     图像相等<emphasis>几乎</emphasis>与简单位元(simple bitwise)相等的条件相同。
     有一个细微的区别：在索引 varlena 数据类型时，由于输入上<acronym>TOAST</acronym>压缩应用不一致，两个图像相等基准的磁盘表示可能不是位相等的。
     从形式上看，当操作符类的 <function>equalimage</function>函数返回 <literal>true</literal> 时，可以安全的地假定 <literal>datum_image_eq()</literal> C 函数将始终与操作符类的 <function>order</function> 函数一致（前提是将同一个排序规则 OID 传递给 <function>equalimage</function> 和 <function>order</function> 函数）。
    </para>
<!--==========================orignal english content==========================
    <para>
     The core code is fundamentally unable to deduce anything about
     the <quote>equality implies image equality</quote> status of an
     operator class within a multiple-data-type family based on
     details from other operator classes in the same family.  Also, it
     is not sensible for an operator family to register a cross-type
     <function>equalimage</function> function, and attempting to do so
     will result in an error.  This is because <quote>equality implies
      image equality</quote> status does not just depend on
     sorting/equality semantics, which are more or less defined at the
     operator family level.  In general, the semantics that one
     particular data type implements must be considered separately.
    </para>
____________________________________________________________________________-->
    <para>
     核心代码从根本上无法推断出任何关于基于同一系列中其他运算符类的详细信息的具有多数据类型系列中的操作符类的<quote>equality implies image equality</quote>状态。 
     此外，操作符系列注册跨类型 <function>equalimage</function>函数是不明智的，尝试这样做将导致错误。
     这是因为<quote>equality implies image equality</quote>状态不仅仅取决于排序/相等语义，这些语义或多或少在操作符系列级别定义。 
     通常，特定数据类型实现的语义必须单独考虑。
    </para>
<!--==========================orignal english content==========================
    <para>
     The convention followed by the operator classes included with the
     core <productname>PostgreSQL</productname> distribution is to
     register a stock, generic <function>equalimage</function>
     function.  Most operator classes register
     <function>btequalimage()</function>, which indicates that
     deduplication is safe unconditionally.  Operator classes for
     collatable data types such as <type>text</type> register
     <function>btvarstrequalimage()</function>, which indicates that
     deduplication is safe with deterministic collations.  Best
     practice for third-party extensions is to register their own
     custom function to retain control.
    </para>
____________________________________________________________________________-->
    <para>
     核心 <productname>PostgreSQL</productname> 分发中包含的操作符类所遵循的约定是注册股票(register a stock)，通用<function>equalimage</function>函数。
     大多数操作符类注册<function>btequalimage()</function>，这表明重复数据删除是安全的。 
     可排序数据类型的操作符类（如 <type>text</type>注册<function>btvarstrequalimage()</function>，这表明在确定性排序规则下应用重复数据删除是安全的。 
     第三方扩展的最佳实践是注册自己的自定义函数以保持控制。
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
<!--==========================orignal english content==========================
   <term><function>options</function></term>
____________________________________________________________________________-->
   <term><function>options</function></term>
   <listitem>
<!--==========================orignal english content==========================
    <para>
     Optionally, a B-tree operator family may provide
     <function>options</function> (<quote>operator class specific
     options</quote>) support functions, registered under support
     function number 5.  These functions define a set of user-visible
     parameters that control operator class behavior.
    </para>
____________________________________________________________________________-->
    <para>
	 可选地，B 树操作符系列可以提供<function>options</function>（<quote>操作符类指定选项</quote>）支持功能，注册在支持函数 5 下面。
	 这些函数定义一组用户可见的参数，用于控制操作符类行为。
    </para>
<!--==========================orignal english content==========================
    <para>
     An <function>options</function> support function must have the
     signature
<synopsis>
options(<replaceable>relopts</replaceable> <type>local_relopts *</type>) returns void
</synopsis>
     The function is passed a pointer to a <replaceable>local_relopts</replaceable>
     struct, which needs to be filled with a set of operator class
     specific options.  The options can be accessed from other support
     functions using the <literal>PG_HAS_OPCLASS_OPTIONS()</literal> and
     <literal>PG_GET_OPCLASS_OPTIONS()</literal> macros.
    </para>
____________________________________________________________________________-->
    <para>
      <function>options</function> 支持函数必须具有签名
<synopsis>
options(<replaceable>relopts</replaceable> <type>local_relopts *</type>) returns void
</synopsis>
     函数传递一个指向<replaceable>local_relopts</replaceable>结构的指针，需要用一组操作符类特定的选项来填充。
	 这些选项可以通过<literal>PG_HAS_OPCLASS_OPTIONS()</literal> 和 <literal>PG_GET_OPCLASS_OPTIONS()</literal> 宏，从其他支持的函数进行访问。
    </para>
<!--==========================orignal english content==========================
    <para>
     Currently, no B-Tree operator class has an <function>options</function>
     support function.  B-tree doesn't allow flexible representation of keys
     like GiST, SP-GiST, GIN and BRIN do.  So, <function>options</function>
     probably doesn't have much application in the current B-tree index
     access method.  Nevertheless, this support function was added to B-tree
     for uniformity, and will probably find uses during further
     evolution of B-tree in <productname>PostgreSQL</productname>.
    </para>
____________________________________________________________________________-->
    <para>
     目前，没有 B-Tree 操作符类具有 <function>options</function>支持功能。 
     B-tree不允许灵活表示键， 例如 GiST, SP-GiST, GIN 和 BRIN。 
     因此，<function>options</function>在当前的B-tree索引访问方法中可能没有太多的应用。 
     不过，此支持函数已添加到 B-tree中以保持一致性，并且可能会在<productname>PostgreSQL</productname>中B-tree的进一步演进中找到更多应用。
    </para>
   </listitem>
  </varlistentry>
 </variablelist>

</sect1>

<sect1 id="btree-implementation">
<!--==========================orignal english content==========================
 <title>Implementation</title>
____________________________________________________________________________-->
 <title>实现</title>

<!--==========================orignal english content==========================
 <para>
  This section covers B-Tree index implementation details that may be
  of use to advanced users.  See
  <filename>src/backend/access/nbtree/README</filename> in the source
  distribution for a much more detailed, internals-focused description
  of the B-Tree implementation.
 </para>
____________________________________________________________________________-->
 <para>
  本节介绍 B-Tree 索引实现详细信息，这些对高级用户可能有用。
  更多信息请参见在源分发中的<filename>src/backend/access/nbtree/README</filename>文件，内部聚焦的 B-Tree实现描述。
 </para>
 <sect2 id="btree-structure">
<!--==========================orignal english content==========================
  <title>B-Tree Structure</title>
____________________________________________________________________________-->
  <title>B-Tree 结构</title>
<!--==========================orignal english content==========================
  <para>
   <productname>PostgreSQL</productname> B-Tree indexes are
   multi-level tree structures, where each level of the tree can be
   used as a doubly-linked list of pages.  A single metapage is stored
   in a fixed position at the start of the first segment file of the
   index.  All other pages are either leaf pages or internal pages.
   Leaf pages are the pages on the lowest level of the tree.  All
   other levels consist of internal pages.  Each leaf page contains
   tuples that point to table rows.  Each internal page contains
   tuples that point to the next level down in the tree.  Typically,
   over 99% of all pages are leaf pages.  Both internal pages and leaf
   pages use the standard page format described in <xref
    linkend="storage-page-layout"/>.
  </para>
____________________________________________________________________________-->
  <para>
   <productname>PostgreSQL</productname> B-Tree 索引是多级树结构，其中树的每个级别都可以用作双链接的页列表。
   单个元页存储在索引的第一个段文件开始时的固定位置。所有其他页都是叶页或内部页。叶页是在树的最低层上的页。 
   所有其他层级由内部页组成。每个叶页都包含指向表行的元组。每个内部页都包含指向树中下一级别的元组。 
   通常，超过 99% 的页面是叶页。 内部页和叶页都使用 <xref linkend="storage-page-layout"/>中描述的标准页格式。
  </para>
<!--==========================orignal english content==========================
  <para>
   New leaf pages are added to a B-Tree index when an existing leaf
   page cannot fit an incoming tuple.  A <firstterm>page
    split</firstterm> operation makes room for items that originally
   belonged on the overflowing page by moving a portion of the items
   to a new page.  Page splits must also insert a new
   <firstterm>downlink</firstterm> to the new page in the parent page,
   which may cause the parent to split in turn.  Page splits
   <quote>cascade upwards</quote> in a recursive fashion.  When the
   root page finally cannot fit a new downlink, a <firstterm>root page
    split</firstterm> operation takes place.  This adds a new level to
   the tree structure by creating a new root page that is one level
   above the original root page.
  </para>
____________________________________________________________________________-->
  <para>
   当已有叶页不能适应传入元组时，新叶页将添加到B-Tree索引中。 
   <firstterm>page split</firstterm>操作通过将部分项目移动到新页面为最初属于溢出页上的项目提供空间。
   页拆分还必须插入新的<firstterm>downlink</firstterm>到父页中的新页，这可能会导致父页依次拆分。 
   页拆分<quote>cascade upwards</quote>以递归的方式。 
   当根页最终无法适合新的下行链接时，发生<firstterm>root page split</firstterm>操作。
   通过创建比原始根页高一个级别的新根页，为树结构添加新级别。
  </para>
 </sect2>

 <sect2 id="btree-deduplication">
<!--==========================orignal english content==========================
  <title>Deduplication</title>
____________________________________________________________________________-->
  <title>Deduplication</title>
<!--==========================orignal english content==========================
  <para>
   A duplicate is a leaf page tuple (a tuple that points to a table
   row) where <emphasis>all</emphasis> indexed key columns have values
   that match corresponding column values from at least one other leaf
   page tuple in the same index.  Duplicate tuples are quite common in
   practice.  B-Tree indexes can use a special, space-efficient
   representation for duplicates when an optional technique is
   enabled: <firstterm>deduplication</firstterm>.
  </para>
____________________________________________________________________________-->
  <para>
   重复项是叶页元组（指向表行的元组），其中<emphasis>所有</emphasis> 索引键列的值与同一索引中至少一个其他叶页元组的相应列值匹配。 
   重复元组在实践中很常见。 
   当启用可选技术：<firstterm>重复</firstterm>时，B-Tree 索引可以对重复项使用特殊的、节省空间的表达方式。
  </para>
<!--==========================orignal english content==========================
  <para>
   Deduplication works by periodically merging groups of duplicate
   tuples together, forming a single <firstterm>posting list</firstterm> tuple for each
   group.  The column key value(s) only appear once in this
   representation.  This is followed by a sorted array of
   <acronym>TID</acronym>s that point to rows in the table.  This
   significantly reduces the storage size of indexes where each value
   (or each distinct combination of column values) appears several
   times on average.  The latency of queries can be reduced
   significantly.  Overall query throughput may increase
   significantly.  The overhead of routine index vacuuming may also be
   reduced significantly.
  </para>
____________________________________________________________________________-->
  <para>
   重复数据删除的工作为通过定期将重复元组合并在一起，为每个组构建一个<firstterm>posting list</firstterm>元组。 
   列键值在此表示形式中仅显示一次。 后面跟着指向表中行的<acronym>TID</acronym>的排序数组。
   这显著减少了索引的存储大小，在其中每个值（或列值的每个不同组合）平均出现多次时。 
   查询的延迟可以显著降低。 总体查询吞吐量可能会显著增加。 常规索引清空的开销也可以显著降低。
  </para>
  <note>
<!--==========================orignal english content==========================
   <para>
    B-Tree deduplication is just as effective with
    <quote>duplicates</quote> that contain a NULL value, even though
    NULL values are never equal to each other according to the
    <literal>=</literal> member of any B-Tree operator class.  As far
    as any part of the implementation that understands the on-disk
    B-Tree structure is concerned, NULL is just another value from the
    domain of indexed values.
   </para>
____________________________________________________________________________-->
   <para>
    B-Tree重复数据删除对于包含 NULL 值的<quote>duplicates</quote>同样有效，即使根据任何 B-Tree 操作符类的 <literal>=</literal> 成员，NULL 值永远不会彼此相等。 
    对于理解磁盘上 B-Tree 结构的实现的任何部分，NULL 只是索引值域中的另一个值。
   </para>
  </note>
<!--==========================orignal english content==========================
  <para>
   The deduplication process occurs lazily, when a new item is
   inserted that cannot fit on an existing leaf page.  This prevents
   (or at least delays) leaf page splits.  Unlike GIN posting list
   tuples, B-Tree posting list tuples do not need to expand every time
   a new duplicate is inserted; they are merely an alternative
   physical representation of the original logical contents of the
   leaf page.  This design prioritizes consistent performance with
   mixed read-write workloads.  Most client applications will at least
   see a moderate performance benefit from using deduplication.
   Deduplication is enabled by default.
  </para>
____________________________________________________________________________-->
  <para>
   当插入的新项无法适应现有叶页时，重复数据删除过程进行缓慢。这可以防止（或至少延迟）叶页拆分。 
   不像 GIN 倒排列表元组，B-Tree倒排列表元组不需要在每次插入新重复项时展开;它们仅仅是叶页原始逻辑内容的替代物理表示方式。 
   此设计优先考虑混合读写工作负载的一致性能。 
   大多数客户端应用程序可以从使用重复数据删除中获得适度的性能收益。默认情况下，将启用重复数据删除。
  </para>
<!--==========================orignal english content==========================
  <para>
   <command>CREATE INDEX</command> and <command>REINDEX</command>
   apply deduplication to create posting list tuples, though the
   strategy they use is slightly different.  Each group of duplicate
   ordinary tuples encountered in the sorted input taken from the
   table is merged into a posting list tuple
   <emphasis>before</emphasis> being added to the current pending leaf
   page.  Individual posting list tuples are packed with as many
   <acronym>TID</acronym>s as possible.  Leaf pages are written out in
   the usual way, without any separate deduplication pass.  This
   strategy is well-suited to <command>CREATE INDEX</command> and
   <command>REINDEX</command> because they are once-off batch
   operations.
  </para>
____________________________________________________________________________-->
  <para>
   <command>CREATE INDEX</command>和 <command>REINDEX</command> 应用重复数据删除来创建倒排列表元组，尽管它们使用的策略有所不同。
   每组重复的普通元组遇到从表中取出的排序输入将合并到倒排列表元组，在添加到当前挂起的叶页<emphasis>之前</emphasis>。 
   单独倒排列表元组尽可能以<acronym>TID</acronym>s封装。 叶页以通常的方式写出，没有任何分开的重复数据删除步骤。 
   此策略非常适合<command>CREATE INDEX</command>和<command>REINDEX</command>，因为它们是一次性的批处理操作。
  </para>
<!--==========================orignal english content==========================
  <para>
   Write-heavy workloads that don't benefit from deduplication due to
   having few or no duplicate values in indexes will incur a small,
   fixed performance penalty (unless deduplication is explicitly
   disabled).  The <literal>deduplicate_items</literal> storage
   parameter can be used to disable deduplication within individual
   indexes.  There is never any performance penalty with read-only
   workloads, since reading posting list tuples is at least as
   efficient as reading the standard tuple representation.  Disabling
   deduplication isn't usually helpful.
  </para>
____________________________________________________________________________-->
  <para>
   由于索引中重复值很少或没有重复值，因此无法从重复数据删除中获益的写频繁工作负载将产生少量的、固定性能损耗（除非显式禁用重复数据删除）。 
   <literal>deduplicate_items</literal>存储参数可用于禁用单个索引中的重复数据消除。 
   只读工作负载永远不会有任何性能损失，因为读取倒排列表元组至少与读取标准元组表示一样高效。 禁用重复数据删除通常没有帮助。
  </para>
<!--==========================orignal english content==========================
  <para>
   B-Tree indexes are not directly aware that under MVCC, there might
   be multiple extant versions of the same logical table row; to an
   index, each tuple is an independent object that needs its own index
   entry.  <quote>Version duplicates</quote> may sometimes accumulate
   and adversely affect query latency and throughput.  This typically
   occurs with <command>UPDATE</command>-heavy workloads where most
   individual updates cannot apply the <acronym>HOT</acronym>
   optimization (often because at least one indexed column gets
   modified, necessitating a new set of index tuple versions &mdash;
   one new tuple for <emphasis>each and every</emphasis> index).  In
   effect, B-Tree deduplication ameliorates index bloat caused by
   version churn.  Note that even the tuples from a unique index are
   not necessarily <emphasis>physically</emphasis> unique when stored
   on disk due to version churn.  The deduplication optimization is
   selectively applied within unique indexes.  It targets those pages
   that appear to have version duplicates.  The high level goal is to
   give <command>VACUUM</command> more time to run before an
   <quote>unnecessary</quote> page split caused by version churn can
   take place.
  </para>
____________________________________________________________________________-->
  <para>
   在 MVCC下B-Tree 索引不能直接感知，同一逻辑表行可能有多个现存版本;对于索引，每个元组都是一个独立对象，需要自己的索引条目。
   <quote>Version duplicates</quote>有时可能会累积并对其查询延迟和吞吐量产生不利影响。
   这通常发生在<command>UPDATE</command>重的工作负载中，其中大多数单独的更新无法应用<acronym>HOT</acronym>优化（通常因为至少修改了一个索引列，需要一组新的索引元组版本 &mdash;一个新的元组对<emphasis>each and every</emphasis>索引）。 
   实际上，B-Tree重复数据删除可以改善由版本变动引起的索引膨胀。
   请注意，即使唯一索引中的元组也不一定<emphasis>物理上</emphasis>唯一的，在版本变化而存储在磁盘上时。 
   重复数据删除优化有选择地应用于唯一索引中。它针对那些看起来具有重复版本的页面。 
   高级目标是给<command>VACUUM</command>更多的时间，在版本改动导致<quote>unnecessary</quote>页面拆分之前。
  </para>
  <tip>
<!--==========================orignal english content==========================
   <para>
    A special heuristic is applied to determine whether a
    deduplication pass in a unique index should take place.  It can
    often skip straight to splitting a leaf page, avoiding a
    performance penalty from wasting cycles on unhelpful deduplication
    passes.  If you're concerned about the overhead of deduplication,
    consider setting <literal>deduplicate_items = off</literal>
    selectively.  Leaving deduplication enabled in unique indexes has
    little downside.
   </para>
____________________________________________________________________________-->
   <para>
    应用一种特殊的启发式方法来确定是否应在唯一索引中进行重复数据删除操作。 
    它通常可以直接跳到拆分叶页，避免在无益的重复数据删除传递上浪费周期会降低性能。 
    如果你担心重复数据删除的开销，可以考虑<literal>deduplicate_items = off</literal>。 在唯一索引中启用重复数据删除没有什么坏处。
   </para>
  </tip>
<!--==========================orignal english content==========================
  <para>
   Deduplication cannot be used in all cases due to
   implementation-level restrictions.  Deduplication safety is
   determined when <command>CREATE INDEX</command> or
   <command>REINDEX</command> is run.
  </para>
____________________________________________________________________________-->
  <para>
   由于实现级别的限制，不能在所有情况下使用重复数据消除。 
   在<command>CREATE INDEX</command> 或 <command>REINDEX</command>时决定重复数据删除安全性。
  </para>
<!--==========================orignal english content==========================
  <para>
   Note that deduplication is deemed unsafe and cannot be used in the
   following cases involving semantically significant differences
   among equal datums:
  </para>
____________________________________________________________________________-->
  <para>
   请注意，重复数据删除被认为是不安全的，不能用于下列涉及相同数据之间语义显著差异的情况:
  </para>
<!--==========================orignal english content==========================
  <para>
   <itemizedlist>
    <listitem>
     <para>
      <type>text</type>, <type>varchar</type>, and <type>char</type>
      cannot use deduplication when a
      <emphasis>nondeterministic</emphasis> collation is used.  Case
      and accent differences must be preserved among equal datums.
     </para>
    </listitem>

    <listitem>
     <para>
      <type>numeric</type> cannot use deduplication.  Numeric display
      scale must be preserved among equal datums.
     </para>
    </listitem>

    <listitem>
     <para>
      <type>jsonb</type> cannot use deduplication, since the
      <type>jsonb</type> B-Tree operator class uses
      <type>numeric</type> internally.
     </para>
    </listitem>

    <listitem>
     <para>
      <type>float4</type> and <type>float8</type> cannot use
      deduplication.  These types have distinct representations for
      <literal>-0</literal> and <literal>0</literal>, which are
      nevertheless considered equal.  This difference must be
      preserved.
     </para>
    </listitem>
   </itemizedlist>
  </para>
____________________________________________________________________________-->
  <para>
   <itemizedlist>
    <listitem>
     <para>
      <type>text</type>, <type>varchar</type>, 和 <type>char</type>在使用<emphasis>nondeterministic</emphasis>排序规则时不能使用重复数据删除。 
      在等值基准之间必须保留大小写和重音差异。
     </para>
    </listitem>

    <listitem>
     <para>
      <type>numeric</type>重复数据删除。 数字显示比例必须在相等的基准之间保留。
     </para>
    </listitem>

    <listitem>
     <para>
      <type>jsonb</type>不能使用重复数据消除，因为<type>jsonb</type>B-Tree操作符类在内部使用<type>numeric</type>。
     </para>
    </listitem>

    <listitem>
     <para>
      <type>float4</type>和<type>float8</type>不能使用重复数据删除。
      这些类型对 <literal>-0</literal> 和 <literal>0</literal>具有不同的表示形式，但被视为相等。 必须保留此差异。
     </para>
    </listitem>
   </itemizedlist>
  </para>
<!--==========================orignal english content==========================
  <para>
   There is one further implementation-level restriction that may be
   lifted in a future version of
   <productname>PostgreSQL</productname>:
  </para>
____________________________________________________________________________-->
  <para>
   在未来版本的<productname>PostgreSQL</productname>中，还有一个实现级限制可能取消：
  </para>
<!--==========================orignal english content==========================
  <para>
   <itemizedlist>
    <listitem>
     <para>
      Container types (such as composite types, arrays, or range
      types) cannot use deduplication.
     </para>
    </listitem>
   </itemizedlist>
  </para>
____________________________________________________________________________-->
  <para>
   <itemizedlist>
    <listitem>
     <para>
      容器类型（例如复合类型、数组或范围类型）不能使用重复数据删除。
     </para>
    </listitem>
   </itemizedlist>
  </para>
<!--==========================orignal english content==========================
  <para>
   There is one further implementation-level restriction that applies
   regardless of the operator class or collation used:
  </para>
____________________________________________________________________________-->
  <para>
   无论使用操作符类或排序规则如何，还有一个实现级别限制适用：
  </para>
<!--==========================orignal english content==========================
  <para>
   <itemizedlist>
    <listitem>
     <para>
      <literal>INCLUDE</literal> indexes can never use deduplication.
     </para>
    </listitem>
   </itemizedlist>
  </para>
____________________________________________________________________________-->
  <para>
   <itemizedlist>
    <listitem>
     <para>
      <literal>INCLUDE</literal> 索引不能使用重复数据删除.
     </para>
    </listitem>
   </itemizedlist>
  </para>

 </sect2>
</sect1>

</chapter>
