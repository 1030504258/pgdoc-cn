<!-- doc/src/sgml/plpgsql.sgml -->

<chapter id="plpgsql">
<!--
  <title><application>PL/pgSQL</application> - <acronym>SQL</acronym> Procedural Language</title>
-->
  <title><application>PL/pgSQL</application> - <acronym>SQL</acronym>过程语言</title>
 <indexterm zone="plpgsql">
  <primary>PL/pgSQL</primary>
 </indexterm>

 <sect1 id="plpgsql-overview">
 <!--
  <title>Overview</title>
  -->
  <title>概述</title>


<para>
   <!--
  <application>PL/pgSQL</application> is a loadable procedural
  language for the <productname>PostgreSQL</productname> database
  system.  The design goals of <application>PL/pgSQL</> were to create
  a loadable procedural language that
  -->
  <application>PL/pgSQL</application>是<productname>PostgreSQL</productname>数据库系统的一个可加载的过程语言。 
  <application>PL/pgSQL</>的设计目标是创建一种可加载的过程语言，可以
    <itemizedlist>
     <listitem>
      <para>
   <!--
       can be used to create functions and trigger procedures,
   -->
   用于创建函数和触发器过程，
      </para>

     </listitem>
     <listitem>
      <!--
<para>
       adds control structures to the <acronym>SQL</acronym> language,
      </para>
-->
<para>
    为<acronym>SQL</acronym>语言增加控制结构，
</para>
     </listitem>
     <listitem>
      <!--
<para>
       can perform complex computations,
      </para>
-->
<para>
    执行复杂的计算，
</para>
     </listitem>
     <listitem>
      <!--
<para>
       inherits all user-defined types, functions, and operators,
      </para>
-->
<para>
    继承所有用户定义类型、函数、操作符，
</para>
     </listitem>
     <listitem>
      <!--
<para>
       can be defined to be trusted by the server,
      </para>
-->
<para>
    定义为被服务器信任的语言，
</para>
     </listitem>
     <listitem>
      <!--
<para>
       is easy to use.
      </para>
-->
<para>
  容易使用。
</para>
     </listitem>
    </itemizedlist>
   </para>

   <!--
<para>
    Functions created with <application>PL/pgSQL</application> can be
    used anywhere that built-in functions could be used.
    For example, it is possible to
    create complex conditional computation functions and later use
    them to define operators or use them in index expressions.
   </para>
-->
<para>
    <application>PL/pgSQL</application>创建的函数可以在那些使用内置函数一样的情形下使用。
比如，可以创建复杂的条件计算函数，并随后将之用于定义操作符或者用于函数索引中。
</para>

   <!--
<para>
    In <productname>PostgreSQL</> 9.0 and later,
    <application>PL/pgSQL</application> is installed by default.
    However it is still a loadable module, so especially security-conscious
    administrators could choose to remove it.
   </para>
-->
<para>
   在<productname>PostgreSQL</> 9.0及其之后的版本中，<application>PL/pgSQL</application>是默认安装的。
   当然，PL/pgSQL仍然是一个可加载的模块，因此，如果实际安全需要，管理员也可以选择将它卸载掉。
</para>

  <sect2 id="plpgsql-advantages">
  <!--
   <title>Advantages of Using <application>PL/pgSQL</application></title>
  -->
    <title>使用<application>PL/pgSQL</application>的优点</title>

    <!--
<para>
     <acronym>SQL</acronym> is the language <productname>PostgreSQL</>
     and most other relational databases use as query language. It's
     portable and easy to learn. But every <acronym>SQL</acronym>
     statement must be executed individually by the database server.
    </para>
-->
<para>
    <acronym>SQL</acronym>是<productname>PostgreSQL</>和大多数其它关系型数据库的命令语言。
它是可移植的，并且容易学习使用。但是所有<acronym>SQL</acronym>语句都必须由数据库服务器独立地执行。
</para>

    <!--
<para>
     That means that your client application must send each query to
     the database server, wait for it to be processed, receive and
     process the results, do some computation, then send further
     queries to the server.  All this incurs interprocess
     communication and will also incur network overhead if your client
     is on a different machine than the database server.
    </para>
-->
<para>
   这就意味着你的客户端应用必须把每条命令发送到数据库服务器，
   等待它处理这个命令，接收结果，对结果进行一些处理，
   然后再给服务器发送另外一条命令。
   所有这些东西都会产生进程间通讯，
   并且如果你的客户端在另外一台机器上甚至还会产生网络开销。
</para>

    <!--
<para>
     With <application>PL/pgSQL</application> you can group a block of
     computation and a series of queries <emphasis>inside</emphasis>
     the database server, thus having the power of a procedural
     language and the ease of use of SQL, but with considerable
     savings of client/server communication overhead.
    </para>
-->
<para>
   通过<application>PL/pgSQL</application>，可以把运算块和一系列命令在数据库服务器<emphasis>内部</emphasis>组成一个块，
   这样就拥有了过程语言的能力并且简化 SQL 的使用，
   因而节约了大量的时间，因为不需要进行客户端/服务器通讯。
</para>
    <itemizedlist>

     <listitem><!--
<para> Extra round trips between
     client and server are eliminated </para>
-->
<para>
   忽略了客户端和服务器端之间的额外往返行程。
</para></listitem>

     <listitem><!--
<para> Intermediate results that the client does not
     need do not have to be marshaled or transferred between server
     and client </para>
-->
<para>
   客户端不需要的中间结果无需在服务器端和客户端来回传递。
</para></listitem>

     <listitem><!--
<para> Multiple rounds of query
     parsing can be avoided </para>
-->
<para>
    不需要多次语法分析步骤。
</para></listitem>

    </itemizedlist>
    <!--
<para> This can result in a considerable performance increase as
    compared to an application that does not use stored functions.
    </para>
-->
<para>
    比起不使用存储函数来，这样做能够产生明显的性能提升。
</para>

    <!--
<para>
     Also, with <application>PL/pgSQL</application> you can use all
     the data types, operators and functions of SQL.
    </para>
-->
<para>
   同样，在<application>PL/pgSQL</application>里，仍然可以使用SQL的所有数据类型，操作符和函数。
</para>
  </sect2>

  <sect2 id="plpgsql-args-results">
  <!--
   <title>Supported Argument and Result Data Types</title>
   -->
   <title>支持的参数和结果数据类型</title>

    <!--
<para>
     Functions written in <application>PL/pgSQL</application> can accept
     as arguments any scalar or array data type supported by the server,
     and they can return a result of any of these types.  They can also
     accept or return any composite type (row type) specified by name.
     It is also possible to declare a <application>PL/pgSQL</application>
     function as returning <type>record</>, which means that the result
     is a row type whose columns are determined by specification in the
     calling query, as discussed in <xref linkend="queries-tablefunctions">.
    </para>
-->
<para>
   使用<application>PL/pgSQL</application>所写的函数能够接受服务器支持的任何标量或数组数据类型作为参数，
   并且同样能够返回这些类型的结果，
   它们还可以接受或者返回任意用名字声明的复合类型(行类型)。
   还可以将一个<application>PL/pgSQL</application>函数声明为一个返回<type>record</>类型(行类型)，
   表明该结果是一个行类型，这个行的字段是在调用它的查询中指定的，
   就像在<xref linkend="queries-tablefunctions">里讨论的那样。
</para>

    <!--
<para>
     <application>PL/pgSQL</> functions can be declared to accept a variable
     number of arguments by using the <literal>VARIADIC</> marker.  This
     works exactly the same way as for SQL functions, as discussed in
     <xref linkend="xfunc-sql-variadic-functions">.
    </para>
-->
<para>
    与声明SQL函数一样，通过使用<literal>VARIADIC</>可以对<application>PL/pgSQL</>
进行声明为能接受可变数目的参数。
正如在<xref linkend="xfunc-sql-variadic-functions">中讨论的那样。
</para>

    <!--
<para>
     <application>PL/pgSQL</> functions can also be declared to accept
     and return the polymorphic types
     <type>anyelement</type>, <type>anyarray</type>, <type>anynonarray</type>,
     <type>anyenum</>, and <type>anyrange</type>.  The actual
     data types handled by a polymorphic function can vary from call to
     call, as discussed in <xref linkend="extend-types-polymorphic">.
     An example is shown in <xref linkend="plpgsql-declaration-parameters">.
    </para>
-->
<para>
    <application>PL/pgSQL</>函数还可以声明为接受并返回多态的
<type>anyelement</type>, <type>anyarray</type>, <type>anynonarray</type>,
     <type>anyenum</>和<type>anyrange</type>类型。
一个多态函数实际操作的数据类型可以在不同的调用环境中变化，
如在<xref linkend="extend-types-polymorphic">里讨论的那样。
<xref linkend="plpgsql-declaration-parameters">是一个使用例子。
</para>

    <!--
<para>
     <application>PL/pgSQL</> functions can also be declared to return
     a <quote>set</> (or table) of any data type that can be returned as
     a single instance.  Such a function generates its output by executing
     <command>RETURN NEXT</> for each desired element of the result
     set, or by using <command>RETURN QUERY</> to output the result of
     evaluating a query.
    </para>
-->
<para>
   <application>PL/pgSQL</>还可以声明为任何一个单个实例返回的数据类型<quote>set</>，或者表。
   这样的函数通过为结果集每个需要返回的元素执行一个<command>RETURN NEXT</>生成它的输出，
   或者通过使用<command>RETURN QUERY</>来输出评估查询的结果。
</para>

    <!--
<para>
     Finally, a <application>PL/pgSQL</> function can be declared to return
     <type>void</> if it has no useful return value.
    </para>
-->
<para>
    最后，如果返回的结果没有太大的价值，<application>PL/pgSQL</>函数可以声明为返回<type>void</>。
</para>

    <!--
<para>
     <application>PL/pgSQL</> functions can also be declared with output
     parameters in place of an explicit specification of the return type.
     This does not add any fundamental capability to the language, but
     it is often convenient, especially for returning multiple values.
     The <literal>RETURNS TABLE</> notation can also be used in place
     of <literal>RETURNS SETOF</>.
    </para>
-->
<para>
   <application>PL/pgSQL</>函数也可以声明为输出某种类型的参数，
   来代替明确的返回类型声明。 这么做并未给该语言增加任何基础设施，
   只是通常更方便些，特别是返回多行数值的时候。同时，
   也可以用<literal>RETURNS TABLE</>来代替<literal>RETURNS SETOF</>。 
</para>

    <!--
<para>
     Specific examples appear in
     <xref linkend="plpgsql-declaration-parameters"> and
     <xref linkend="plpgsql-statements-returning">.
    </para>
-->
<para>
    具体的例子在<xref linkend="plpgsql-declaration-parameters">和
     <xref linkend="plpgsql-statements-returning">中。
</para>
  </sect2>
 </sect1>

 <sect1 id="plpgsql-structure">
 <!--
  <title>Structure of <application>PL/pgSQL</application></title>
 -->
  <title><application>PL/pgSQL</application>的结构</title>

 
<para>
    <!--
   <application>PL/pgSQL</application> is a block-structured language.
   The complete text of a function definition must be a
   <firstterm>block</>. A block is defined as:
   -->
   <application>PL/pgSQL</application>是一种块结构的语言。
   函数定义的所有文本都必须是一个块（<firstterm>block</>）。
   可以用下面的方法定义一个块：
   
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
<optional> DECLARE
    <replaceable>declarations</replaceable> </optional>
BEGIN
    <replaceable>statements</replaceable>
END <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
    </para>

    <!--
<para>
     Each declaration and each statement within a block is terminated
     by a semicolon.  A block that appears within another block must
     have a semicolon after <literal>END</literal>, as shown above;
     however the final <literal>END</literal> that
     concludes a function body does not require a semicolon.
    </para>
-->
<para>
    块中的每个声明和每条语句都是用一个分号终止的，
如果一个子块在另外一个块里，那么<literal>END</literal>后面必须有个分号，如上所述；
不过结束函数体的最后的<literal>END</literal>可以不要这个分号。
</para>

    <tip>
     <!--
<para>
      A common mistake is to write a semicolon immediately after
      <literal>BEGIN</>.  This is incorrect and will result in a syntax error.
     </para>
-->
<para>
   一个常见的错误是紧跟在<literal>BEGIN</>之后使用一个分号，
   这是不正确的，并且会返回一个语法错误。
</para>
    </tip>

    <!--
<para>
     A <replaceable>label</replaceable> is only needed if you want to
     identify the block for use
     in an <literal>EXIT</> statement, or to qualify the names of the
     variables declared in the block.  If a label is given after
     <literal>END</>, it must match the label at the block's beginning.
    </para>
-->
<para>
   如果你想标记出在<literal>EXIT</>声明中的block，或者描述在block中所声明的变量名字，
   此时，可以选择使用<replaceable>label</replaceable>。如果是在<literal>END</>之后给出一个标签，那么，
   它必须与block开始时定义的标签相匹配。
</para>

    <!--
<para>
     All key words are case-insensitive.
     Identifiers are implicitly converted to lower case
     unless double-quoted, just as they are in ordinary SQL commands.
    </para>
-->
<para>
   所有的关键字都是不区分大小写的，正如在SQL命令中一样，
   会隐式的将其转换成小写，除非是使用双引号。   
</para>

    <!--
<para>
     Comments work the same way in <application>PL/pgSQL</> code as in
     ordinary SQL.  A double dash (<literal>&#045;-</literal>) starts a comment
     that extends to the end of the line. A <literal>/*</literal> starts a
     block comment that extends to the matching occurrence of
     <literal>*/</literal>.  Block comments nest.
    </para>
-->
<para>
   如同在普通的SQL语句中一样，在<application>PL/pgSQL</>代码中，用同样的方式定义注释：
   在语句的最后，通过一个双破折号(<literal>--</literal>)来开始一条行注释。
   而块注释是成对出现的，
   通过<literal>/*</literal>和<literal>*/</literal>来定义。
</para>

    <para>
<!--
     Any statement in the statement section of a block
     can be a <firstterm>subblock</>.  Subblocks can be used for
     logical grouping or to localize variables to a small group
     of statements.  Variables declared in a subblock mask any
     similarly-named variables of outer blocks for the duration
     of the subblock; but you can access the outer variables anyway
     if you qualify their names with their block's label. For example:
 -->
 块语句段里的任何语句都可以是一个<firstterm>子块</>。子块可以用于逻辑
 分组或者把变量局部化为作用于一个较小的语句组。为了子块的持续时间任何同样命名的外部子块的变量在子块中声明变量，
 但是如果你符合它们的名字和它们子块标签，无论如何你可以访问外部变量，比如：
 
<programlisting>
CREATE FUNCTION somefunc() RETURNS integer AS $$
&lt;&lt; outerblock &gt;&gt;
DECLARE
    quantity integer := 30;
BEGIN
    <!--
    RAISE NOTICE 'Quantity here is %', quantity;  &#045;- Prints 30
-->
RAISE NOTICE 'Quantity here is %', quantity;  -- 在这里的数量是30
    quantity := 50;
    --
<!--
    &#045;- Create a subblock
-->
-- 创建一个子块
    --
    DECLARE
        quantity integer := 80;
    BEGIN
    <!--
        RAISE NOTICE 'Quantity here is %', quantity;  &#045;- Prints 80
        RAISE NOTICE 'Outer quantity here is %', outerblock.quantity;  &#045;- Prints 50
-->
RAISE NOTICE 'Quantity here is %', quantity;  -- 在这里的数量是80
        RAISE NOTICE 'Outer quantity here is %', outerblock.quantity;  -- 在这里的数量是50
    END;
    <!--
    RAISE NOTICE 'Quantity here is %', quantity;  &#045;- Prints 50
    -->
RAISE NOTICE 'Quantity here is %', quantity;  -- 在这里的数量是50

    RETURN quantity;
END;
$$ LANGUAGE plpgsql;
</programlisting>
    </para>
    <note>
     <!--
<para>
      There is actually a hidden <quote>outer block</> surrounding the body
      of any <application>PL/pgSQL</> function.  This block provides the
      declarations of the function's parameters (if any), as well as some
      special variables such as <literal>FOUND</literal> (see
      <xref linkend="plpgsql-statements-diagnostics">).  The outer block is
      labeled with the function's name, meaning that parameters and special
      variables can be qualified with the function's name.
     </para>
-->
<para>
    在任何<application>PL/pgSQL</>函数主体周围有隐藏的<quote>外部块</>。
这个块提供了函数参数的声明（如果有），以及一些特殊变量比如 <literal>FOUND</literal> 
(参阅<xref linkend="plpgsql-statements-diagnostics">)。
外部块可以使用函数的名字标记，意味着参数和特殊变量可以满足函数名字。
</para>
    </note>

    <!--
<para>
     It is important not to confuse the use of
     <command>BEGIN</>/<command>END</> for grouping statements in
     <application>PL/pgSQL</> with the similarly-named SQL commands
     for transaction
     control.  <application>PL/pgSQL</>'s <command>BEGIN</>/<command>END</>
     are only for grouping; they do not start or end a transaction.
     Functions and trigger procedures are always executed within a transaction
     established by an outer query &mdash; they cannot start or commit that
     transaction, since there would be no context for them to execute in.
     However, a block containing an <literal>EXCEPTION</> clause effectively
     forms a subtransaction that can be rolled back without affecting the
     outer transaction.  For more about that see <xref
     linkend="plpgsql-error-trapping">.
    </para>
-->
<para>
    一定不要把<application>PL/pgSQL</>里用于语句分组的<command>BEGIN</>/<command>END</>和用于事务控制的数据库命令搞混了。
<application>PL/pgSQL</>的<command>BEGIN</>/<command>END</>只是用于分组；它们不会开始和结束一个事务。 
函数和触发器过程总是在一个由外层命令建立起来的事务里执行，
它们无法开始或者提交事务，因为PostgreSQL没有嵌套事务。
不过，一个包含<literal>EXCEPTION</>子句的块实际上形成一个子事务，
它可以在不影响外层事务的情况下回滚。更多相关信息请参阅<xref linkend="plpgsql-error-trapping">。
</para>
  </sect1>

  <sect1 id="plpgsql-declarations">
  <!--
    <title>Declarations</title>
  -->
     <title>声明</title>

    <!--
<para>
     All variables used in a block must be declared in the
     declarations section of the block.
     (The only exceptions are that the loop variable of a <literal>FOR</> loop
     iterating over a range of integer values is automatically declared as an
     integer variable, and likewise the loop variable of a <literal>FOR</> loop
     iterating over a cursor's result is automatically declared as a
     record variable.)
    </para>
-->
<para>
   所有在块里使用的变量都必须在一个块的声明段里声明。
   唯一的例外是一个<literal>FOR</>循环里的循环变量是在一个整数范围内迭代的，
   被自动声明为整数变量。并且同样从游标结果中<literal>FOR</>循环迭代的循环变量自动被声明为记录变量。

</para>

    <!--
<para>
     <application>PL/pgSQL</> variables can have any SQL data type, such as
     <type>integer</type>, <type>varchar</type>, and
     <type>char</type>.
    </para>
-->
<para>
   <application>PL/pgSQL</>变量可以使用任意的SQL数据类型，比如<type>integer</type>, 
   <type>varchar</type>和<type>char</type>等等。
</para>

    
<para>
    <!--
     Here are some examples of variable declarations:
 -->
下面是一些变量声明的例子： 
<programlisting>
user_id integer;
quantity numeric(5);
url varchar;
myrow tablename%ROWTYPE;
myfield tablename.columnname%TYPE;
arow RECORD;
</programlisting>
    </para>

    
<para>
     <!--
     The general syntax of a variable declaration is:
 -->
 一个变量声明的一般性语法是:
 
<synopsis>
<replaceable>name</replaceable> <optional> CONSTANT </optional> <replaceable>type</replaceable> <optional> COLLATE <replaceable>collation_name</replaceable> </optional> <optional> NOT NULL </optional> <optional> { DEFAULT | := } <replaceable>expression</replaceable> </optional>;
</synopsis>
     <!--
      The <literal>DEFAULT</> clause, if given, specifies the initial value assigned
      to the variable when the block is entered.  If the <literal>DEFAULT</> clause
      is not given then the variable is initialized to the
      <acronym>SQL</acronym> null value.
      The <literal>CONSTANT</> option prevents the variable from being
      assigned to after initialization, so that its value will remain constant
      for the duration of the block.
      The <literal>COLLATE</> option specifies a collation to use for the
      variable (see <xref linkend="plpgsql-declaration-collation">).
      If <literal>NOT NULL</>
      is specified, an assignment of a null value results in a run-time
      error. All variables declared as <literal>NOT NULL</>
      must have a nonnull default value specified.
  -->
  如果给出了<literal>DEFAULT</>子句，那么它声明了在进入该块的时候赋予该变量的初始值。
  如果没有给出<literal>DEFAULT</>子句，那么该变量初始化为<acronym>SQL</acronym> NULL。
  <literal>CONSTANT</>选项避免了该变量被赋值，这样其数值在该块的范围内保持常量。
  <literal>COLLATE</>选项声明变量使用的排序规则（参见<xref linkend="plpgsql-declaration-collation">）。
  如果声明了<literal>NOT NULL</>，那么赋予NULL的数值将运行时导致错误。
  所以所有声明为<literal>NOT NULL</>的变量还必须声明一个非空的缺省值。
     </para>

     <!--
<para>
      A variable's default value is evaluated and assigned to the variable
      each time the block is entered (not just once per function call).
      So, for example, assigning <literal>now()</literal> to a variable of type
      <type>timestamp</type> causes the variable to have the
      time of the current function call, not the time when the function was
      precompiled.
     </para>
-->
<para>
     缺省值是在每次进入该块的时候计算的，而不是每次调用函数时。
 因此，如果把<literal>now()</literal>赋予一个类型为<type>timestamp</type>的变量会令变量拥有函数实际调用的时间，
 而不是函数预编译的时间。
</para>

     
<para>
    <!--
      Examples:
-->
例如：
<programlisting>
quantity integer DEFAULT 32;
url varchar := 'http://mysite.com';
user_id CONSTANT integer := 10;
</programlisting>
     </para>


    <sect2 id="plpgsql-declaration-parameters">
<!--
     <title>Declaring Function Parameters</title>
-->
 <title>声明函数参数</title>

     <!--
<para>
      Parameters passed to functions are named with the identifiers
      <literal>$1</literal>, <literal>$2</literal>,
      etc.  Optionally, aliases can be declared for
      <literal>$<replaceable>n</replaceable></literal>
      parameter names for increased readability.  Either the alias or the
      numeric identifier can then be used to refer to the parameter value.
     </para>
-->
<para>
    传递给函数的参数都是用<literal>$1</literal>, <literal>$2</literal>等等这样的标识符。
为了增加可读性，可以为<literal>$<replaceable>n</replaceable></literal>参数名声明别名。
然后别名或者数字标识符都可以指向参数值。
</para>

     
<para>
     <!--
      There are two ways to create an alias.  The preferred way is to give a
      name to the parameter in the <command>CREATE FUNCTION</command> command,
      for example:
-->
有两种创建别名的方法，比较好的是在<command>CREATE FUNCTION</command>命令里给出参数名，比如：
<programlisting>
CREATE FUNCTION sales_tax(subtotal real) RETURNS real AS $$
BEGIN
    RETURN subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;
</programlisting>
    <!--
      The other way, which was the only way available before
      <productname>PostgreSQL</productname> 8.0, is to explicitly
      declare an alias, using the declaration syntax
    -->
另外一个方法（也是<productname>PostgreSQL</productname> 8.0以前的唯一的方法），
是使用声明语法明确声明别名：
<synopsis>
<replaceable>name</replaceable> ALIAS FOR $<replaceable>n</replaceable>;
</synopsis>
     <!--
      The same example in this style looks like:
 -->
 这个风格的同一个例子看起来像下面这样：
<programlisting>
CREATE FUNCTION sales_tax(real) RETURNS real AS $$
DECLARE
    subtotal ALIAS FOR $1;
BEGIN
    RETURN subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>

    <note>
     <!--
<para>
      These two examples are not perfectly equivalent.  In the first case,
      <literal>subtotal</> could be referenced as
      <literal>sales_tax.subtotal</>, but in the second case it could not.
      (Had we attached a label to the inner block, <literal>subtotal</> could
      be qualified with that label, instead.)
     </para>
-->
<para>
   这两个例子的作用不是完全一致的。
   在第一个例子中，<literal>subtotal</>可以作为<literal>sales_tax.subtotal</>被引用，
   而在第二个例子中是不可以的。（我们在内部块中附加标签，反而<literal>subtotal</>符合这个标签）。
</para>
    </note>

     
<para>
     <!--
      Some more examples:
  -->
  更多例子：
<programlisting>
CREATE FUNCTION instr(varchar, integer) RETURNS integer AS $$
DECLARE
    v_string ALIAS FOR $1;
    index ALIAS FOR $2;
BEGIN
    <!--
    &#045;- some computations using v_string and index here
-->
这里放一些使用 v_string 和 index 的计算
END;
$$ LANGUAGE plpgsql;


CREATE FUNCTION concat_selected_fields(in_t sometablename) RETURNS text AS $$
BEGIN
    RETURN in_t.f1 || in_t.f3 || in_t.f5 || in_t.f7;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>

     
<para>
     <!--
      When a <application>PL/pgSQL</application> function is declared
      with output parameters, the output parameters are given
      <literal>$<replaceable>n</replaceable></literal> names and optional
      aliases in just the same way as the normal input parameters.  An
      output parameter is effectively a variable that starts out NULL;
      it should be assigned to during the execution of the function.
      The final value of the parameter is what is returned.  For instance,
      the sales-tax example could also be done this way:
    -->
如果一个<application>PL/pgSQL</application>函数声明中含有输出参数，
那么就会给予输出参数<literal>$<replaceable>n</replaceable></literal>的名字以及可选的别名，
方法和其它正常输入参数一样。一个输出参数实际上是初始值为 NULL 的变量；
在函数执行的过程中，应该给它赋值。
该参数的最后数值是返回的东西。比如，
销售额-税费的例子也可以这么做:

<programlisting>
CREATE FUNCTION sales_tax(subtotal real, OUT tax real) AS $$
BEGIN
    tax := subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;
</programlisting>
      <!--
      Notice that we omitted <literal>RETURNS real</> &mdash; we could have
      included it, but it would be redundant.
  -->
  请注意忽略了<literal>RETURNS real</> &mdash;当然也可以包含它，不过这样就显得多余了。
     </para>

     
<para>
     <!--
      Output parameters are most useful when returning multiple values.
      A trivial example is:
     -->
 输出参数在返回多个数值的时候非常有用。一个简单的例子是：
<programlisting>
CREATE FUNCTION sum_n_product(x int, y int, OUT sum int, OUT prod int) AS $$
BEGIN
    sum := x + y;
    prod := x * y;
END;
$$ LANGUAGE plpgsql;
</programlisting>
      <!--
      As discussed in <xref linkend="xfunc-output-parameters">, this
      effectively creates an anonymous record type for the function's
      results.  If a <literal>RETURNS</> clause is given, it must say
      <literal>RETURNS record</>.
  -->
  正如在<xref linkend="xfunc-output-parameters">里面讨论的，  这样做实际上为函数的结果创建了一个匿名的记录类型。如果给出一个
  <literal>RETURNS</>子句，那么它就必须使用
  <literal>RETURNS record</>。
     </para>

     
<para>
     <!--
      Another way to declare a <application>PL/pgSQL</application> function
      is with <literal>RETURNS TABLE</>, for example:
     -->
 另一个声明<application>PL/pgSQL</application>函数的方法是使用
 <literal>RETURNS TABLE</>，例如：
<programlisting>
CREATE FUNCTION extended_sales(p_itemno int)
RETURNS TABLE(quantity int, total numeric) AS $$
BEGIN
    RETURN QUERY SELECT quantity, quantity * price FROM sales
                 WHERE itemno = p_itemno;
END;
$$ LANGUAGE plpgsql;
</programlisting>
      <!--
      This is exactly equivalent to declaring one or more <literal>OUT</>
      parameters and specifying <literal>RETURNS SETOF
      <replaceable>sometype</></literal>.
  -->
  这完全等价于声明一个或多个<literal>OUT</>参数，
  并且声明<literal>RETURNS SETOF<replaceable>sometype</></literal>。
     </para>

     
<para>
     <!--
      When the return type of a <application>PL/pgSQL</application>
      function is declared as a polymorphic type (<type>anyelement</type>,
      <type>anyarray</type>, <type>anynonarray</type>, <type>anyenum</type>,
      or <type>anyrange</type>), a special parameter <literal>$0</literal>
      is created.  Its data type is the actual return type of the function,
      as deduced from the actual input types (see <xref
      linkend="extend-types-polymorphic">).
      This allows the function to access its actual return type
      as shown in <xref linkend="plpgsql-declaration-type">.
      <literal>$0</literal> is initialized to null and can be modified by
      the function, so it can be used to hold the return value if desired,
      though that is not required.  <literal>$0</literal> can also be
      given an alias.  For example, this function works on any data type
      that has a <literal>+</> operator:
      -->
  如果将<application>PL/pgSQL</application>函数的返回类型声明为多态类型 (<type>anyelement</type>,
      <type>anyarray</type>, <type>anynonarray</type>, <type>anyenum</type>,
      或者<type>anyrange</type>), 那么就会创建一个特殊的<literal>$0</literal>参数， 它的数据类型是函数的实际返回类型， 和从实际输入类型的推导类型一样
  (参阅<xref linkend="extend-types-polymorphic">)。这样就允许函数像
  <xref linkend="plpgsql-declaration-type">里显示的那样访问它的实际返回类型。 <literal>$0</literal>初始化为空，并且可以被函数修改， 所以，如果需要，它可以用于保存返回值，虽然这并非必须。 <literal>$0</literal>还可以给予一个别名。 比如，这个函数可以在任何有<literal>+</>操作符的数据类型上运转：
  
<programlisting>
CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement)
RETURNS anyelement AS $$
DECLARE
    result ALIAS FOR $0;
BEGIN
    result := v1 + v2 + v3;
    RETURN result;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>

     
<para>
     <!--
      The same effect can be had by declaring one or more output parameters as
      polymorphic types.  In this case the
      special <literal>$0</literal> parameter is not used; the output
      parameters themselves serve the same purpose.  For example:
     -->
 通过将一个或多个输出参数声明为多态类型，可以达到相同的效果。 在这种情况下，特殊的参数<literal>$0</literal>不会使用；输出参数自己起这个作用。比如：
<programlisting>
CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement,
                                 OUT sum anyelement)
AS $$
BEGIN
    sum := v1 + v2 + v3;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>

    </sect2>

  <sect2 id="plpgsql-declaration-alias">
  <!--
   <title><literal>ALIAS</></title>
  -->
   <title><literal>别名</></title>
<synopsis>
<replaceable>newname</> ALIAS FOR <replaceable>oldname</>;
</synopsis>

   <!--
<para>
    The <literal>ALIAS</> syntax is more general than is suggested in the
    previous section: you can declare an alias for any variable, not just
    function parameters.  The main practical use for this is to assign
    a different name for variables with predetermined names, such as
    <varname>NEW</varname> or <varname>OLD</varname> within
    a trigger procedure.
   </para>
-->
<para>
   <literal>别名</>语法比在之前章节提到的更普遍：可以为任何一个参数声明别名，而不仅仅只是对函数。
 这样做的主要目的是为已经有名字的参数重新定义一个名字，例如触发器中的<varname>NEW</varname> 或者<varname>OLD</varname>。
</para>

   
<para>
   <!--
    Examples:
-->
例如：
<programlisting>
DECLARE
  prior ALIAS FOR old;
  updated ALIAS FOR new;
</programlisting> 
   </para>

   <!--
<para>
    Since <literal>ALIAS</> creates two different ways to name the same
    object, unrestricted use can be confusing.  It's best to use it only
    for the purpose of overriding predetermined names.
   </para>
-->
<para>
   由于<literal>ALIAS</>创建了两种不同的方式来命名相同的对象，因此，无限制的使用会造成混淆。 最好是在重写预定名称时使用。
</para>
   </sect2>

  <sect2 id="plpgsql-declaration-type">
  <!--
   <title>Copying Types</title>
  -->
   <title>拷贝类型</title>
<synopsis>
<replaceable>variable</replaceable>%TYPE
</synopsis>

   
<para>
    <!--
    <literal>%TYPE</literal> provides the data type of a variable or
    table column. You can use this to declare variables that will hold
    database values. For example, let's say you have a column named
    <literal>user_id</literal> in your <literal>users</literal>
    table. To declare a variable with the same data type as
    <literal>users.user_id</> you write:
-->
<literal>%TYPE</literal>提供一个变量或者表字段的数据类型。 你可以用这个声明将要保存数据库数值的变量。比如，假如你
在<literal>users</literal>表里面有一个<literal>user_id</literal>字段。 要声明一个和<literal>users.user_id</>类型相同的变量，可以这样写：
<programlisting>
user_id users.user_id%TYPE;
</programlisting>
   </para>

   <!--
<para>
    By using <literal>%TYPE</literal> you don't need to know the data
    type of the structure you are referencing, and most importantly,
    if the data type of the referenced item changes in the future (for
    instance: you change the type of <literal>user_id</>
    from <type>integer</type> to <type>real</type>), you might not need
    to change your function definition.
   </para>
-->
<para>
   通过使用<literal>%TYPE</literal>，你无需知道引用的结构的数据类型，并且，最重要的是， 如果被引用项的数据类型在将来变化了(比如把<literal>user_id</>的类型从<type>integer</type> 改成<type>real</type>)，也不需要修改函数定义。
</para>

   <!--
<para>
    <literal>%TYPE</literal> is particularly valuable in polymorphic
    functions, since the data types needed for internal variables can
    change from one call to the next.  Appropriate variables can be
    created by applying <literal>%TYPE</literal> to the function's
    arguments or result placeholders.
   </para>
-->
<para>
<literal>%TYPE</literal>对多态函数特别有用，因为内部变量的数据类型可能在不同调用中不一样。 可以通过给函数的参数或者结果占位符附加<literal>%TYPE</literal>的方法来创建合适的变量。
</para>

  </sect2>

    <sect2 id="plpgsql-declaration-rowtypes">
<!--
     <title>Row Types</title>
 -->
 <title>行类型</title>

<synopsis>
<replaceable>name</replaceable> <replaceable>table_name</replaceable><literal>%ROWTYPE</literal>;
<replaceable>name</replaceable> <replaceable>composite_type_name</replaceable>;
</synopsis>

   <!--
<para>
    A variable of a composite type is called a <firstterm>row</>
    variable (or <firstterm>row-type</> variable).  Such a variable
    can hold a whole row of a <command>SELECT</> or <command>FOR</>
    query result, so long as that query's column set matches the
    declared type of the variable.
    The individual fields of the row value
    are accessed using the usual dot notation, for example
    <literal>rowvar.field</literal>.
   </para>
-->
<para>
   一个复合类型变量叫做<firstterm>行</>变量(或者<firstterm>row-type</>变量)。 这样的一个变量可以保存一次<command>SELECT</>或者<command>FOR</>命令结果的完整一行， 只要命令的字段集匹配该变量声明的类型。
   行数值的字段使用点表示法访问，比如<literal>rowvar.field</literal>。
</para>

   <!--
<para>
    A row variable can be declared to have the same type as the rows of
    an existing table or view, by using the
    <replaceable>table_name</replaceable><literal>%ROWTYPE</literal>
    notation; or it can be declared by giving a composite type's name.
    (Since every table has an associated composite type of the same name,
    it actually does not matter in <productname>PostgreSQL</> whether you
    write <literal>%ROWTYPE</literal> or not.  But the form with
    <literal>%ROWTYPE</literal> is more portable.)
   </para>
-->
<para>
    行变量可以声明为和一个现有的表或者视图的行类型相同， 方法是使用<replaceable>table_name</replaceable><literal>%ROWTYPE</literal>表示法； 或者你也可以声明它的类型是一个复合类型的名字。 因为每个表都有一个相关联的同名数据类型，在<productname>PostgreSQL</>里实在是无所谓你写不写<literal>%ROWTYPE</literal>。但是有<literal>%ROWTYPE</literal>的形式移植性更好。
</para>

   <!--
<para>
    Parameters to a function can be
    composite types (complete table rows). In that case, the
    corresponding identifier <literal>$<replaceable>n</replaceable></> will be a row variable, and fields can
    be selected from it, for example <literal>$1.user_id</literal>.
   </para>
-->
<para>
   函数的参数可以是复合类型(表的完整行)。 这个时候，对应的标识符<literal>$<replaceable>n</replaceable></>将是一个行变量， 并且可以从中选取字段，比如<literal>$1.user_id</literal>。
</para>

   <!--
<para>
    Only the user-defined columns of a table row are accessible in a
    row-type variable, not the OID or other system columns (because the
    row could be from a view).  The fields of the row type inherit the
    table's field size or precision for data types such as
    <type>char(<replaceable>n</>)</type>.
   </para>
-->
<para>
   在一个行类型的变量中，只可以访问用户定义的表中行的属性，不包括OID 或者其它系统属性(因为该行可能来自一个视图)。 该行类型的数据域继承表中像<type>char(<replaceable>n</>)</type>
   这种类型字段的尺寸和精度。
</para>

   
<para>
   <!--
    Here is an example of using composite types.  <structname>table1</>
    and <structname>table2</> are existing tables having at least the
    mentioned fields:
    -->
这里是一个使用复合类型的例子。<structname>table1</>
    和<structname>table2</>是现有的表，至少包含代码中提到的字段：

<programlisting>
CREATE FUNCTION merge_fields(t_row table1) RETURNS text AS $$
DECLARE
    t2_row table2%ROWTYPE;
BEGIN
    SELECT * INTO t2_row FROM table2 WHERE ... ;
    RETURN t_row.f1 || t2_row.f3 || t_row.f5 || t2_row.f7;
END;
$$ LANGUAGE plpgsql;

SELECT merge_fields(t.*) FROM table1 t WHERE ... ;
</programlisting>
   </para>

  </sect2>

  <sect2 id="plpgsql-declaration-records">
  <!--
   <title>Record Types</title>
  -->
   <title>记录类型</title>

<synopsis>
<replaceable>name</replaceable> RECORD;
</synopsis>

   <!--
<para>
    Record variables are similar to row-type variables, but they have no
    predefined structure.  They take on the actual row structure of the
    row they are assigned during a <command>SELECT</> or <command>FOR</> command.  The substructure
    of a record variable can change each time it is assigned to.
    A consequence of this is that until a record variable is first assigned
    to, it has no substructure, and any attempt to access a
    field in it will draw a run-time error.
   </para>
-->
<para>
   纪录变量类似行类型变量，但是它们没有预定义的结构。它们在<command>SELECT</> 或者<command>FOR</>命令中获取实际的行结构。 一个行变量的子结构可以在每次赋值的时候改变。 这样做的一个结果是：在一个记录变量被赋予数值之前，它没有子结构， 并且任何对其中的数据域进行访问的企图都将产生一个运行时错误。
</para>

   <!--
<para>
    Note that <literal>RECORD</> is not a true data type, only a placeholder.
    One should also realize that when a <application>PL/pgSQL</application>
    function is declared to return type <type>record</>, this is not quite the
    same concept as a record variable, even though such a function might
    use a record variable to hold its result.  In both cases the actual row
    structure is unknown when the function is written, but for a function
    returning <type>record</> the actual structure is determined when the
    calling query is parsed, whereas a record variable can change its row
    structure on-the-fly.
   </para>
-->
<para>
    请注意，<literal>RECORD</>不是真正的数据类型，只是一个占位符。 还应该意识到在把一个<application>PL/pgSQL</application>函数声明为返回<type>record</>类型的时候，它和一个记录变量的概念并不完全相同， 即使这个函数可能使用一个记录变量保存它的结果也如此。 在这两种情况下书写函数的时候，实际的行结构都是未知的， 但是对于返回<type>record</>的函数来说， 实际的结构是在调用它的查询被分析的时候决定的，而行变量可以在运行中改变其行结构。

</para>
  </sect2>

  <sect2 id="plpgsql-declaration-collation">
  <!--
   <title>Collation of <application>PL/pgSQL</application> Variables</title>
  -->
   <title><application>PL/pgSQL</application>变量的排序规则</title>

   <indexterm>
    <primary>collation</>
    <secondary>in PL/pgSQL</>
   </indexterm>

   
<para>
    <!--
    When a <application>PL/pgSQL</application> function has one or more
    parameters of collatable data types, a collation is identified for each
    function call depending on the collations assigned to the actual
    arguments, as described in <xref linkend="collation">.  If a collation is
    successfully identified (i.e., there are no conflicts of implicit
    collations among the arguments) then all the collatable parameters are
    treated as having that collation implicitly.  This will affect the
    behavior of collation-sensitive operations within the function.
    For example, consider
    -->
当<application>PL/pgSQL</application>函数有排序规则数据类型的一个以上的参数时，
排序规则确定每个函数调用依赖于分配给实际参数的排序规则，正如<xref linkend="collation">。
如果排序规则成功被识别（比如，在这些参数之间没有隐式排序规则冲突），那么所有
排序规则参数作为有隐式排序规则对待。
这将影响函数内部排序规则敏感操作行为。比如，考虑：

<programlisting>
CREATE FUNCTION less_than(a text, b text) RETURNS boolean AS $$
BEGIN
    RETURN a &lt; b;
END;
$$ LANGUAGE plpgsql;

SELECT less_than(text_field_1, text_field_2) FROM table1;
SELECT less_than(text_field_1, text_field_2 COLLATE "C") FROM table1;
</programlisting>
    <!--
    The first use of <function>less_than</> will use the common collation
    of <structfield>text_field_1</> and <structfield>text_field_2</> for
    the comparison, while the second use will use <literal>C</> collation.
-->
<function>less_than</>的第一次使用出于比较将使用<structfield>text_field_1</>和
<structfield>text_field_2</>的通用排序规则，然而第二次使用将使用<literal>C</>
排序规则。
   </para>

   
<para>
    <!--
    Furthermore, the identified collation is also assumed as the collation of
    any local variables that are of collatable types.  Thus this function
    would not work any differently if it were written as
    -->
此外，被识别的排序规则也被假定为任何局部变量是collatable类型的排序规则。 
因此这个函数没有任何不同，如果它被写为：

<programlisting>
CREATE FUNCTION less_than(a text, b text) RETURNS boolean AS $$
DECLARE
    local_a text := a;
    local_b text := b;
BEGIN
    RETURN local_a &lt; local_b;
END;
$$ LANGUAGE plpgsql;
</programlisting>
   </para>


   <!--
<para>
    If there are no parameters of collatable data types, or no common
    collation can be identified for them, then parameters and local variables
    use the default collation of their data type (which is usually the
    database's default collation, but could be different for variables of
    domain types).
   </para>
-->
<para>
     如果没有collatable数据类型的参数，或者没有通用排序规则可以识别他们，那么参数和局部变量
 使用数据类型的缺省排序规则（这往往是数据库的缺省排序规则，但是可能不同于域类型变量）。
</para>

   
<para>
    <!--
    A local variable of a collatable data type can have a different collation
    associated with it by including the <literal>COLLATE</> option in its
    declaration, for example
-->
collatable数据类型的局部变量可以有与声明中包含<literal>COLLATE</>选项的相关联的不同排序规则。
比如，

<programlisting>
DECLARE
    local_a text COLLATE "en_US";
</programlisting>
    <!--
    This option overrides the collation that would otherwise be
    given to the variable according to the rules above.
-->
这个选项覆盖排序规则，否则按照上述规则给定变量。
   </para>

   
<para>
    <!--
    Also, of course explicit <literal>COLLATE</> clauses can be written inside
    a function if it is desired to force a particular collation to be used in
    a particular operation.  For example,
    -->
同时，如果期望强迫在特定操作中使用特定排序规则，当然明确的<literal>COLLATE</>子句可以写
在函数中。
<programlisting>
CREATE FUNCTION less_than_c(a text, b text) RETURNS boolean AS $$
BEGIN
    RETURN a &lt; b COLLATE "C";
END;
$$ LANGUAGE plpgsql;
</programlisting>
    <!--
    This overrides the collations associated with the table columns,
    parameters, or local variables used in the expression, just as would
    happen in a plain SQL command.
-->
这将重写与表列，参数，或者表达式中使用的局部变量相关联的排序规则，正如在纯SQL命令中一样。
   </para>

  </sect2>
  </sect1>

  <sect1 id="plpgsql-expressions">
  <!--
  <title>Expressions</title>
  -->
  <title>表达式</title>

    
<para>
    <!--
     All expressions used in <application>PL/pgSQL</application>
     statements are processed using the server's main
     <acronym>SQL</acronym> executor.  For example, when you write
     a <application>PL/pgSQL</application> statement like
 -->
 所有在<application>PL/pgSQL</application>语句里使用的表达式都是用服务器的普通
 <acronym>SQL</acronym>执行器进行处理的。
 例如，当要写一个如下的<application>PL/pgSQL</application>声明时
<synopsis>
IF <replaceable>expression</replaceable> THEN ...
</synopsis>
     <!--
     <application>PL/pgSQL</application> will evaluate the expression by
     feeding a query like
 -->
 <application>PL/pgSQL</application>会通过在SQL引擎中输入类似下面的查询来计算表达式
 
<synopsis>
SELECT <replaceable>expression</replaceable>
</synopsis>
     <!--
     to the main SQL engine.  While forming the <command>SELECT</> command,
     any occurrences of <application>PL/pgSQL</application> variable names
     are replaced by parameters, as discussed in detail in
     <xref linkend="plpgsql-var-subst">.
     This allows the query plan for the <command>SELECT</command> to
     be prepared just once and then reused for subsequent
     evaluations with different values of the variables.  Thus, what
     really happens on first use of an expression is essentially a
     <command>PREPARE</> command.  For example, if we have declared
     two integer variables <literal>x</> and <literal>y</>, and we write
 -->
 一旦形成<command>SELECT</>命令，任何出现的<application>PL/pgSQL</application>变量名会由参数取代，
 正如在<xref linkend="plpgsql-var-subst">讨论的那样。 
 因此，只需要定义一次SELECT查询计划，
 之后可以重复使用。也就是说，第一次使用表达式时，
 本质上是生效的是<command>PREPARE</>命令。
 例如，我们声明两个整型变量<literal>x</>和<literal>y</>：
 
<programlisting>
IF x &lt; y THEN ...
</programlisting>
     <!--
     what happens behind the scenes is equivalent to
 -->
 后台实际执行的是：
<programlisting>
PREPARE <replaceable>statement_name</>(integer, integer) AS SELECT $1 &lt; $2;
</programlisting>
     <!--
     and then this prepared statement is <command>EXECUTE</>d for each
     execution of the <command>IF</> statement, with the current values
     of the <application>PL/pgSQL</application> variables supplied as
     parameter values.  Normally these details are
     not important to a <application>PL/pgSQL</application> user, but
     they are useful to know when trying to diagnose a problem.
     More information appears in <xref linkend="plpgsql-plan-caching">.
 -->
 并且，一条<command>EXECUTE</>说明语句会处于预备状态，
 以后每一次执行<command>IF</>语句时都会调用该说明语句，
 将当前<application>PL/pgSQL</application>变量的值提供为参数值。
 通常情况下，对于<application>PL/pgSQL</application>用户来说，
 这样做并不是特别重要，不过，
 当在进行错误诊断时，如果知道这一点的话会很有用。
 更多详细信息参阅<xref linkend="plpgsql-plan-caching">。
    </para>

  </sect1>

  <sect1 id="plpgsql-statements">
  <!--
  <title>Basic Statements</title>
  -->
  <title>基本语句</title>

   <!--
<para>
    In this section and the following ones, we describe all the statement
    types that are explicitly understood by
    <application>PL/pgSQL</application>.
    Anything not recognized as one of these statement types is presumed
    to be an SQL command and is sent to the main database engine to execute,
    as described in <xref linkend="plpgsql-statements-sql-noresult">
    and <xref linkend="plpgsql-statements-sql-onerow">.
   </para>
-->
<para>
   本节以及随后的一节里，
   描述所有<application>PL/pgSQL</application>明确可以理解的语句类型。
   任何无法识别为这样类型的语句将被做为SQL命令看待，
   并且被发送到主数据库引擎执行，
   正如在节<xref linkend="plpgsql-statements-sql-noresult">
    和<xref linkend="plpgsql-statements-sql-onerow">中描述的那样。
</para>

   <sect2 id="plpgsql-statements-assignment">
   <!--
    <title>Assignment</title>
   -->
   <title>赋值</title>

   
<para>
     <!--
     An assignment of a value to a <application>PL/pgSQL</application>
     variable is written as:
 -->
 
  给一个<application>PL/pgSQL</application>变量的赋值如下:
 
<synopsis>
<replaceable>variable</replaceable> := <replaceable>expression</replaceable>;
</synopsis>
     <!--
     As explained previously, the expression in such a statement is evaluated
     by means of an SQL <command>SELECT</> command sent to the main
     database engine.  The expression must yield a single value (possibly
     a row value, if the variable is a row or record variable).  The target
     variable can be a simple variable (optionally qualified with a block
     name), a field of a row or record variable, or an element of an array
     that is a simple variable or field.
 -->
 如上所述，语句中的表达式是用一个发送到主数据库引擎的<command>SELECT</>命令计算的。
 该表达式必须生成单一的数值。表达式必须只能生成一个值
 （如果变量一个行或者record，那么该值可能是一个行）。
 目标变量可以是一个简单的变量（可以用一个block的名字来描述），
 行或record变量的字段，或者是一个简单变量或字段的数组元素。
    </para>

    <!--
<para>
     If the expression's result data type doesn't match the variable's
     data type, or the variable has a specific size/precision
     (like <type>char(20)</type>), the result value will be implicitly
     converted by the <application>PL/pgSQL</application> interpreter using
     the result type's output-function and
     the variable type's input-function. Note that this could potentially
     result in run-time errors generated by the input function, if the
     string form of the result value is not acceptable to the input function.
    </para>
-->
<para>
如果表达式的结果数据类型和变量数据类型不一致，
或者变量具有已知的尺寸/精度(比如<type>char(20)</type>)，
结果值将隐含地被<application>PL/pgSQL</application>解释器用结果类型的输出
函数和变量类型的输入函数转换。
注意，如果结果数值的字符串形式不是输入函数可以接受的形式，
那么这样做可能导致类型输入函数产生的运行时错误。
</para>

    
<para>
    <!--
     Examples:
-->
 例子：
<programlisting>
tax := subtotal * 0.06;
my_record.user_id := 20;
</programlisting>
    </para>

   </sect2>

   <sect2 id="plpgsql-statements-sql-noresult">
   <!--
    <title>Executing a Command With No Result</title>
-->
<title>执行一个没有结果的查询</title>

    <!--
<para>
     For any SQL command that does not return rows, for example
     <command>INSERT</> without a <literal>RETURNING</> clause, you can
     execute the command within a <application>PL/pgSQL</application> function
     just by writing the command.
    </para>
-->
<para>
    对于不返回任何行的SQL命令，例如没有<literal>RETURNING</>子句的<command>INSERT</>，
你可以简单的在<application>PL/pgSQL</application>函数内写上该语句，
然后执行该函数即可。
</para>

    <!--
<para>
     Any <application>PL/pgSQL</application> variable name appearing
     in the command text is treated as a parameter, and then the
     current value of the variable is provided as the parameter value
     at run time.  This is exactly like the processing described earlier
     for expressions; for details see <xref linkend="plpgsql-var-subst">.
    </para>
-->
<para>
出现在查询文本中的任何<application>PL/pgSQL</application>变量名都会被参数符号代替，
并在运行时将参数值替换为变量的当前值。
就像之前描述的表达式进程，可以查看资料<xref linkend="plpgsql-var-subst">。
</para>

    <!--
<para>
     When executing a SQL command in this way,
     <application>PL/pgSQL</application> may cache and re-use the execution
     plan for the command, as discussed in
     <xref linkend="plpgsql-plan-caching">.
    </para>
-->
<para>
   当以这种方式执行一条SQL命令，这条命令在<application>PL/pgSQL</application>
   中缓存并且在执行规划中重新使用。
   正如在<xref linkend="plpgsql-plan-caching">中讨论的。
</para>

   
<para>
      <!--
     Sometimes it is useful to evaluate an expression or <command>SELECT</>
     query but discard the result, for example when calling a function
     that has side-effects but no useful result value.  To do
     this in <application>PL/pgSQL</application>, use the
     <command>PERFORM</command> statement:
     -->
 有时评估一个表达式或<command>SELECT</>查询但是丢弃其结果也是有用的，
 例如，调用一个具有副作用的函数，但对它的结果不感兴趣。
 要在<application>PL/pgSQL</application>中这样做，可以使用<command>PERFORM</command>语句:
 
<synopsis>
PERFORM <replaceable>query</replaceable>;
</synopsis>
     <!--
     This executes <replaceable>query</replaceable> and discards the
     result.  Write the <replaceable>query</replaceable> the same
     way you would write an SQL <command>SELECT</> command, but replace the
     initial keyword <command>SELECT</> with <command>PERFORM</command>.
     For <command>WITH</> queries, use <command>PERFORM</> and then
     place the query in parentheses.  (In this case, the query can only
     return one row.)
     <application>PL/pgSQL</application> variables will be
     substituted into the query just as for commands that return no result,
     and the plan is cached in the same way.  Also, the special variable
     <literal>FOUND</literal> is set to true if the query produced at
     least one row, or false if it produced no rows (see
     <xref linkend="plpgsql-statements-diagnostics">).
 -->
 这将执行<replaceable>query</replaceable>并丢弃其结果。
 用<command>SELECT</>命令重写<replaceable>query</replaceable>，并将<command>SELECT</>
 替换为<command>PERFORM</command>，
 对于<command>WITH</>查询，使用<command>PERFORM</>并且将查询放在括号中（在这种情况下， 
 查询只仅仅返回一行）。 
 这样，<application>PL/pgSQL</application>变量将会在查询中被照常替换。
 另外，如果查询生成至少一行结果的话，
 特殊变量<literal>FOUND</literal>将会被设为真，否则将被设为假。
 （查阅<xref linkend="plpgsql-statements-diagnostics">）
    </para>

    <note>
     <!--
<para>
      One might expect that writing <command>SELECT</command> directly
      would accomplish this result, but at
      present the only accepted way to do it is
      <command>PERFORM</command>.  A SQL command that can return rows,
      such as <command>SELECT</command>, will be rejected as an error
      unless it has an <literal>INTO</> clause as discussed in the
      next section.
     </para>
-->
<para>
    有些人可能期望直接写<command>SELECT</command>就能同样达到此目的，
但目前确实只有<command>PERFORM</command>一种方法。
诸如<command>SELECT</command>这样返回行的查询将会被当作错误拒绝，
除非其带有一个下面将要讨论的<literal>INTO</>子句。
</para>
    </note>

    
<para>
    <!--
     An example:
 -->
 例如：
<programlisting>
PERFORM create_mv('cs_session_page_requests_mv', my_query);
</programlisting>
    </para>
   </sect2>

   <sect2 id="plpgsql-statements-sql-onerow">
   <!--
    <title>Executing a Query with a Single-row Result</title>
   -->
     <title>执行一个仅有单行结果的查询</title>

    <indexterm zone="plpgsql-statements-sql-onerow">
     <primary>SELECT INTO</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>

    <indexterm zone="plpgsql-statements-sql-onerow">
     <primary>RETURNING INTO</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>

    
<para>
    <!--
     The result of a SQL command yielding a single row (possibly of multiple
     columns) can be assigned to a record variable, row-type variable, or list
     of scalar variables.  This is done by writing the base SQL command and
     adding an <literal>INTO</> clause.  For example,
    -->
如果一个SQL命令的结果是一个单独的行(可能有多个字段)，
那么可以将其赋予一个记录变量、行类型变量、标量变量的列表。
这可以通过在基本SQL命令之后添加一个<literal>INTO</>子句达到。例如：
<synopsis>
SELECT <replaceable>select_expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable> FROM ...;
INSERT ... RETURNING <replaceable>expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable>;
UPDATE ... RETURNING <replaceable>expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable>;
DELETE ... RETURNING <replaceable>expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable>;
</synopsis>
     <!--
     where <replaceable>target</replaceable> can be a record variable, a row
     variable, or a comma-separated list of simple variables and
     record/row fields.
     <application>PL/pgSQL</application> variables will be
     substituted into the rest of the query, and the plan is cached,
     just as described above for commands that do not return rows.
     This works for <command>SELECT</>,
     <command>INSERT</>/<command>UPDATE</>/<command>DELETE</> with
     <literal>RETURNING</>, and utility commands that return row-set
     results (such as <command>EXPLAIN</>).
     Except for the <literal>INTO</> clause, the SQL command is the same
     as it would be written outside <application>PL/pgSQL</application>.
 -->
 这里的<replaceable>target</replaceable>可以是一个记录变量、
 行变量、逗号分隔的简单变量列表、逗号分隔记录/行字段列表。
 <application>PL/pgSQL</application>变量将被照常代入查询的其余部分，
 适用于带有<literal>RETURNING</>的<command>SELECT</>,
     <command>INSERT</>/<command>UPDATE</>/<command>DELETE</>，
 以及返回行集合的命令(比如<command>EXPLAIN</>)。
 除<literal>INTO</>子句外，
 SQL命令与其在<application>PL/pgSQL</application>外面时完全相同。 
    </para>

   <tip>
    <!--
<para>
     Note that this interpretation of <command>SELECT</> with <literal>INTO</>
     is quite different from <productname>PostgreSQL</>'s regular
     <command>SELECT INTO</command> command, wherein the <literal>INTO</>
     target is a newly created table.  If you want to create a table from a
     <command>SELECT</> result inside a
     <application>PL/pgSQL</application> function, use the syntax
     <command>CREATE TABLE ... AS SELECT</command>.
    </para>
-->
<para>
    请注意，上面带有<literal>INTO</>的<command>SELECT</>和
<productname>PostgreSQL</>普通的<command>SELECT INTO</command>命令是不一样的，
后者的<literal>INTO</>目标是一个新创建的表。
如果你想在<application>PL/pgSQL</application>函数里从一个<command>SELECT</>结果中创建表，
那么请使用<command>CREATE TABLE ... AS SELECT</command>语法。
</para>
   </tip>

    <!--
<para>
     If a row or a variable list is used as target, the query's result columns
     must exactly match the structure of the target as to number and data
     types, or else a run-time error
     occurs.  When a record variable is the target, it automatically
     configures itself to the row type of the query result columns.
    </para>
-->
<para>
如果将一行或者一个变量列表用做目标，那么查询的结果必需作为数目或者数据类型精确匹配目标的结构，
否则就会产生运行时错误。如果目标是一个记录变量，那么它自动将自己配置成命令结果列的行类型。
</para>

    <!--
<para>
     The <literal>INTO</> clause can appear almost anywhere in the SQL
     command.  Customarily it is written either just before or just after
     the list of <replaceable>select_expressions</replaceable> in a
     <command>SELECT</> command, or at the end of the command for other
     command types.  It is recommended that you follow this convention
     in case the <application>PL/pgSQL</application> parser becomes
     stricter in future versions.
    </para>
-->
<para>
  <literal>INTO</>子句几乎可以出现在SQL命令的任何地方。
  习惯上把它写在<command>SELECT</>命令的<replaceable>select_expressions</replaceable>列表的之前或之后，
  对于其它命令则位于结尾。
  我们建议你遵守这个约定，以防万一<application>PL/pgSQL</application>分析器在未来的版本中变得更加严格。
</para>

    
<para>
     <!--
     If <literal>STRICT</literal> is not specified in the <literal>INTO</>
     clause, then <replaceable>target</replaceable> will be set to the first
     row returned by the query, or to nulls if the query returned no rows.
     (Note that <quote>the first row</> is not
     well-defined unless you've used <literal>ORDER BY</>.)  Any result rows
     after the first row are discarded.
     You can check the special <literal>FOUND</literal> variable (see
     <xref linkend="plpgsql-statements-diagnostics">) to
     determine whether a row was returned:
     -->
 如果没有在INTO指定STRICT，那么target将被设为查询返回结果的第一行或者 NULL(查询返回零行)，
 请注意，除非用ORDER BY进行排序，否则"the first row"是不明确的。
 第一行之后的所有结果都将被丢弃。
 你可以检查特殊变量FOUND(参见Section 39.5.5)来判断查询是否至少返回一行。
 
<programlisting>
SELECT * INTO myrec FROM emp WHERE empname = myname;
IF NOT FOUND THEN
    RAISE EXCEPTION 'employee % not found', myname;
END IF;
</programlisting>
    <!--
     If the <literal>STRICT</literal> option is specified, the query must
     return exactly one row or a run-time error will be reported, either
     <literal>NO_DATA_FOUND</> (no rows) or <literal>TOO_MANY_ROWS</>
     (more than one row). You can use an exception block if you wish
     to catch the error, for example:
    -->
如果指定了<literal>STRICT</literal>选项，
那么查询必须返回恰好一个行或者是运行时的错误，
要么是<literal>NO_DATA_FOUND</>(没有行)，要么是<literal>TOO_MANY_ROWS</>(多于一行)。
可以使用异常块来捕获这些错误。例如：
<programlisting>
BEGIN
    SELECT * INTO STRICT myrec FROM emp WHERE empname = myname;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE EXCEPTION 'employee % not found', myname;
        WHEN TOO_MANY_ROWS THEN
            RAISE EXCEPTION 'employee % not unique', myname;
END;
</programlisting>
     <!--
     Successful execution of a command with <literal>STRICT</>
     always sets <literal>FOUND</literal> to true.
 -->
 成功执行了一个带有<literal>STRICT</>的命令之后，<literal>FOUND</literal>将总是被设为真。
    </para>

    <!--
<para>
     For <command>INSERT</>/<command>UPDATE</>/<command>DELETE</> with
     <literal>RETURNING</>, <application>PL/pgSQL</application> reports
     an error for more than one returned row, even when
     <literal>STRICT</literal> is not specified.  This is because there
     is no option such as <literal>ORDER BY</> with which to determine
     which affected row should be returned.
    </para>
-->
<para>
   对于带有<literal>RETURNING</>的<command>INSERT</>/<command>UPDATE</>/<command>DELETE</>，
   即使没有指定<literal>STRICT</literal>，<application>PL/pgSQL</application>也会在返回多行时报错。
   这是因为没有<literal>ORDER BY</>之类的选项用于确定究竟返回那一行。
</para>

    <note>
     <!--
<para>
      The <literal>STRICT</> option matches the behavior of
      Oracle PL/SQL's <command>SELECT INTO</command> and related statements.
     </para>
-->
<para>
    <literal>STRICT</>兼容 Oracle PL/SQL的<command>SELECT INTO</command>行为以及相关语句。
</para>
    </note>

    <!--
<para>
     To handle cases where you need to process multiple result rows
     from a SQL query, see <xref linkend="plpgsql-records-iterating">.
    </para>
-->
<para>
对于如何处理一个SQL查询中返回的多行，参见<xref linkend="plpgsql-records-iterating">。
</para>

   </sect2>

   <sect2 id="plpgsql-statements-executing-dyn">
   <!--
    <title>Executing Dynamic Commands</title>
   -->
    <title>执行动态命令</title>

    
<para>
    <!--
     Oftentimes you will want to generate dynamic commands inside your
     <application>PL/pgSQL</application> functions, that is, commands
     that will involve different tables or different data types each
     time they are executed.  <application>PL/pgSQL</application>'s
     normal attempts to cache plans for commands (as discussed in
     <xref linkend="plpgsql-plan-caching">) will not work in such
     scenarios.  To handle this sort of problem, the
     <command>EXECUTE</command> statement is provided:
    -->
你经常会希望在你的<application>PL/pgSQL</application>函数里生成动态命令。
也就是那些每次执行的时候都会涉及不同表或不同数据类型的命令。在这样的情况下，
<application>PL/pgSQL</application>试图为命令(正如<xref linkend="plpgsql-plan-caching">讨论的)
缓冲执行计划的一般企图将不再合适。
为了处理这样的问题，提供了<command>EXECUTE</command>语句：

<synopsis>
EXECUTE <replaceable class="command">command-string</replaceable> <optional> INTO <optional>STRICT</optional> <replaceable>target</replaceable> </optional> <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional>;
</synopsis>
     <!--
     where <replaceable>command-string</replaceable> is an expression
     yielding a string (of type <type>text</type>) containing the
     command to be executed.  The optional <replaceable>target</replaceable>
     is a record variable, a row variable, or a comma-separated list of
     simple variables and record/row fields, into which the results of
     the command will be stored.  The optional <literal>USING</> expressions
     supply values to be inserted into the command.
 -->
 这里的<replaceable>command-string</replaceable>是一个生成字符串(类型为<type>text</type>)的表达式， 
 该字符串包含要执行的命令。
 而<replaceable>target</replaceable>是一个记录变量、行变量、逗号分隔的简单变量列表、
 逗号分隔的记录/行列表，来存储命令的结果。通过使用<literal>USING</>表达式，将参数值插入到命令中。
    </para>

    <!--
<para>
     No substitution of <application>PL/pgSQL</> variables is done on the
     computed command string.  Any required variable values must be inserted
     in the command string as it is constructed; or you can use parameters
     as described below.
    </para>
-->
<para>
  
   请特别注意在该命令字符串里将不会发生任何<application>PL/pgSQL</>变量代换。
   变量的数值必需在构造的时候插入该字符串的值，或者也可以使用下面介绍的参数。
</para>

    <!--
<para>
     Also, there is no plan caching for commands executed via
     <command>EXECUTE</command>.  Instead, the command is always planned
     each time the statement is run. Thus the command
     string can be dynamically created within the function to perform
     actions on different tables and columns.
    </para>
-->
<para>
   同时，对于通过<command>EXECUTE</command>执行的命令，没有预先设置缓存计划。
   相反，在该语句每次运行的时候，命令都准备一次。
   命令字符串可以在过程里动态地生成以便于对各种不同的表和字段进行操作。
</para>

    <!--
<para>
     The <literal>INTO</literal> clause specifies where the results of
     a SQL command returning rows should be assigned. If a row
     or variable list is provided, it must exactly match the structure
     of the query's results (when a
     record variable is used, it will configure itself to match the
     result structure automatically). If multiple rows are returned,
     only the first will be assigned to the <literal>INTO</literal>
     variable. If no rows are returned, NULL is assigned to the
     <literal>INTO</literal> variable(s). If no <literal>INTO</literal>
     clause is specified, the query results are discarded.
    </para>
-->
<para>
    <literal>INTO</literal>子句声明SQL命令的结果应该传递到哪里。
如果提供了一个行变量或者一个变量列表，
那么它必须和查询生成的结果的结构一样(如果使用了记录变量，那么它回自动调整为匹配结果的结构)。
如果返回了多行，那么只有第一行将被赋予<literal>INTO</literal>变量。
如果返回零行，那么将给<literal>INTO</literal>变量赋予NULL。
如果没有声明<literal>INTO</literal>子句，则抛弃查询结果。
</para>

    <!--
<para>
     If the <literal>STRICT</> option is given, an error is reported
     unless the query produces exactly one row.
    </para>
-->
<para>
    如果使用了<literal>STRICT</>选项，那么在查询没有恰好返回一个行的情况下将会报错。
</para>

    
<para>
     <!--
     The command string can use parameter values, which are referenced
     in the command as <literal>$1</>, <literal>$2</>, etc.
     These symbols refer to values supplied in the <literal>USING</>
     clause.  This method is often preferable to inserting data values
     into the command string as text: it avoids run-time overhead of
     converting the values to text and back, and it is much less prone
     to SQL-injection attacks since there is no need for quoting or escaping.
     An example is: 
 -->
 该命令可以使用那些在命令中被引用为<literal>$1</>, <literal>$2</>等的参数值。
 这些标签指向的是在<literal>USING</>子句中使用的值。
 这样做可以很好的将数据值以文本类型插入到命令字符串中：
 避免了运行期间在数据值和文本类型之间转换的开销，
 并且这种方法不是倾向于进行SQL-injection，因为没有进行引用和转义的必要。例如： 
 
<programlisting>
EXECUTE 'SELECT count(*) FROM mytable WHERE inserted_by = $1 AND inserted &lt;= $2'
   INTO c
   USING checked_user, checked_date;
</programlisting>
    </para>

    
<para>
     <!--
     Note that parameter symbols can only be used for data values
     &mdash; if you want to use dynamically determined table or column
     names, you must insert them into the command string textually.
     For example, if the preceding query needed to be done against a
     dynamically selected table, you could do this:
 -->
 
 需要注意的是，参数标签只能用于数据值&mdash;
 如果想要使用动态的已知的表或列的名字，
 那么必须将它们以文本字符串类型插入到命令中。
 例如，当上面那个查询需要在一个动态选择的表上执行时，你可以这么做：
 
<programlisting>
EXECUTE 'SELECT count(*) FROM '
    || tabname::regclass
    || ' WHERE inserted_by = $1 AND inserted &lt;= $2'
   INTO c
   USING checked_user, checked_date;
</programlisting>
     <!--
     Another restriction on parameter symbols is that they only work in
     <command>SELECT</>, <command>INSERT</>, <command>UPDATE</>, and
     <command>DELETE</> commands.  In other statement
     types (generically called utility statements), you must insert
     values textually even if they are just data values.
 -->
 另一个关于参数标签的限制是，
 它们只能在<command>SELECT</>, <command>INSERT</>, <command>UPDATE</>和
     <command>DELETE</>命令中使用。
 在另一种语法类型中，通常称为通用语法中，可以将参数值以文本类型插入，
 哪怕它们只是数据值。
    </para>

    <!--
<para>
     An <command>EXECUTE</> with a simple constant command string and some
     <literal>USING</> parameters, as in the first example above, is
     functionally equivalent to just writing the command directly in
     <application>PL/pgSQL</application> and allowing replacement of
     <application>PL/pgSQL</application> variables to happen automatically.
     The important difference is that <command>EXECUTE</> will re-plan
     the command on each execution, generating a plan that is specific
     to the current parameter values; whereas
     <application>PL/pgSQL</application> may otherwise create a generic plan
     and cache it for re-use.  In situations where the best plan depends
     strongly on the parameter values, it can be helpful to use
     <command>EXECUTE</> to positively ensure that a generic plan is not
     selected.
    </para>
-->
<para>
   如在上面第一个例子中的，带有一个简单常量字符串和<literal>USING</>参数的<command>EXECUTE</>命令，
   它在功能上等同于直接在<application>PL/pgSQL</application>中写命令，
   并且允许<application>PL/pgSQL</application>变量自动替换。
   最重要的不同之处在于，<command>EXECUTE</>会在每一次执行时，根据当前的参数值更新该命令计划，
   在这一点上，<application>PL/pgSQL</application>可能创建一个命令计划，并将
   其放于缓存中以待重新使用。
   当命令计划对参数值的依赖性很强时，
   对于使用<command>EXECUTE</>积极确保通用计划不被选择是很有帮助的。
</para>

    <!--
<para>
     <command>SELECT INTO</command> is not currently supported within
     <command>EXECUTE</command>; instead, execute a plain <command>SELECT</>
     command and specify <literal>INTO</> as part of the <command>EXECUTE</>
     itself.
    </para>
-->
<para>
   <command>EXECUTE</command>命令目前不支持<command>SELECT INTO</command>，
   但是支持一个纯<command>SELECT</>命令，并且声明一个<literal>INTO</>作为命令本身的一部分。
</para>

   <note>
    <!--
<para>
     The <application>PL/pgSQL</application>
     <command>EXECUTE</command> statement is not related to the
     <xref linkend="sql-execute"> SQL
     statement supported by the
     <productname>PostgreSQL</productname> server. The server's
     <command>EXECUTE</command> statement cannot be used directly within
     <application>PL/pgSQL</> functions (and is not needed).
    </para>
-->
<para>
    <application>PL/pgSQL</application>中的<command>EXECUTE</command>语法与
<productname>PostgreSQL</productname>服务器支持的<xref linkend="sql-execute">语法无关。
服务器支持的<command>EXECUTE</command>语法不能
被<application>PL/pgSQL</>函数直接使用（并且也没有必要）。
</para>
   </note>

   <example id="plpgsql-quote-literal-example">
   <!--
   <title>Quoting Values In Dynamic Queries</title>
   -->
   <title>动态查询中的引用值</title>

    <indexterm>
     <primary>quote_ident</primary>
     <secondary>use in PL/pgSQL</secondary>
    </indexterm>

    <indexterm>
     <primary>quote_literal</primary>
     <secondary>use in PL/pgSQL</secondary>
    </indexterm>

    <indexterm>
     <primary>quote_nullable</primary>
     <secondary>use in PL/pgSQL</secondary>
    </indexterm>

    <indexterm>
     <primary>format</primary>
     <secondary>use in PL/pgSQL</secondary>
    </indexterm>

    <!--
<para>
     When working with dynamic commands you will often have to handle escaping
     of single quotes.  The recommended method for quoting fixed text in your
     function body is dollar quoting.  (If you have legacy code that does
     not use dollar quoting, please refer to the
     overview in <xref linkend="plpgsql-quote-tips">, which can save you
     some effort when translating said code to a more reasonable scheme.)
    </para>
-->
<para>
    使用动态命令的时候经常需要逃逸单引号。
建议使用美元符界定函数体内的固定文本。
如果你有没有使用美元符界定的老代码，请参考<xref linkend="plpgsql-quote-tips">，
这样在把老代码转换成更合理的结构时，会节省你的一些精力。
</para>

    
<para>
     <!--
     Dynamic values that are to be inserted into the constructed
     query require careful handling since they might themselves contain
     quote characters.
     An example (this assumes that you are using dollar quoting for the
     function as a whole, so the quote marks need not be doubled):
 -->
 插入到构造出来的查询中的动态数值也需要特殊处理，
 因为他们自己可能包含引号字符。
 一个例子(这里都假设你使用了美元符作为整体，所以引号标记不需要加倍)：
 
<programlisting>
EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = '
        || quote_literal(newvalue)
        || ' WHERE key = '
        || quote_literal(keyvalue);
</programlisting>
    </para>

    <!--
<para>
     This example demonstrates the use of the
     <function>quote_ident</function> and
     <function>quote_literal</function> functions (see <xref
     linkend="functions-string">).  For safety, expressions containing column
     or table identifiers should be passed through
     <function>quote_ident</function> before insertion in a dynamic query.
     Expressions containing values that should be literal strings in the
     constructed command should be passed through <function>quote_literal</>.
     These functions take the appropriate steps to return the input text
     enclosed in double or single quotes respectively, with any embedded
     special characters properly escaped.
    </para>
-->
<para>
   这个例子显示了<function>quote_ident</function>和<function>quote_literal</function>
   函数的使用（参阅<xref linkend="functions-string">）。 
   为了安全，包含字段和表标识符的变量应该传递给<function>quote_ident</function>函数。
   那些包含数值的表达式，如果中的数值在构造出来的命令字符串里是文本字符串，
   那么应该传递给<function>quote_literal</>。
   它们俩都会采取合适的步骤把输入文本包围在单或双引号里，
   并且对任何嵌入其中的特殊字符进行合适的逃逸处理。
</para>

    
<para>
    <!--
     Because <function>quote_literal</function> is labeled
     <literal>STRICT</literal>, it will always return null when called with a
     null argument.  In the above example, if <literal>newvalue</> or
     <literal>keyvalue</> were null, the entire dynamic query string would
     become null, leading to an error from <command>EXECUTE</command>.
     You can avoid this problem by using the <function>quote_nullable</>
     function, which works the same as <function>quote_literal</> except that
     when called with a null argument it returns the string <literal>NULL</>.
     For example,
 -->
 因为<function>quote_literal</function>被标记为<literal>STRICT</literal>，
 当发出带有null参数的请求时，
 往往会返回一个null。在上面的例子中，如果<literal>newvalue</>或者
     <literal>keyvalue</>是null，
 整个动态查询字符串会变成null，最终<command>EXECUTE</command>会报错。
 可以通过使用<function>quote_nullable</>函数来避免该错误，
 除了当发出带有null参数的请求时，往往会返回一个字符串NULL之外，
 该函数与<function>quote_literal</>一样工作。例如：
 
<programlisting>
EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = '
        || quote_nullable(newvalue)
        || ' WHERE key = '
        || quote_nullable(keyvalue);
</programlisting>
     <!--
     If you are dealing with values that might be null, you should usually
     use <function>quote_nullable</> in place of <function>quote_literal</>.
 -->
 如果处理的参数值是null，那么应该用<function>quote_nullable</>来代替<function>quote_literal</>。
    </para>

    
<para>
    <!--
     As always, care must be taken to ensure that null values in a query do
     not deliver unintended results.  For example the <literal>WHERE</> clause
-->
通常，应该注意确保查询中的null值返回意料之外的结果。例如：
<programlisting>
'WHERE key = ' || quote_nullable(keyvalue)
</programlisting>
     <!--
     will never succeed if <literal>keyvalue</> is null, because the
     result of using the equality operator <literal>=</> with a null operand
     is always null.  If you wish null to work like an ordinary key value,
     you would need to rewrite the above as
 -->
 如果<literal>keyvalue</>是null，那么该<literal>WHERE</>子句永远不会成功，
 因为当<literal>=</>操作符带有null操作数，操作返回的结果往往是null。
 如果想让null同普通关键字一样使用，那么将上面的命令修改如下：
 
<programlisting>
'WHERE key IS NOT DISTINCT FROM ' || quote_nullable(keyvalue)
</programlisting>
     <!--
     (At present, <literal>IS NOT DISTINCT FROM</> is handled much less
     efficiently than <literal>=</>, so don't do this unless you must.
     See <xref linkend="functions-comparison"> for
     more information on nulls and <literal>IS DISTINCT</>.)
 -->
 目前，<literal>IS NOT DISTINCT FROM</>处理效率不如<literal>=</>，因此如非必要，
 不用这么做。关于null和<literal>IS DISTINCT</>的资料可参阅<xref linkend="functions-comparison">。
    </para>

    
<para>
    <!--
     Note that dollar quoting is only useful for quoting fixed text.
     It would be a very bad idea to try to write this example as:
-->
请注意美元符界定只对包围固定文本有用。如果想像下面这样做上面的例子，那就太糟糕了:
<programlisting>
EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = $$'
        || newvalue
        || '$$ WHERE key = '
        || quote_literal(keyvalue);
</programlisting>
    <!--
     because it would break if the contents of <literal>newvalue</>
     happened to contain <literal>$$</>.  The same objection would
     apply to any other dollar-quoting delimiter you might pick.
     So, to safely quote text that is not known in advance, you
     <emphasis>must</> use <function>quote_literal</>,
     <function>quote_nullable</>, or <function>quote_ident</>, as appropriate.
-->
因为如果<literal>newvalue</>的内容碰巧含有<literal>$$</>，那么这段代码就有毛病了。
同样的问题可能出现在你选用的任何美元符界定分隔符上。
因此，要想安全地包围事先不知道的文本，
<emphasis>必须</>恰当的使用<function>quote_literal</>，
     <function>quote_nullable</>或者<function>quote_ident</>。
    </para>

    
<para>
     <!--
     Dynamic SQL statements can also be safely constructed using the
     <function>format</function> function (see <xref
     linkend="functions-string">). For example:
 -->
 动态SQL语句可以使用<function>format</function>函数安全构建
 （参阅<xref linkend="functions-string">）。比如：
<programlisting>
EXECUTE format('UPDATE tbl SET %I = %L WHERE key = %L', colname, newvalue, keyvalue);
</programlisting>
    <!--
     The <function>format</function> function can be used in conjunction with
     the <literal>USING</literal> clause:
 -->
 在<literal>USING</literal>子句连接中使用<function>format</function>函数：
 
<programlisting>
EXECUTE format('UPDATE tbl SET %I = $1 WHERE key = $2', colname)
   USING newvalue, keyvalue;
</programlisting>
     <!--
     This form is more efficient, because the parameters
     <literal>newvalue</literal> and <literal>keyvalue</literal> are not
     converted to text.
 -->
 这种形式更有效，因为参数<literal>newvalue</literal> and <literal>keyvalue</literal>
 不转换为文本。
    </para>

   </example>

    <!--
<para>
     A much larger example of a dynamic command and
     <command>EXECUTE</command> can be seen in <xref
     linkend="plpgsql-porting-ex2">, which builds and executes a
     <command>CREATE FUNCTION</> command to define a new function.
    </para>
-->
<para>
关于动态命令和<command>EXECUTE</command>的另一个例子
是<xref linkend="plpgsql-porting-ex2">，
这个例子制作并执行了一个定义新函数的<command>CREATE FUNCTION</>命令。
</para>
   </sect2>

   <sect2 id="plpgsql-statements-diagnostics">
   <!--
    <title>Obtaining the Result Status</title>
-->
<title>获取结果状态</title>

    
<para>
    <!--
     There are several ways to determine the effect of a command. The
     first method is to use the <command>GET DIAGNOSTICS</command>
     command, which has the form:
    -->
有好几种方法可以判断一条命令的效果。
第一个方法是使用<command>GET DIAGNOSTICS</command>，它的形式如下：
<synopsis>
GET <optional> CURRENT </optional> DIAGNOSTICS <replaceable>variable</replaceable> = <replaceable>item</replaceable> <optional> , ... </optional>;
</synopsis>
    <!--
     This command allows retrieval of system status indicators.  Each
     <replaceable>item</replaceable> is a key word identifying a status
     value to be assigned to the specified variable (which should be
     of the right data type to receive it).  The currently available
     status items are <varname>ROW_COUNT</>, the number of rows
     processed by the last <acronym>SQL</acronym> command sent to
     the <acronym>SQL</acronym> engine, and <varname>RESULT_OID</>,
     the OID of the last row inserted by the most recent
     <acronym>SQL</acronym> command.  Note that <varname>RESULT_OID</>
     is only useful after an <command>INSERT</command> command into a
     table containing OIDs.
-->
这条命令允许检索系统状态标识符。每个<replaceable>item</replaceable>是一个关键字，
表示一个将要赋予该特定变量的状态值(该变量应该和要接收的数值类型相同)。
当前可用的状态项有<varname>ROW_COUNT</>、最后一个<acronym>SQL</acronym>命
令发送到<acronym>SQL</acronym>引擎处理的行数量、<varname>RESULT_OID</>，
最后一条<acronym>SQL</acronym>命令插入的最后一行的OID。
请注意<varname>RESULT_OID</>只有在一个向包含OID的表中<command>INSERT</command>
的命令之后才有用。
    </para>

    
<para>
    <!-- 
     An example:
-->
 例如：
<programlisting>
GET DIAGNOSTICS integer_var = ROW_COUNT;
</programlisting>
    </para>

   
<para>
     <!--
     The second method to determine the effects of a command is to check the
     special variable named <literal>FOUND</literal>, which is of
     type <type>boolean</type>.  <literal>FOUND</literal> starts out
     false within each <application>PL/pgSQL</application> function call.
     It is set by each of the following types of statements:
     -->
 另外一个判断命令效果的方法是一个<type>boolean</type>类型的特殊变量<literal>FOUND</literal>，
 它在每个<application>PL/pgSQL</application>函数调用中<literal>FOUND</literal>开始都为假。
 并被下列语句设置：
 
         <itemizedlist>
          <listitem>
           <para>
    <!--
            A <command>SELECT INTO</command> statement sets
            <literal>FOUND</literal> true if a row is assigned, false if no
            row is returned.
-->
一个<command>SELECT INTO</command>语句如果返回一行则将<literal>FOUND</literal>设置为真，
如果没有返回行则设置为假。
           </para>
          </listitem>
          <listitem>
           <!--
<para>
            A <command>PERFORM</> statement sets <literal>FOUND</literal>
            true if it produces (and discards) one or more rows, false if
            no row is produced.
           </para>
-->
<para>
    一个<command>PERFORM</>语句如果生成(或抛弃)一行，则将<literal>FOUND</literal>设置为真，
如果没有生成行则为假。
</para>
          </listitem>
          <listitem>
           <!--
<para>
            <command>UPDATE</>, <command>INSERT</>, and <command>DELETE</>
            statements set <literal>FOUND</literal> true if at least one
            row is affected, false if no row is affected.
           </para>
-->
<para>
    如果至少影响了一行，那么<command>UPDATE</>, <command>INSERT</>和<command>DELETE</>语句
设置FOUND为真，如果没有行受影响则为假。
</para>
          </listitem>
          <listitem>
           <!--
<para>
            A <command>FETCH</> statement sets <literal>FOUND</literal>
            true if it returns a row, false if no row is returned.
           </para>
-->
<para>
   一个<command>FETCH</>语句如果返回行则设置<literal>FOUND</literal>为真，如果不返回行则为假
</para>
          </listitem>
          <listitem>
           <!--
<para>
            A <command>MOVE</> statement sets <literal>FOUND</literal>
            true if it successfully repositions the cursor, false otherwise.
           </para>
-->
<para>
当成功定位游标的位置时，<command>MOVE</>将<literal>FOUND</literal>设为真，反之为假。
</para>
          </listitem>
          <listitem>
           <!--
<para>
            A <command>FOR</> or <command>FOREACH</> statement sets
            <literal>FOUND</literal> true
            if it iterates one or more times, else false.
            <literal>FOUND</literal> is set this way when the
            loop exits; inside the execution of the loop,
            <literal>FOUND</literal> is not modified by the
            loop statement, although it might be changed by the
            execution of other statements within the loop body.
           </para>
-->
<para>
   一个<command>FOR</>或者<command>FOREACH</>语句如果迭代了一次或多次，
   则设置<literal>FOUND</literal>真，否则为假。
   只有在循环退出的时候才设置<literal>FOUND</literal>；
   在循环执行的内部，<literal>FOUND</literal>不被循环语句修改，
   但是在循环体里它可能被其它语句的执行而修改。
</para>
          </listitem>
          <listitem>
           <!--
<para>
            <command>RETURN QUERY</command> and <command>RETURN QUERY
            EXECUTE</command> statements set <literal>FOUND</literal>
            true if the query returns at least one row, false if no row
            is returned.
           </para>
-->
<para>
   如果查询结果返回至少一个行，
   <command>RETURN QUERY</command> and <command>RETURN QUERY EXECUTE</command>声明
   将<literal>FOUND</literal>设为真，
   反之如果没有返回行，则为假。
</para>
          </listitem>
         </itemizedlist>
      <!--
     Other <application>PL/pgSQL</application> statements do not change
     the state of <literal>FOUND</literal>.
     Note in particular that <command>EXECUTE</command>
     changes the output of <command>GET DIAGNOSTICS</command>, but
     does not change <literal>FOUND</literal>.
 -->
 其他的<application>PL/pgSQL</application>声明不会改变<literal>FOUND</literal>的位置。
 尤其需要注意的一点是：<command>EXECUTE</command>会修改<command>GET DIAGNOSTICS</command>的输出，
 但不会修改<literal>FOUND</literal>的输出。
    </para>

    <!--
<para>
     <literal>FOUND</literal> is a local variable within each
     <application>PL/pgSQL</application> function; any changes to it
     affect only the current function.
    </para>
-->
<para>
   <literal>FOUND</literal>是每个<application>PL/pgSQL</application>里的局部变量；
   任何对它的任何修改只影响当前的函数。
</para>

   </sect2>

   <sect2 id="plpgsql-statements-null">
   <!--
    <title>Doing Nothing At All</title>
   -->
     <title>什么也不做</title>

   
<para>
     <!--
     Sometimes a placeholder statement that does nothing is useful.
     For example, it can indicate that one arm of an if/then/else
     chain is deliberately empty.  For this purpose, use the
     <command>NULL</command> statement:
     -->
 
 有时一个什么也不做的占位语句也是很有用的。
 例如，用于if/then/else 的空分支。
 可以使用<command>NULL</command>语句达到这个目的。
  
<synopsis>
NULL;
</synopsis>
    </para>

    
<para>
     <!--
     For example, the following two fragments of code are equivalent:
 -->
     比如，下面的两段代码是相等的： 
<programlisting>
BEGIN
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN
        NULL;  -- ignore the error
END;
</programlisting>

<programlisting>
BEGIN
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN  -- ignore the error
END;
</programlisting>
     <!--
     Which is preferable is a matter of taste.
 -->
 究竟使用哪一个取决于个人的喜好。
    </para>

    <note>
     <!--
<para>
      In Oracle's PL/SQL, empty statement lists are not allowed, and so
      <command>NULL</> statements are <emphasis>required</> for situations
      such as this.  <application>PL/pgSQL</application> allows you to
      just write nothing, instead.
     </para>
-->
<para>
    在Oracle的PL/SQL中，不允许出现空语句列，
所以在这种情况下必须使用<command>NULL</>语句，
而<application>PL/pgSQL</application>允许你什么也不写。
</para>
    </note>

   </sect2>
  </sect1>

  <sect1 id="plpgsql-control-structures">
  <!--
   <title>Control Structures</title>
  -->
    <title>控制结构</title>

   <!--
<para>
    Control structures are probably the most useful (and
    important) part of <application>PL/pgSQL</>. With
    <application>PL/pgSQL</>'s control structures,
    you can manipulate <productname>PostgreSQL</> data in a very
    flexible and powerful way.
   </para>
-->
<para>
  控制结构可能是<application>PL/pgSQL</>中最有用的(以及最重要)的部分了。
  利用<application>PL/pgSQL</>的控制结构，
  你可以以非常灵活而且强大的方法操纵<productname>PostgreSQL</>的数据。
</para>

   <sect2 id="plpgsql-statements-returning">
   <!--
    <title>Returning From a Function</title>
   -->
    <title>从函数返回</title>

    <!--
<para>
     There are two commands available that allow you to return data
     from a function: <command>RETURN</command> and <command>RETURN
     NEXT</command>.
    </para>
-->
<para>
  有两个命令可以用来从函数中返回数据：<command>RETURN</command>和
  <command>RETURN NEXT</command>。
</para>

    <sect3>

     <title><command>RETURN</></title>


<synopsis>
RETURN <replaceable>expression</replaceable>;
</synopsis>

     <!--
<para>
      <command>RETURN</command> with an expression terminates the
      function and returns the value of
      <replaceable>expression</replaceable> to the caller.  This form
      is used for <application>PL/pgSQL</> functions that do
      not return a set.
     </para>
-->
<para>
 带表达式的<command>RETURN</command>用于终止函数
 并把<replaceable>expression</replaceable>的值返回给调用者。
 这种形式用于不返回集合的<application>PL/pgSQL</>函数。
</para>

     <!--
<para>
      In a function that returns a scalar type, the expression's result will
      automatically be cast into the function's return type as described for
      assignments.  But to return a composite (row) value, you must write an
      expression delivering exactly the requested column set.  This may
      require use of explicit casting.
     </para>
-->
<para>
   如果函数中返回标量类型，那么表达式结果将被自动转换成函数的返回类型，
   就像在赋值中描述的那样。但是要返回一个复合(行)数值，
   你必须写一个准确提供需求列集合的表达式，这可能需要显式转换。
</para>

     <!--
<para>
      If you declared the function with output parameters, write just
      <command>RETURN</command> with no expression.  The current values
      of the output parameter variables will be returned.
     </para>
-->
<para>
  如果你声明带有输出参数的函数，那么就只需要写无表达式的<command>RETURN</command>。
  那么输出参数变量的当前值将被返回。
</para>

     <!--
<para>
      If you declared the function to return <type>void</type>, a
      <command>RETURN</command> statement can be used to exit the function
      early; but do not write an expression following
      <command>RETURN</command>.
     </para>
-->
<para>
    如果你声明函数返回<type>void</type>，那么一个<command>RETURN</command>
语句可以用于提前退出函数；
但是不要在<command>RETURN</command>后面写一个表达式。
</para>

     <!--
<para>
      The return value of a function cannot be left undefined. If
      control reaches the end of the top-level block of the function
      without hitting a <command>RETURN</command> statement, a run-time
      error will occur.  This restriction does not apply to functions
      with output parameters and functions returning <type>void</type>,
      however.  In those cases a <command>RETURN</command> statement is
      automatically executed if the top-level block finishes.
     </para>
-->
<para>
   一个函数的返回值不能是未定义。
   如果控制到达了函数最顶层的块而没有碰到一个<command>RETURN</command>语句，
   那么它就会发生一个错误。不过，这个限制不适用于带输出参数的函数以及那些返回<type>void</type>的函数。
   在这些例子里，如果顶层的块结束，则自动执行一个<command>RETURN</command>语句。
</para>

     
<para>
     <!--
      Some examples:
  -->
  例子：

<programlisting>
<!--
&#045;- functions returning a scalar type
-->
-- 返回一个标量类型函数
RETURN 1 + 2;
RETURN scalar_var;
<!--
&#045;- functions returning a composite type
-->
-- 返回复合类型函数
RETURN composite_type_var;
RETURN (1, 2, 'three'::text);  -- must cast columns to correct types
</programlisting>
     </para>

    </sect3>

    <sect3>
<!--
     <title><command>RETURN NEXT</> and <command>RETURN QUERY</command></title>
-->
  <title><command>RETURN NEXT</>和<command>RETURN QUERY</command></title>
    <indexterm>
     <primary>RETURN NEXT</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>
    <indexterm>
     <primary>RETURN QUERY</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>

<synopsis>
RETURN NEXT <replaceable>expression</replaceable>;
RETURN QUERY <replaceable>query</replaceable>;
RETURN QUERY EXECUTE <replaceable class="command">command-string</replaceable> <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional>;
</synopsis>

     <!--
<para>
      When a <application>PL/pgSQL</> function is declared to return
      <literal>SETOF <replaceable>sometype</></literal>, the procedure
      to follow is slightly different.  In that case, the individual
      items to return are specified by a sequence of <command>RETURN
      NEXT</command> or <command>RETURN QUERY</command> commands, and
      then a final <command>RETURN</command> command with no argument
      is used to indicate that the function has finished executing.
      <command>RETURN NEXT</command> can be used with both scalar and
      composite data types; with a composite result type, an entire
      <quote>table</quote> of results will be returned.
      <command>RETURN QUERY</command> appends the results of executing
      a query to the function's result set. <command>RETURN
      NEXT</command> and <command>RETURN QUERY</command> can be freely
      intermixed in a single set-returning function, in which case
      their results will be concatenated.
     </para>
-->
<para>
    如果一个<application>PL/pgSQL</>函数声明为返回<literal>SETOF <replaceable>sometype</></literal>，
那么遵循的过程则略有不同。
在这种情况下，要返回的独立项是在<command>RETURN NEXT</command>或者
<command>RETURN QUERY</command>命令里声明的，
然后最后有一个不带参数的<command>RETURN</command>命令用于告诉这个函数已经完成执行了。
<command>RETURN NEXT</command>可以用于标量和复合数据类型；对于复合类型，
将返回一个完整的结果<quote>table</quote>。
<command>RETURN QUERY</command>命令将一条查询的结果追加到一个函数的结果集中。
<command>RETURN NEXT</command>和<command>RETURN QUERY</command>在单一集合返回
函数中自由混合，在这种情况下，结果将被级联。
</para>

     <!--
<para>
      <command>RETURN NEXT</command> and <command>RETURN
      QUERY</command> do not actually return from the function &mdash;
      they simply append zero or more rows to the function's result
      set.  Execution then continues with the next statement in the
      <application>PL/pgSQL</> function.  As successive
      <command>RETURN NEXT</command> or <command>RETURN
      QUERY</command> commands are executed, the result set is built
      up.  A final <command>RETURN</command>, which should have no
      argument, causes control to exit the function (or you can just
      let control reach the end of the function).
     </para>
-->
<para>
<command>RETURN NEXT</command>和<command>RETURN QUERY</command>实际上不会从函数中返回，
它们是将零或者多个行追加到函数的结果集中。
然后继续执行<application>PL/pgSQL</>函数里的下一条语句。
随着后继的<command>RETURN NEXT</command>或者<command>RETURN QUERY</command>命令的执行，
结果集就建立起来了。最后一个<command>RETURN</command>应该没有参数，
它导致控制退出该函数(或者你可以简单地让控制到达函数的结尾)。
</para>

     <!--
<para>
      <command>RETURN QUERY</command> has a variant
      <command>RETURN QUERY EXECUTE</command>, which specifies the
      query to be executed dynamically.  Parameter expressions can
      be inserted into the computed query string via <literal>USING</>,
      in just the same way as in the <command>EXECUTE</> command.
     </para>
-->
<para>
  <command>RETURN QUERY</command>有一个变形<command>RETURN QUERY EXECUTE</command>，
指定查询将被动态执行。
参数表达式可以通过<literal>USING</>插入到计算查询字符串中，以<command>EXECUTE</>命令的同样方式。

</para>

     <!--
<para>
      If you declared the function with output parameters, write just
      <command>RETURN NEXT</command> with no expression.  On each
      execution, the current values of the output parameter
      variable(s) will be saved for eventual return as a row of the
      result.  Note that you must declare the function as returning
      <literal>SETOF record</literal> when there are multiple output
      parameters, or <literal>SETOF <replaceable>sometype</></literal>
      when there is just one output parameter of type
      <replaceable>sometype</>, in order to create a set-returning
      function with output parameters.
     </para>
-->
<para>
   如果你声明函数带有输出参数，那么就只需要写不带表达式的<command>RETURN NEXT</command>。
   输出参数的当前值将被保存，用于最终返回。请注意如果有多个输出参数，
   比如声明函数为返回<literal>SETOF record</literal>或者是在只有一个类
   型为<replaceable>sometype</>的输出参数时声明
   为<literal>SETOF <replaceable>sometype</></literal>，
   这样才能创建一个带有输出参数的返回集合的函数。
</para>

     
<para>
     <!--
      Here is an example of a function using <command>RETURN
      NEXT</command>:
     -->
 下面是一个使用<command>RETURN NEXT</command>的函数例子:
<programlisting>
CREATE TABLE foo (fooid INT, foosubid INT, fooname TEXT);
INSERT INTO foo VALUES (1, 2, 'three');
INSERT INTO foo VALUES (4, 5, 'six');

CREATE OR REPLACE FUNCTION get_all_foo() RETURNS SETOF foo AS
$BODY$
DECLARE
    r foo%rowtype;
BEGIN
    FOR r IN
        SELECT * FROM foo WHERE fooid &gt; 0
    LOOP
   <!--
        &#045;- can do some processing here
-->
-- 可以在这里做一些处理
        RETURN NEXT r; -- return current row of SELECT
    END LOOP;
    RETURN;
END
$BODY$
LANGUAGE plpgsql;

SELECT * FROM get_all_foo();
</programlisting>
     </para>


     
<para>
     <!--
      Here is an example of a function using <command>RETURN
      QUERY</command>:
 -->
 这是一个使用<command>RETURN QUERY</command>的函数例子:

<programlisting>
CREATE FUNCTION get_available_flightid(date) RETURNS SETOF integer AS
$BODY$
BEGIN
    RETURN QUERY SELECT flightid
                   FROM flight
                  WHERE flightdate >= $1
                    AND flightdate < ($1 + 1);
    <!--
    &#045;- Since execution is not finished, we can check whether rows were returned
    &#045;- and raise exception if not.
-->
-- 由于没有完成执行，我们可以检查行是否返回并且如果没有则抛出异常。
    IF NOT FOUND THEN
        RAISE EXCEPTION 'No flight at %.', $1;
    END IF;

    RETURN;
 END
$BODY$
LANGUAGE plpgsql;
<!--
&#045;- Returns available flights or raises exception if there are no
&#045;- available flights.
-->
-- 如果没有可用航班，则返回可用航班或者抛出异常。
SELECT * FROM get_available_flightid(CURRENT_DATE);
</programlisting>
     </para>

     <note>
      <!--
<para>
       The current implementation of <command>RETURN NEXT</command>
       and <command>RETURN QUERY</command> stores the entire result set
       before returning from the function, as discussed above.  That
       means that if a <application>PL/pgSQL</> function produces a
       very large result set, performance might be poor: data will be
       written to disk to avoid memory exhaustion, but the function
       itself will not return until the entire result set has been
       generated.  A future version of <application>PL/pgSQL</> might
       allow users to define set-returning functions
       that do not have this limitation.  Currently, the point at
       which data begins being written to disk is controlled by the
       <xref linkend="guc-work-mem">
       configuration variable.  Administrators who have sufficient
       memory to store larger result sets in memory should consider
       increasing this parameter.
      </para>
-->
<para>
   目前<command>RETURN NEXT</command>和<command>RETURN QUERY</command>
   实现在从函数返回之前把整个结果集都保存起来，
   就像上面描述的那样。这意味着如果一个<application>PL/pgSQL</>函数生成一个非常大的结果集，
   性能可能会很差：数据将被写到磁盘上以避免内存耗尽，
   但是函数在完成整个结果集的生成之前不会退出。
   将来的<application>PL/pgSQL</>版本可能会允许用户定义没有这样限制的返回集合的函数。
   目前，数据开始向磁盘里写的时刻是由配置变量<xref linkend="guc-work-mem">控制的。
   拥有足够内存的管理员如果想在内存里存储更大的结果集，
   则可以考虑把这个参数增大一些。
</para>
     </note>
    </sect3>
   </sect2>

   <sect2 id="plpgsql-conditionals">
   <!--
    <title>Conditionals</title>
-->
<title>条件</title>

    
<para>
     <!--
     <command>IF</> and <command>CASE</> statements let you execute
     alternative commands based on certain conditions.
     <application>PL/pgSQL</> has three forms of <command>IF</>:
 -->
 <command>IF</>和<command>CASE</>语句让你可以根据某种条件执行命令。
 <application>PL/pgSQL</>有三种形式的<command>IF</>：
 
    <itemizedlist>
     <listitem>
      <para><literal>IF ... THEN</></>
     </listitem>
     <listitem>
      <para><literal>IF ... THEN ... ELSE</></>
     </listitem>
     <listitem>
      <para><literal>IF ... THEN ... ELSIF ... THEN ... ELSE</></>
     </listitem>
    </itemizedlist>
    <!--
    and two forms of <command>CASE</>:
-->
以及两种形式的<command>CASE</>:

    <itemizedlist>
     <listitem>
      <para><literal>CASE ... WHEN ... THEN ... ELSE ... END CASE</></>
     </listitem>
     <listitem>
      <para><literal>CASE WHEN ... THEN ... ELSE ... END CASE</></>
     </listitem>
    </itemizedlist>
    </para>

    <sect3>
     <title><literal>IF-THEN</></title>

<synopsis>
IF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
END IF;
</synopsis>

       <!--
<para>
        <literal>IF-THEN</literal> statements are the simplest form of
        <literal>IF</literal>. The statements between
        <literal>THEN</literal> and <literal>END IF</literal> will be
        executed if the condition is true. Otherwise, they are
        skipped.
       </para>
-->
<para>
   <literal>IF-THEN</literal>语句是<literal>IF</literal>的最简单形式。如果条件为真，
   在<literal>THEN</literal>和<literal>END IF</literal>之间的语句将被执行。
   否则，将忽略它们。
</para>

       
<para>
     <!--
        Example:
-->
  例如：
<programlisting>
IF v_user_id &lt;&gt; 0 THEN
    UPDATE users SET email = v_email WHERE user_id = v_user_id;
END IF;
</programlisting>
       </para>

     </sect3>

     <sect3>
      <title><literal>IF-THEN-ELSE</></title>

<synopsis>
IF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
ELSE
    <replaceable>statements</replaceable>
END IF;
</synopsis>

       <!--
<para>
        <literal>IF-THEN-ELSE</literal> statements add to
        <literal>IF-THEN</literal> by letting you specify an
        alternative set of statements that should be executed if the
        condition is not true.  (Note this includes the case where the
        condition evaluates to NULL.)
       </para>
-->
<para>
   <literal>IF-THEN-ELSE</literal>语句增加了<literal>IF-THEN</literal>的分支，
   让你可以声明在条件为假的时候执行的语句。（请注意这包含条件是NULL的情况）。
</para>

       
<para>
      <!--
        Examples:
  -->
    例如：
<programlisting>
IF parentid IS NULL OR parentid = ''
THEN
    RETURN fullname;
ELSE
    RETURN hp_true_filename(parentid) || '/' || fullname;
END IF;
</programlisting>

<programlisting>
IF v_count &gt; 0 THEN
    INSERT INTO users_count (count) VALUES (v_count);
    RETURN 't';
ELSE
    RETURN 'f';
END IF;
</programlisting>
     </para>

    </sect3>

     <sect3>
      <title><literal>IF-THEN-ELSIF</></title>

<synopsis>
IF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
<optional> ELSIF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
<optional> ELSIF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
    ...
</optional>
</optional>
<optional> ELSE
    <replaceable>statements</replaceable> </optional>
END IF;
</synopsis>

       <!--
<para>
        Sometimes there are more than just two alternatives.
        <literal>IF-THEN-ELSIF</> provides a convenient
        method of checking several alternatives in turn.
        The <literal>IF</> conditions are tested successively
        until the first one that is true is found.  Then the
        associated statement(s) are executed, after which control
        passes to the next statement after <literal>END IF</>.
        (Any subsequent <literal>IF</> conditions are <emphasis>not</>
        tested.)  If none of the <literal>IF</> conditions is true,
        then the <literal>ELSE</> block (if any) is executed.
       </para>
-->
<para>
  有时不止两个选择。<literal>IF-THEN-ELSIF</>
  反过来提供了一个简便的方法来检查选择条件。
  <literal>IF</>判断会陆续检查，直到找到第一个为真的，然后执行相关声明，如此，
  直到<literal>END IF</>（<emphasis>不会</>检测<literal>IF</>子查询）。
  如果没有一个条件符合<literal>IF</>判断，那么会接着执行<literal>ELSE</>判断。
</para>

       
<para>
     <!--
        Here is an example:
-->
        例如：
<programlisting>
IF number = 0 THEN
    result := 'zero';
ELSIF number &gt; 0 THEN
    result := 'positive';
ELSIF number &lt; 0 THEN
    result := 'negative';
ELSE
    <!--
    &#045;- hmm, the only other possibility is that number is null
-->
-- 唯一可能性是号码为空
    result := 'NULL';
END IF;
</programlisting>
       </para>

       <!--
<para>
        The key word <literal>ELSIF</> can also be spelled
        <literal>ELSEIF</>.
       </para>
-->
<para>
   <literal>ELSIF</>关键字也可以写成<literal>ELSEIF</>。
</para>

       
<para>
     <!--
        An alternative way of accomplishing the same task is to nest
        <literal>IF-THEN-ELSE</literal> statements, as in the
        following example:
     -->
   另一个可以实现该目的的方法是使用<literal>IF-THEN-ELSE</literal>声明，如下:
<programlisting>
IF demo_row.sex = 'm' THEN
    pretty_sex := 'man';
ELSE
    IF demo_row.sex = 'f' THEN
        pretty_sex := 'woman';
    END IF;
END IF;
</programlisting>
       </para>

       <!--
<para>
        However, this method requires writing a matching <literal>END IF</>
        for each <literal>IF</>, so it is much more cumbersome than
        using <literal>ELSIF</> when there are many alternatives.
       </para>
-->
<para>
   然而，这个方法需要为每个<literal>IF</>写<literal>END IF</>，
   因此当有很多选择时，这种方法明显比<literal>ELSIF</>繁琐。
</para>
     </sect3>

     <sect3>
 <!--
      <title>Simple <literal>CASE</></title>
 -->
   <title>简单<literal>CASE</></title>

<synopsis>
CASE <replaceable>search-expression</replaceable>
    WHEN <replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> <optional> ... </optional></optional> THEN
      <replaceable>statements</replaceable>
  <optional> WHEN <replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> <optional> ... </optional></optional> THEN
      <replaceable>statements</replaceable>
    ... </optional>
  <optional> ELSE
      <replaceable>statements</replaceable> </optional>
END CASE;
</synopsis>

      <!--
<para>
       The simple form of <command>CASE</> provides conditional execution
       based on equality of operands.  The <replaceable>search-expression</>
       is evaluated (once) and successively compared to each
       <replaceable>expression</> in the <literal>WHEN</> clauses.
       If a match is found, then the corresponding
       <replaceable>statements</replaceable> are executed, and then control
       passes to the next statement after <literal>END CASE</>.  (Subsequent
       <literal>WHEN</> expressions are not evaluated.)  If no match is
       found, the <literal>ELSE</> <replaceable>statements</replaceable> are
       executed; but if <literal>ELSE</> is not present, then a
       <literal>CASE_NOT_FOUND</literal> exception is raised.
      </para>
-->
<para>
    <command>CASE</>简单的形式提供基于操作数平等的条件执行。<replaceable>search-expression</>被评价并且
先后比较<literal>WHEN</>子句中的每个<replaceable>表达式</>。
如果找到匹配，那么相应的<replaceable>statements</replaceable>被执行，
然后控制在<literal>END CASE</>之后传递到下一个语句。
（随后的<literal>WHEN</>表达式不被评估。）
如果没有发现匹配，执行<literal>ELSE</> <replaceable>statements</replaceable>；
但如果<literal>ELSE</>是不存在的，然后引发<literal>CASE_NOT_FOUND</literal>异常。
</para>
 
     
<para>
     
       <!--
       Here is a simple example:
     -->
   例如：
<programlisting>
CASE x
    WHEN 1, 2 THEN
        msg := 'one or two';
    ELSE
        msg := 'other value than one or two';
END CASE;
</programlisting>
      </para>
     </sect3>

     <sect3>
  <!--
      <title>Searched <literal>CASE</></title>
  -->
  <title>搜索<literal>CASE</></title>

<synopsis>
CASE
    WHEN <replaceable>boolean-expression</replaceable> THEN
      <replaceable>statements</replaceable>
  <optional> WHEN <replaceable>boolean-expression</replaceable> THEN
      <replaceable>statements</replaceable>
    ... </optional>
  <optional> ELSE
      <replaceable>statements</replaceable> </optional>
END CASE;
</synopsis>

      <!--
<para>
       The searched form of <command>CASE</> provides conditional execution
       based on truth of Boolean expressions.  Each <literal>WHEN</> clause's
       <replaceable>boolean-expression</replaceable> is evaluated in turn,
       until one is found that yields <literal>true</>.  Then the
       corresponding <replaceable>statements</replaceable> are executed, and
       then control passes to the next statement after <literal>END CASE</>.
       (Subsequent <literal>WHEN</> expressions are not evaluated.)
       If no true result is found, the <literal>ELSE</>
       <replaceable>statements</replaceable> are executed;
       but if <literal>ELSE</> is not present, then a
       <literal>CASE_NOT_FOUND</literal> exception is raised.
      </para>
-->
<para>
    <command>CASE</>搜索形式基于布尔表达式的真理提供条件执行。
每个<literal>WHEN</>子句的<replaceable>boolean-expression</replaceable>依次被评估，
直到找到一个产生<literal>true</>为止。
然后执行相应的<replaceable>statements</replaceable>，
控制<literal>END CASE</>之后传递到下一个语句。
（随后不评估<literal>WHEN</>表达式）。
如果发现没有真实结果，则执行<literal>ELSE</><replaceable>statements</replaceable>；
但如果<literal>ELSE</>是不存在的，那么引发
<literal>CASE_NOT_FOUND</literal>异常。
</para>

     
<para>
       <!--
       Here is an example:
   -->
   例如：

<programlisting>
CASE
    WHEN x BETWEEN 0 AND 10 THEN
        msg := 'value is between zero and ten';
    WHEN x BETWEEN 11 AND 20 THEN
        msg := 'value is between eleven and twenty';
END CASE;
</programlisting>
      </para>

      <!--
<para>
       This form of <command>CASE</> is entirely equivalent to
       <literal>IF-THEN-ELSIF</>, except for the rule that reaching
       an omitted <literal>ELSE</> clause results in an error rather
       than doing nothing.
      </para>
-->
<para>
    <command>CASE</>这种形式完全等价于
<literal>IF-THEN-ELSIF</>，除了达到忽略错误中的<literal>ELSE</>子句结果而不是什么都不做的规则。
</para>

     </sect3>
   </sect2>

   <sect2 id="plpgsql-control-structures-loops">
   <!--
    <title>Simple Loops</title>
-->
<title>简单循环</title>

    <indexterm zone="plpgsql-control-structures-loops">
     <primary>loop</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>

    <!--
<para>
     With the <literal>LOOP</>, <literal>EXIT</>,
     <literal>CONTINUE</>, <literal>WHILE</>, <literal>FOR</>,
     and <literal>FOREACH</> statements, you can arrange for your
     <application>PL/pgSQL</> function to repeat a series of commands.
    </para>
-->
<para>
   使用<literal>LOOP</>, <literal>EXIT</>,<literal>CONTINUE</>, <literal>WHILE</>，
   <literal>FOR</>和<literal>FOREACH</>语句，
   可以控制<application>PL/pgSQL</>函数重复一系列命令。
</para>

    <sect3>
<!--
     <title><literal>LOOP</></title>
-->
 <title><literal>循环</></title>

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>

     <!--
<para>
      <literal>LOOP</> defines an unconditional loop that is repeated
      indefinitely until terminated by an <literal>EXIT</> or
      <command>RETURN</command> statement.  The optional
      <replaceable>label</replaceable> can be used by <literal>EXIT</>
      and <literal>CONTINUE</literal> statements within nested loops to
      specify which loop those statements refer to.
     </para>
-->
<para>
    <literal>LOOP</>定义一个无条件的循环，无限循环，
直到由<literal>EXIT</>或者
      <command>RETURN</command>语句终止。
可选的<replaceable>label</replaceable>可以由<literal>EXIT</>
    和<literal>CONTINUE</literal>语句使用，
用于在嵌套循环中声明应该应用于哪一层循环。
</para>
    </sect3>

     <sect3>
 <!--
      <title><literal>EXIT</></title>
 -->
   <title><literal>退出</></title>

     <indexterm>
      <primary>EXIT</primary>
      <secondary>in PL/pgSQL</secondary>
     </indexterm>

<synopsis>
EXIT <optional> <replaceable>label</replaceable> </optional> <optional> WHEN <replaceable>boolean-expression</replaceable> </optional>;
</synopsis>

       <!--
<para>
        If no <replaceable>label</replaceable> is given, the innermost
        loop is terminated and the statement following <literal>END
        LOOP</> is executed next.  If <replaceable>label</replaceable>
        is given, it must be the label of the current or some outer
        level of nested loop or block. Then the named loop or block is
        terminated and control continues with the statement after the
        loop's/block's corresponding <literal>END</>.
       </para>
-->
<para>
   如果没有给出<replaceable>label</replaceable>，那么退出最内层的循环，
   然后执行跟在<literal>END LOOP</>后面的语句。
   如果给出<replaceable>label</replaceable>，
   那么它必须是当前或者更高层的嵌套循环块或者语句块的标签。
   然后该命名块或者循环就会终止，而控制落到对应循环/块的<literal>END</>语句后面的语句上。
</para>

       <!--
<para>
        If <literal>WHEN</> is specified, the loop exit occurs only if
        <replaceable>boolean-expression</> is true. Otherwise, control passes
        to the statement after <literal>EXIT</>.
       </para>
-->
<para>
   如果声明了<literal>WHEN</>，
   循环退出只有在<replaceable>boolean-expression</>为真的时候才发生，
   否则控制会落到<literal>EXIT</>后面的语句上。
</para>

       <!--
<para>
        <literal>EXIT</> can be used with all types of loops; it is
        not limited to use with unconditional loops.
       </para>
-->
<para>
   <literal>EXIT</>可以用于在所有的循环类型中，它并不仅仅限制于在无条件循环中使用。
</para>

       <!--
<para>
        When used with a
        <literal>BEGIN</literal> block, <literal>EXIT</literal> passes
        control to the next statement after the end of the block.
        Note that a label must be used for this purpose; an unlabeled
        <literal>EXIT</literal> is never considered to match a
        <literal>BEGIN</literal> block.  (This is a change from
        pre-8.4 releases of <productname>PostgreSQL</productname>, which
        would allow an unlabeled <literal>EXIT</literal> to match
        a <literal>BEGIN</literal> block.)
       </para>
-->
<para>
在和<literal>BEGIN</literal>块一起使用的时候，<literal>EXIT</literal>把控制交给块结束后的下一个语句。
需要注意的是，一个标签必须用于这个目的；
一个没有标记的<literal>EXIT</literal>永远无法与<literal>BEGIN</literal>进行匹配。
（这是<productname>PostgreSQL</productname> 8.4之前版本的一个变化，
这将允许未标记<literal>EXIT</literal>匹配<literal>BEGIN</literal>块）。
</para>

       
<para>
       <!--
        Examples:
-->
例如：
<programlisting>
LOOP
    <!--
    &#045;- some computations
-->
-- 一些计算
    IF count &gt; 0 THEN
        EXIT;  -- exit loop
    END IF;
END LOOP;

LOOP
    <!--
    &#045;- some computations
-->
-- 一些计算
<!--
    EXIT WHEN count &gt; 0;  &#045;- same result as previous example
-->
EXIT WHEN count &gt; 0;  -- 和前面的例子相同结果
END LOOP;

&lt;&lt;ablock&gt;&gt;
BEGIN
    <!--
    &#045;- some computations
-->
-- 一些计算
    IF stocks &gt; 100000 THEN
<!--
        EXIT ablock;  &#045;- causes exit from the BEGIN block
-->
    EXIT ablock;  -- 导致从BEGIN块退出
    END IF;
<!--
    &#045;- computations here will be skipped when stocks &gt; 100000
-->
 -- 忽略这儿的计算，当stocks &gt; 100000时
END;
</programlisting>
       </para>

     </sect3>

     <sect3>
      <title><literal>CONTINUE</></title>

     <indexterm>
      <primary>CONTINUE</primary>
      <secondary>in PL/pgSQL</secondary>
     </indexterm>

<synopsis>
CONTINUE <optional> <replaceable>label</replaceable> </optional> <optional> WHEN <replaceable>boolean-expression</replaceable> </optional>;
</synopsis>

       <!--
<para>
        If no <replaceable>label</> is given, the next iteration of
        the innermost loop is begun. That is, all statements remaining
        in the loop body are skipped, and control returns
        to the loop control expression (if any) to determine whether
        another loop iteration is needed.
        If <replaceable>label</> is present, it
        specifies the label of the loop whose execution will be
        continued.
       </para>
-->
<para>
   如果没有给出<replaceable>label</>，那么就开始最内层循环的下一次执行。
   也就是说，控制传递回给循环控制表达式(如果有)，然后重新计算循环体。
   如果出现了<replaceable>label</>，它声明即将继续执行的循环的标签。
</para>

       <!--
<para>
        If <literal>WHEN</> is specified, the next iteration of the
        loop is begun only if <replaceable>boolean-expression</> is
        true. Otherwise, control passes to the statement after
        <literal>CONTINUE</>.
       </para>
-->
<para>
    如果声明了<literal>WHEN</>，那么循环的下一次执行只有
在<replaceable>boolean-expression</>为真的情况下才进行。
否则，控制传递给<literal>CONTINUE</>后面的语句。
</para>

       <!--
<para>
        <literal>CONTINUE</> can be used with all types of loops; it
        is not limited to use with unconditional loops.
       </para>
-->
<para>
     <literal>CONTINUE</>可以用于所有类型的循环；它并不仅仅限于无条件循环。
</para>

      
<para>
       <!--
        Examples:
   -->
     例如：
<programlisting>
LOOP
    <!--
    &#045;- some computations
-->
-- 一些计算
    EXIT WHEN count &gt; 100; 
    CONTINUE WHEN count &lt; 50;
<!--
    &#045;- some computations for count IN [50 .. 100]
-->
-- 在[50 .. 100]内的计算
END LOOP;
</programlisting>
       </para>

     </sect3>


     <sect3>
      <title><literal>WHILE</></title>

     <indexterm>
      <primary>WHILE</primary>
      <secondary>in PL/pgSQL</secondary>
     </indexterm>

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
WHILE <replaceable>boolean-expression</replaceable> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>

       <!--
<para>
        The <literal>WHILE</> statement repeats a
        sequence of statements so long as the
        <replaceable>boolean-expression</replaceable>
        evaluates to true.  The expression is checked just before
        each entry to the loop body.
       </para>
-->
<para>
    只要条件表达式（<replaceable>boolean-expression</replaceable>）为真，
<literal>WHILE</>语句就会不停的在一系列语句上进行循环，
条件是在每次进入循环体的时候被检查。
</para>

       
<para>
     
        <!--
        For example:
-->
例如：
<programlisting>
WHILE amount_owed &gt; 0 AND gift_certificate_balance &gt; 0 LOOP
<!--
    &#045;- some computations here
-->
    -- 这里的一些计算
END LOOP;

WHILE NOT done LOOP
<!--
    &#045;- some computations here
-->
    -- 这里的一些计算
END LOOP;
</programlisting>
       </para>

     </sect3>

     <sect3 id="plpgsql-integer-for">
 <!--
      <title><literal>FOR</> (Integer Variant)</title>
 -->
  <title><literal>FOR</> (Integer 变量)</title>

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>name</replaceable> IN <optional> REVERSE </optional> <replaceable>expression</replaceable> .. <replaceable>expression</replaceable> <optional> BY <replaceable>expression</replaceable> </optional> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>

       <!--
<para>
        This form of <literal>FOR</> creates a loop that iterates over a range
        of integer values. The variable
        <replaceable>name</replaceable> is automatically defined as type
        <type>integer</> and exists only inside the loop (any existing
        definition of the variable name is ignored within the loop).
        The two expressions giving
        the lower and upper bound of the range are evaluated once when entering
        the loop. If the <literal>BY</> clause isn't specified the iteration
        step is 1, otherwise it's the value specified in the <literal>BY</>
        clause, which again is evaluated once on loop entry.
        If <literal>REVERSE</> is specified then the step value is
        subtracted, rather than added, after each iteration.
       </para>
-->
<para>
    这种形式的<literal>FOR</>对一定范围的整数进行迭代的循环。
变量<replaceable>name</replaceable>会自动定义为<literal>BY</>类型并且只在循环里存在
(任何该变量名的现存定义在此循环内都将被忽略)。
给出范围上下界的两个表达式在进入循环的时候计算一次。
<literal>BY</>子句指定迭代步长(缺省为 1)，
但如果声明了<literal>REVERSE</>步长将变为相应的负值。
</para>

       
<para>
        <!--
        Some examples of integer <literal>FOR</> loops:
-->
一些整数<literal>FOR</>循环的例子：
<programlisting>
FOR i IN 1..10 LOOP
<!--
    &#045;- i will take on the values 1,2,3,4,5,6,7,8,9,10 within the loop
-->
    -- 我将在值1,2,3,4,5,6,7,8,9,10中循环
END LOOP;

FOR i IN REVERSE 10..1 LOOP
<!--
    &#045;- i will take on the values 10,9,8,7,6,5,4,3,2,1 within the loop
-->
    -- 将在值10,9,8,7,6,5,4,3,2,1中循环
END LOOP;

FOR i IN REVERSE 10..1 BY 2 LOOP
<!--
    &#045;- i will take on the values 10,8,6,4,2 within the loop
-->
    -- 将在值10,8,6,4,2中循环
END LOOP;
</programlisting>
       </para>

       <!--
<para>
        If the lower bound is greater than the upper bound (or less than,
        in the <literal>REVERSE</> case), the loop body is not
        executed at all.  No error is raised.
       </para>
-->
<para>
    如果下界大于上界(或者是在<literal>REVERSE</>情况下是小于)，
那么循环体将完全不被执行。
而且不会抛出任何错误。
</para>

       <!--
<para>
        If a <replaceable>label</replaceable> is attached to the
        <literal>FOR</> loop then the integer loop variable can be
        referenced with a qualified name, using that
        <replaceable>label</replaceable>.
       </para>
-->
<para>
    如果<replaceable>label</replaceable>被附加到<literal>FOR</>循环，那么整数循环变量
可以使用<replaceable>label</replaceable>引用适当名称。
</para>
     </sect3>
   </sect2>

   <sect2 id="plpgsql-records-iterating">
   <!--
    <title>Looping Through Query Results</title>
   -->
    <title>遍历命令结果</title>

    
<para>
     <!--
     Using a different type of <literal>FOR</> loop, you can iterate through
     the results of a query and manipulate that data
     accordingly. The syntax is:
 -->
 使用不同类型的<literal>FOR</>循环，
 你可以遍历一个命令的结果并且对其进行相应的操作。语法是：
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>target</replaceable> IN <replaceable>query</replaceable> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
     <!--
     The <replaceable>target</replaceable> is a record variable, row variable,
     or comma-separated list of scalar variables.
     The <replaceable>target</replaceable> is successively assigned each row
     resulting from the <replaceable>query</replaceable> and the loop body is
     executed for each row. Here is an example:
 -->
 <replaceable>target</replaceable>是一个记录变量、
 行变量、逗号分隔的标量变量列表<replaceable>target</replaceable>
 被连续不断赋予所有来自<replaceable>query</replaceable>的行，
 并且循环体将为每行执行一次。
 下面是一个例子：
 
<programlisting>
CREATE FUNCTION cs_refresh_mviews() RETURNS integer AS $$
DECLARE
    mviews RECORD;
BEGIN
    RAISE NOTICE 'Refreshing materialized views...';

    FOR mviews IN SELECT * FROM cs_materialized_views ORDER BY sort_key LOOP
        <!--
        &#045;- Now "mviews" has one record from cs_materialized_views
-->
-- 现在"mviews"里有了一条来自 cs_materialized_views 的记录 

        RAISE NOTICE 'Refreshing materialized view %s ...', quote_ident(mviews.mv_name);
        EXECUTE 'TRUNCATE TABLE ' || quote_ident(mviews.mv_name);
        EXECUTE 'INSERT INTO '
                   || quote_ident(mviews.mv_name) || ' '
                   || mviews.mv_query;
    END LOOP;

    RAISE NOTICE 'Done refreshing materialized views.';
    RETURN 1;
END;
$$ LANGUAGE plpgsql;
</programlisting>
      <!--
     If the loop is terminated by an <literal>EXIT</> statement, the last
     assigned row value is still accessible after the loop.
 -->
 如果循环是用一个<literal>EXIT</>语句终止的，
 那么在循环之后你仍然可以访问最后赋值的行。
    </para>
    <!--
<para>
     The <replaceable>query</replaceable> used in this type of <literal>FOR</>
     statement can be any SQL command that returns rows to the caller:
     <command>SELECT</> is the most common case,
     but you can also use <command>INSERT</>, <command>UPDATE</>, or
     <command>DELETE</> with a <literal>RETURNING</> clause.  Some utility
     commands such as <command>EXPLAIN</> will work too.
    </para>
-->
<para>
   <literal>FOR</>语句中使用的这种<replaceable>query</replaceable>可以是任何返回行的SQL命令，
   通常是<command>SELECT</>，不过带有<literal>RETURNING</>子句的<command>INSERT</>, <command>UPDATE</>
   或<command>DELETE</>也是可以的，
   一些诸如<command>EXPLAIN</>之类的命令也可以。
</para>

    <!--
<para>
     <application>PL/pgSQL</> variables are substituted into the query text,
     and the query plan is cached for possible re-use, as discussed in
     detail in <xref linkend="plpgsql-var-subst"> and
     <xref linkend="plpgsql-plan-caching">.
    </para>
-->
<para>
    <application>PL/pgSQL</>变量代替查询文本，并且查询计划为了重新使用被缓存，正如
<xref linkend="plpgsql-var-subst">和<xref linkend="plpgsql-plan-caching">。
</para>

    
<para>
     <!--
     The <literal>FOR-IN-EXECUTE</> statement is another way to iterate over
     rows:
 -->
 <literal>FOR-IN-EXECUTE</>语句是遍历所有行的另外一种方法：
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>target</replaceable> IN EXECUTE <replaceable>text_expression</replaceable> <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
     <!--
     This is like the previous form, except that the source query
     is specified as a string expression, which is evaluated and replanned
     on each entry to the <literal>FOR</> loop.  This allows the programmer to
     choose the speed of a preplanned query or the flexibility of a dynamic
     query, just as with a plain <command>EXECUTE</command> statement.
     As with <command>EXECUTE</command>, parameter values can be inserted
     into the dynamic command via <literal>USING</>.
 -->
 这个例子类似前面的形式，只不过源查询语句声明为了一个字符串表达式，
 这样它在每次进入<literal>FOR</>循环的时候都会重新计算和生成执行计划。
 这样就允许程序员在一个预先规划好了的命令所获得的速度和一个动态命令所获得的灵活性 
 (就像一个简单的<command>EXECUTE</command>语句那样)之间进行选择。
 当使用<command>EXECUTE</command>时，
 可以通过<literal>USING</>将参数值插入到动态命令中。
    </para>

    <!--
<para>
     Another way to specify the query whose results should be iterated
     through is to declare it as a cursor.  This is described in
     <xref linkend="plpgsql-cursor-for-loop">.
    </para>
-->
<para>
    对于一个需要将结果迭代的查询，
另外一个声明的方法是将它定义为游标（cursor），
可参阅<xref linkend="plpgsql-cursor-for-loop">。
</para>
   </sect2>

   <sect2 id="plpgsql-foreach-array">
    <!--
    <title>Looping Through Arrays</title>
-->
<title>遍历数组</title>

    
<para>
     <!--
     The <literal>FOREACH</> loop is much like a <literal>FOR</> loop,
     but instead of iterating through the rows returned by a SQL query,
     it iterates through the elements of an array value.
     (In general, <literal>FOREACH</> is meant for looping through
     components of a composite-valued expression; variants for looping
     through composites besides arrays may be added in future.)
     The <literal>FOREACH</> statement to loop over an array is:
     -->
 
<literal>FOREACH</>循环类似于<literal>FOR</>循环，
但不是遍历SQL查询返回的行，它遍历数组值元素。
（一般而言，<literal>FOREACH</>是遍历复合值表达式组成部分；
循环遍历除数组外的复合值变量将来可以被添加。）
<literal>FOREACH</>语句循环数组是：
 
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOREACH <replaceable>target</replaceable> <optional> SLICE <replaceable>number</replaceable> </optional> IN ARRAY <replaceable>expression</replaceable> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
    </para>

    
<para>
    <!--
     Without <literal>SLICE</>, or if <literal>SLICE 0</> is specified,
     the loop iterates through individual elements of the array produced
     by evaluating the <replaceable>expression</replaceable>.
     The <replaceable>target</replaceable> variable is assigned each
     element value in sequence, and the loop body is executed for each element.
     Here is an example of looping through the elements of an integer
     array:
    -->
没有<literal>SLICE</>，或者如果声明<literal>SLICE 0</>，则
循环遍历通过评估<replaceable>expression</replaceable>产生的数组的单个元素。  
<replaceable>target</replaceable>变量分配每个
序列中的元素值，并为每个元素执行循环体。
这里是遍历整数数组元素的一个例子：

<programlisting>
CREATE FUNCTION sum(int[]) RETURNS int8 AS $$
DECLARE
  s int8 := 0;
  x int;
BEGIN
  FOREACH x IN ARRAY $1
  LOOP
    s := s + x;
  END LOOP;
  RETURN s;
END;
$$ LANGUAGE plpgsql;
</programlisting>
    <!--
     The elements are visited in storage order, regardless of the number of
     array dimensions.  Although the <replaceable>target</replaceable> is
     usually just a single variable, it can be a list of variables when
     looping through an array of composite values (records).  In that case,
     for each array element, the variables are assigned from successive
     columns of the composite value.
 -->
 元素以存储顺序进行访问，不论数组维数的数量。尽管<replaceable>target</replaceable>
通常只是一个单一的变量，当循环复合值的数组（记录）时，它可以是一个变量列表，
在这种情况下，每个数组元素，从连续的复合值列中分配变量。
    </para>

    
<para>
    <!--
     With a positive <literal>SLICE</> value, <literal>FOREACH</>
     iterates through slices of the array rather than single elements.
     The <literal>SLICE</> value must be an integer constant not larger
     than the number of dimensions of the array.  The
     <replaceable>target</replaceable> variable must be an array,
     and it receives successive slices of the array value, where each slice
     is of the number of dimensions specified by <literal>SLICE</>.
     Here is an example of iterating through one-dimensional slices:
     -->
 以正数<literal>SLICE</>值，<literal>FOREACH</>遍历数组的元素部分，而不是单一元素。
<literal>SLICE</>的值必须是不大于数组维数的整数常数。
<replaceable>target</replaceable>变量必须是一个数组，
并且它接收数组值的连续片段，而每个片段
是通过<literal>SLICE</>指定的维数。这里是遍历一维切片的一个例子：

<programlisting>
CREATE FUNCTION scan_rows(int[]) RETURNS void AS $$
DECLARE
  x int[];
BEGIN
  FOREACH x SLICE 1 IN ARRAY $1
  LOOP
    RAISE NOTICE 'row = %', x;
  END LOOP;
END;
$$ LANGUAGE plpgsql;

SELECT scan_rows(ARRAY[[1,2,3],[4,5,6],[7,8,9],[10,11,12]]);

NOTICE:  row = {1,2,3}
NOTICE:  row = {4,5,6}
NOTICE:  row = {7,8,9}
NOTICE:  row = {10,11,12}
</programlisting>
    </para>
   </sect2>

   <sect2 id="plpgsql-error-trapping">
   <!--
    <title>Trapping Errors</title>
-->
     <title>捕获错误</title>
 
    <indexterm>
     <primary>exceptions</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>

    
<para>
    <!--
     By default, any error occurring in a <application>PL/pgSQL</>
     function aborts execution of the function, and indeed of the
     surrounding transaction as well.  You can trap errors and recover
     from them by using a <command>BEGIN</> block with an
     <literal>EXCEPTION</> clause.  The syntax is an extension of the
     normal syntax for a <command>BEGIN</> block:
    -->
缺省时，一个在<application>PL/pgSQL</>函数里发生的错误退出函数的执行，
并且实际上其周围的事务也会退出。
你可以使用一个带有<literal>EXCEPTION</>子句的<command>BEGIN</>块捕获错误并且从中恢复。
其语法是正常的<command>BEGIN</>块语法的一个扩展：
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
<optional> DECLARE
    <replaceable>declarations</replaceable> </optional>
BEGIN
    <replaceable>statements</replaceable>
EXCEPTION
    WHEN <replaceable>condition</replaceable> <optional> OR <replaceable>condition</replaceable> ... </optional> THEN
        <replaceable>handler_statements</replaceable>
    <optional> WHEN <replaceable>condition</replaceable> <optional> OR <replaceable>condition</replaceable> ... </optional> THEN
          <replaceable>handler_statements</replaceable>
      ... </optional>
END;
</synopsis>
    </para>
    <!--
<para>
     If no error occurs, this form of block simply executes all the
     <replaceable>statements</replaceable>, and then control passes
     to the next statement after <literal>END</>.  But if an error
     occurs within the <replaceable>statements</replaceable>, further
     processing of the <replaceable>statements</replaceable> is
     abandoned, and control passes to the <literal>EXCEPTION</> list.
     The list is searched for the first <replaceable>condition</replaceable>
     matching the error that occurred.  If a match is found, the
     corresponding <replaceable>handler_statements</replaceable> are
     executed, and then control passes to the next statement after
     <literal>END</>.  If no match is found, the error propagates out
     as though the <literal>EXCEPTION</> clause were not there at all:
     the error can be caught by an enclosing block with
     <literal>EXCEPTION</>, or if there is none it aborts processing
     of the function.
    </para>
-->
<para>
  如果没有发生错误，这种形式的块只是简单地执行所有<replaceable>statements</replaceable>，
  然后转到下一个<literal>END</>之后的语句。
  但是如果在<replaceable>statements</replaceable>内部发生了一个错误，
  则对<replaceable>statements</replaceable>的进一步处理将废弃，然后转到<literal>EXCEPTION</>列表。
  系统搜索这个列表，寻找匹配错误的第一个<replaceable>condition</replaceable>。
  如果找到匹配，则执行对应的<replaceable>handler_statements</replaceable>，
  然后转到<literal>END</>之后的下一个语句。如果没有找到匹配，该错误就会广播出去，
  就好像根本没有<literal>EXCEPTION</>子句一样：
  该错误可以被一个包围块用<literal>EXCEPTION</>捕获，
  如果没有包围块，则退出函数的处理。
</para>

    
<para>
     <!--
     The <replaceable>condition</replaceable> names can be any of
     those shown in <xref linkend="errcodes-appendix">.  A category
     name matches any error within its category.  The special
     condition name <literal>OTHERS</> matches every error type except
     <literal>QUERY_CANCELED</>.  (It is possible, but often unwise,
     to trap <literal>QUERY_CANCELED</> by name.)  Condition names are
     not case-sensitive.  Also, an error condition can be specified
     by <literal>SQLSTATE</> code; for example these are equivalent:
 -->
 <replaceable>condition</replaceable>的名字可以是<xref linkend="errcodes-appendix">里显示的任何名字。
 一个范畴名匹配任意该范畴里的错误。
 特殊的条件名<literal>OTHERS</>匹配除了<literal>QUERY_CANCELED</>之外的所有错误类型。
 可以用名字捕获<literal>QUERY_CANCELED</>，不过通常是不明智的。
 条件名是大小写无关的。同时也可以通过<literal>SQLSTATE</>来声明一个错误条件，
 例如：
 
<programlisting>
WHEN division_by_zero THEN ...
WHEN SQLSTATE '22012' THEN ...
</programlisting>
    </para>

    <!--
<para>
     If a new error occurs within the selected
     <replaceable>handler_statements</replaceable>, it cannot be caught
     by this <literal>EXCEPTION</> clause, but is propagated out.
     A surrounding <literal>EXCEPTION</> clause could catch it.
    </para>
-->
<para>
    如果在选中的<replaceable>handler_statements</replaceable>里发生了新错误，
那么它不能被这个<literal>EXCEPTION</>子句捕获，而是传播出去。
一个外层的<literal>EXCEPTION</>子句可以捕获它。
</para>

    
<para>
     <!--
     When an error is caught by an <literal>EXCEPTION</> clause,
     the local variables of the <application>PL/pgSQL</> function
     remain as they were when the error occurred, but all changes
     to persistent database state within the block are rolled back.
     As an example, consider this fragment:
     -->
 如果一个错误被<literal>EXCEPTION</>捕获，<application>PL/pgSQL</>函数的局部变量保持错误发生时的原值，
 但是所有该块中想固化在数据库中的状态都回滚。
 作为一个例子，让我们看看下面片断:
 
<programlisting>
INSERT INTO mytab(firstname, lastname) VALUES('Tom', 'Jones');
BEGIN
    UPDATE mytab SET firstname = 'Joe' WHERE lastname = 'Jones';
    x := x + 1;
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN
        RAISE NOTICE 'caught division_by_zero';
        RETURN x;
END;
</programlisting>
     <!--
     When control reaches the assignment to <literal>y</>, it will
     fail with a <literal>division_by_zero</> error.  This will be caught by
     the <literal>EXCEPTION</> clause.  The value returned in the
     <command>RETURN</> statement will be the incremented value of
     <literal>x</>, but the effects of the <command>UPDATE</> command will
     have been rolled back.  The <command>INSERT</> command preceding the
     block is not rolled back, however, so the end result is that the database
     contains <literal>Tom Jones</> not <literal>Joe Jones</>.
 -->
 当控制到达给<literal>y</>赋值的地方时，
 它会带着一个<literal>division_by_zero</>错误失败。
 这个错误将被<literal>EXCEPTION</>子句捕获。
 而在<command>RETURN</>语句里返回的数值将是<literal>x</>的增量值。
 但是<command>UPDATE</>已经被回滚。然而，在该块之前的<command>INSERT</>将不会回滚，
 因此最终的结果是数据库包含<literal>Tom Jones</>而不是<literal>Joe Jones</>。
    </para>

    <tip>
     <!--
<para>
      A block containing an <literal>EXCEPTION</> clause is significantly
      more expensive to enter and exit than a block without one.  Therefore,
      don't use <literal>EXCEPTION</> without need.
     </para>
-->
<para>
     进入和退出一个包含<literal>EXCEPTION</>子句的块要比不包含的块开销大的多。
 因此，不必要的时候不要使用<literal>EXCEPTION</>。
</para>
    </tip>

    <example id="plpgsql-upsert-example">
<!--
    <title>Exceptions with <command>UPDATE</>/<command>INSERT</></title>
-->
<title><command>UPDATE</>/<command>INSERT</>异常</title>
   
<para>
     <!--

    This example uses exception handling to perform either
    <command>UPDATE</> or <command>INSERT</>, as appropriate:
    -->
 这个例子根据使用异常处理器执行恰当的<command>UPDATE</>或者<command>INSERT</>。
<programlisting>
CREATE TABLE db (a INT PRIMARY KEY, b TEXT);

CREATE FUNCTION merge_db(key INT, data TEXT) RETURNS VOID AS
$$
BEGIN
    LOOP
    <!--
        &#045;- first try to update the key
-->
-- 第一次尝试更新key
        UPDATE db SET b = data WHERE a = key;
        IF found THEN
            RETURN;
        END IF;
<!--
        &#045;- not there, so try to insert the key
        &#045;- if someone else inserts the same key concurrently,
        &#045;- we could get a unique-key failure
-->
-- 不存在，所以尝试插入key,如果其他人同时插入相同的key，我们可能得到唯一key失败。
        BEGIN
            INSERT INTO db(a,b) VALUES (key, data);
            RETURN;
        EXCEPTION WHEN unique_violation THEN
<!--
            &#045;- Do nothing, and loop to try the UPDATE again.
-->
    -- 什么也不做，并且循环尝试再次更新。
        END;
    END LOOP;
END;
$$
LANGUAGE plpgsql;

SELECT merge_db(1, 'david');
SELECT merge_db(1, 'dennis');
</programlisting>
     <!--
     This coding assumes the <literal>unique_violation</> error is caused by
     the <command>INSERT</>, and not by, say, an <command>INSERT</> in a
     trigger function on the table.  It might also misbehave if there is
     more than one unique index on the table, since it will retry the
     operation regardless of which index caused the error.
     More safety could be had by using the
     features discussed next to check that the trapped error was the one
     expected.
 -->
 这个代码假设通过<command>INSERT</>不是说表上触发器函数中的<command>INSERT</>
 产生<literal>unique_violation</>错误，如果表上有超过一个以上的唯一索引，它可能行为不端，
 因为将重试操作不论哪个索引产生错误。
 可以通过特性讨论下一步检查捕获的错误是预期的来获取更高的安全性。
    </para>

    </example>

   <sect3 id="plpgsql-exception-diagnostics">
   <!--
    <title>Obtaining information about an error</title>
-->
<title>获得有关错误的信息</title>

    <!--
<para>
     Exception handlers frequently need to identify the specific error that
     occurred.  There are two ways to get information about the current
     exception in <application>PL/pgSQL</>: special variables and the
     <command>GET STACKED DIAGNOSTICS</command> command.
    </para>
-->
<para>
    异常处理程序经常需要确定发生的具体错误。有两种方法来获得
    当前<application>PL/pgSQL</>异常：
特殊变量和<command>GET STACKED DIAGNOSTICS</command>命令
的有关信息。
</para>

    <!--
<para>
     Within an exception handler, the special variable
     <varname>SQLSTATE</varname> contains the error code that corresponds to
     the exception that was raised (refer to <xref linkend="errcodes-table">
     for a list of possible error codes). The special variable
     <varname>SQLERRM</varname> contains the error message associated with the
     exception. These variables are undefined outside exception handlers.
    </para>
-->
<para>
    在一个异常处理程序中，特殊变量
<varname>SQLSTATE</varname>包含相当于发生异常的错误代码
（参考<xref linkend="errcodes-table">获得可能错误代码列）。
特殊变量<varname>SQLERRM</varname>包含与异常有关的错误消息。
这些变量是在异常处理外未被定义的。
</para>

    
<para>
    <!--
     Within an exception handler, one may also retrieve
     information about the current exception by using the
     <command>GET STACKED DIAGNOSTICS</command> command, which has the form:
    -->
 在一个异常处理程序中，也可以检索关于使用<command>GET STACKED DIAGNOSTICS</command>命令的当前异常信息，形成了：
<synopsis>
GET STACKED DIAGNOSTICS <replaceable>variable</replaceable> = <replaceable>item</replaceable> <optional> , ... </optional>;
</synopsis>
     <!--
     Each <replaceable>item</replaceable> is a key word identifying a status
     value to be assigned to the specified variable (which should be
     of the right data type to receive it).  The currently available
     status items are shown in <xref linkend="plpgsql-exception-diagnostics-values">.
 -->
 每个<replaceable>item</replaceable>是识别被分配到指定变量的状态值（应该是接收它的正确数据类型）的一个关键字。
目前可用的状态显示在<xref linkend="plpgsql-exception-diagnostics-values">中。

    </para>

     <table id="plpgsql-exception-diagnostics-values">
 <!--
      <title>Error diagnostics values</title>
  -->
  <title>错误诊断值</title>
      <tgroup cols="3">
       <thead>
        <row>
<!--
         <entry>Name</entry>
         <entry>Type</entry>
         <entry>Description</entry>
 -->
  <entry>名字</entry>
         <entry>类型</entry>
         <entry>描述</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><literal>RETURNED_SQLSTATE</literal></entry>
         <entry>text</entry>
 <!--
         <entry>the SQLSTATE error code of the exception</entry>
 -->
 <entry>异常的SQLSTATE错误代码</entry>
        </row>
        <row>
         <entry><literal>COLUMN_NAME</literal></entry>
         <entry>text</entry>
 <!--
         <entry>the name of column related to exception</entry>
 -->
 <entry>与异常相关的列名</entry>
        </row>
        <row>
         <entry><literal>CONSTRAINT_NAME</literal></entry>
         <entry>text</entry>
 <!--
         <entry>the name of constraint related to exception</entry>
 -->
 <entry>与异常相关的约束名</entry>
        </row>
        <row>
         <entry><literal>PG_DATATYPE_NAME</literal></entry>
         <entry>text</entry>
 <!--
         <entry>the name of datatype related to exception</entry>
 -->
 <entry>与异常相关的数据类型名</entry>
        </row>
        <row>
         <entry><literal>MESSAGE_TEXT</literal></entry>
         <entry>text</entry>
 <!--
         <entry>the text of the exception's primary message</entry>
 -->
 <entry>异常的主要消息文本</entry>
        </row>
        <row>
         <entry><literal>TABLE_NAME</literal></entry>
         <entry>text</entry>
 <!--
         <entry>the name of table related to exception</entry>
 -->
 <entry>与异常相关的表名</entry>
        </row>
        <row>
         <entry><literal>SCHEMA_NAME</literal></entry>
         <entry>text</entry>
 <!--
         <entry>the name of schema related to exception</entry>
 -->
 <entry>与异常相关的模式名</entry>
        </row>
        <row>
         <entry><literal>PG_EXCEPTION_DETAIL</literal></entry>
         <entry>text</entry>
 <!--
         <entry>the text of the exception's detail message, if any</entry>
 -->
 <entry>异常的详细信息文本，如果任何</entry>
        </row>
        <row>
         <entry><literal>PG_EXCEPTION_HINT</literal></entry>
         <entry>text</entry>
 <!--
         <entry>the text of the exception's hint message, if any</entry>
 -->
 <entry>异常的提示信息文本，如果任何</entry>
        </row>
        <row>
         <entry><literal>PG_EXCEPTION_CONTEXT</literal></entry>
         <entry>text</entry>
 <!--
         <entry>line(s) of text describing the call stack</entry>
 -->
 <entry>描述调用堆栈的文本线程</entry>
        </row>
       </tbody>
      </tgroup>
     </table>

    <!--
<para>
     If the exception did not set a value for an item, an empty string
     will be returned.
    </para>
-->
<para>
    如果异常没有设置项值，则返回空字符串。
</para>

    
<para>
    <!--
     Here is an example:
-->
 例子：
<programlisting>
DECLARE
  text_var1 text;
  text_var2 text;
  text_var3 text;
BEGIN
  <!--
  &#045;- some processing which might cause an exception
  -->
  -- 一些处理可能引起异常
  ...
EXCEPTION WHEN OTHERS THEN
  GET STACKED DIAGNOSTICS text_var1 = MESSAGE_TEXT,
                          text_var2 = PG_EXCEPTION_DETAIL,
                          text_var3 = PG_EXCEPTION_HINT;
END;
</programlisting>
    </para>

   </sect3>
  </sect2>
  </sect1>

  <sect1 id="plpgsql-cursors">
  <!--
   <title>Cursors</title>
   -->
    <title>游标</title>

   <indexterm zone="plpgsql-cursors">
    <primary>cursor</primary>
    <secondary>in PL/pgSQL</secondary>
   </indexterm>

   <!--
<para>
    Rather than executing a whole query at once, it is possible to set
    up a <firstterm>cursor</> that encapsulates the query, and then read
    the query result a few rows at a time. One reason for doing this is
    to avoid memory overrun when the result contains a large number of
    rows. (However, <application>PL/pgSQL</> users do not normally need
    to worry about that, since <literal>FOR</> loops automatically use a cursor
    internally to avoid memory problems.) A more interesting usage is to
    return a reference to a cursor that a function has created, allowing the
    caller to read the rows. This provides an efficient way to return
    large row sets from functions.
   </para>
-->
<para>
   如果不想一次执行整个命令，可以设置一个封装该命令的游标（<firstterm>cursor</>），
   然后每次读取几行命令结果。这么干的一个原因是在结果包含数量非常大的行时避免内存耗尽。
   不过<application>PL/pgSQL</>用户不必担心这个，因为<literal>FOR</>
   循环自动在内部使用一个游标以避免内存问题。
   一个更有趣的用法是某个函数可以返回一个它创建的游标的引用，这样就允许调用者读取各行。
   从而提供了一种从函数返回一个结果集的手段。
</para>

   <sect2 id="plpgsql-cursor-declarations">
   <!--
    <title>Declaring Cursor Variables</title>
   -->
     <title>声明游标变量</title>
    
<para>
    <!--
     All access to cursors in <application>PL/pgSQL</> goes through
     cursor variables, which are always of the special data type
     <type>refcursor</>.  One way to create a cursor variable
     is just to declare it as a variable of type <type>refcursor</>.
     Another way is to use the cursor declaration syntax,
     which in general is:
-->
所有在<application>PL/pgSQL</>里对游标的访问都是通过游标变量实现的，
它总是特殊的数据类型<type>refcursor</>。
创建游标变量的一个方法是把它声明为一个类型为<type>refcursor</>的变量。
另外一个方法是使用游标声明语法，像下面这样：

<synopsis>
<replaceable>name</replaceable> <optional> <optional> NO </optional> SCROLL </optional> CURSOR <optional> ( <replaceable>arguments</replaceable> ) </optional> FOR <replaceable>query</replaceable>;
</synopsis>
    <!--
     (<literal>FOR</> can be replaced by <literal>IS</> for
     <productname>Oracle</productname> compatibility.)
     If <literal>SCROLL</> is specified, the cursor will be capable of
     scrolling backward; if <literal>NO SCROLL</> is specified, backward
     fetches will be rejected; if neither specification appears, it is
     query-dependent whether backward fetches will be allowed.
     <replaceable>arguments</replaceable>, if specified, is a
     comma-separated list of pairs <literal><replaceable>name</replaceable>
     <replaceable>datatype</replaceable></literal> that define names to be
     replaced by parameter values in the given query.  The actual
     values to substitute for these names will be specified later,
     when the cursor is opened.
-->
(<productname>Oracle</productname>兼容中<literal>FOR</>可以用<literal>IS</>代替)。
如果定义了<literal>SCROLL</>，则游标可以向后回滚；如果定义了<literal>NO SCROLL</>，
则向后抓取的动作被拒绝；如果二者都没有定义，
那么是否进行向后取的动作会根据查询来判断。
如果有<replaceable>arguments</replaceable>，
那么它是一个逗号分隔<literal><replaceable>name</replaceable><replaceable>datatype</replaceable></literal>列表，
这个列表定义由已给查询中的参数值来替代的name。
实际用于代换这些名字的数值将在游标打开之后声明。
    </para>

    
<para>
    <!--
     Some examples:
-->
 例如：
<programlisting>
DECLARE
    curs1 refcursor;
    curs2 CURSOR FOR SELECT * FROM tenk1;
    curs3 CURSOR (key integer) FOR SELECT * FROM tenk1 WHERE unique1 = key;
</programlisting>
    <!--
     All three of these variables have the data type <type>refcursor</>,
     but the first can be used with any query, while the second has
     a fully specified query already <firstterm>bound</> to it, and the last
     has a parameterized query bound to it.  (<literal>key</> will be
     replaced by an integer parameter value when the cursor is opened.)
     The variable <literal>curs1</>
     is said to be <firstterm>unbound</> since it is not bound to
     any particular query.
 -->
 所有这三个变量都是<type>refcursor</>类型，但是第一个可以用于任何命令，
 而第二个已经绑定（<firstterm>bound</>）了一个声明完整的命令，最后一个是绑定了一个带参数的命令。
 <literal>key</>将在游标打开的时候被代换成一个整数。
 变量<literal>curs1</>可以称之为<firstterm>未绑定</>的，
 因为它没有和任何查询相绑定。
    </para>

   </sect2>

   <sect2 id="plpgsql-cursor-opening">
   <!--
    <title>Opening Cursors</title>
-->
 <title>打开游标</title>

    <!--
<para>
     Before a cursor can be used to retrieve rows, it must be
     <firstterm>opened</>. (This is the equivalent action to the SQL
     command <command>DECLARE CURSOR</>.) <application>PL/pgSQL</> has
     three forms of the <command>OPEN</> statement, two of which use unbound
     cursor variables while the third uses a bound cursor variable.
    </para>
-->
<para>
   在你使用游标检索行之前，你必需先<firstterm>打开</>它。
   这是和SQL命令<command>DECLARE CURSOR</>相等的操作。
   <application>PL/pgSQL</>有三种形式的<command>OPEN</>语句，
   两种用于未绑定的游标变量，
   另外一种用于已绑定的游标变量。
</para>

    <note>
     <!--
<para>
      Bound cursor variables can also be used without explicitly opening the cursor,
      via the <command>FOR</> statement described in
      <xref linkend="plpgsql-cursor-for-loop">.
     </para>
-->
<para>
   可以通过<xref linkend="plpgsql-cursor-for-loop">中描述的<command>FOR</>语句，
   在不用打开游标的情况下使用已绑定的游标。
</para>
    </note>

    <sect3>
     <title><command>OPEN FOR</command> <replaceable>query</replaceable></title>

<synopsis>
OPEN <replaceable>unbound_cursorvar</replaceable> <optional> <optional> NO </optional> SCROLL </optional> FOR <replaceable>query</replaceable>;
</synopsis>

       <!--
<para>
        The cursor variable is opened and given the specified query to
        execute.  The cursor cannot be open already, and it must have been
        declared as an unbound cursor variable (that is, as a simple
        <type>refcursor</> variable).  The query must be a
        <command>SELECT</command>, or something else that returns rows
        (such as <command>EXPLAIN</>).  The query
        is treated in the same way as other SQL commands in
        <application>PL/pgSQL</>: <application>PL/pgSQL</>
        variable names are substituted, and the query plan is cached for
        possible reuse.  When a <application>PL/pgSQL</>
        variable is substituted into the cursor query, the value that is
        substituted is the one it has at the time of the <command>OPEN</>;
        subsequent changes to the variable will not affect the cursor's
        behavior.
        The <literal>SCROLL</> and <literal>NO SCROLL</>
        options have the same meanings as for a bound cursor.
       </para>
-->
<para>
   该游标变量打开并且执行给出的查询。游标不能是已经打开的，
   并且它必需是声明为一个未绑定的游标(也就是声明为一个简单的<type>refcursor</>变量)。
   查询必须是一条<command>SELECT</command>或者其它返回行的东西(比如<command>EXPLAIN</>)。
   查询是和其它在<application>PL/pgSQL</>里的SQL命令平等对待的：先代换<application>PL/pgSQL</>的变量名，
   而且执行计划为将来可能的复用缓存起来。
   当一个<application>PL/pgSQL</>变量被替换到游标查询中时，
   被替换的值是在<command>OPEN</>时它所具有的值。
   后续的改变不会影响游标的动作，对于一个已经绑定的游标来说，
   <literal>SCROLL</>和<literal>NO SCROLL</>这两个选项具有相同的含义。
</para>

       
<para>
       <!--
        An example:
   -->
    一个例子：
<programlisting>
OPEN curs1 FOR SELECT * FROM foo WHERE key = mykey;
</programlisting>
       </para>

     </sect3>

    <sect3>
     <title><command>OPEN FOR EXECUTE</command></title>

<synopsis>
OPEN <replaceable>unbound_cursorvar</replaceable> <optional> <optional> NO </optional> SCROLL </optional> FOR EXECUTE <replaceable class="command">query_string</replaceable>
                                     <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional>;
</synopsis>

         <!--
<para>
          The cursor variable is opened and given the specified query to
          execute.  The cursor cannot be open already, and it must have been
          declared as an unbound cursor variable (that is, as a simple
          <type>refcursor</> variable).  The query is specified as a string
          expression, in the same way as in the <command>EXECUTE</command>
          command.  As usual, this gives flexibility so the query plan can vary
          from one run to the next (see <xref linkend="plpgsql-plan-caching">),
          and it also means that variable substitution is not done on the
          command string. As with <command>EXECUTE</command>, parameter values
          can be inserted into the dynamic command via <literal>USING</>.
          The <literal>SCROLL</> and
          <literal>NO SCROLL</> options have the same meanings as for a bound
          cursor.
         </para>
-->
<para>
    
打开游标变量并且执行给出的查询。游标不能是已打开的，
并且必须声明为一个未绑定的游标(也就是一个简单的<type>refcursor</>变量)。 
命令是用和那些用于<command>EXECUTE</command>命令一样的方法声明的字符串表达式， 
这样，就有了命令可以在两次运行间发生变化的灵活性。
参阅<xref linkend="plpgsql-plan-caching">）这也意味着在命令字符串上不能进行变量替换。
跟<command>EXECUTE</command>一起，通过使用<literal>USING</>，参数值可以被插入到动态命令中。 
对于一个已经绑定的游标来说，<literal>SCROLL</>和<literal>NO SCROLL</>这两个选项具有相同的含义。

</para>

       
<para>
       <!--
        An example:
   -->
   一个例子：
<programlisting>
OPEN curs1 FOR EXECUTE 'SELECT * FROM ' || quote_ident(tabname)
                                        || ' WHERE col1 = $1' USING keyvalue;
</programlisting>
        <!--
        In this example, the table name is inserted into the query textually,
        so use of <function>quote_ident()</> is recommended to guard against
        SQL injection.  The comparison value for <literal>col1</> is inserted
        via a <literal>USING</> parameter, so it needs no quoting.
-->
在这个例子中，表名被插入到文本查询中，
因此使用<function>quote_ident()</>时要注意SQL注入。
通过<literal>USING</>参数对插入的<literal>col1</>进行比较值，因此不需要使用引号。
       </para>

     </sect3>

    <sect3 id="plpgsql-open-bound-cursor">
     <!--
     <title>Opening a Bound Cursor</title>
     -->
 <title>打开一个绑定的游标</title>
<synopsis>
OPEN <replaceable>bound_cursorvar</replaceable> <optional> ( <optional> <replaceable>argument_name</replaceable> := </optional> <replaceable>argument_value</replaceable> <optional>, ...</optional> ) </optional>;
</synopsis>

         <!--
<para>
          This form of <command>OPEN</command> is used to open a cursor
          variable whose query was bound to it when it was declared.  The
          cursor cannot be open already.  A list of actual argument value
          expressions must appear if and only if the cursor was declared to
          take arguments.  These values will be substituted in the query.
         </para>
-->
<para>
   这种形式的<command>OPEN</command>用于打开一个游标变量，
   该游标变量的命令是在声明的时候和它绑定在一起的。游标不能是已经打开的。
   当且仅当该游标声明为接受参数的时候，语句中才必需出现一个实际参数值表达式的列表。
   这些值将代换到命令中。
</para>

         <!--
<para>
          The query plan for a bound cursor is always considered cacheable;
          there is no equivalent of <command>EXECUTE</command> in this case.
          Notice that <literal>SCROLL</> and <literal>NO SCROLL</> cannot be
          specified in <command>OPEN</>, as the cursor's scrolling
          behavior was already determined.
         </para>
-->
<para>
    一个绑定的游标的命令计划总是认为可缓冲的，这种情况下没有等效的<command>EXECUTE</command>。
需要注意的是<literal>SCROLL</>和<literal>NO SCROLL</>不能在<command>OPEN</>中被声明，
因为游标的滚动动作已经被定义了。 
</para>

         <!--
<para>
          Argument values can be passed using either <firstterm>positional</firstterm>
          or <firstterm>named</firstterm> notation.  In positional
          notation, all arguments are specified in order.  In named notation,
          each argument's name is specified using <literal>:=</literal> to
          separate it from the argument expression. Similar to calling
          functions, described in <xref linkend="sql-syntax-calling-funcs">, it
          is also allowed to mix positional and named notation.
         </para>
-->
<para>
    参数值可以使用<firstterm>positional</firstterm>或者<firstterm>named</firstterm>符号传递。
在位置符号中，所有的参数以顺序指定。
在命名法中，每个参数的名称使用<literal>:=</literal>声明以
从参数表达式中分开。类似于调用函数，在<xref linkend="sql-syntax-calling-funcs">中描述，
它也允许混合位置和命名法。
</para>

         
<para>
       <!--
          Examples (these use the cursor declaration examples above):
     -->
  例子（以上使用游标声明的例子）:
<programlisting>
OPEN curs2;
OPEN curs3(42);
OPEN curs3(key := 42);
</programlisting>
         </para>

         
<para>
       <!--
          Because variable substitution is done on a bound cursor's query,
          there are really two ways to pass values into the cursor: either
          with an explicit argument to <command>OPEN</>, or implicitly by
          referencing a <application>PL/pgSQL</> variable in the query.
          However, only variables declared before the bound cursor was
          declared will be substituted into it.  In either case the value to
          be passed is determined at the time of the <command>OPEN</>.
          For example, another way to get the same effect as the
          <literal>curs3</> example above is
  -->
  因为在绑定游标查询上做了变量替换，有两种方法将值传递到游标：要么
使用明确参数到<command>OPEN</>，或者隐式地在查询中引用<application>PL/pgSQL</>变量。
然而，只有在绑定游标之前声明的变量将取代它。在这两种情况下
可以在<command>OPEN</>时决定将被传递的值。例如，另一种方式来获得相同的效果
如<literal>curs3</>上面的例子

<programlisting>
DECLARE
    key integer;
    curs4 CURSOR FOR SELECT * FROM tenk1 WHERE unique1 = key;
BEGIN
    key := 42;
    OPEN curs4;
</programlisting>
         </para>
     </sect3>
   </sect2>

   <sect2 id="plpgsql-cursor-using">
   <!--
    <title>Using Cursors</title>
   -->
     <title>使用游标</title>

    <!--
<para>
     Once a cursor has been opened, it can be manipulated with the
     statements described here.
    </para>
-->
<para>
    一旦你已经打开了一个游标，那么你就可以用这里描述的语句操作它。
</para>

    <!--
<para>
     These manipulations need not occur in the same function that
     opened the cursor to begin with.  You can return a <type>refcursor</>
     value out of a function and let the caller operate on the cursor.
     (Internally, a <type>refcursor</> value is simply the string name
     of a so-called portal containing the active query for the cursor.  This name
     can be passed around, assigned to other <type>refcursor</> variables,
     and so on, without disturbing the portal.)
    </para>
-->
<para>
     这些操作不需要发生在和打开该游标开始操作的同一个函数里。
 你可以从函数里返回一个<type>refcursor</>值，然后让调用者操作该游标。
 在内部，<type>refcursor</>值只是一个包含该游标命令的活跃查询的信使的字符串名。
 这个名字可以传来传去，可以赋予其它<type>refcursor</>变量等等，也不用担心扰乱信使。
</para>

    <!--
<para>
     All portals are implicitly closed at transaction end.  Therefore
     a <type>refcursor</> value is usable to reference an open cursor
     only until the end of the transaction.
    </para>
-->
<para>
    所有信使在事务的结尾都会隐含地关闭。
因此一个<type>refcursor</>值只能在该事务结束前用于引用一个打开的游标。
</para>

    <sect3>
     <title><literal>FETCH</></title>

<synopsis>
FETCH <optional> <replaceable>direction</replaceable> { FROM | IN } </optional> <replaceable>cursor</replaceable> INTO <replaceable>target</replaceable>;
</synopsis>

    <!--
<para>
     <command>FETCH</command> retrieves the next row from the
     cursor into a target, which might be a row variable, a record
     variable, or a comma-separated list of simple variables, just like
     <command>SELECT INTO</command>.  If there is no next row, the
     target is set to NULL(s).  As with <command>SELECT
     INTO</command>, the special variable <literal>FOUND</literal> can
     be checked to see whether a row was obtained or not.
    </para>
-->
<para>
     <command>FETCH</command>从游标中检索下一行到目标中，
 目标可以是一个行变量、记录变量、逗号分隔的普通变量列表，
 就像<command>SELECT INTO</command>一样，
 如果下一行中没有，目标会设为NULL。如同<command>SELECT INTO</command>，
 可以使用特殊变量<literal>FOUND</literal>来检查是否检索出一个行。
</para>

    <!--
<para>
     The <replaceable>direction</replaceable> clause can be any of the
     variants allowed in the SQL <xref linkend="sql-fetch">
     command except the ones that can fetch
     more than one row; namely, it can be
     <literal>NEXT</>,
     <literal>PRIOR</>,
     <literal>FIRST</>,
     <literal>LAST</>,
     <literal>ABSOLUTE</> <replaceable>count</replaceable>,
     <literal>RELATIVE</> <replaceable>count</replaceable>,
     <literal>FORWARD</>, or
     <literal>BACKWARD</>.
     Omitting <replaceable>direction</replaceable> is the same
     as specifying <literal>NEXT</>.
     <replaceable>direction</replaceable> values that require moving
     backward are likely to fail unless the cursor was declared or opened
     with the <literal>SCROLL</> option.
    </para>
-->
<para>
    <replaceable>direction</replaceable>子句可以是任何
一个SQL <xref linkend="sql-fetch">命令允许的变量，
除了那些可以抓取不止一行的；形如：<literal>NEXT</>,
     <literal>PRIOR</>，<literal>FIRST</>，<literal>LAST</>，
     <literal>ABSOLUTE</> <replaceable>count</replaceable>，
     <literal>RELATIVE</> <replaceable>count</replaceable>，
     <literal>FORWARD</>或者<literal>BACKWARD</>。
 忽略<replaceable>direction</replaceable>作为声明的<literal>NEXT</>是相同的。
 <replaceable>direction</replaceable>值需要往后移动可能会失败，除非声明的或者打开的
 游标带有<literal>SCROLL</>选项。
 
</para>

    <!--
<para>
     <replaceable>cursor</replaceable> must be the name of a <type>refcursor</>
     variable that references an open cursor portal.
    </para>
-->
<para>
    <replaceable>cursor</replaceable>必须是一个指向一个
打开的游标的<type>refcursor</>变量的名字。
</para>

    
<para>
    <!--
     Examples:
-->
 一个例子：
<programlisting>
FETCH curs1 INTO rowvar;
FETCH curs2 INTO foo, bar, baz;
FETCH LAST FROM curs3 INTO x, y;
FETCH RELATIVE -2 FROM curs4 INTO x;
</programlisting>
       </para>

     </sect3>

    <sect3>
     <title><literal>MOVE</></title>

<synopsis>
MOVE <optional> <replaceable>direction</replaceable> { FROM | IN } </optional> <replaceable>cursor</replaceable>;
</synopsis>

    <!--
<para>
     <command>MOVE</command> repositions a cursor without retrieving
     any data. <command>MOVE</command> works exactly like the
     <command>FETCH</command> command, except it only repositions the
     cursor and does not return the row moved to. As with <command>SELECT
     INTO</command>, the special variable <literal>FOUND</literal> can
     be checked to see whether there was a next row to move to.
    </para>
-->
<para>
     <command>MOVE</command>重新定位一个游标，而不需要检索任何数据。
 <command>MOVE</command>的工作方式与<command>FETCH</command>及其相似，
 除了它只是重新定位游标并且不返回至移动到的行。
 在进行<command>SELECT INTO</command>命令时，
 声明的<literal>FOUND</literal>变量可以用来检查下一个需要移动到的行是否存在。
</para>

    <!--
<para>
     The <replaceable>direction</replaceable> clause can be any of the
     variants allowed in the SQL <xref linkend="sql-fetch">
     command, namely
     <literal>NEXT</>,
     <literal>PRIOR</>,
     <literal>FIRST</>,
     <literal>LAST</>,
     <literal>ABSOLUTE</> <replaceable>count</replaceable>,
     <literal>RELATIVE</> <replaceable>count</replaceable>,
     <literal>ALL</>,
     <literal>FORWARD</> <optional> <replaceable>count</replaceable> | <literal>ALL</> </optional>, or
     <literal>BACKWARD</> <optional> <replaceable>count</replaceable> | <literal>ALL</> </optional>.
     Omitting <replaceable>direction</replaceable> is the same
     as specifying <literal>NEXT</>.
     <replaceable>direction</replaceable> values that require moving
     backward are likely to fail unless the cursor was declared or opened
     with the <literal>SCROLL</> option.
    </para>
-->
<para>
     <replaceable>direction</replaceable>可以是任何一个SQL <xref linkend="sql-fetch">
 命令允许的变量，如下<literal>NEXT</>,
     <literal>PRIOR</>，
     <literal>FIRST</>，
     <literal>LAST</>，
     <literal>ABSOLUTE</> <replaceable>count</replaceable>,
     <literal>RELATIVE</> <replaceable>count</replaceable>,
     <literal>ALL</>，
     <literal>FORWARD</> <optional> <replaceable>count</replaceable> | <literal>ALL</> </optional>
     或者<literal>BACKWARD</> <optional> <replaceable>count</replaceable> | <literal>ALL</> </optional>。
 忽略<replaceable>direction</replaceable>作为声明的<literal>NEXT</>是相同的。
 <replaceable>direction</replaceable>值需要往后移动可能会失败，除非声明的或者打开的
 游标带有<literal>SCROLL</>选项。
</para>

    
<para>
     <!--
     Examples:
 -->
 例如：
<programlisting>
MOVE curs1;
MOVE LAST FROM curs3;
MOVE RELATIVE -2 FROM curs4;
MOVE FORWARD 2 FROM curs4;
</programlisting>
       </para>

     </sect3>

    <sect3>
     <title><literal>UPDATE/DELETE WHERE CURRENT OF</></title>

<synopsis>
UPDATE <replaceable>table</replaceable> SET ... WHERE CURRENT OF <replaceable>cursor</replaceable>;
DELETE FROM <replaceable>table</replaceable> WHERE CURRENT OF <replaceable>cursor</replaceable>;
</synopsis>

       <!--
<para>
        When a cursor is positioned on a table row, that row can be updated
        or deleted using the cursor to identify the row.  There are
        restrictions on what the cursor's query can be (in particular,
        no grouping) and it's best to use <literal>FOR UPDATE</> in the
        cursor.  For more information see the
        <xref linkend="sql-declare">
        reference page.
       </para>
-->
<para>
   当一个游标被定位到一个表的行上，那么通过使用该游标来识别该行，
   从而进行更新或删除操作。当然，对于如何定义游标查询（特别是没有分组时）是存在一定限制的；
   在游标中使用<literal>FOR UPDATE</>是个不错的主意。更多信息可参阅<xref linkend="sql-declare">。
</para>

       
<para>
      
       <!--
        An example:
   -->
   例如：
<programlisting>
UPDATE foo SET dataval = myval WHERE CURRENT OF curs1;
</programlisting>
       </para>

     </sect3>

    <sect3>
     <title><literal>CLOSE</></title>

<synopsis>
CLOSE <replaceable>cursor</replaceable>;
</synopsis>

       <!--
<para>
        <command>CLOSE</command> closes the portal underlying an open
        cursor.  This can be used to release resources earlier than end of
        transaction, or to free up the cursor variable to be opened again.
       </para>
-->
<para>
     <command>CLOSE</command>关闭支撑在一个打开的游标下面的信使。
 这样就可以在事务结束之前释放资源，
 或者释放掉该游标变量，用于稍后再次打开。
</para>

       
<para>
        <!--
        An example:
-->
例如：
<programlisting>
CLOSE curs1;
</programlisting>
       </para>

     </sect3>

    <sect3>
 <!--
     <title>Returning Cursors</title>
 -->
 <title>返回游标</title>

       <!--
<para>
        <application>PL/pgSQL</> functions can return cursors to the
        caller. This is useful to return multiple rows or columns,
        especially with very large result sets.  To do this, the function
        opens the cursor and returns the cursor name to the caller (or simply
        opens the cursor using a portal name specified by or otherwise known
        to the caller).  The caller can then fetch rows from the cursor. The
        cursor can be closed by the caller, or it will be closed automatically
        when the transaction closes.
       </para>
-->
<para>
    <application>PL/pgSQL</>函数可以向调用者返回游标这个功能用于从函数里返回多行或多列，
特别是巨大的结果集。要想这么做，该函数必须打开游标并且把该游标的名字返回给调用者，
或者简单的使用指定的入口名或调用者已知的名字打开游标。
调用者然后从游标里抓取行。游标可以由调用者关闭，或者是在事务结束的时候自动关闭。
</para>

       <!--
<para>
        The portal name used for a cursor can be specified by the
        programmer or automatically generated.  To specify a portal name,
        simply assign a string to the <type>refcursor</> variable before
        opening it.  The string value of the <type>refcursor</> variable
        will be used by <command>OPEN</> as the name of the underlying portal.
        However, if the <type>refcursor</> variable is null,
        <command>OPEN</> automatically generates a name that does not
        conflict with any existing portal, and assigns it to the
        <type>refcursor</> variable.
       </para>
-->
<para>
    函数返回的游标名可以由调用者声明或者自动生成。
要声明一个信使的名字，只要在打开游标之前，给<type>refcursor</>变量赋予一个字符串就可以了。
<type>refcursor</>变量的字符串值将被<command>OPEN</>当作下层的信使的名字使用。
不过，如果<type>refcursor</>变量是空，
那么<command>OPEN</>将自动生成一个和现有信使不冲突的名字，
然后将它赋予<type>refcursor</>变量。
</para>

       <note>
        <!--
<para>
         A bound cursor variable is initialized to the string value
         representing its name, so that the portal name is the same as
         the cursor variable name, unless the programmer overrides it
         by assignment before opening the cursor.  But an unbound cursor
         variable defaults to the null value initially, so it will receive
         an automatically-generated unique name, unless overridden.
        </para>
-->
<para>
   一个绑定的游标变量其名字初始化为对应的字符串值，
   因此信使的名字和游标变量名同名，除非程序员在打开游标之前通过赋值覆盖了这个名字。
   但是一个未绑定的游标变量初始化的时候缺省是空，
   因此它会收到一个自动生成的唯一名字，除非被覆盖。
</para>
       </note>

       
<para>
       <!--
        The following example shows one way a cursor name can be supplied by
        the caller:
      -->
    下面的例子显示了一个调用者声明游标名字的方法：
<programlisting>
CREATE TABLE test (col text);
INSERT INTO test VALUES ('123');

CREATE FUNCTION reffunc(refcursor) RETURNS refcursor AS '
BEGIN
    OPEN $1 FOR SELECT col FROM test;
    RETURN $1;
END;
' LANGUAGE plpgsql;

BEGIN;
SELECT reffunc('funccursor');
FETCH ALL IN funccursor;
COMMIT;
</programlisting>
       </para>

       
<para>
        <!--
        The following example uses automatic cursor name generation:
-->

        下面的例子使用了自动生成的游标名：
<programlisting>
CREATE FUNCTION reffunc2() RETURNS refcursor AS '
DECLARE
    ref refcursor;
BEGIN
    OPEN ref FOR SELECT col FROM test;
    RETURN ref;
END;
' LANGUAGE plpgsql;
<!--
&#045;- need to be in a transaction to use cursors.
-->
-- 需要在一个事务中使用游标。
BEGIN;
SELECT reffunc2();

      reffunc2
--------------------
 &lt;unnamed cursor 1&gt;
(1 row)

FETCH ALL IN "&lt;unnamed cursor 1&gt;";
COMMIT;
</programlisting>
       </para>


       
<para>
        <!--
        The following example shows one way to return multiple cursors
        from a single function:
-->

        下面的例子显示了从一个函数里返回多个游标的方法：
<programlisting>
CREATE FUNCTION myfunc(refcursor, refcursor) RETURNS SETOF refcursor AS $$
BEGIN
    OPEN $1 FOR SELECT * FROM table_1;
    RETURN NEXT $1;
    OPEN $2 FOR SELECT * FROM table_2;
    RETURN NEXT $2;
END;
$$ LANGUAGE plpgsql;
<!--
&#045;- need to be in a transaction to use cursors.
-->
-- 需要在事务里使用游标。
BEGIN;

SELECT * FROM myfunc('a', 'b');

FETCH ALL FROM a;
FETCH ALL FROM b;
COMMIT;
</programlisting>
       </para>

     </sect3>
   </sect2>

   <sect2 id="plpgsql-cursor-for-loop">
   <!--
    <title>Looping Through a Cursor's Result</title>
   -->
    <title>通过游标结果进行循环</title>
    
<para>
    <!--
     There is a variant of the <command>FOR</> statement that allows
     iterating through the rows returned by a cursor.  The syntax is:
    -->
 有这么一个<command>FOR</>语法的变形，它允许通过游标返回的行进行迭代。如下：
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>recordvar</replaceable> IN <replaceable>bound_cursorvar</replaceable> <optional> ( <optional> <replaceable>argument_name</replaceable> := </optional> <replaceable>argument_value</replaceable> <optional>, ...</optional> ) </optional> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
     <!--
     The cursor variable must have been bound to some query when it was
     declared, and it <emphasis>cannot</> be open already.  The
     <command>FOR</> statement automatically opens the cursor, and it closes
     the cursor again when the loop exits.  A list of actual argument value
     expressions must appear if and only if the cursor was declared to take
     arguments.  These values will be substituted in the query, in just
     the same way as during an <command>OPEN</> (see <xref
     linkend="plpgsql-open-bound-cursor">).
 -->
 在声明游标变量时，它必须已经绑定到一些查询语句上，并且<emphasis>不能</>是打开状态。
 <command>FOR</>语法会自动打开游标，并且当退出循环时自动关闭游标。只有当游标被声明要使用参数时，
 必须有一列实际参数值表达式。这些值会被替换到查询中，采用如同<command>OPEN</>的方式
 (参阅<xref linkend="plpgsql-open-bound-cursor">)。

   </para>
   
   <!--
<para>
     The variable <replaceable>recordvar</replaceable> is automatically
     defined as type <type>record</> and exists only inside the loop (any
     existing definition of the variable name is ignored within the loop).
     Each row returned by the cursor is successively assigned to this
     record variable and the loop body is executed.
    </para>
-->
<para>
 <replaceable>recordvar</replaceable>变量会自动定义为<type>record</>类型，
 并且只存在于循环中（循环中任何的定义变量名的动作都会被忽略）。
 每一个由游标返回的行都会陆续的被分配到记录变量中，然后执行循环体。
</para>
   </sect2>

  </sect1>

  <sect1 id="plpgsql-errors-and-messages">
  <!--
   <title>Errors and Messages</title>
  -->
   <title>错误和消息</title> 

   <indexterm>
    <primary>RAISE</primary>
   </indexterm>

   <indexterm>
    <primary>reporting errors</primary>
    <secondary>in PL/pgSQL</secondary>
   </indexterm>

   
<para>
    <!--
    Use the <command>RAISE</command> statement to report messages and
    raise errors.
    -->
利用<command>RAISE</command>语句报告信息以及抛出错误。
<synopsis>
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> '<replaceable class="parameter">format</replaceable>' <optional>, <replaceable class="parameter">expression</replaceable> <optional>, ... </optional></optional> <optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional> </optional>;
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> <replaceable class="parameter">condition_name</> <optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional> </optional>;
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> SQLSTATE '<replaceable class="parameter">sqlstate</>' <optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional> </optional>;
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional>;
RAISE ;
</synopsis>
    <!--
    The <replaceable class="parameter">level</replaceable> option specifies
    the error severity.  Allowed levels are <literal>DEBUG</literal>,
    <literal>LOG</literal>, <literal>INFO</literal>,
    <literal>NOTICE</literal>, <literal>WARNING</literal>,
    and <literal>EXCEPTION</literal>, with <literal>EXCEPTION</literal>
    being the default.
    <literal>EXCEPTION</literal> raises an error (which normally aborts the
    current transaction); the other levels only generate messages of different
    priority levels.
    Whether messages of a particular priority are reported to the client,
    written to the server log, or both is controlled by the
    <xref linkend="guc-log-min-messages"> and
    <xref linkend="guc-client-min-messages"> configuration
    variables. See <xref linkend="runtime-config"> for more
    information.
-->
<replaceable class="parameter">level</replaceable>选项声明了错误的严重性等级。
可能的级别有<literal>DEBUG</literal>,<literal>LOG</literal>, <literal>INFO</literal>,
    <literal>NOTICE</literal>, <literal>WARNING</literal>,
    和<literal>EXCEPTION</literal>，默认的是<literal>EXCEPTION</literal>。
<literal>EXCEPTION</literal>会抛出一个错误（强制关闭当前事务），
而其他级别仅仅是产生不同的优先级信息。
无论是将优先级别的信息是报告给客户端，还是写到服务器日志，亦或是二者都是，
都是由<xref linkend="guc-log-min-messages">和<xref linkend="guc-client-min-messages">配置变量控制的。
参阅<xref linkend="runtime-config">获取更多细节。
   </para>

   <!--
<para>
    After <replaceable class="parameter">level</replaceable> if any,
    you can write a <replaceable class="parameter">format</replaceable>
    (which must be a simple string literal, not an expression).  The
    format string specifies the error message text to be reported.
    The format string can be followed
    by optional argument expressions to be inserted into the message.
    Inside the format string, <literal>%</literal> is replaced by the
    string representation of the next optional argument's value. Write
    <literal>%%</literal> to emit a literal <literal>%</literal>.
   </para>
-->
<para>
    如果真有的话，在<replaceable class="parameter">level</replaceable>之后，
你可以写<replaceable class="parameter">format</replaceable>，
（这必须是一个简单的字符串文本，而不是表达式）。
 格式字符串声明要报告的错误信息文本。
 格式字符串可以遵循插入到信息中的可选参数表达式。
在格式字符串里，<literal>%</literal>被下一个可选参数的外部表现形式代替。
要表示<literal>%</literal>字符必须发出(<literal>%%</literal>)。

</para>

   
<para>
    <!--
    In this example, the value of <literal>v_job_id</> will replace the
    <literal>%</literal> in the string:
-->
在这个例子里，<literal>v_job_id</>的值将代替字符串中的<literal>%</literal>：
<programlisting>
RAISE NOTICE 'Calling cs_create_job(%)', v_job_id;
</programlisting>
   </para>

   
<para>
    <!--
    You can attach additional information to the error report by writing
    <literal>USING</> followed by <replaceable
    class="parameter">option</replaceable> = <replaceable
    class="parameter">expression</replaceable> items.  Each
    <replaceable class="parameter">expression</replaceable> can be any
    string-valued expression.  The allowed <replaceable
    class="parameter">option</replaceable> key words are:
     -->
 你可以通过在<replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable>项后边写<literal>USING</>来附加额外信息到错误报告中。
每一个<replaceable class="parameter">expression</replaceable>可以是任何字符串值表达式。
允许的<replaceable class="parameter">option</replaceable>关键字是：

    <variablelist id="raise-using-options">
     <varlistentry>
      <term><literal>MESSAGE</literal></term>
      <listitem>
   
       <para>
   <!--
    Sets the error message text.  This option can't be used in the
        form of <command>RAISE</> that includes a format string
        before <literal>USING</>.
-->
设置错误消息文本。这个选项不能用于包含<literal>USING</>之前的格式字符串
的<command>RAISE</>形式中。
</para>

      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DETAIL</literal></term>
      <listitem>
       <!--
<para>Supplies an error detail message.</para>
-->
<para>
     提供一个错误详细信息。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>HINT</literal></term>
      <listitem>
       <!--
<para>Supplies a hint message.</para>
-->
<para>
   提供提示信息。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ERRCODE</literal></term>
      <listitem>
       <!--
<para>Specifies the error code (SQLSTATE) to report, either by condition
        name, as shown in <xref linkend="errcodes-appendix">, or directly as a
        five-character SQLSTATE code.</para>
-->
<para>
    指定错误代码（SQLSTATE）用来报告，通过条件名，
如<xref linkend="errcodes-appendix">，或直接作为
五个字符的SQLSTATE代码。
</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>COLUMN</literal></term>
      <term><literal>CONSTRAINT</literal></term>
      <term><literal>DATATYPE</literal></term>
      <term><literal>TABLE</literal></term>
      <term><literal>SCHEMA</literal></term>
      <listitem>
       <!--
<para>Supplies the name of a related object.</para>
-->
<para>
    提供一个相关对象名称。
</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

  
<para>
     <!--
    This example will abort the transaction with the given error message
    and hint:
-->

该例子会强制退出事务，并返回如下提示：

<programlisting>
RAISE EXCEPTION 'Nonexistent ID --> %', user_id
      USING HINT = 'Please check your user ID';
</programlisting>
   </para>

   
<para>
   <!--
    These two examples show equivalent ways of setting the SQLSTATE:
   -->
   
下面两个例子在设置SQLSTATE方面具有相同的作用：
<programlisting>
RAISE 'Duplicate user ID: %', user_id USING ERRCODE = 'unique_violation';
RAISE 'Duplicate user ID: %', user_id USING ERRCODE = '23505';
</programlisting>
   </para>

   
<para>
    <!--
    There is a second <command>RAISE</> syntax in which the main argument
    is the condition name or SQLSTATE to be reported, for example:
-->
这是第二个<command>RAISE</>语法，其中主要参数是条件名字或者要报告的SQLSTATE，比如：

<programlisting>
RAISE division_by_zero;
RAISE SQLSTATE '22012';
</programlisting>
    <!--
    In this syntax, <literal>USING</> can be used to supply a custom
    error message, detail, or hint.  Another way to do the earlier
    example is
    -->
在这个语法中，<literal>USING</>可以来提供一个通用的错误信息，详情，或者提示。另一个较早的例子是：
<programlisting>
RAISE unique_violation USING MESSAGE = 'Duplicate user ID: ' || user_id;
</programlisting>
   </para>

   <!--
<para>
    Still another variant is to write <literal>RAISE USING</> or <literal>RAISE
    <replaceable class="parameter">level</replaceable> USING</> and put
    everything else into the <literal>USING</> list.
   </para>
-->
<para>
   另一个变形是
   写<literal>RAISE USING</>或者<literal>RAISE<replaceable class="parameter">level</replaceable> USING</>，
   然后将其他的所有东西都放在<literal>USING</>列中。
</para>

   <!--
<para>
    The last variant of <command>RAISE</> has no parameters at all.
    This form can only be used inside a <literal>BEGIN</> block's
    <literal>EXCEPTION</> clause;
    it causes the error currently being handled to be re-thrown.
   </para>
-->
<para>
最后一个<command>RAISE</>变形中没有任何参数。
这种形式只能在<literal>BEGIN</>块的<literal>EXCEPTION</>字句中使用。
它的作用是将正在处理的错误放到下一个封闭的块中。
</para>

   <note>
    <!--
<para>
     Before <productname>PostgreSQL</> 9.1, <command>RAISE</> without
     parameters was interpreted as re-throwing the error from the block
     containing the active exception handler.  Thus an <literal>EXCEPTION</>
     clause nested within that handler could not catch it, even if the
     <command>RAISE</> was within the nested <literal>EXCEPTION</> clause's
     block. This was deemed surprising as well as being incompatible with
     Oracle's PL/SQL.
    </para>
-->
<para>

在<productname>PostgreSQL</> 9.1之前，
没有参数的<command>RAISE</>被解释为
包含有活跃异常处理程序的块中重新抛出错误。
因此，<literal>EXCEPTION</>子句嵌套在该处理器中无法抓取它，即使
<command>RAISE</>在嵌套的<literal>EXCEPTION</>子句块中。
这被认为是令人惊讶并且不兼容Oracle的PL/SQL。

</para>
   </note>

   <!--
<para>
    If no condition name nor SQLSTATE is specified in a
    <command>RAISE EXCEPTION</command> command, the default is to use
    <literal>RAISE_EXCEPTION</> (<literal>P0001</>).  If no message
    text is specified, the default is to use the condition name or
    SQLSTATE as message text.
   </para>
-->
<para>
如果<command>RAISE EXCEPTION</command>中没有声明SQLSTATE的情形名称，
那么缺省使用<literal>RAISE_EXCEPTION</> (<literal>P0001</>)。
如果没有声明信息文本，那么缺省将情形名称或SQLSTATE作为信息文本。
</para>

   <note>
    <!--
<para>
     When specifying an error code by SQLSTATE code, you are not
     limited to the predefined error codes, but can select any
     error code consisting of five digits and/or upper-case ASCII
     letters, other than <literal>00000</>.  It is recommended that
     you avoid throwing error codes that end in three zeroes, because
     these are category codes and can only be trapped by trapping
     the whole category.
    </para>
-->
<para>
    当通过SQLSTATE编码声明一个错误代码时，你不能限制预定义错误代码，
但是可以选择任何由五个数字和/或者大写ASCII字母组成的错误代码，
而不是<literal>00000</>。建议避免抛出以三个零结尾的错误代码，因为
这些是类别码并且只能通过捕获整个类别来获取。

</para>
   </note>

 </sect1>

 <sect1 id="plpgsql-trigger">
 <!--
  <title>Trigger Procedures</title>
 -->
   <title>触发器过程</title>

  <indexterm zone="plpgsql-trigger">
   <primary>trigger</primary>
   <secondary>in PL/pgSQL</secondary>
  </indexterm>

  <sect2 id="plpgsql-dml-trigger">
  <!--
   <title>Triggers on data changes</title>
   -->
   <title>对数据变化的触发</title>

   <!--
<para>
    <application>PL/pgSQL</application> can be used to define trigger
    procedures. A trigger procedure is created with the
    <command>CREATE FUNCTION</> command, declaring it as a function with
    no arguments and a return type of <type>trigger</type>.  Note that
    the function must be declared with no arguments even if it expects
    to receive arguments specified in <command>CREATE TRIGGER</> &mdash;
    trigger arguments are passed via <varname>TG_ARGV</>, as described
    below.
  </para>
-->
<para>
   <application>PL/pgSQL</application>可以用于定义触发器过程。
   一个触发器过程是用<command>CREATE FUNCTION</>命令创建的，
   创建的形式是一个不接受参数并且返回<type>trigger</type>类型的函数。
   请注意该函数即使在<command>CREATE TRIGGER</>声明里声明为准备接受参数，
   它也必需声明为无参数，因为触发器的参数是通过<varname>TG_ARGV</>传递的(下面有描述)。
</para>

  
<para>
  
   <!--
   When a <application>PL/pgSQL</application> function is called as a
   trigger, several special variables are created automatically in the
   top-level block. They are:
    -->
在一个<application>PL/pgSQL</application>函数当做触发器调用的时候，
系统会在顶层的声明段里自动创建几个特殊变量。有如下这些：

   <variablelist>
    <varlistentry>
     <term><varname>NEW</varname></term>
     <listitem>
      <para>
   <!--
       Data type <type>RECORD</type>; variable holding the new
       database row for <command>INSERT</>/<command>UPDATE</> operations in row-level
       triggers. This variable is unassigned in statement-level triggers
       and for <command>DELETE</command> operations.
   -->
   数据类型是<type>RECORD</type>；
   该变量为行级触发器中的<command>INSERT</>/<command>UPDATE</>操作存储新数据行。
   在语句级别的触发器里这个变量以及<command>DELETE</command>操作未赋值。
   
      </para>

     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>OLD</varname></term>
     <listitem>
      <!--
<para>
       Data type <type>RECORD</type>; variable holding the old
       database row for <command>UPDATE</>/<command>DELETE</> operations in row-level
       triggers. This variable is unassigned in statement-level triggers
       and for <command>INSERT</command> operations.
      </para>
-->
<para>
    数据类型是<type>RECORD</type>；该变量为行级触发器中的<command>UPDATE</>/<command>DELETE</>操作存储旧数据行。
在语句级别的触发器里以及对<command>INSERT</command>动作，这个变量未赋值。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_NAME</varname></term>
     <listitem>
      <!--
<para>
       Data type <type>name</type>; variable that contains the name of the trigger actually
       fired.
      </para>
-->
<para>
  数据类型是<type>name</type>；该变量包含实际触发的触发器名。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_WHEN</varname></term>
     <listitem>
      <!--
<para>
       Data type <type>text</type>; a string of
       <literal>BEFORE</literal>, <literal>AFTER</literal>, or
       <literal>INSTEAD OF</literal>, depending on the trigger's definition.
      </para>
-->
<para>
   数据类型是<type>text</type>；是一个由触发器定义决定的字符串
   (<literal>BEFORE</literal>, <literal>AFTER</literal>或者<literal>INSTEAD OF</literal>)。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_LEVEL</varname></term>
     <listitem>
      <!--
<para>
       Data type <type>text</type>; a string of either
       <literal>ROW</literal> or <literal>STATEMENT</literal>
       depending on the trigger's definition.
      </para>
-->
<para>
数据类型是<type>text</type>；是一个由触发器定义决定的字符串(<literal>ROW</literal>或者<literal>STATEMENT</literal>)。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_OP</varname></term>
     <listitem>
      <!--
<para>
       Data type <type>text</type>; a string of
       <literal>INSERT</literal>, <literal>UPDATE</literal>,
       <literal>DELETE</literal>, or <literal>TRUNCATE</>
       telling for which operation the trigger was fired.
      </para>
-->
<para>
   数据类型是<type>text</type>；是一个说明激活触发器的操作的字符串
   (<literal>INSERT</literal>, <literal>UPDATE</literal>，<literal>DELETE</literal>或者<literal>TRUNCATE</>)。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_RELID</varname></term>
     <listitem>
      <!--
<para>
       Data type <type>oid</type>; the object ID of the table that caused the
       trigger invocation.
      </para>
-->
<para>
   数据类型是<type>oid</type>；是激活触发器调用的表的对象标识(OID)。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_RELNAME</varname></term>
     <listitem>
      <!--
<para>
       Data type <type>name</type>; the name of the table that caused the trigger
       invocation. This is now deprecated, and could disappear in a future
       release. Use <literal>TG_TABLE_NAME</> instead.
      </para>
-->
<para>
   数据类型是<type>name</type>；是激活触发器调用的表的名称。
   反对使用，并会在将来的版本中消失，推荐使用<literal>TG_TABLE_NAME</>。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_TABLE_NAME</varname></term>
     <listitem>
      <!--
<para>
       Data type <type>name</type>; the name of the table that
       caused the trigger invocation.
      </para>
-->
<para>
    数据类型是<type>name</type>；是激活触发器调用的表的名称。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_TABLE_SCHEMA</varname></term>
     <listitem>
      <!--
<para>
       Data type <type>name</type>; the name of the schema of the
       table that caused the trigger invocation.
      </para>
-->
<para>
   数据类型是<type>name</type>；是激活触发器调用的表的模式名。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_NARGS</varname></term>
     <listitem>
      <!--
<para>
       Data type <type>integer</type>; the number of arguments given to the trigger
       procedure in the <command>CREATE TRIGGER</command> statement.
      </para>
-->
<para>
    数据类型是<type>integer</type>；是在<command>CREATE TRIGGER</command>语句里面赋予触发器过程的参数的个数。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_ARGV[]</varname></term>
     <listitem>
      <!--
<para>
       Data type array of <type>text</type>; the arguments from
       the <command>CREATE TRIGGER</command> statement.
       The index counts from 0. Invalid
       indexes (less than 0 or greater than or equal to <varname>tg_nargs</>)
       result in a null value.
      </para>
-->
<para>
   数据类型是<type>text</type>的数组；是<command>CREATE TRIGGER</command>语句里的参数。下标从0开始记数。
   非法下标(小于0或者大于等于<varname>tg_nargs</>)导致返回一个NULL值。
</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

   <!--
<para>
    A trigger function must return either <symbol>NULL</symbol> or a
    record/row value having exactly the structure of the table the
    trigger was fired for.
   </para>
-->
<para>
   一个触发器函数必须返回<symbol>NULL</symbol>或者是
   一个与激活触发器运行的表的记录/行结构完全相同的数据。
</para>

   <!--
<para>
    Row-level triggers fired <literal>BEFORE</> can return null to signal the
    trigger manager to skip the rest of the operation for this row
    (i.e., subsequent triggers are not fired, and the
    <command>INSERT</>/<command>UPDATE</>/<command>DELETE</> does not occur
    for this row).  If a nonnull
    value is returned then the operation proceeds with that row value.
    Returning a row value different from the original value
    of <varname>NEW</> alters the row that will be inserted or
    updated.  Thus, if the trigger function wants the triggering
    action to succeed normally without altering the row
    value, <varname>NEW</varname> (or a value equal thereto) has to be
    returned.  To alter the row to be stored, it is possible to
    replace single values directly in <varname>NEW</> and return the
    modified <varname>NEW</>, or to build a complete new record/row to
    return.  In the case of a before-trigger
    on <command>DELETE</command>, the returned value has no direct
    effect, but it has to be nonnull to allow the trigger action to
    proceed.  Note that <varname>NEW</varname> is null
    in <command>DELETE</command> triggers, so returning that is
    usually not sensible.  The usual idiom in <command>DELETE</command>
    triggers is to return <varname>OLD</varname>.
   </para>
-->
<para>
    因<literal>BEFORE</>触发的行级别触发器可以返回一个NULL，
告诉触发器管理器忽略对该行剩下的操作，也就是说，随后的触发器将不再执行，
并且不会对该行产生<command>INSERT</>/<command>UPDATE</>/<command>DELETE</>动作)。
如果返回了一个非NULL的行，那么将继续对该行数值进行处理。请注意，
返回一个和原来的<varname>NEW</>不同的行数值将修改那个将插入或更新的行
因此，如果想在没有修改行值的同时成功的执行触发器动作，那么需要返回<varname>NEW</varname>（或等价的）。
为了修改行存储，可以用一个值直接代替<varname>NEW</>里的某个数值并且返回之，
或者也可以构建一个全新的记录/行再返回。在<command>DELETE</command>上的before触发器的情况下，
返回值没有直接的影响，但是它不得不是非null以允许触发器操作继续执行。
请注意<command>DELETE</command>触发器中<varname>NEW</varname>是null，因此
返回往往是不明智的。<command>DELETE</command>触发器通常情况返回<varname>OLD</varname>。
</para>

   <!--
<para>
    <literal>INSTEAD OF</> triggers (which are always row-level triggers,
    and may only be used on views) can return null to signal that they did
    not perform any updates, and that the rest of the operation for this
    row should be skipped (i.e., subsequent triggers are not fired, and the
    row is not counted in the rows-affected status for the surrounding
    <command>INSERT</>/<command>UPDATE</>/<command>DELETE</>).
    Otherwise a nonnull value should be returned, to signal
    that the trigger performed the requested operation. For
    <command>INSERT</> and <command>UPDATE</> operations, the return value
    should be <varname>NEW</>, which the trigger function may modify to
    support <command>INSERT RETURNING</> and <command>UPDATE RETURNING</>
    (this will also affect the row value passed to any subsequent triggers).
    For <command>DELETE</> operations, the return value should be
    <varname>OLD</>.
   </para>
-->
<para>
<literal>INSTEAD OF</>触发器（总是行级触发器，并且只能用于视图）可以返回null标记他们
不执行任何更新，并且应该忽略这些行操作的剩余部分（比如，随后的触发器不会被触发，并且
为了周围的<command>INSERT</>/<command>UPDATE</>/<command>DELETE</>在受影响的行状态下不计算行）。
另外应该返回一个空值，用来标记触发器执行所需要的操作。为了
<command>INSERT</>和<command>UPDATE</>操作，返回值应是<varname>NEW</>，
这个触发器函数可以修改以支持<command>INSERT RETURNING</>和<command>UPDATE RETURNING</>
（这也将影响传递到任何随后触发器的行值）。
为了<command>DELETE</>操作，返回值应是<varname>OLD</>。

</para>

   <!--
<para>
    The return value of a row-level trigger
    fired <literal>AFTER</literal> or a statement-level trigger
    fired <literal>BEFORE</> or <literal>AFTER</> is
    always ignored; it might as well be null. However, any of these types of
    triggers might still abort the entire operation by raising an error.
   </para>
-->
<para>
    一个<literal>AFTER</literal>行级别的触发器或者
<literal>BEFORE</>或者<literal>AFTER</>语句级别的触发器
返回值将总是被忽略；
它们也可以返回NULL来忽略返回值。不过，
任何这种类型的触发器仍然可以通过抛出一个错误来退出整个触发器操作。
</para>

   <!--
<para>
    <xref linkend="plpgsql-trigger-example"> shows an example of a
    trigger procedure in <application>PL/pgSQL</application>.
   </para>
-->
<para>
    <xref linkend="plpgsql-trigger-example">显示了一个<application>PL/pgSQL</application>
写的触发器过程的例子。
</para>

   <example id="plpgsql-trigger-example">
   <!--
    <title>A <application>PL/pgSQL</application> Trigger Procedure</title>
   -->
   <title><application>PL/pgSQL</application>触发器过程</title>

    <!--
<para>
     This example trigger ensures that any time a row is inserted or updated
     in the table, the current user name and time are stamped into the
     row. And it checks that an employee's name is given and that the
     salary is a positive value.
    </para>
-->
<para>
下面的示例触发器的作用是：任何时候表中插入或更新了行，当前的用户名和时间都记录入行中。
并且它保证给出了雇员名称并且薪水是一个正数。
</para>

<programlisting>
CREATE TABLE emp (
    empname text,
    salary integer,
    last_date timestamp,
    last_user text
);

CREATE FUNCTION emp_stamp() RETURNS trigger AS $emp_stamp$
    BEGIN
    <!--
        &#045;- Check that empname and salary are given
-->
-- 检查是否给出了empname和salary
        IF NEW.empname IS NULL THEN
            RAISE EXCEPTION 'empname cannot be null';
        END IF;
        IF NEW.salary IS NULL THEN
            RAISE EXCEPTION '% cannot have null salary', NEW.empname;
        END IF;
        <!--
        &#045;- Who works for us when she must pay for it?
-->
-- 必须付账给谁?
        IF NEW.salary &lt; 0 THEN
            RAISE EXCEPTION '% cannot have a negative salary', NEW.empname;
        END IF;
        <!--
        &#045;- Remember who changed the payroll when
-->
-- 记住何时何人的薪水被修改了

        NEW.last_date := current_timestamp;
        NEW.last_user := current_user;
        RETURN NEW;
    END;
$emp_stamp$ LANGUAGE plpgsql;

CREATE TRIGGER emp_stamp BEFORE INSERT OR UPDATE ON emp
    FOR EACH ROW EXECUTE PROCEDURE emp_stamp();
</programlisting> 
   </example>

   <!--
<para>
    Another way to log changes to a table involves creating a new table that
    holds a row for each insert, update, or delete that occurs. This approach
    can be thought of as auditing changes to a table.
    <xref linkend="plpgsql-trigger-audit-example"> shows an example of an
    audit trigger procedure in <application>PL/pgSQL</application>.
   </para>
-->
<para>
另外一个向表里记录变化的方法涉及创建一个新表，
然后为后来发生的每次插入、更新或者删除动作保存一行。
这个方法可以当作对一个表的审计。 
<xref linkend="plpgsql-trigger-audit-example">显示了
一个<application>PL/pgSQL</application>写的审计触发器过程的例子。
</para>

   <example id="plpgsql-trigger-audit-example">
   <!--
    <title>A <application>PL/pgSQL</application> Trigger Procedure For Auditing</title>
-->
<title><application>PL/pgSQL</application>审计触发器过程</title>

    <!--
<para>
     This example trigger ensures that any insert, update or delete of a row
     in the <literal>emp</literal> table is recorded (i.e., audited) in the <literal>emp_audit</literal> table.
     The current time and user name are stamped into the row, together with
     the type of operation performed on it.
    </para>
-->
<para>
    这个例子触发器保证了在<literal>emp</literal>表上的任何插入、更新、
删除动作都被记录到了<literal>emp_audit</literal>表里(也就是审计)。
当前时间和用户名会被记录到数据行里，以及还有执行的操作。
</para>

<programlisting>
CREATE TABLE emp (
    empname           text NOT NULL,
    salary            integer
);

CREATE TABLE emp_audit(
    operation         char(1)   NOT NULL,
    stamp             timestamp NOT NULL,
    userid            text      NOT NULL,
    empname           text      NOT NULL,
    salary integer
);

CREATE OR REPLACE FUNCTION process_emp_audit() RETURNS TRIGGER AS $emp_audit$
    BEGIN
    <!--
        &#045;-
        &#045;- Create a row in emp_audit to reflect the operation performed on emp,
        &#045;- make use of the special variable TG_OP to work out the operation.
        &#045;-
-->
--
        -- 在emp_audit里创建一行，反映对emp的操作，
        -- 使用特殊变量TG_OP获取操作类型。
        --
        IF (TG_OP = 'DELETE') THEN
            INSERT INTO emp_audit SELECT 'D', now(), user, OLD.*;
            RETURN OLD;
        ELSIF (TG_OP = 'UPDATE') THEN
            INSERT INTO emp_audit SELECT 'U', now(), user, NEW.*;
            RETURN NEW;
        ELSIF (TG_OP = 'INSERT') THEN
            INSERT INTO emp_audit SELECT 'I', now(), user, NEW.*;
            RETURN NEW;
        END IF;
        RETURN NULL; -- result is ignored since this is an AFTER trigger
    END;
$emp_audit$ LANGUAGE plpgsql;

CREATE TRIGGER emp_audit
AFTER INSERT OR UPDATE OR DELETE ON emp
    FOR EACH ROW EXECUTE PROCEDURE process_emp_audit();
</programlisting>
   </example>

   <!--
<para>
    A variation of the previous example uses a view joining the main table
    to the audit table, to show when each entry was last modified. This
    approach still records the full audit trail of changes to the table,
    but also presents a simplified view of the audit trail, showing just
    the last modified timestamp derived from the audit trail for each entry.
    <xref linkend="plpgsql-view-trigger-audit-example"> shows an example
    of an audit trigger on a view in <application>PL/pgSQL</application>.
   </para>
-->
<para>
    先前例子的一个变化使用连接主表到审计表的视图，
显示上次修改的每个项。这个方法还记录了改变表的完整审计追踪，但是
也提出了审计追踪的简单视图，显示来源于每项审计追踪的最后修改的时间戳。
<xref linkend="plpgsql-view-trigger-audit-example">显示了<application>PL/pgSQL</application>
    中视图上的审计触发器的例子。

</para>

   <example id="plpgsql-view-trigger-audit-example">
   <!--
    <title>A <application>PL/pgSQL</application> View Trigger Procedure For Auditing</title>
-->
<title>审计<application>PL/pgSQL</application>视图触发器程序</title>

    <!--
<para>
     This example uses a trigger on the view to make it updatable, and
     ensure that any insert, update or delete of a row in the view is
     recorded (i.e., audited) in the <literal>emp_audit</literal> table. The current time
     and user name are recorded, together with the type of operation
     performed, and the view displays the last modified time of each row.
    </para>
-->
<para>
    这个例子使用视图上的一个触发器更新，并且
确保任何插入，更新或删除视图中的一行被记录（即，审核）在<literal>emp_audit</literal>表中。
当前时间和用户名被记录，连同执行操作类型，而且视图显示每一行的最后修改时间。
</para>

<programlisting>
CREATE TABLE emp (
    empname           text PRIMARY KEY,
    salary            integer
);

CREATE TABLE emp_audit(
    operation         char(1)   NOT NULL,
    userid            text      NOT NULL,
    empname           text      NOT NULL,
    salary            integer,
    stamp             timestamp NOT NULL
);

CREATE VIEW emp_view AS
    SELECT e.empname,
           e.salary,
           max(ea.stamp) AS last_updated
      FROM emp e
      LEFT JOIN emp_audit ea ON ea.empname = e.empname
     GROUP BY 1, 2;

CREATE OR REPLACE FUNCTION update_emp_view() RETURNS TRIGGER AS $$
    BEGIN
    <!--
        &#045;-
        &#045;- Perform the required operation on emp, and create a row in emp_audit
        &#045;- to reflect the change made to emp.
        &#045;-
-->
--
        -- 在emp上执行所需操作，并且在emp_audit中创建一行以反映emp所做的变化。
        --
        IF (TG_OP = 'DELETE') THEN
            DELETE FROM emp WHERE empname = OLD.empname;
            IF NOT FOUND THEN RETURN NULL; END IF;

            OLD.last_updated = now();
            INSERT INTO emp_audit VALUES('D', user, OLD.*);
            RETURN OLD;
        ELSIF (TG_OP = 'UPDATE') THEN
            UPDATE emp SET salary = NEW.salary WHERE empname = OLD.empname;
            IF NOT FOUND THEN RETURN NULL; END IF;

            NEW.last_updated = now();
            INSERT INTO emp_audit VALUES('U', user, NEW.*);
            RETURN NEW;
        ELSIF (TG_OP = 'INSERT') THEN
            INSERT INTO emp VALUES(NEW.empname, NEW.salary);

            NEW.last_updated = now();
            INSERT INTO emp_audit VALUES('I', user, NEW.*);
            RETURN NEW;
        END IF;
    END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER emp_audit
INSTEAD OF INSERT OR UPDATE OR DELETE ON emp_view
    FOR EACH ROW EXECUTE PROCEDURE update_emp_view();
</programlisting>
   </example>

   <!--
<para>
    One use of triggers is to maintain a summary table
    of another table. The resulting summary can be used in place of the
    original table for certain queries &mdash; often with vastly reduced run
    times.
    This technique is commonly used in Data Warehousing, where the tables
    of measured or observed data (called fact tables) might be extremely large.
    <xref linkend="plpgsql-trigger-summary-example"> shows an example of a
    trigger procedure in <application>PL/pgSQL</application> that maintains
    a summary table for a fact table in a data warehouse.
   </para>
-->
<para>
触发器的一个用途是维持另外一个表的概要。
生成的概要可以用于在某些查询中代替原始表(通常可以大大缩小运行时间)。
这个技巧经常用于数据仓库，这个时候，
需要测量的表(叫事实表)可能会非常巨大。
<xref linkend="plpgsql-trigger-summary-example">演示了一个
<application>PL/pgSQL</application>触发器过程的例子，
它为某个数据仓库的一个事实表维护一个概要表。
</para>


   <example id="plpgsql-trigger-summary-example">
   <!--
    <title>A <application>PL/pgSQL</application> Trigger Procedure For Maintaining A Summary Table</title>
   -->
   <title>一个维护概要表的<application>PL/pgSQL</application>触发器过程</title>
    <!--
<para>
     The schema detailed here is partly based on the <emphasis>Grocery Store
     </emphasis> example from <emphasis>The Data Warehouse Toolkit</emphasis>
     by Ralph Kimball.
    </para>
-->
<para>
下面的模式有一部分
是基于<emphasis>数据仓库工具</emphasis>里面的<emphasis>Grocery Store</emphasis>例子。
</para>

<programlisting>
<!--
&#045;-
&#045;- Main tables - time dimension and sales fact.
&#045;-
-->
--
-- 主表 - 时间维以及销售事实。 
--
CREATE TABLE time_dimension (
    time_key                    integer NOT NULL,
    day_of_week                 integer NOT NULL,
    day_of_month                integer NOT NULL,
    month                       integer NOT NULL,
    quarter                     integer NOT NULL,
    year                        integer NOT NULL
);
CREATE UNIQUE INDEX time_dimension_key ON time_dimension(time_key);

CREATE TABLE sales_fact (
    time_key                    integer NOT NULL,
    product_key                 integer NOT NULL,
    store_key                   integer NOT NULL,
    amount_sold                 numeric(12,2) NOT NULL,
    units_sold                  integer NOT NULL,
    amount_cost                 numeric(12,2) NOT NULL
);
CREATE INDEX sales_fact_time ON sales_fact(time_key);
<!--
&#045;-
&#045;- Summary table - sales by time.
&#045;-
-->
--
-- 摘要表-根据时间的销售。
--
CREATE TABLE sales_summary_bytime (
    time_key                    integer NOT NULL,
    amount_sold                 numeric(15,2) NOT NULL,
    units_sold                  numeric(12) NOT NULL,
    amount_cost                 numeric(15,2) NOT NULL
);
CREATE UNIQUE INDEX sales_summary_bytime_key ON sales_summary_bytime(time_key);
<!--
&#045;-
&#045;- Function and trigger to amend summarized column(s) on UPDATE, INSERT, DELETE.
&#045;-
-->
--
-- 在UPDATE，INSERT，DELETE的时候更新概要字段的函数和触发器
--
CREATE OR REPLACE FUNCTION maint_sales_summary_bytime() RETURNS TRIGGER
AS $maint_sales_summary_bytime$
    DECLARE
        delta_time_key          integer;
        delta_amount_sold       numeric(15,2);
        delta_units_sold        numeric(12);
        delta_amount_cost       numeric(15,2);
    BEGIN
        <!--
        &#045;- Work out the increment/decrement amount(s).
-->
 -- 计算增/减量
        IF (TG_OP = 'DELETE') THEN

            delta_time_key = OLD.time_key;
            delta_amount_sold = -1 * OLD.amount_sold;
            delta_units_sold = -1 * OLD.units_sold;
            delta_amount_cost = -1 * OLD.amount_cost;

        ELSIF (TG_OP = 'UPDATE') THEN
            <!--
            &#045;- forbid updates that change the time_key -
            &#045;- (probably not too onerous, as DELETE + INSERT is how most
            &#045;- changes will be made).
-->
-- 禁止改变 time_key 的更新
            -- (可能并不是很强制，因为 DELETE + INSERT 是大多数可能产生的修改)。
            
            IF ( OLD.time_key != NEW.time_key) THEN
                RAISE EXCEPTION 'Update of time_key : % -&gt; % not allowed',
                                                      OLD.time_key, NEW.time_key;
            END IF;

            delta_time_key = OLD.time_key;
            delta_amount_sold = NEW.amount_sold - OLD.amount_sold;
            delta_units_sold = NEW.units_sold - OLD.units_sold;
            delta_amount_cost = NEW.amount_cost - OLD.amount_cost;

        ELSIF (TG_OP = 'INSERT') THEN

            delta_time_key = NEW.time_key;
            delta_amount_sold = NEW.amount_sold;
            delta_units_sold = NEW.units_sold;
            delta_amount_cost = NEW.amount_cost;

        END IF;

        <!--
        &#045;- Insert or update the summary row with the new values.
-->
 --用新数值插入或更新概要行。

        &lt;&lt;insert_update&gt;&gt;
        LOOP
            UPDATE sales_summary_bytime
                SET amount_sold = amount_sold + delta_amount_sold,
                    units_sold = units_sold + delta_units_sold,
                    amount_cost = amount_cost + delta_amount_cost
                WHERE time_key = delta_time_key;

            EXIT insert_update WHEN found;

            BEGIN
                INSERT INTO sales_summary_bytime (
                            time_key,
                            amount_sold,
                            units_sold,
                            amount_cost)
                    VALUES (
                            delta_time_key,
                            delta_amount_sold,
                            delta_units_sold,
                            delta_amount_cost
                           );

                EXIT insert_update;

            EXCEPTION
                WHEN UNIQUE_VIOLATION THEN
                    -- do nothing
            END;
        END LOOP insert_update;

        RETURN NULL;

    END;
$maint_sales_summary_bytime$ LANGUAGE plpgsql;

CREATE TRIGGER maint_sales_summary_bytime
AFTER INSERT OR UPDATE OR DELETE ON sales_fact
    FOR EACH ROW EXECUTE PROCEDURE maint_sales_summary_bytime();

INSERT INTO sales_fact VALUES(1,1,1,10,3,15);
INSERT INTO sales_fact VALUES(1,2,1,20,5,35);
INSERT INTO sales_fact VALUES(2,2,1,40,15,135);
INSERT INTO sales_fact VALUES(2,3,1,10,1,13);
SELECT * FROM sales_summary_bytime;
DELETE FROM sales_fact WHERE product_key = 1;
SELECT * FROM sales_summary_bytime;
UPDATE sales_fact SET units_sold = units_sold * 2;
SELECT * FROM sales_summary_bytime;
</programlisting>
   </example>
</sect2>

  <sect2 id="plpgsql-event-trigger">
  <!--
   <title>Triggers on events</title>
   -->
   <title>事件触发器</title>
   <!--
<para>
    <application>PL/pgSQL</application> can be used to define event
    triggers.  <productname>PostgreSQL</> requires that a procedure that
    is to be called as an event trigger must be declared as a function with
    no arguments and a return type of <literal>event_trigger</>.
   </para>
-->
<para>
   <application>PL/pgSQL</application>用于定义事件触发器。<productname>PostgreSQL</>
   要求作为事件触发器调用的程序必须声明为无参函数，并且返回<literal>event_trigger</>类型。
</para>

   
<para>
   <!--
    When a <application>PL/pgSQL</application> function is called as a
    event trigger, several special variables are created automatically
    in the top-level block. They are:
-->
    当<application>PL/pgSQL</application>函数作为事件触发器调用时，
在顶层自动创建一些特殊变量，他们是：

   <variablelist>
    <varlistentry>
     <term><varname>TG_EVENT</varname></term>
     <listitem>
      <para>
   <!--
       Data type <type>text</type>; a string representing the event the
       trigger is fired for.
   -->
   数据类型<type>text</type>;表示事件的字符串触发触发器。
      </para>

     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_TAG</varname></term>
     <listitem>
      <!--
<para>
       Data type <type>text</type>; variable that contains the command tag
       for which the trigger is fired.
      </para>
-->
<para>
    数据类型<type>text</type>;包含命令标签的变量触发的触发器。
</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

   <!--
<para>
    <xref linkend="plpgsql-event-trigger-example"> shows an example of a
    event trigger procedure in <application>PL/pgSQL</application>.
   </para>
-->
<para>
  <xref linkend="plpgsql-event-trigger-example">显示<application>PL/pgSQL</application>中的
  事件触发器程序例子。
</para>

   <example id="plpgsql-event-trigger-example">
   <!--
    <title>A <application>PL/pgSQL</application> Event Trigger Procedure</title>
-->
<title><application>PL/pgSQL</application>事件触发器程序</title>

    <!--
<para>
     This example trigger simply raises a <literal>NOTICE</literal> message
     each time a supported command is executed.
    </para>
-->
<para>
    这个例子触发器每次执行可支持命令时简单触发<literal>NOTICE</literal>消息。
</para>

<programlisting>
CREATE OR REPLACE FUNCTION snitch() RETURNS event_trigger AS $$
BEGIN
    RAISE NOTICE 'snitch: % %', tg_event, tg_tag;
END;
$$ LANGUAGE plpgsql;

CREATE EVENT TRIGGER snitch ON ddl_command_start EXECUTE PROCEDURE snitch();
</programlisting>
   </example>
  </sect2>

  </sect1>

  <sect1 id="plpgsql-implementation">
  <!--
   <title><application>PL/pgSQL</> Under the Hood</title>
   -->
   <title>在后台下的<application>PL/pgSQL</></title>

   <!--
<para>
    This section discusses some implementation details that are
    frequently important for <application>PL/pgSQL</> users to know.
   </para>
-->
<para>
   本节讨论<application>PL/pgSQL</>用户知道的比较重要的一些实现细节。
</para>

  <sect2 id="plpgsql-var-subst">
  <!--
   <title>Variable Substitution</title>
  -->
    <title>变量替换</title>

   
<para>
    <!--
    SQL statements and expressions within a <application>PL/pgSQL</> function
    can refer to variables and parameters of the function.  Behind the scenes,
    <application>PL/pgSQL</> substitutes query parameters for such references.
    Parameters will only be substituted in places where a parameter or
    column reference is syntactically allowed.  As an extreme case, consider
    this example of poor programming style:
-->
在<application>PL/pgSQL</>函数内的SQL语句和表达式
可以参考变量和函数的参数。在后台，<application>PL/pgSQL</>替代这些参考查询参数。
参数只会按照句法允许一个参数或列引用的地方被取代。作为一个极端的例子，
考虑不好的编程风格的这个例子：

<programlisting>
INSERT INTO foo (foo) VALUES (foo);
</programlisting>
    <!--
    The first occurrence of <literal>foo</> must syntactically be a table
    name, so it will not be substituted, even if the function has a variable
    named <literal>foo</>.  The second occurrence must be the name of a
    column of the table, so it will not be substituted either.  Only the
    third occurrence is a candidate to be a reference to the function's
    variable.
-->
<literal>foo</>第一次出现一定在语法上是表名字，所以它不会被取代，即使函数有一个可变名
<literal>foo</>。第二次发生必须是表列名称，所以它也不会被取代。
只有第三次发生是参考函数变量的一个候选。
   </para>

   <note>
    <!--
<para>
     <productname>PostgreSQL</productname> versions before 9.0 would try
     to substitute the variable in all three cases, leading to syntax errors.
    </para>
-->
<para>
   9.0之前的<productname>PostgreSQL</productname>版本可能尝试所有三种情况中替换变量，导致语法错误。
</para>
   </note>

   
<para>
    <!--
    Since the names of variables are syntactically no different from the names
    of table columns, there can be ambiguity in statements that also refer to
    tables: is a given name meant to refer to a table column, or a variable?
    Let's change the previous example to
-->
由于变量的名字语法上和表列名字没有什么不同，参考表的语句中有模糊：它是一个给定的名字意味着引用一个表列，或一个变量？
让我们改变以往的例子

<programlisting>
INSERT INTO dest (col) SELECT foo + bar FROM src;
</programlisting>
    <!--
    Here, <literal>dest</> and <literal>src</> must be table names, and
    <literal>col</> must be a column of <literal>dest</>, but <literal>foo</>
    and <literal>bar</> might reasonably be either variables of the function
    or columns of <literal>src</>.
-->
在这里，<literal>dest</>和<literal>src</>必须是表名，并且
<literal>col</>必须是<literal>dest</>的列，但是<literal>foo</>
和<literal>bar</>可能是函数变量或者<literal>src</>的列。
   </para>

   <!--
<para>
    By default, <application>PL/pgSQL</> will report an error if a name
    in a SQL statement could refer to either a variable or a table column.
    You can fix such a problem by renaming the variable or column,
    or by qualifying the ambiguous reference, or by telling
    <application>PL/pgSQL</> which interpretation to prefer.
   </para>
-->
<para>
    默认情况下，如果在一个SQL语句中的名字
可以参考一个变量或表列，则<application>PL/pgSQL</>将报告错误。
你可以通过重命名变量或列，或限定不明确的引用，或者告诉<application>PL/pgSQL</>
说明更喜欢哪个来解决这样的问题。
</para>

   <!--
<para>
    The simplest solution is to rename the variable or column.
    A common coding rule is to use a
    different naming convention for <application>PL/pgSQL</application>
    variables than you use for column names.  For example,
    if you consistently name function variables
    <literal>v_<replaceable>something</></literal> while none of your
    column names start with <literal>v_</>, no conflicts will occur.
   </para>
-->
<para>
  最简单的解决方案是重命名变量或列。一个常见的编码规则是使用
  <application>PL/pgSQL</application>变量的不同命名惯例而不是你使用列名称。
  比如，如果你一贯地命名函数变量<literal>v_<replaceable>something</></literal>，
  然而你的列没有以<literal>v_</>开头命名，不会发生冲突。 
</para>

   
<para>
    <!--
    Alternatively you can qualify ambiguous references to make them clear.
    In the above example, <literal>src.foo</> would be an unambiguous reference
    to the table column.  To create an unambiguous reference to a variable,
    declare it in a labeled block and use the block's label
    (see <xref linkend="plpgsql-structure">).  For example,
-->
另外你可以限定含糊的引用以使得它们明确。
在上面的例子中，<literal>src.foo</>将是表列的明确参考。
为了创建明确的引用变量，
在标记块声明它并且使用块标签（参阅<xref linkend="plpgsql-structure">）。比如，


<programlisting>
&lt;&lt;block&gt;&gt;
DECLARE
    foo int;
BEGIN
    foo := ...;
    INSERT INTO dest (col) SELECT block.foo + bar FROM src;
</programlisting>
   <!--
    Here <literal>block.foo</> means the variable even if there is a column
    <literal>foo</> in <literal>src</>.  Function parameters, as well as
    special variables such as <literal>FOUND</>, can be qualified by the
    function's name, because they are implicitly declared in an outer block
    labeled with the function's name.
-->
这里<literal>block.foo</>意味着变量，
即使在<literal>src</>中有一列<literal>foo</>。
函数的参数，以及特殊变量如<literal>FOUND</>，可以满足
函数的名字，因为他们在使用函数名标记的外部块中隐式声明。
   </para>


   <!--
<para>
    Sometimes it is impractical to fix all the ambiguous references in a
    large body of <application>PL/pgSQL</> code.  In such cases you can
    specify that <application>PL/pgSQL</> should resolve ambiguous references
    as the variable (which is compatible with <application>PL/pgSQL</>'s
    behavior before <productname>PostgreSQL</productname> 9.0), or as the
    table column (which is compatible with some other systems such as
    <productname>Oracle</productname>).
   </para>
-->
<para>
    有时修复在<application>PL/pgSQL</>编码主体下所有不明确的引用是不切实际的。
在这种情况下，你可以指定<application>PL/pgSQL</>应该解决不明确的引用，作为变量
（即兼容<productname>PostgreSQL</productname> 9.0之前的<application>PL/pgSQL</>的行为），
或作为表列（与其他一些系统兼容，如<productname>Oracle</productname>）
</para>

   <indexterm>
     <primary><varname>plpgsql.variable_conflict</> configuration parameter</primary>
   </indexterm>

   <!--
<para>
    To change this behavior on a system-wide basis, set the configuration
    parameter <literal>plpgsql.variable_conflict</> to one of
    <literal>error</>, <literal>use_variable</>, or
    <literal>use_column</> (where <literal>error</> is the factory default).
    This parameter affects subsequent compilations
    of statements in <application>PL/pgSQL</> functions, but not statements
    already compiled in the current session.
    Because changing this setting
    can cause unexpected changes in the behavior of <application>PL/pgSQL</>
    functions, it can only be changed by a superuser.
   </para>
-->
<para>
   要改变在系统范围基础上的这种行为，设置配置参数<literal>plpgsql.variable_conflict</>为
<literal>error</>, <literal>use_variable</>或者
<literal>use_column</>之一（<literal>error</>是出厂缺省值）。
此参数会影响<application>PL/pgSQL</>函数中语句后续的编译，但不是在当前会话中已编译的语句。
由于更改此设置可以导致<application>PL/pgSQL</>函数行为意想不到的变化，它只能由超级用户改变。
</para>

   
<para>
    <!--
    You can also set the behavior on a function-by-function basis, by
    inserting one of these special commands at the start of the function
    text:
-->
你也可以在功能分析的基础上设定行为，通过在函数文本的开始处插入这些特殊的命令之一：
<programlisting>
#variable_conflict error
#variable_conflict use_variable
#variable_conflict use_column
</programlisting>
    <!--
    These commands affect only the function they are written in, and override
    the setting of <literal>plpgsql.variable_conflict</>.  An example is
-->
这些命令只影响写入的函数，
并且重写<literal>plpgsql.variable_conflict</>的设置。例如：

<programlisting>
CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$
    #variable_conflict use_variable
    DECLARE
        curtime timestamp := now();
    BEGIN
        UPDATE users SET last_modified = curtime, comment = comment
          WHERE users.id = id;
    END;
$$ LANGUAGE plpgsql;
</programlisting>
    <!--
    In the <literal>UPDATE</> command, <literal>curtime</>, <literal>comment</>,
    and <literal>id</> will refer to the function's variable and parameters
    whether or not <literal>users</> has columns of those names.  Notice
    that we had to qualify the reference to <literal>users.id</> in the
    <literal>WHERE</> clause to make it refer to the table column.
    But we did not have to qualify the reference to <literal>comment</>
    as a target in the <literal>UPDATE</> list, because syntactically
    that must be a column of <literal>users</>.  We could write the same
    function without depending on the <literal>variable_conflict</> setting
    in this way:
-->
在<literal>UPDATE</>命令中，<literal>curtime</>, <literal>comment</>,
    和<literal>id</>将引用函数的变量和<literal>users</>是否具有这些名称列的参数。
    请注意我们必须限定到<literal>WHERE</>子句<literal>users.id</>的引用以使得它引用表列。
    我们没有必要限定引用到<literal>comment</>作为<literal>UPDATE</>列表中的目标，
因为语法上必定是<literal>users</>的列。
我们可以写不依赖于这种方式的<literal>variable_conflict</>设置的同样函数： 

<programlisting>
CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$
    &lt;&lt;fn&gt;&gt;
    DECLARE
        curtime timestamp := now();
    BEGIN
        UPDATE users SET last_modified = fn.curtime, comment = stamp_user.comment
          WHERE users.id = stamp_user.id;
    END;
$$ LANGUAGE plpgsql;
</programlisting>
   </para>

   <!--
<para>
    Variable substitution does not happen in the command string given
    to <command>EXECUTE</> or one of its variants.  If you need to
    insert a varying value into such a command, do so as part of
    constructing the string value, or use <literal>USING</>, as illustrated in
    <xref linkend="plpgsql-statements-executing-dyn">.
   </para>
-->
<para>
    变量代换不会发生在给定<command>EXECUTE</>或者它的变种之一的命令字符串中。
如果你需要插入一个不同的值到这个命令中，
执行它作为构建字符串值的一部分，
或使用<literal>USING</>，正如
<xref linkend="plpgsql-statements-executing-dyn">说明的。
</para>

   <!--
<para>
    Variable substitution currently works only in <command>SELECT</>,
    <command>INSERT</>, <command>UPDATE</>, and <command>DELETE</> commands,
    because the main SQL engine allows query parameters only in these
    commands.  To use a non-constant name or value in other statement
    types (generically called utility statements), you must construct
    the utility statement as a string and <command>EXECUTE</> it.
   </para>
-->
<para>
    变量替换目前只能在<command>SELECT</>,<command>INSERT</>, <command>UPDATE</>和
<command>DELETE</>命令中运行，因为主要的SQL引擎允许这些命令中的查询参数。
为了使用其他语句类型中非恒定的名称或值
（一般称为实用语句），你必须构建实用语句作为字符串并且<command>EXECUTE</>它。
</para>

  </sect2>

  <sect2 id="plpgsql-plan-caching">
  <!--
   <title>Plan Caching</title>
   -->
   <title>计划缓存</title>

   <!--
<para>
    The <application>PL/pgSQL</> interpreter parses the function's source
    text and produces an internal binary instruction tree the first time the
    function is called (within each session).  The instruction tree
    fully translates the
    <application>PL/pgSQL</> statement structure, but individual
    <acronym>SQL</acronym> expressions and <acronym>SQL</acronym> commands
    used in the function are not translated immediately.
   </para>
-->
<para>
   <application>PL/pgSQL</>解释器解析函数的源
文本并且第一次函数被调用时（每个会话中）产生一个内部二进制指令树。
指令树充分翻译<application>PL/pgSQL</>语句结构，
但个别<acronym>SQL</acronym>表达式和在函数中使用的<acronym>SQL</acronym>命令不是立即翻译。
</para>

   
<para>
    <indexterm>
     <primary>preparing a query</>
     <secondary>in PL/pgSQL</>
    </indexterm>
<!--
    As each expression and <acronym>SQL</acronym> command is first
    executed in the function, the <application>PL/pgSQL</> interpreter
    parses and analyzes the command to create a prepared statement,
    using the <acronym>SPI</acronym> manager's
    <function>SPI_prepare</function> function.
    Subsequent visits to that expression or command
    reuse the prepared statement.  Thus, a function with conditional code
    paths that are seldom visited will never incur the overhead of
    analyzing those commands that are never executed within the current
    session.  A disadvantage is that errors
    in a specific expression or command cannot be detected until that
    part of the function is reached in execution.  (Trivial syntax
    errors will be detected during the initial parsing pass, but
    anything deeper will not be detected until execution.)
-->
在函数中首先执行每个表达式和<acronym>SQL</acronym>命令，<application>PL/pgSQL</>
解释器解析并且分析命令以创建预备语句，使用<acronym>SPI</acronym>管理的
<function>SPI_prepare</function>函数。
随后访问表达式或命令重新使用事先准备好的语句。
因此，带有条件编码路径的函数很少被访问将不会产生分析不在当前会话中执行的命令的开销，
一个缺点是在一个特定的表达或命令中的错误
不能被检测到直到执行达到函数部分
（琐碎的语法错误在初步解析传递期间将被检测到，但是任何更深的东西将不会被检测到直到执行为止。）
   </para>


   <!--
<para>
    <application>PL/pgSQL</> (or more precisely, the SPI manager) can
    furthermore attempt to cache the execution plan associated with any
    particular prepared statement.  If a cached plan is not used, then
    a fresh execution plan is generated on each visit to the statement,
    and the current parameter values (that is, <application>PL/pgSQL</>
    variable values) can be used to optimize the selected plan.  If the
    statement has no parameters, or is executed many times, the SPI manager
    will consider creating a <firstterm>generic</> plan that is not dependent
    on specific parameter values, and caching that for re-use.  Typically
    this will happen only if the execution plan is not very sensitive to
    the values of the <application>PL/pgSQL</> variables referenced in it.
    If it is, generating a plan each time is a net win.  See <xref
    linkend="sql-prepare"> for more information about the behavior of
    prepared statements.
   </para>
-->
<para>
    <application>PL/pgSQL</>（或者更准确的说，SPI管理者）可以
尝试与任何特别已准备语句相关的缓存执行计划。
如果没有使用缓存计划， 
那么在每次访问语句中产生一个新的执行计划，并且
当前的参数值（即，<application>PL/pgSQL</>
变量值）可以用来优化选择方案。
如果语句没有参数，或是执行多次，SPI管理者
将考虑创建<firstterm>generic</>计划不依赖于特定的参数值，并且缓存再利用。
只有执行计划对<application>PL/pgSQL</>变量中引用的值不太敏感时，往往会发生。
如果是，每次生成一个计划都是净赢。
参阅<xref linkend="sql-prepare">获得更多有关预备语句行为信息。 
</para>

   <!--
<para>
    Because <application>PL/pgSQL</application> saves prepared statements
    and sometimes execution plans in this way,
    SQL commands that appear directly in a
    <application>PL/pgSQL</application> function must refer to the
    same tables and columns on every execution; that is, you cannot use
    a parameter as the name of a table or column in an SQL command.  To get
    around this restriction, you can construct dynamic commands using
    the <application>PL/pgSQL</application> <command>EXECUTE</command>
    statement &mdash; at the price of performing new parse analysis and
    constructing a new execution plan on every execution.
    
   </para>
-->
<para>
    因为<application>PL/pgSQL</application>保存已预备好语句并且有时以这种方式执行计划，
直接出现在<application>PL/pgSQL</application>函数中的SQL命令必须查阅相同表和每个执行列；
也就是说，你不能使用参数作为SQL命令的表或列的名字。
为了应对这个限制，
你可以使用<application>PL/pgSQL</application> <command>EXECUTE</command>
语句构建动态命令；以执行新的解析分析和每个执行上构建新的执行计划为代价。
</para>

    <!--
<para>
     The mutable nature of record variables presents another problem in this
     connection.  When fields of a record variable are used in
     expressions or statements, the data types of the fields must not
     change from one call of the function to the next, since each
     expression will be analyzed using the data type that is present
     when the expression is first reached.  <command>EXECUTE</command> can be
     used to get around this problem when necessary.
    </para>
-->
<para>
    记录变量的可变性质提出连接中的另一个问题。
当在表达式或语句中使用记录变量字段时，
该字段数据类型必须不能从函数的一个调用到下一个改变，
因为当表达式第一个到达时使用目前数据类型分析每个表达式。
<command>EXECUTE</command>必要时可以用于解决这个问题。
</para>

    <!--
<para>
     If the same function is used as a trigger for more than one table,
     <application>PL/pgSQL</application> prepares and caches statements
     independently for each such table &mdash; that is, there is a cache
     for each trigger function and table combination, not just for each
     function.  This alleviates some of the problems with varying
     data types; for instance, a trigger function will be able to work
     successfully with a column named <literal>key</> even if it happens
     to have different types in different tables.
    </para>
-->
<para>
    如果相同函数作为多个表的触发器使用，
<application>PL/pgSQL</application>为了每个表独立地准备并且缓存声明；
即，有一个触发器函数和表组合的高速缓存，而不只是为每个函数。
这解决了一些数据类型不同的问题；例如，一个触发器函数可以使用命名<literal>key</>的列
成功运行，即使发生不同的表中有不同的类型。
</para>

    <!--
<para>
     Likewise, functions having polymorphic argument types have a separate
     statement cache for each combination of actual argument types they have
     been invoked for, so that data type differences do not cause unexpected
     failures.
    </para>
-->
<para>
    同样，具有多态性参数类型的函数
有一个他们被调用的实际参数类型的每个组合的单独声明缓存，
所以该数据类型差异不会导致意外失败。
</para>

   
<para>
    <!--
    Statement caching can sometimes have surprising effects on the
    interpretation of time-sensitive values.  For example there
    is a difference between what these two functions do:
    -->
语句缓存有时会对时间敏感值的解释有令人惊讶的影响。
例如在这两个函数要做的内容之间有区别：

<programlisting>
CREATE FUNCTION logfunc1(logtxt text) RETURNS void AS $$
    BEGIN
        INSERT INTO logtable VALUES (logtxt, 'now');
    END;
$$ LANGUAGE plpgsql;
</programlisting>
     <!--
     and: 
 -->
 和

<programlisting>
CREATE FUNCTION logfunc2(logtxt text) RETURNS void AS $$
    DECLARE
        curtime timestamp;
    BEGIN
        curtime := 'now';
        INSERT INTO logtable VALUES (logtxt, curtime);
    END;
$$ LANGUAGE plpgsql;
</programlisting>
    </para>

    <!--
<para>
     In the case of <function>logfunc1</function>, the
     <productname>PostgreSQL</productname> main parser knows when
     analyzing the <command>INSERT</command> that the
     string <literal>'now'</literal> should be interpreted as
     <type>timestamp</type>, because the target column of
     <classname>logtable</classname> is of that type. Thus,
     <literal>'now'</literal> will be converted to a <type>timestamp</type>
     constant when the
     <command>INSERT</command> is analyzed, and then used in all
     invocations of <function>logfunc1</function> during the lifetime
     of the session. Needless to say, this isn't what the programmer
     wanted.  A better idea is to use the <literal>now()</> or
     <literal>current_timestamp</> function.
    </para>
-->
<para>
    在<function>logfunc1</function>的情况下，该
<productname>PostgreSQL</productname>主解析器知道当
分析<command>INSERT</command>时
字符串<literal>'now'</literal>应解释为<type>时间戳</type>，
因为<classname>logtable</classname>目标列是那种类型。
因此，当分析<command>INSERT</command>时，
<literal>'now'</literal>将被转换为<type>timestamp</type>常量，
然后在会话的整个生命周期中用于<function>logfunc1</function>的所有调用。
不用说，这不是程序员希望的。
一个更好的办法是使用<literal>now()</>或者<literal>current_timestamp</>函数。
</para>

    <!--
<para>
     In the case of <function>logfunc2</function>, the
     <productname>PostgreSQL</productname> main parser does not know
     what type <literal>'now'</literal> should become and therefore
     it returns a data value of type <type>text</type> containing the string
     <literal>now</literal>. During the ensuing assignment
     to the local variable <varname>curtime</varname>, the
     <application>PL/pgSQL</application> interpreter casts this
     string to the <type>timestamp</type> type by calling the
     <function>text_out</function> and <function>timestamp_in</function>
     functions for the conversion.  So, the computed time stamp is updated
     on each execution as the programmer expects.  Even though this
     happens to work as expected, it's not terribly efficient, so
     use of the <literal>now()</> function would still be a better idea.
    </para>
-->
<para>
    在<function>logfunc2</function>的情况下，
<productname>PostgreSQL</productname>主解析器并不知道
<literal>'now'</literal>应该成为什么类型，因此它返回包含字符串<literal>now</literal>
类型<type>text</type>的数据值。
随后分配给局部变量<varname>curtime</varname>期间，
<application>PL/pgSQL</application>解析器通过调用<function>text_out</function>和
<function>timestamp_in</function>转换函数将这个字符串转换为<type>timestamp</type>类型，
因此，作为编程期望每次执行时更新计算时间戳。
尽管这正如预期的那样发生，这不是非常有效的，
所以<literal>now()</>函数的使用仍然会是一个更好的主意。
</para>

  </sect2>

  </sect1>

 <sect1 id="plpgsql-development-tips">
 <!--
  <title>Tips for Developing in <application>PL/pgSQL</application></title>
  -->
    <title>开发<application>PL/pgSQL</application>的一些提示</title>

   
<para>
    <!--
    One good way to develop in
    <application>PL/pgSQL</> is to use the text editor of your
    choice to create your functions, and in another window, use
    <application>psql</application> to load and test those functions.
    If you are doing it this way, it
    is a good idea to write the function using <command>CREATE OR
    REPLACE FUNCTION</>. That way you can just reload the file to update
    the function definition.  For example:
-->
用<application>PL/pgSQL</>做开发的一个好方法是简单地使用文本编辑器创建函数，
然后在另外一个控制台里，用<application>psql</application>加载这些函数。
如果你用这种方法，那么用<command>CREATE OR REPLACE FUNCTION</>写函数是个好主意。
这样，重读文件就可以更新函数定义。比如：

<programlisting>
CREATE OR REPLACE FUNCTION testfunc(integer) RETURNS integer AS $$
          ....
$$ LANGUAGE plpgsql;
</programlisting>
   </para>

   
<para>
    <!--
    While running <application>psql</application>, you can load or reload such
    a function definition file with:
-->
在运行<application>psql</application>的时候，
可以用下面命令加载或者重载函数定义文件:

<programlisting>
\i filename.sql
</programlisting>
   <!--
    and then immediately issue SQL commands to test the function.
-->
然后马上发出SQL命令测试该函数。 
   </para>

   <!--
<para>
    Another good way to develop in <application>PL/pgSQL</> is with a
    GUI database access tool that facilitates development in a
    procedural language. One example of such a tool is
    <application>pgAdmin</>, although others exist. These tools often
    provide convenient features such as escaping single quotes and
    making it easier to recreate and debug functions.
   </para>
-->
<para>
   另外一个开发<application>PL/pgSQL</>程序的好方法是使用一种支持
   过程语言开发的GUI工具。
   比如<application>pgAdmin</>，当然还有其它的。这些工具通常提供了一些很有用的功能，
   比如逃逸单引号使得重建和调试函数更简单等。
</para>

  <sect2 id="plpgsql-quote-tips">
  <!--
   <title>Handling of Quotation Marks</title>
   -->
   <title>引号标记处理</title>

   
<para>
    <!--
    The code of a <application>PL/pgSQL</> function is specified in
    <command>CREATE FUNCTION</command> as a string literal.  If you
    write the string literal in the ordinary way with surrounding
    single quotes, then any single quotes inside the function body
    must be doubled; likewise any backslashes must be doubled (assuming
    escape string syntax is used).
    Doubling quotes is at best tedious, and in more complicated cases
    the code can become downright incomprehensible, because you can
    easily find yourself needing half a dozen or more adjacent quote marks.
    It's recommended that you instead write the function body as a
    <quote>dollar-quoted</> string literal (see <xref
    linkend="sql-syntax-dollar-quoting">).  In the dollar-quoting
    approach, you never double any quote marks, but instead take care to
    choose a different dollar-quoting delimiter for each level of
    nesting you need.  For example, you might write the <command>CREATE
    FUNCTION</command> command as: 
-->
<application>PL/pgSQL</>函数的代码都是在
<command>CREATE FUNCTION</command>里以一个字符串文本的方式声明的。
如果你用两边包围单引号的常规方式写字符串文本，那么任何函数体内的单引号都必须写双份；
类似的是反斜杠也必须双份。双份引号非常乏味，在更复杂的场合下，代码可能会让人难以理解，
因为你很容易发现自己需要半打甚至更多相连的引号。
建议你用<quote>dollar-quoted</>的字符串文本来写函数体。
(参阅<xref linkend="sql-syntax-dollar-quoting">)。使用美元符界定的时候，
你从不需要对任何引号写双份，
只需要为每层引号包围嵌套选择一个不同的美元符号包围分隔符即可。
比如，你可能这么写<command>CREATE FUNCTION</command>命令：

<programlisting>
CREATE OR REPLACE FUNCTION testfunc(integer) RETURNS integer AS $PROC$
          ....
$PROC$ LANGUAGE plpgsql;
</programlisting>
    <!--
    Within this, you might use quote marks for simple literal strings in
    SQL commands and <literal>$$</> to delimit fragments of SQL commands
    that you are assembling as strings.  If you need to quote text that
    includes <literal>$$</>, you could use <literal>$Q$</>, and so on.
-->
在这个函数体中，可以在SQL命令里使用单引号包围文本字符串，
用<literal>$$</>分隔那些SQL命令的片断。
如果你需要对包含<literal>$$</>的文本进行引号包围，可以使用<literal>$Q$</>等等。
   </para>

   <!--
<para>
    The following chart shows what you have to do when writing quote
    marks without dollar quoting.  It might be useful when translating
    pre-dollar quoting code into something more comprehensible.
  </para>
-->
<para>
   下表展示了不使用美元符界定的时候该如何写单引号。
   把美元符引号之前的引号包围的代码转换成某种可以理解的形式时，
   应该会用得上。
</para>

  <variablelist>
   <varlistentry>
   <!--
    <term>1 quotation mark</term>
-->
 <term>1个单引号</term>
    <listitem>
     
<para>
      <!--
      To begin and end the function body, for example:
  -->
  开始/结束函数体，比如：
  
<programlisting>
CREATE FUNCTION foo() RETURNS integer AS '
          ....
' LANGUAGE plpgsql;
</programlisting>
      <!--
      Anywhere within a single-quoted function body, quote marks
      <emphasis>must</> appear in pairs.
  -->
  在函数体内部的任何位置，问号都<emphasis>必须</>成对出现。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
   <!--
    <term>2 quotation marks</term>
   -->
     <term>2个单引号</term>
    <listitem>
     
<para>
      <!--
      For string literals inside the function body, for example:
  -->
  对于函数体内的字符串文本，比如：
<programlisting>
a_output := ''Blah'';
SELECT * FROM users WHERE f_name=''foobar'';
</programlisting>
      <!--
      In the dollar-quoting approach, you'd just write:
  -->
  在美元符界定的方法里，你只要写:
<programlisting>
a_output := 'Blah';
SELECT * FROM users WHERE f_name='foobar';
</programlisting>
      <!--
      which is exactly what the <application>PL/pgSQL</> parser would see
      in either case.
  -->
  两种情况都是<application>PL/pgSQL</>分析器期望看到的东西。
     </para>

    </listitem>
   </varlistentry>

   <varlistentry>
   <!--
    <term>4 quotation marks</term>
-->
<term>4个单引号</term>
    <listitem>
     
<para>
      <!--
      When you need a single quotation mark in a string constant inside the
      function body, for example:
  -->
  如果你在函数体中的字符串里面需要一个单引号，比如：
<programlisting>
a_output := a_output || '' AND name LIKE ''''foobar'''' AND xyz''
</programlisting>
      <!--
      The value actually appended to <literal>a_output</literal> would be:
      <literal> AND name LIKE 'foobar' AND xyz</literal>.
  -->
  <literal>a_output</literal>的值将是<literal> AND name LIKE 'foobar' AND xyz</literal>。
     </para>

     
<para>
      <!--
      In the dollar-quoting approach, you'd write:
  -->
  使用美元符界定的方法应该这样写:
<programlisting>
a_output := a_output || $$ AND name LIKE 'foobar' AND xyz$$
</programlisting>
      <!--
      being careful that any dollar-quote delimiters around this are not
      just <literal>$$</>.
  -->
  注意，这样的美元符界定的分隔符并不是只有<literal>$$</>。

     </para>

    </listitem>
   </varlistentry>

   <varlistentry>
   <!--
    <term>6 quotation marks</term>
-->
<term>6个单引号</term>
    <listitem>
     
<para>
      <!--
      When a single quotation mark in a string inside the function body is
      adjacent to the end of that string constant, for example:
  -->
  如果一个在函数体中的字符串内的单引号与该字符串常量结尾前后相连，比如：
<programlisting>
a_output := a_output || '' AND name LIKE ''''foobar''''''
</programlisting>
     <!--
      The value appended to <literal>a_output</literal> would then be:
      <literal> AND name LIKE 'foobar'</literal>.
  -->
  
  <literal>a_output</literal>的值将是<literal> AND name LIKE 'foobar'</literal>。
     </para>

     
<para>
     <!--
      In the dollar-quoting approach, this becomes:
  -->
  用美元符界定的方法则为是:
<programlisting>
a_output := a_output || $$ AND name LIKE 'foobar'$$
</programlisting>
     </para>

    </listitem>
   </varlistentry>

   <varlistentry>
   <!--
    <term>10 quotation marks</term>
-->
<term>10个单引号</term>
    <listitem>
     
<para>
      <!--
      When you want two single quotation marks in a string constant (which
      accounts for 8 quotation marks) and this is adjacent to the end of that
      string constant (2 more).  You will probably only need that if
      you are writing a function that generates other functions, as in
      <xref linkend="plpgsql-porting-ex2">.
      For example:
  -->
  如果你想要在字符串常量里有两个单引号(它们在一起是8个了) ，
  并且这两个单引号和该字符串常量的结尾相连(又加2个)。
  可能只有在写一个生成其它函数的函数的时候，
  像<xref linkend="plpgsql-porting-ex2">里那样。比如：
  
<programlisting>
a_output := a_output || '' if v_'' ||
    referrer_keys.kind || '' like ''''''''''
    || referrer_keys.key_string || ''''''''''
    then return ''''''  || referrer_keys.referrer_type
    || ''''''; end if;'';
</programlisting>
      <!--
      The value of <literal>a_output</literal> would then be:
  -->
  <literal>a_output</literal>的值将是:
<programlisting>
if v_... like ''...'' then return ''...''; end if;
</programlisting>
     </para>

     
<para>
      <!--
      In the dollar-quoting approach, this becomes:
  -->
  使用美元符界定的方法应该这样写:
<programlisting>
a_output := a_output || $$ if v_$$ || referrer_keys.kind || $$ like '$$
    || referrer_keys.key_string || $$'
    then return '$$  || referrer_keys.referrer_type
    || $$'; end if;$$;
</programlisting>
      <!--
      where we assume we only need to put single quote marks into
      <literal>a_output</literal>, because it will be re-quoted before use.
  -->
  假设我们只需要在<literal>a_output</literal>里放单引号，因为在使用前它会被重新引号包围。
     </para>

    </listitem>
   </varlistentry>
  </variablelist>

  </sect2>
 </sect1>

  <!-- **** Porting from Oracle PL/SQL **** -->

 <sect1 id="plpgsql-porting">
 <!--
  <title>Porting from <productname>Oracle</productname> PL/SQL</title>
 -->
 <title>从<productname>Oracle</productname> PL/SQL进行移植</title>

  <indexterm zone="plpgsql-porting">
   <primary>Oracle</primary>
   <secondary>porting from PL/SQL to PL/pgSQL</secondary>
  </indexterm>

  <indexterm zone="plpgsql-porting">
   <primary>PL/SQL (Oracle)</primary>
   <secondary>porting to PL/pgSQL</secondary>
  </indexterm>

  <!--
<para>
   This section explains differences between
   <productname>PostgreSQL</>'s <application>PL/pgSQL</application>
   language and Oracle's <application>PL/SQL</application> language,
   to help developers who port applications from
   <trademark class="registered">Oracle</> to <productname>PostgreSQL</>.
  </para>
-->
<para>
   本节解释了<productname>PostgreSQL</>的<application>PL/pgSQL</application>
   和Oracle的<application>PL/SQL</application>语言之间的差别，
   希望能对那些从<trademark class="registered">Oracle</>向
   <productname>PostgreSQL</>移植应用的人有所帮助。 
</para>

  
<para>
    <!--
   <application>PL/pgSQL</application> is similar to PL/SQL in many
   aspects. It is a block-structured, imperative language, and all
   variables have to be declared.  Assignments, loops, conditionals
   are similar.  The main differences you should keep in mind when
   porting from <application>PL/SQL</> to
   <application>PL/pgSQL</application> are:
    -->
<application>PL/pgSQL</application>与PL/SQL在许多方面都非常类似。
它是一种块结构的，祈使语气(命令性)的语言并且必须声明所有变量。
赋值、循环、条件等都很类似。在从<application>PL/SQL</>向
   <application>PL/pgSQL</application>移植的时候必须记住一些事情：

    <itemizedlist>
     <listitem>
      <para>
   <!--
       If a name used in a SQL command could be either a column name of a
       table or a reference to a variable of the function,
       <application>PL/SQL</> treats it as a column name.  This corresponds
       to <application>PL/pgSQL</>'s
       <literal>plpgsql.variable_conflict</> = <literal>use_column</>
       behavior, which is not the default,
       as explained in <xref linkend="plpgsql-var-subst">.
       It's often best to avoid such ambiguities in the first place,
       but if you have to port a large amount of code that depends on
       this behavior, setting <literal>variable_conflict</> may be the
       best solution.
   -->
   如果一个SQL命令中使用的名字是一个表中的列名，或者是一个函数中变量的引用，
   那么<application>PL/SQL</>会将它当作一个变量名。
   这对应的是<application>PL/pgSQL</>的<literal>plpgsql.variable_conflict</> = <literal>use_column</>
   动作（不是默认动作），
   参考<xref linkend="plpgsql-var-subst">中的描述。
   首先，最好是避免这种模糊的方式，但如果不得不移植一个依赖于该动作的大量的代码，
   那么设置<literal>variable_conflict</>是个不错的主意。
   
      </para>

     </listitem>

     <listitem>
      <!--
<para>
       In <productname>PostgreSQL</> the function body must be written as
       a string literal.  Therefore you need to use dollar quoting or escape
       single quotes in the function body. (See <xref
       linkend="plpgsql-quote-tips">.)
      </para>
-->
<para>
   在<productname>PostgreSQL</>里，函数体必须写成字符串文本，
   因此你需要使用美元符界定或者逃逸函数体里面的单引号(见<xref linkend="plpgsql-quote-tips">)。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       Instead of packages, use schemas to organize your functions
       into groups.
      </para>
-->
<para>
    应该用模式把函数组织成不同的组，而不是用包。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       Since there are no packages, there are no package-level variables
       either. This is somewhat annoying.  You can keep per-session state
       in temporary tables instead.
      </para>
-->
<para>
    因为没有包，所以也没有包级别的变量。这一点有时候挺讨厌。
你可以在临时表里保存会话级别的状态。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       Integer <command>FOR</> loops with <literal>REVERSE</> work
       differently: <application>PL/SQL</> counts down from the second
       number to the first, while <application>PL/pgSQL</> counts down
       from the first number to the second, requiring the loop bounds
       to be swapped when porting.  This incompatibility is unfortunate
       but is unlikely to be changed. (See <xref
       linkend="plpgsql-integer-for">.)
      </para>
-->
<para>
    带有<literal>REVERSE</>的整数的<command>FOR</>循环的工作模式是不一样的：
<application>PL/SQL</>中是从第二个数向第一个数倒计，
而<application>PL/pgSQL</>是从第一个数想第二个数倒计，
因此在移植时，需要交换循环边界。
不幸的是这种不兼容性是不太可能改变的（参阅<xref linkend="plpgsql-integer-for">）。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       <command>FOR</> loops over queries (other than cursors) also work
       differently: the target variable(s) must have been declared,
       whereas <application>PL/SQL</> always declares them implicitly.
       An advantage of this is that the variable values are still accessible
       after the loop exits.
      </para>
-->
<para>
   遍历查询的<command>FOR</>循环（而不是循环游标）同样有不同的工作模式：
   必须已经声明了目标变量，在这一点上<application>PL/SQL</>通常是隐式的声明。
   这样做的优点是，在退出循环后，仍然可以获得变量值。
</para>
     </listitem>

     <listitem>
      <!--
<para>
       There are various notational differences for the use of cursor
       variables.
      </para>
-->
<para>
     在使用游标变量方面，存在一些记数法差异。
</para>
     </listitem>

    </itemizedlist>
   </para>

  <sect2>
   <!--
   <title>Porting Examples</title>
   -->
   <title>移植样例</title>
   
   <!--
<para>
    <xref linkend="pgsql-porting-ex1"> shows how to port a simple
    function from <application>PL/SQL</> to <application>PL/pgSQL</>.
   </para>
-->
<para>
     <xref linkend="pgsql-porting-ex1">演示了
 如何从<application>PL/SQL</>向<application>PL/pgSQL</>移植一个简单的函数。
</para>

   <example id="pgsql-porting-ex1">
   <!--
    <title>Porting a Simple Function from <application>PL/SQL</> to <application>PL/pgSQL</></title>
   -->
    <title>从<application>PL/SQL</>向<application>PL/pgSQL</>移植一个简单的函数</title>

    
<para>
     <!--
     Here is an <productname>Oracle</productname> <application>PL/SQL</> function:
 -->
 下面是一个<productname>Oracle</productname> <application>PL/SQL</>函数:
<programlisting>
CREATE OR REPLACE FUNCTION cs_fmt_browser_version(v_name varchar,
                                                  v_version varchar)
RETURN varchar IS
BEGIN
    IF v_version IS NULL THEN
        RETURN v_name;
    END IF;
    RETURN v_name || '/' || v_version;
END;
/
show errors;
</programlisting>
    </para>

    
<para>
     <!--
     Let's go through this function and see the differences compared to
     <application>PL/pgSQL</>:
     -->
 让我们读一遍这个函数然后看<application>PL/pgSQL</>与之的不同：
     <itemizedlist>
      <listitem>
       <para>
    <!--
        The <literal>RETURN</literal> key word in the function
        prototype (not the function body) becomes
        <literal>RETURNS</literal> in
        <productname>PostgreSQL</productname>.
        Also, <literal>IS</> becomes <literal>AS</>, and you need to
        add a <literal>LANGUAGE</> clause because <application>PL/pgSQL</>
        is not the only possible function language.
-->
在函数原型里的<literal>RETURN</literal>(不是函数体里的)关键字到了<productname>PostgreSQL</productname>里就
是<literal>RETURNS</literal>。还有，
<literal>IS</>变成<literal>AS</>，
并且你还需要增加一个<literal>LANGUAGE</>子句，
因为<application>PL/pgSQL</>并非唯一可用的函数语言。
       </para>

      </listitem>

      <listitem>
       <!--
<para>
        In <productname>PostgreSQL</>, the function body is considered
        to be a string literal, so you need to use quote marks or dollar
        quotes around it.  This substitutes for the terminating <literal>/</>
        in the Oracle approach.
       </para>
-->
<para>
    在<productname>PostgreSQL</>里，函数体被认为是一个字符串文本，
所以你需要使用单引号或者美元符界定它，
这个包围符代替了Oracle 最后的那个<literal>/</>。
</para>
      </listitem>

      <listitem>
       <!--
<para>
        The <literal>show errors</literal> command does not exist in
        <productname>PostgreSQL</>, and is not needed since errors are
        reported automatically.
       </para>
-->
<para>
    在<productname>PostgreSQL</>里没有<literal>show errors</literal>命令，
不需要这个命令是因为错误是自动报告的。
</para>
      </listitem>
     </itemizedlist>
    </para>

    
<para>
    <!--
     This is how this function would look when ported to
     <productname>PostgreSQL</>:
    -->
下面是这个函数移植到<productname>PostgreSQL</>之后的样子:
<programlisting>
CREATE OR REPLACE FUNCTION cs_fmt_browser_version(v_name varchar,
                                                  v_version varchar)
RETURNS varchar AS $$
BEGIN
    IF v_version IS NULL THEN
        RETURN v_name;
    END IF;
    RETURN v_name || '/' || v_version;
END;
$$ LANGUAGE plpgsql;
</programlisting>
    </para>

   </example>

   <!--
<para>
    <xref linkend="plpgsql-porting-ex2"> shows how to port a
    function that creates another function and how to handle the
    ensuing quoting problems.
   </para>
-->
<para>
    <xref linkend="plpgsql-porting-ex2">演示了如何移植一个创建另外一个函数的函数的方法，
以及演示了如何处理引号逃逸的问题。
</para>

   <example id="plpgsql-porting-ex2">
   <!--
    <title>Porting a Function that Creates Another Function from <application>PL/SQL</> to <application>PL/pgSQL</></title>
   -->
    <title>从<application>PL/SQL</>向<application>PL/pgSQL</>移植一个创建其它函数的函数</title>
    
    <!--
<para>
     The following procedure grabs rows from a
     <command>SELECT</command> statement and builds a large function
     with the results in <literal>IF</literal> statements, for the
     sake of efficiency.
    </para>
-->
<para>
    下面的过程从一个<command>SELECT</command>语句中抓取若干行，
然后为了提高效率，又用<literal>IF</literal>语句中的结果制作了一个巨大的函数。
</para>

    
<para>
     <!--
     This is the Oracle version:
 -->
 这是Oracle版本:
<programlisting>
CREATE OR REPLACE PROCEDURE cs_update_referrer_type_proc IS
    CURSOR referrer_keys IS
        SELECT * FROM cs_referrer_keys
        ORDER BY try_order;
    func_cmd VARCHAR(4000);
BEGIN
    func_cmd := 'CREATE OR REPLACE FUNCTION cs_find_referrer_type(v_host IN VARCHAR,
                 v_domain IN VARCHAR, v_url IN VARCHAR) RETURN VARCHAR IS BEGIN';

    FOR referrer_key IN referrer_keys LOOP
        func_cmd := func_cmd ||
          ' IF v_' || referrer_key.kind
          || ' LIKE ''' || referrer_key.key_string
          || ''' THEN RETURN ''' || referrer_key.referrer_type
          || '''; END IF;';
    END LOOP;

    func_cmd := func_cmd || ' RETURN NULL; END;';

    EXECUTE IMMEDIATE func_cmd;
END;
/
show errors;
</programlisting>
    </para>

    
<para>
     <!--
     Here is how this function would end up in <productname>PostgreSQL</>:
 -->
 下面是这个函数在<productname>PostgreSQL</>里面的样子：
<programlisting>
CREATE OR REPLACE FUNCTION cs_update_referrer_type_proc() RETURNS void AS $func$
DECLARE
    referrer_keys CURSOR IS
        SELECT * FROM cs_referrer_keys
        ORDER BY try_order;
    func_body text;
    func_cmd text;
BEGIN
    func_body := 'BEGIN';

    FOR referrer_key IN referrer_keys LOOP
        func_body := func_body ||
          ' IF v_' || referrer_key.kind
          || ' LIKE ' || quote_literal(referrer_key.key_string)
          || ' THEN RETURN ' || quote_literal(referrer_key.referrer_type)
          || '; END IF;' ;
    END LOOP;

    func_body := func_body || ' RETURN NULL; END;';

    func_cmd :=
      'CREATE OR REPLACE FUNCTION cs_find_referrer_type(v_host varchar,
                                                        v_domain varchar,
                                                        v_url varchar)
        RETURNS varchar AS '
      || quote_literal(func_body)
      || ' LANGUAGE plpgsql;' ;

    EXECUTE func_cmd;
END;
$func$ LANGUAGE plpgsql;
</programlisting>
     <!--
     Notice how the body of the function is built separately and passed
     through <literal>quote_literal</> to double any quote marks in it.  This
     technique is needed because we cannot safely use dollar quoting for
     defining the new function: we do not know for sure what strings will
     be interpolated from the <structfield>referrer_key.key_string</> field.
     (We are assuming here that <structfield>referrer_key.kind</> can be
     trusted to always be <literal>host</>, <literal>domain</>, or
     <literal>url</>, but <structfield>referrer_key.key_string</> might be
     anything, in particular it might contain dollar signs.) This function
     is actually an improvement on the Oracle original, because it will
     not generate broken code when <structfield>referrer_key.key_string</> or
     <structfield>referrer_key.referrer_type</> contain quote marks.
 -->
 请注意函数体是如何独立制作并且传递给<literal>quote_literal</>，对其中的单引号复制双份的。
 需要这个技巧是因为无法使用美元符界定定义新函数：
 没法保证<structfield>referrer_key.key_string</>字段过来的字符串会解析成什么样子。
 可以假设<structfield>referrer_key.kind</>是只有<literal>host</>, <literal>domain</>或者
     <literal>url</>，但是<structfield>referrer_key.key_string</>可能是任何东西，特别是它可能包含美元符。
 这个函数实际上是对原来 Oracle 版本的一个改进，
 因为如果在<structfield>referrer_key.key_string</>或者
     <structfield>referrer_key.referrer_type</>包含单引号的时候，
 它不会生成有毛病的代码。 
 
    </para>

   </example>

   <!--
<para>
    <xref linkend="plpgsql-porting-ex3"> shows how to port a function
    with <literal>OUT</> parameters and string manipulation.
    <productname>PostgreSQL</> does not have a built-in
    <function>instr</function> function, but you can create one
    using a combination of other
    functions.<indexterm><primary>instr</></indexterm> In <xref
    linkend="plpgsql-porting-appendix"> there is a
    <application>PL/pgSQL</application> implementation of
    <function>instr</function> that you can use to make your porting
    easier.
   </para>
-->
<para>
   <xref linkend="plpgsql-porting-ex3">演示了如何移植一个带有<literal>OUT</>参数和字符串处理的函数。
   <productname>PostgreSQL</>里面没有内置<function>instr</function>函数，但是你可以用其它函数的组合来绕开它。
   <indexterm><primary>instr</></indexterm>
   在<xref  linkend="plpgsql-porting-appendix">里有一个<application>PL/pgSQL</application>
的<function>instr</function>实现，你可以用它让你的移植变得更简单些。
</para>

   <example id="plpgsql-porting-ex3">
   <!--
    <title>Porting a Procedure With String Manipulation and
    <literal>OUT</> Parameters from <application>PL/SQL</> to
    <application>PL/pgSQL</></title>
   -->
    <title>从<application>PL/SQL</>向
    <application>PL/pgSQL</>移植一个字符串操作和<literal>OUT</>参数的过程</title>

    <!--
<para>
     The following <productname>Oracle</productname> PL/SQL procedure is used
     to parse a URL and return several elements (host, path, and query).
    </para>
-->
<para>
    下面的<productname>Oracle</productname> PL/SQL过程用于分析一个URL并且返回若干个元素(主机、路径、命令)。
</para>

    
<para>
     <!--
     This is the Oracle version:
 -->
 下面是Oracle版本:
<programlisting>
CREATE OR REPLACE PROCEDURE cs_parse_url(
    v_url IN VARCHAR,
<!--
    v_host OUT VARCHAR,  &#045;- This will be passed back
    v_path OUT VARCHAR,  &#045;- This one too
    v_query OUT VARCHAR) &#045;- And this one
-->
v_host OUT VARCHAR,  -- 这个变量是要传回的
    v_path OUT VARCHAR,  -- 这个也是
    v_query OUT VARCHAR) -- 还有这个
IS
    a_pos1 INTEGER;
    a_pos2 INTEGER;
BEGIN
    v_host := NULL;
    v_path := NULL;
    v_query := NULL;
    a_pos1 := instr(v_url, '//');

    IF a_pos1 = 0 THEN
        RETURN;
    END IF;
    a_pos2 := instr(v_url, '/', a_pos1 + 2);
    IF a_pos2 = 0 THEN
        v_host := substr(v_url, a_pos1 + 2);
        v_path := '/';
        RETURN;
    END IF;

    v_host := substr(v_url, a_pos1 + 2, a_pos2 - a_pos1 - 2);
    a_pos1 := instr(v_url, '?', a_pos2 + 1);

    IF a_pos1 = 0 THEN
        v_path := substr(v_url, a_pos2);
        RETURN;
    END IF;

    v_path := substr(v_url, a_pos2, a_pos1 - a_pos2);
    v_query := substr(v_url, a_pos1 + 1);
END;
/
show errors;
</programlisting>
    </para>

    
<para>
    <!--
     Here is a possible translation into <application>PL/pgSQL</>:
-->
下面就是把这个过程翻译成<application>PL/pgSQL</>可能的样子：
<programlisting>
CREATE OR REPLACE FUNCTION cs_parse_url(
    v_url IN VARCHAR,
<!--
    v_host OUT VARCHAR,  &#045;- This will be passed back
    v_path OUT VARCHAR,  &#045;- This one too
    v_query OUT VARCHAR) &#045;- And this one
-->
v_host OUT VARCHAR,  -- 这个将被传回
    v_path OUT VARCHAR,  -- 这个也传回
    v_query OUT VARCHAR) -- 还有这个
AS $$
DECLARE
    a_pos1 INTEGER;
    a_pos2 INTEGER;
BEGIN
    v_host := NULL;
    v_path := NULL;
    v_query := NULL;
    a_pos1 := instr(v_url, '//');

    IF a_pos1 = 0 THEN
        RETURN;
    END IF;
    a_pos2 := instr(v_url, '/', a_pos1 + 2);
    IF a_pos2 = 0 THEN
        v_host := substr(v_url, a_pos1 + 2);
        v_path := '/';
        RETURN;
    END IF;

    v_host := substr(v_url, a_pos1 + 2, a_pos2 - a_pos1 - 2);
    a_pos1 := instr(v_url, '?', a_pos2 + 1);

    IF a_pos1 = 0 THEN
        v_path := substr(v_url, a_pos2);
        RETURN;
    END IF;

    v_path := substr(v_url, a_pos2, a_pos1 - a_pos2);
    v_query := substr(v_url, a_pos1 + 1);
END;
$$ LANGUAGE plpgsql;
</programlisting>
     <!--
     This function could be used like this:
 -->
 这个函数可以这么用:
<programlisting>
SELECT * FROM cs_parse_url('http://foobar.com/query.cgi?baz');
</programlisting>
    </para>

   </example>

   <!--
<para>
    <xref linkend="plpgsql-porting-ex4"> shows how to port a procedure
    that uses numerous features that are specific to Oracle.
   </para>
-->
<para>
   <xref linkend="plpgsql-porting-ex4">演示了如何一个使用各种Oracle专有特性的过程。
</para>

   <example id="plpgsql-porting-ex4">
   <!--
    <title>Porting a Procedure from <application>PL/SQL</> to <application>PL/pgSQL</></title>
-->
<title>从<application>PL/SQL</>向<application>PL/pgSQL</>移植一个过程</title>

    
<para>
     <!--
     The Oracle version:
 -->
 Oracle版本：

<programlisting>
CREATE OR REPLACE PROCEDURE cs_create_job(v_job_id IN INTEGER) IS
    a_running_job_count INTEGER;
    PRAGMA AUTONOMOUS_TRANSACTION;<co id="co.plpgsql-porting-pragma">
BEGIN
    LOCK TABLE cs_jobs IN EXCLUSIVE MODE;<co id="co.plpgsql-porting-locktable">

    SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;

    IF a_running_job_count &gt; 0 THEN
        COMMIT; -- free lock<co id="co.plpgsql-porting-commit">
        raise_application_error(-20000,
                 'Unable to create a new job: a job is currently running.');
    END IF;

    DELETE FROM cs_active_job;
    INSERT INTO cs_active_job(job_id) VALUES (v_job_id);

    BEGIN
        INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, sysdate);
    EXCEPTION
        WHEN dup_val_on_index THEN NULL; -- don't worry if it already exists
    END;
    COMMIT;
END;
/
show errors
</programlisting>
   </para>


  
<para>
     <!--
    Procedures like this can easily be converted into <productname>PostgreSQL</>
    functions returning <type>void</type>. This procedure in
    particular is interesting because it can teach us some things:
    -->

像这样的过程可以很容易用返回<type>void</type>的函数移植到<productname>PostgreSQL</>里。
对这个过程特别感兴趣是因为它可以教一些东西：
 
    <calloutlist>
     <callout arearefs="co.plpgsql-porting-pragma">
      <para>
  <!--
       There is no <literal>PRAGMA</literal> statement in <productname>PostgreSQL</>.
  -->
    在<productname>PostgreSQL</>里没有<literal>PRAGMA</literal>语句。
      </para>
     </callout>

     <callout arearefs="co.plpgsql-porting-locktable">
      <!--
<para>
       If you do a <command>LOCK TABLE</command> in <application>PL/pgSQL</>,
       the lock will not be released until the calling transaction is
       finished.
      </para>
-->
<para>
    如果你在<application>PL/pgSQL</>里做一个<command>LOCK TABLE</command>，
那么这个锁在调用该命令的事务完成之前将不会释放。
</para>
     </callout>

     <callout arearefs="co.plpgsql-porting-commit">
      <!--
<para>
       You cannot issue <command>COMMIT</> in a
       <application>PL/pgSQL</application> function.  The function is
       running within some outer transaction and so <command>COMMIT</>
       would imply terminating the function's execution.  However, in
       this particular case it is not necessary anyway, because the lock
       obtained by the <command>LOCK TABLE</command> will be released when
       we raise an error.
      </para>
-->
<para>
     你不能在<application>PL/pgSQL</application>函数里发出<command>COMMIT</>。
 函数是在外层的事务里运行的，因此<command>COMMIT</>蕴涵着结束函数的执行。
 不过，在这个特殊场合下，这是不必要的了，
 因为<command>LOCK TABLE</command>获取的锁将在抛出错误的时候释放。
</para>
     </callout>
    </calloutlist>
   </para>

   
<para>
    <!--
    This is how we could port this procedure to <application>PL/pgSQL</>:
-->

    下面是把这个过程移植到<application>PL/pgSQL</>里的一种方法：

<programlisting>
CREATE OR REPLACE FUNCTION cs_create_job(v_job_id integer) RETURNS void AS $$
DECLARE
    a_running_job_count integer;
BEGIN
    LOCK TABLE cs_jobs IN EXCLUSIVE MODE;

    SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;

    IF a_running_job_count &gt; 0 THEN
        RAISE EXCEPTION 'Unable to create a new job: a job is currently running';<co id="co.plpgsql-porting-raise">
    END IF;

    DELETE FROM cs_active_job;
    INSERT INTO cs_active_job(job_id) VALUES (v_job_id);

    BEGIN
        INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, now());
    EXCEPTION
        WHEN unique_violation THEN <co id="co.plpgsql-porting-exception">
            -- don't worry if it already exists
    END;
END;
$$ LANGUAGE plpgsql;
</programlisting>

    <calloutlist>
     <callout arearefs="co.plpgsql-porting-raise">
      <para>
   <!--
       The syntax of <literal>RAISE</> is considerably different from
       Oracle's statement, although the basic case <literal>RAISE</>
       <replaceable class="parameter">exception_name</replaceable> works
       similarly.
   -->
   <literal>RAISE</>的语法和Oracle的类似语句差别相当明显。
   尽管<literal>RAISE</><replaceable class="parameter">exception_name</replaceable>运行的基本情况相似。
      </para>

     </callout>
     <callout arearefs="co.plpgsql-porting-exception">
      <!--
<para>
       The exception names supported by <application>PL/pgSQL</> are
       different from Oracle's.  The set of built-in exception names
       is much larger (see <xref linkend="errcodes-appendix">).  There
       is not currently a way to declare user-defined exception names,
       although you can throw user-chosen SQLSTATE values instead.
      </para>
-->
<para>
    <application>PL/pgSQL</>里支持的异常的名字和Oracle的不同。
内置的异常名要大的多(参阅<xref linkend="errcodes-appendix">)。
目前还不能声明用户定义的异常名。
</para>
     </callout>
    </calloutlist>
    <!--
    The main functional difference between this procedure and the
    Oracle equivalent is that the exclusive lock on the <literal>cs_jobs</>
    table will be held until the calling transaction completes.  Also, if
    the caller later aborts (for example due to an error), the effects of
    this procedure will be rolled back.
-->
整个过程和Oracle的等效的主要的功能型差别是，
在<literal>cs_jobs</>上持有的排他锁将保持到调用的事务结束。
同样，如果调用者后来退出(比如说因为错误)，这个过程的效果将被回滚掉。
   </para>
   </example>
  </sect2>

  <sect2 id="plpgsql-porting-other">
  <!--
   <title>Other Things to Watch For</title>
  -->
   <title>其它注意事项</title>

   <!--
<para>
    This section explains a few other things to watch for when porting
    Oracle <application>PL/SQL</> functions to
    <productname>PostgreSQL</productname>.
   </para>
-->
<para>
    本节解释几个从Oracle <application>PL/SQL</>函数向<productname>PostgreSQL</productname>
移植的几个其它方面的事情。
</para>

   <sect3 id="plpgsql-porting-exceptions">
   <!--
    <title>Implicit Rollback after Exceptions</title>
   -->
    <title>异常后的隐含回滚</title>

    
<para>
     <!--
     In <application>PL/pgSQL</>, when an exception is caught by an
     <literal>EXCEPTION</> clause, all database changes since the block's
     <literal>BEGIN</> are automatically rolled back.  That is, the behavior
     is equivalent to what you'd get in Oracle with:
     -->
 在<application>PL/pgSQL</>里，如果一个异常被<literal>EXCEPTION</>子句捕获，
 那么所有自这个块的<literal>BEGIN</>以来的数据库改变都会被自动回滚。
 也就是说，这个行为等于你在Oracle里的：
 
<programlisting>
BEGIN
    SAVEPOINT s1;
    ... code here ...
EXCEPTION
    WHEN ... THEN
        ROLLBACK TO s1;
        ... code here ...
    WHEN ... THEN
        ROLLBACK TO s1;
        ... code here ...
END;
</programlisting>
     <!--
     If you are translating an Oracle procedure that uses
     <command>SAVEPOINT</> and <command>ROLLBACK TO</> in this style,
     your task is easy: just omit the <command>SAVEPOINT</> and
     <command>ROLLBACK TO</>.  If you have a procedure that uses
     <command>SAVEPOINT</> and <command>ROLLBACK TO</> in a different way
     then some actual thought will be required.
 -->
 如果你在翻译使用<command>SAVEPOINT</>和<command>ROLLBACK TO</>的Oracle过程，
 那么你的活儿很好干：只要省略<command>SAVEPOINT</>和
     <command>ROLLBACK TO</>即可。
 如果你要翻译的过程使用了不同的<command>SAVEPOINT</>和<command>ROLLBACK TO</>，那么就需要想想了。
    </para>

   </sect3>

   <sect3>
    <title><command>EXECUTE</command></title>

    <!--
<para>
     The <application>PL/pgSQL</> version of
     <command>EXECUTE</command> works similarly to the
     <application>PL/SQL</> version, but you have to remember to use
     <function>quote_literal</function> and
     <function>quote_ident</function> as described in <xref
     linkend="plpgsql-statements-executing-dyn">.  Constructs of the
     type <literal>EXECUTE 'SELECT * FROM $1';</literal> will not work
     reliably unless you use these functions.
    </para>
-->
<para>
    <application>PL/pgSQL</>版本的<command>EXECUTE</command>类似<application>PL/SQL</>运转，
不过你必须记住要像<xref linkend="plpgsql-statements-executing-dyn">里描述的那样
用<function>quote_literal</function>和<function>quote_ident</function>。
如果你不用这些函数，那么像<literal>EXECUTE 'SELECT * FROM $1';</literal>这样的构造是不会运转的。
</para>
   </sect3>

   <sect3 id="plpgsql-porting-optimization">
   <!--
    <title>Optimizing <application>PL/pgSQL</application> Functions</title>
-->

<title>优化<application>PL/pgSQL</application>函数</title>

    <!--
<para>
     <productname>PostgreSQL</> gives you two function creation
     modifiers to optimize execution: <quote>volatility</> (whether
     the function always returns the same result when given the same
     arguments) and <quote>strictness</quote> (whether the function
     returns null if any argument is null).  Consult the <xref
     linkend="sql-createfunction">
     reference page for details.
    </para>
-->
<para>
   <productname>PostgreSQL</>给你两个创建函数的修饰词用来优化执行：<quote>volatility</>
   (易变的，在给出的参数相同时， 函数总是返回相同结果)和<quote>strictness</quote>
   (严格的，如果任何参数是NULL，那么函数返回NULL)。
   参考<xref linkend="sql-createfunction">的手册获取细节。
</para>

    
<para>
     <!--
     When making use of these optimization attributes, your
     <command>CREATE FUNCTION</command> statement might look something
     like this:
    -->
如果要使用这些优化属性，那么你的<command>CREATE FUNCTION</command>语句可能看起来像这样：
<programlisting>
CREATE FUNCTION foo(...) RETURNS integer AS $$
...
$$ LANGUAGE plpgsql STRICT IMMUTABLE;
</programlisting>
    </para>

   </sect3>
  </sect2>

  <sect2 id="plpgsql-porting-appendix">
  <!--
   <title>Appendix</title>
   -->
   <title>附录</title>

   <!--
<para>
    This section contains the code for a set of Oracle-compatible
    <function>instr</function> functions that you can use to simplify
    your porting efforts.
   </para>
-->
<para>
   本节包含Oracle兼容的<function>instr</function>函数，你可以用它简化你的移植过程。
</para>

<programlisting>
<!--
&#045;-
&#045;- instr functions that mimic Oracle's counterpart
&#045;- Syntax: instr(string1, string2, [n], [m]) where [] denotes optional parameters.
&#045;-
&#045;- Searches string1 beginning at the nth character for the mth occurrence
&#045;- of string2.  If n is negative, search backwards.  If m is not passed,
&#045;- assume 1 (search starts at first character).
&#045;-
-->

--
-- 模拟 Oracle 概念的 instr 函数
-- 语法: instr(string1, string2, [n], [m])  这里的 [] 表示可选参数
--
-- 从 string1 的第 n 个字符开始寻找 string2 的第 m 个出现。
-- 如果 n 是负数，则从后向前着。如果没有传递 m ，假定为 1(从第一个字符开始找)。
--

CREATE FUNCTION instr(varchar, varchar) RETURNS integer AS $$
DECLARE
    pos integer;
BEGIN
    pos:= instr($1, $2, 1);
    RETURN pos;
END;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;


CREATE FUNCTION instr(string varchar, string_to_search varchar, beg_index integer)
RETURNS integer AS $$
DECLARE
    pos integer NOT NULL DEFAULT 0;
    temp_str varchar;
    beg integer;
    length integer;
    ss_length integer;
BEGIN
    IF beg_index &gt; 0 THEN
        temp_str := substring(string FROM beg_index);
        pos := position(string_to_search IN temp_str);

        IF pos = 0 THEN
            RETURN 0;
        ELSE
            RETURN pos + beg_index - 1;
        END IF;
    ELSIF beg_index &lt; 0 THEN
        ss_length := char_length(string_to_search);
        length := char_length(string);
        beg := length + beg_index - ss_length + 2;

        WHILE beg &gt; 0 LOOP
            temp_str := substring(string FROM beg FOR ss_length);
            pos := position(string_to_search IN temp_str);

            IF pos &gt; 0 THEN
                RETURN beg;
            END IF;

            beg := beg - 1;
        END LOOP;

        RETURN 0;
    ELSE
        RETURN 0;
    END IF;
END;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;


CREATE FUNCTION instr(string varchar, string_to_search varchar,
                      beg_index integer, occur_index integer)
RETURNS integer AS $$
DECLARE
    pos integer NOT NULL DEFAULT 0;
    occur_number integer NOT NULL DEFAULT 0;
    temp_str varchar;
    beg integer;
    i integer;
    length integer;
    ss_length integer;
BEGIN
    IF beg_index &gt; 0 THEN
        beg := beg_index;
        temp_str := substring(string FROM beg_index);

        FOR i IN 1..occur_index LOOP
            pos := position(string_to_search IN temp_str);

            IF i = 1 THEN
                beg := beg + pos - 1;
            ELSE
                beg := beg + pos;
            END IF;

            temp_str := substring(string FROM beg + 1);
        END LOOP;

        IF pos = 0 THEN
            RETURN 0;
        ELSE
            RETURN beg;
        END IF;
    ELSIF beg_index &lt; 0 THEN
        ss_length := char_length(string_to_search);
        length := char_length(string);
        beg := length + beg_index - ss_length + 2;

        WHILE beg &gt; 0 LOOP
            temp_str := substring(string FROM beg FOR ss_length);
            pos := position(string_to_search IN temp_str);

            IF pos &gt; 0 THEN
                occur_number := occur_number + 1;

                IF occur_number = occur_index THEN
                    RETURN beg;
                END IF;
            END IF; 

            beg := beg - 1;
        END LOOP;

        RETURN 0;
    ELSE
        RETURN 0;
    END IF;
END;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;
</programlisting>
  </sect2>

 </sect1>

</chapter>
