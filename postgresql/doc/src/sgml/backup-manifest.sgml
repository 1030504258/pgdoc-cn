<!-- doc/src/sgml/backupmanifest.sgml -->

<chapter id="backup-manifest-format">
<!--==========================orignal english content==========================
 <title>Backup Manifest Format</title>
____________________________________________________________________________-->
 <title>备份清单格式</title>

<!--==========================orignal english content==========================
  <indexterm>
   <primary>Backup Manifest</primary>
  </indexterm>
____________________________________________________________________________-->
  <indexterm>
   <primary>Backup Manifest</primary>
  </indexterm>

<!--==========================orignal english content==========================
  <para>
   The backup manifest generated by <xref linkend="app-pgbasebackup" /> is
   primarily intended to permit the backup to be verified using
   <xref linkend="app-pgverifybackup" />. However, it is
   also possible for other tools to read the backup manifest file and use
   the information contained therein for their own purposes. To that end,
   this chapter describes the format of the backup manifest file.
  </para>
____________________________________________________________________________-->
  <para>
   由<xref linkend="app-pgbasebackup" />生成的备份清单主要用于允许使用<xref linkend="app-pgverifybackup" />验证备份。
   但是，其他工具也可以读取备份清单文件并使用其中包含的信息用于其自己的用途。
   为此，本章介绍备份清单文件的格式。
  </para>

<!--==========================orignal english content==========================
  <para>
   A backup manifest is a JSON document encoded as UTF-8. (Although in
   general JSON documents are required to be Unicode, PostgreSQL permits
   the <type>json</type> and <type>jsonb</type> data types to be used with any
   supported server encoding. There is no similar exception for backup
   manifests.) The JSON document is always an object; the keys that are present
   in this object are described in the next section.
  </para>
____________________________________________________________________________-->
  <para>
   备份清单是编码为 UTF-8 的 JSON 文档。
   （虽然通常情况下 JSON 文档需要 Unicode，PostgreSQL 允许<type>json</type> 和 <type>jsonb</type>数据类型可使用任何受支持的服务器编码。备份清单没有类似的例外。）
   JSON 文档始终是一个对象;此对象中存在的键将放在下一节中进行介绍。
  </para>

 <sect1 id="backup-manifest-toplevel">
<!--==========================orignal english content==========================
  <title>Backup Manifest Top-level Object</title>
____________________________________________________________________________-->
  <title>备份清单顶级(Top-level)对象</title>

<!--==========================orignal english content==========================
  <para>
   The backup manifest JSON document contains the following keys.
  </para>
____________________________________________________________________________-->
  <para>
   备份清单 JSON 文档包含以下键.
  </para>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>PostgreSQL-Backup-Manifest-Version</literal></term>
____________________________________________________________________________-->
    <term><literal>PostgreSQL-Backup-Manifest-Version</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The associated value is always the integer 1.
     </para>
____________________________________________________________________________-->
     <para>
      关联的值始终为整数 1.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>Files</literal></term>
____________________________________________________________________________-->
    <term><literal>Files</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The associated value is always a list of objects, each describing one
      file that is present in the backup. No entries are present in this
      list for the WAL files that are needed in order to use the backup,
      or for the backup manifest itself.  The structure of each object in the
      list is described in <xref linkend="backup-manifest-files" />.
     </para>
____________________________________________________________________________-->
     <para>
      关联的值始终是对象列表，每个描述备份中存在的一个文件。
      此列表中不存在使用备份所需要的 WAL 文件的条目或备份清单本身的条目。 
      列表中每个对象的结构在<xref linkend="backup-manifest-files" />中描述。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>WAL-Ranges</literal></term>
____________________________________________________________________________-->
    <term><literal>WAL-Ranges</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The associated value is always a list of objects, each describing a
      range of WAL records that must be readable from a particular timeline
      in order to make use of the backup.  The structure of these objects is
      further described in <xref linkend="backup-manifest-wal-ranges" />.
     </para>
____________________________________________________________________________-->
     <para>
      关联的值始终是对象的列表，每个对象描述一个WAL记录范，并且必须从特定时间线读取，才能使用备份。 
      这些对象的结构在<xref linkend="backup-manifest-wal-ranges" />中进一步描述。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>Manifest-Checksum</literal></term>
____________________________________________________________________________-->
    <term><literal>Manifest-Checksum</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      This key is always present on the last line of the backup manifest file.
      The associated value is a SHA256 checksum of all the preceding lines.
      We use a fixed checksum method here to make it possible for clients
      to do incremental parsing of the manifest. While a SHA256 checksum
      is significantly more expensive than a CRC32C checksum, the manifest
      should normally be small enough that the extra computation won't matter
      very much.
     </para>
____________________________________________________________________________-->
     <para>
      此键始终位于于备份清单文件的最后一行。
      关联的值是前面所有行的 SHA256 校验和。
      我们在此处使用固定校验和的方法使客户端能够对清单进行增量分析。
      虽然 SHA256 校验和比 CRC32C 校验和代价大得多，但清单通常应该足够小，因此额外的计算的影响并不很大。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>

 <sect1 id="backup-manifest-files">
<!--==========================orignal english content==========================
  <title>Backup Manifest File Object</title>
____________________________________________________________________________-->
  <title>Backup Manifest File Object</title>

<!--==========================orignal english content==========================
  <para>
   The object which describes a single file contains either a
   <literal>Path</literal> key or an <literal>Encoded-Path</literal> key.
   Normally, the <literal>Path</literal> key will be present. The
   associated string value is the path of the file relative to the root
   of the backup directory. Files located in a user-defined tablespace
   will have paths whose first two components are <filename>pg_tblspc</filename> and the OID
   of the tablespace. If the path is not a string that is legal in UTF-8,
   or if the user requests that encoded paths be used for all files, then
   the <literal>Encoded-Path</literal> key will be present instead.  This
   stores the same data, but it is encoded as a string of hexadecimal
   digits. Each pair of hexadecimal digits in the string represents a
   single octet.
  </para>
____________________________________________________________________________-->
  <para>
   描述单个文件的对象包含<literal>Path</literal> 键或一个 <literal>Encoded-Path</literal> 键。
   通常，<literal>Path</literal> 键将会出现。
   关联的字符串值是文件相对于备份目录根目录的路径。
   位于用户定义的表空间中的文件将具有其前两个组件为<filename>pg_tblspc</filename>和表空间的 OID 的路径。
   如果路径不是 UTF-8 中合法的字符串，或者用户需要编码路径用于所有文件，则将替换为<literal>Encoded-Path</literal> 键。
   这样会存储相同的数据，但它被编码为十六进制数字的字符串。字符串中的每对十六进制数字表示一个八位数。
  </para>

<!--==========================orignal english content==========================
  <para>
   The following two keys are always present:
  </para>
____________________________________________________________________________-->
  <para>
   下面两个键始终存在:
  </para>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>Size</literal></term>
____________________________________________________________________________-->
    <term><literal>Size</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The expected size of this file, as an integer.
     </para>
____________________________________________________________________________-->
     <para>
      此文件的预期大小，为整数。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>Last-Modified</literal></term>
____________________________________________________________________________-->
    <term><literal>Last-Modified</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The last modification time of the file as reported by the server at
      the time of the backup. Unlike the other fields stored in the backup,
      this field is not used by <xref linkend="app-pgverifybackup" />.
      It is included only for informational purposes.
     </para>
____________________________________________________________________________-->
     <para>
      服务器在备份时报告的文件的最后修改时间。
      与备份中存储的其他字段不同，此字段不用于 <xref linkend="app-pgverifybackup" />。
      它在此只是为了提供参考的作用。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

<!--==========================orignal english content==========================
  <para>
   If the backup was taken with file checksums enabled, the following
   keys will be present:
  </para>
____________________________________________________________________________-->
  <para>
   如果备份是在启用文件校验和的情况下进行，将存在以下键：
  </para>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>Checksum-Algorithm</literal></term>
____________________________________________________________________________-->
    <term><literal>Checksum-Algorithm</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The checksum algorithm used to compute a checksum for this file.
      Currently, this will be the same for every file in the backup
      manifest, but this may change in future releases. At present, the
      supported checksum algorithms are <literal>CRC32C</literal>,
      <literal>SHA224</literal>,
      <literal>SHA256</literal>,
      <literal>SHA384</literal>, and
      <literal>SHA512</literal>.
     </para>
____________________________________________________________________________-->
     <para>
      用于计算此文件校验和的校验和算法。
      目前，备份清单中每个文件的算法都是相同的，但在将来的版本中可能会改变。
      目前，支持的校验和算法包括<literal>CRC32C</literal>、<literal>SHA224</literal>、<literal>SHA256</literal>、<literal>SHA384</literal>、和<literal>SHA512</literal>。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>Checksum</literal></term>
____________________________________________________________________________-->
    <term><literal>Checksum</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The checksum computed for this file, stored as a series of
      hexadecimal characters, two for each byte of the checksum.
     </para>
____________________________________________________________________________-->
     <para>
      为此文件计算的校验和，存储为一系列十六进制字符，每两个字符对应校验和的一个字节。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </sect1>

 <sect1 id="backup-manifest-wal-ranges">
<!--==========================orignal english content==========================
  <title>Backup Manifest WAL Range Object</title>
____________________________________________________________________________-->
  <title>Backup Manifest WAL Range Object</title>

<!--==========================orignal english content==========================
  <para>
   The object which describes a WAL range always has three keys:
  </para>
____________________________________________________________________________-->
  <para>
   描述 WAL 范围的对象始终有三个键：
  </para>

  <variablelist>
   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>Timeline</literal></term>
____________________________________________________________________________-->
    <term><literal>Timeline</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The timeline for this range of WAL records, as an integer.
     </para>
____________________________________________________________________________-->
     <para>
      此 WAL 记录范围的时间线，为整数.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>Start-LSN</literal></term>
____________________________________________________________________________-->
    <term><literal>Start-LSN</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The LSN at which replay must begin on the indicated timeline in order to
      make use of this backup.  The LSN is stored in the format normally used
      by <productname>PostgreSQL</productname>; that is, it is a string
      consisting of two strings of hexadecimal characters, each with a length
      of between 1 and 8, separated by a slash.
     </para>
____________________________________________________________________________-->
     <para>
      此LSN位于必须在指示的时间线上开始的回放，以便使用此备份。 
      此LSN 通常使用<productname>PostgreSQL</productname>的格式存储;也就是说，它是一个字符串，由两个十六进制字符字符串组成，每个字符串的长度介于 1 和 8 之间，用斜杠分隔。
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
<!--==========================orignal english content==========================
    <term><literal>End-LSN</literal></term>
____________________________________________________________________________-->
    <term><literal>End-LSN</literal></term>
    <listitem>
<!--==========================orignal english content==========================
     <para>
      The earliest LSN at which replay on the indicated timeline may end when
      making use of this backup. This is stored in the same format as
      <literal>Start-LSN</literal>.
     </para>
____________________________________________________________________________-->
     <para>
      当使用此备份时，在指示的时间线上回放的最早 LSN 可能会结束。
      其存储的格式与 <literal>Start-LSN</literal>相同。
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

<!--==========================orignal english content==========================
  <para>
   Ordinarily, there will be only a single WAL range. However, if a backup is
   taken from a standby which switches timelines during the backup due to an
   upstream promotion, it is possible for multiple ranges to be present, each
   with a different timeline. There will never be multiple WAL ranges present
   for the same timeline.
  </para>
____________________________________________________________________________-->
  <para>
   一般情况下，只有一个 WAL 范围。
   但是，如果备份来自备用的(standby)备份，在备份期间由于上游升级而切换时间线，则可能存在多个范围，每个具有不同的时间线。
   对于同一时间线，永远不会有多个 WAL 范围出现。
  </para>
 </sect1>
</chapter>