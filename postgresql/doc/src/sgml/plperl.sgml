<!-- doc/src/sgml/plperl.sgml -->

 <chapter id="plperl">
  <!-- 
  <title>PL/Perl - Perl Procedural Language</title> 
  -->
  <title>PL/Perl - Perl 过程语言</title>

  <indexterm zone="plperl">
   <primary>PL/Perl</primary>
  </indexterm>

  <indexterm zone="plperl">
   <primary>Perl</primary>
  </indexterm>

  <!--
<para>
   PL/Perl is a loadable procedural language that enables you to write
   <productname>PostgreSQL</productname> functions in the
   <ulink url="http://www.perl.org">Perl programming language</ulink>.
  </para>
-->
<para>
PL/Perl 是一种可加载的过程语言，通过它可以用<ulink url="http://www.perl.org">Perl 编程语言</ulink>
编写<productname>PostgreSQL</productname>函数。
</para>

  <!--
<para>
   The main advantage to using PL/Perl is that this allows use,
   within stored functions, of the manyfold <quote>string
   munging</quote> operators and functions available for Perl.  Parsing
   complex strings might be easier using Perl than it is with the
   string functions and control structures provided in PL/pgSQL.
  </para>
-->
<para>
使用 PL/Perl 的主要优点是允许在函数中大量使用来自 Perl 的处理字符串的操作和函数。
PL/pgSQL 很难分析的复杂字符串对 Perl 来说却是小菜一碟。
</para>

  <!--
<para>
   To install PL/Perl in a particular database, use
   <literal>CREATE EXTENSION plperl</>, or from the shell command line use
   <literal>createlang plperl <replaceable>dbname</></literal>.
  </para>
-->
<para>
要在特定数据库里安装 PL/Perl ，使用<literal>CREATE EXTENSION plperl</>，或在shell命令行里使用
<literal>createlang plperl <replaceable>dbname</></literal>。
</para>

  <tip>
   <!--
<para>
    If a language is installed into <literal>template1</>, all subsequently
    created databases will have the language installed automatically.
   </para>
-->
<para>
如果某种编程语言安装到<literal>template1</>，那么所有随后创建的数据库都会自动安装这种语言。
</para>
  </tip>

  <note>
   <!--
<para>
    Users of source packages must specially enable the build of
    PL/Perl during the installation process.  (Refer to <xref
    linkend="installation"> for more information.)  Users of
    binary packages might find PL/Perl in a separate subpackage.
   </para>
-->
<para>
使用源码包的用户必须在安装过程中特别打开 PL/Perl 的编译。请参考<xref linkend="installation">
获取更多信息。二进制包的用户可能会在一些独立的子包中找到 PL/Perl 。
</para>
  </note>

 <sect1 id="plperl-funcs">
  <!--
  <title>PL/Perl Functions and Arguments</title>
  -->
  <title>PL/Perl 函数和参数</title>

<para>
<!-- 
   To create a function in the PL/Perl language, use the standard
   <xref linkend="sql-createfunction">
   syntax:
-->
要用 PL/Perl 语言创建一个函数，可以使用标准的<xref linkend="sql-createfunction">语法：
<programlisting>
CREATE FUNCTION <replaceable>funcname</replaceable> (<replaceable>argument-types</replaceable>) RETURNS <replaceable>return-type</replaceable> AS $$
    # PL/Perl function body
$$ LANGUAGE plperl;
</programlisting>
<!-- 
   The body of the function is ordinary Perl code. In fact, the PL/Perl
   glue code wraps it inside a Perl subroutine.  A PL/Perl function is
   called in a scalar context, so it can't return a list.  You can return
   non-scalar values (arrays, records, and sets) by returning a reference,
   as discussed below.
-->
函数体是普通 Perl 代码。实际上，PL/Perl 胶水代码将其封装在一个 Perl 子过程里。
一个 PL/Perl 函数在一个标量环境中调用，所以不能返回一个列表。
你可以像下面描述的那样用返回引用的方法返回非标量值（arrays, records, 和 sets）。
  </para>

<para>
<!-- 
   PL/Perl also supports anonymous code blocks called with the
   <xref linkend="sql-do"> statement:
 -->
PL/Perl也支持<xref linkend="sql-do">语句调用匿名代码块：
<programlisting>
DO $$
    # PL/Perl code
$$ LANGUAGE plperl;
</programlisting>
<!-- 
   An anonymous code block receives no arguments, and whatever value it
   might return is discarded.  Otherwise it behaves just like a function.
 -->
一个匿名代码块不接收参数，而且丢弃任何返回值。否则它的行为就像一个函数。
  </para>

  <note>
   <!--
<para>
    The use of named nested subroutines is dangerous in Perl, especially if
    they refer to lexical variables in the enclosing scope. Because a PL/Perl
    function is wrapped in a subroutine, any named subroutine you place inside
    one will be nested. In general, it is far safer to create anonymous
    subroutines which you call via a coderef. For more information, see the
    entries for <literal>Variable "%s" will not stay shared</literal> and
    <literal>Variable "%s" is not available</literal> in the
    <citerefentry><refentrytitle>perldiag</></citerefentry> man page, or
    search the Internet for <quote>perl nested named subroutine</>.
   </para>
-->
<para>
在 Perl 里使用命名的嵌套子过程是很危险的，特别是它们在闭包里引用了词法变量的时候。
因为 PL/Perl 是封装在一个子过程里，因此，任何你放进去的命名子过程都将被嵌套。通常，
创建一个用 coderef 调用的匿名子过程要安全得多。想要获取更多细节，请参阅
<literal>Variable "%s" will not stay shared</literal>里的记录或
<citerefentry><refentrytitle>perldiag</></citerefentry>手册页中的<literal>Variable "%s" is not available</literal>，
或在Internet上搜索<quote>perl 嵌套命名子过程</>。
</para>
  </note>

  <!--
<para>
   The syntax of the <command>CREATE FUNCTION</command> command requires
   the function body to be written as a string constant.  It is usually
   most convenient to use dollar quoting (see <xref
   linkend="sql-syntax-dollar-quoting">) for the string constant.
   If you choose to use escape string syntax <literal>E''</>,
   you must double any single quote marks (<literal>'</>) and backslashes
   (<literal>\</>) used in the body of the function
   (see <xref linkend="sql-syntax-strings">).
  </para>
-->
<para>
<command>CREATE FUNCTION</command>命令的语法要求把函数体写成字符串常量。
通常处理字符串文本用美元符界定更方便(参阅<xref linkend="sql-syntax-dollar-quoting">)，
如果你想使用传统的<literal>E''</>逃逸语法，必须双写函数体里使用的任何单引号(<literal>'</>)
和反斜杠(<literal>\</>)(参见<xref linkend="sql-syntax-strings">)。
</para>

  <!--
<para>
   Arguments and results are handled as in any other Perl subroutine:
   arguments are passed in <varname>@_</varname>, and a result value
   is returned with <literal>return</> or as the last expression
   evaluated in the function.
  </para>
-->
<para>
参数和结果都是和任何其它 Perl 子过程里那样处理的：参数是放在<varname>@_</varname>里传递的，
结果值是用<literal>return</>返回或者作为函数中最后计算的表达式的值返回。
</para>

<para>
<!-- 
   For example, a function returning the greater of two integer values
   could be defined as:
 -->
比如，一个返回两个整数中较大值的函数可以这么写：
<programlisting>
CREATE FUNCTION perl_max (integer, integer) RETURNS integer AS $$
    if ($_[0] &gt; $_[1]) { return $_[0]; }
    return $_[1];
$$ LANGUAGE plperl;
</programlisting>
  </para>

  <note>
    <!--
<para>
      Arguments will be converted from the database's encoding to UTF-8
      for use inside PL/Perl, and then converted from UTF-8 back to the
      database encoding upon return.
    </para>
-->
<para>
为了能够在PL/Perl里使用，参数将从数据库编码转换为UTF-8，然后在返回时从UTF-8回到数据库编码。
</para>
  </note>

<para>
<!-- 
   If an SQL null value<indexterm><primary>null value</><secondary
   sortas="PL/Perl">in PL/Perl</></indexterm> is passed to a function,
   the argument value will appear as <quote>undefined</> in Perl.  The
   above function definition will not behave very nicely with null
   inputs (in fact, it will act as though they are zeroes).  We could
   add <literal>STRICT</> to the function definition to make
   <productname>PostgreSQL</productname> do something more reasonable:
   if a null value is passed, the function will not be called at all,
   but will just return a null result automatically.  Alternatively,
   we could check for undefined inputs in the function body.  For
   example, suppose that we wanted <function>perl_max</function> with
   one null and one nonnull argument to return the nonnull argument,
   rather than a null value:
 -->
如果给函数传递一个 NULL<indexterm><primary>null value</><secondary
   sortas="PL/Perl">in PL/Perl</></indexterm> 那么其参数值将以 Perl 中<quote>undefined</>
的形式出现。上面的函数定义在输入为 NULL 时的行为不是很正常(实际上，
它将表现得好像它们都是零一样)。可以给函数定义增加<literal>STRICT</>让
<productname>PostgreSQL</productname>做一些更合理的事情：如果传递进来一个 NULL ，
那么该函数则根本不会被调用，而只是自动返回一个 NULL 结果。另外，
可以在函数体里检查未定义的输入。比如，假设想收到一个 NULL 和一个非 NULL 参数的
<function>perl_max</function>返回非 NULL 的参数，而不是 NULL ：
<programlisting>
CREATE FUNCTION perl_max (integer, integer) RETURNS integer AS $$
    my ($x, $y) = @_;
    if (not defined $x) {
        return undef if not defined $y;
        return $y;
    }
    return $x if not defined $y;
    return $x if $x &gt; $y;
    return $y;
$$ LANGUAGE plperl;
</programlisting>
<!-- 
   As shown above, to return an SQL null value from a PL/Perl
   function, return an undefined value.  This can be done whether the
   function is strict or not. 
-->
如上所述，要从 PL/Perl 函数中返回一个 NULL ，可以返回一个未定义的数值。
不管该函数是否严格，都可以这么做。
  </para>

  <!--
<para>
   Anything in a function argument that is not a reference is
   a string, which is in the standard <productname>PostgreSQL</productname>
   external text representation for the relevant data type. In the case of
   ordinary numeric or text types, Perl will just do the right thing and
   the programmer will normally not have to worry about it. However, in
   other cases the argument will need to be converted into a form that is
   more usable in Perl. For example, the <function>decode_bytea</function>
   function can be used to convert an argument of
   type <type>bytea</> into unescaped binary.
  </para>
-->
<para>
任何一个不是引用的函数参数是一个字符串，这是相关数据类型在标准<productname>PostgreSQL</productname>
外部文本里的表示。普通数字或文本类型的情况下，Perl将只是做正确的事情，程序员不需要担心。
然而，在其他情况下，需要将参数转换为Perl可用的形式。例如，<function>decode_bytea</function>
函数可以用来转换类型<type>bytea</>的参数为非逃逸的二进制。
</para>

  <!--
<para>
   Similarly, values passed back to <productname>PostgreSQL</productname>
   must be in the external text representation format. For example, the
   <function>encode_bytea</function> function can be used to
   escape binary data for a return value of type <type>bytea</>.
  </para>
-->
<para>
相似的，传回<productname>PostgreSQL</productname>的值必须是外部文本表示格式。
例如，<function>encode_bytea</function>函数可以用来为一个类型为<type>bytea</>
的返回值逃逸二进制数据。
</para>

<para>
<!-- 
   Perl can return <productname>PostgreSQL</productname> arrays as
   references to Perl arrays.  Here is an example:
 -->
Perl 可以用 Perl 数组引用的方式返回<productname>PostgreSQL</productname>数组。
下面是一个例子：
<programlisting>
CREATE OR REPLACE function returns_array()
RETURNS text[][] AS $$
    return [['a&quot;b','c,d'],['e\\f','g']];
$$ LANGUAGE plperl;

select returns_array();
</programlisting>
  </para>

<para>
<!-- 
   Perl passes <productname>PostgreSQL</productname> arrays as a blessed
   <type>PostgreSQL::InServer::ARRAY</type> object. This object may be treated as an array
   reference or a string, allowing for backward compatibility with Perl
   code written for <productname>PostgreSQL</productname> versions below 9.1 to
   run.  For example:
 -->
Perl作为一个<type>PostgreSQL::InServer::ARRAY</type>对象传递<productname>PostgreSQL</productname>
数组。这个对象可以被视为一个数组引用或一个字符串，Perl为<productname>PostgreSQL</productname>
低于9.1的版本编写了代码，允许向后兼容。例如：
<programlisting>
CREATE OR REPLACE FUNCTION concat_array_elements(text[]) RETURNS TEXT AS $$
    my $arg = shift;
    my $result = "";
    return undef if (!defined $arg);

    # as an array reference
    for (@$arg) {
        $result .= $_;
    }

    # also works as a string
    $result .= $arg;

    return $result;
$$ LANGUAGE plperl;

SELECT concat_array_elements(ARRAY['PL','/','Perl']);
</programlisting>

  <note>
<!-- 
   <para>
    Multidimensional arrays are represented as references to
    lower-dimensional arrays of references in a way common to every Perl
    programmer.
   </para> 
-->
<para>
多维数组的表现就和每个Perl程序员引用低维数组的引用一样。
</para> 
  </note>
  </para>

<para>
<!-- 
   Composite-type arguments are passed to the function as references
   to hashes.  The keys of the hash are the attribute names of the
   composite type.  Here is an example:
 -->
复合类型的参数是当做指向散列的引用传递给函数的。散列的键字是复合类型的属性名。下面是一个例子：
<programlisting>
CREATE TABLE employee (
    name text,
    basesalary integer,
    bonus integer
);

CREATE FUNCTION empcomp(employee) RETURNS integer AS $$
    my ($emp) = @_;
    return $emp-&gt;{basesalary} + $emp-&gt;{bonus};
$$ LANGUAGE plperl;

SELECT name, empcomp(employee.*) FROM employee;
</programlisting>
  </para>

<para>
<!-- 
   A PL/Perl function can return a composite-type result using the same
   approach: return a reference to a hash that has the required attributes.
   For example:
 -->
使用同样的办法，一个 PL/Perl 函数可以返回一个复合类型的结果：
返回一个包含所需要的属性的散列的引用。比如，
<programlisting>
CREATE TYPE testrowperl AS (f1 integer, f2 text, f3 text);

CREATE OR REPLACE FUNCTION perl_row() RETURNS testrowperl AS $$
    return {f2 =&gt; 'hello', f1 =&gt; 1, f3 =&gt; 'world'};
$$ LANGUAGE plperl;

SELECT * FROM perl_row();
</programlisting>
<!-- 
   Any columns in the declared result data type that are not present in the
   hash will be returned as null values.
-->
在声明的结果数据类型里的任何字段如果在散列里面没有出现，那么都会当作 NULL 返回。
  </para>

<para>
<!-- 
    PL/Perl functions can also return sets of either scalar or
    composite types.  Usually you'll want to return rows one at a
    time, both to speed up startup time and to keep from queuing up
    the entire result set in memory.  You can do this with
    <function>return_next</function> as illustrated below.  Note that
    after the last <function>return_next</function>, you must put
    either <literal>return</literal> or (better) <literal>return
    undef</literal>.
 -->
PL/Perl 函数也能返回标量或者复合类型的集合。通常你希望一次返回一行，
一方面加速函数启动时间，另外一方面防止在内存里堆积整个结果集。
可以用下面说明的函数<function>return_next</function>。请注意在最后的
<function>return_next</function>，你必须放一个 <literal>return</literal>
或者(最好是)<literal>return undef</literal>。
<programlisting>
CREATE OR REPLACE FUNCTION perl_set_int(int)
RETURNS SETOF INTEGER AS $$
    foreach (0..$_[0]) {
        return_next($_);
    }
    return undef;
$$ LANGUAGE plperl;

SELECT * FROM perl_set_int(5);

CREATE OR REPLACE FUNCTION perl_set()
RETURNS SETOF testrowperl AS $$
    return_next({ f1 =&gt; 1, f2 =&gt; 'Hello', f3 =&gt; 'World' });
    return_next({ f1 =&gt; 2, f2 =&gt; 'Hello', f3 =&gt; 'PostgreSQL' });
    return_next({ f1 =&gt; 3, f2 =&gt; 'Hello', f3 =&gt; 'PL/Perl' });
    return undef;
$$ LANGUAGE plperl;
</programlisting>
<!-- 
    For small result sets, you can return a reference to an array that
    contains either scalars, references to arrays, or references to
    hashes for simple types, array types, and composite types,
    respectively.  Here are some simple examples of returning the entire
    result set as an array reference:
-->
对于小的结果集，你可以返回一个指向一个数组的引用，这个数组可以包含标量，指向数组的引用，
或者指向简单类型，数组类型以及复合类型等的散列的引用。这里是一个简单的例子，
它把整个结果集当作一个数组引用返回：
<programlisting>
CREATE OR REPLACE FUNCTION perl_set_int(int) RETURNS SETOF INTEGER AS $$
    return [0..$_[0]];
$$ LANGUAGE plperl;

SELECT * FROM perl_set_int(5);

CREATE OR REPLACE FUNCTION perl_set() RETURNS SETOF testrowperl AS $$
    return [
        { f1 =&gt; 1, f2 =&gt; 'Hello', f3 =&gt; 'World' },
        { f1 =&gt; 2, f2 =&gt; 'Hello', f3 =&gt; 'PostgreSQL' },
        { f1 =&gt; 3, f2 =&gt; 'Hello', f3 =&gt; 'PL/Perl' }
    ];
$$ LANGUAGE plperl;

SELECT * FROM perl_set();
</programlisting>
  </para>

  <!--
<para>
   If you wish to use the <literal>strict</> pragma with your code you
   have a few options. For temporary global use you can <command>SET</>
   <literal>plperl.use_strict</literal> to true.
   This will affect subsequent compilations of <application>PL/Perl</>
   functions, but not functions already compiled in the current session.
   For permanent global use you can set <literal>plperl.use_strict</literal>
   to true in the <filename>postgresql.conf</filename> file.
  </para>
-->
<para>
如果你想在自己的代码里使用<literal>strict</>用法你有几种选择。对于临时全局使用你可以
<command>SET</> <literal>plperl.use_strict</literal>为真。这个参数影响随后的<application>PL/Perl</>
函数的编译，但是不影响在当前会话里已经编译了的函数。为了永久全局使用，
可以在<filename>postgresql.conf</filename>文件里设置<literal>plperl.use_strict</literal>为真。
</para>

  <!--
<para>
   For permanent use in specific functions you can simply put:
<programlisting>
use strict;
</programlisting>
   at the top of the function body.
  </para>
-->
<para>
要在特定的函数中永久使用，只需要简单地在函数体的顶部放置：
<programlisting>
use strict;
</programlisting>
</para>

  <!--
<para>
  The <literal>feature</> pragma is also available to <function>use</> if your Perl is version 5.10.0 or higher.
  </para>
-->
<para>
如果你的Perl是版本5.10.0或更高，那么<literal>feature</>程序也适用于<function>use</>。
</para>

 </sect1>

 <sect1 id="plperl-data">
  <!-- 
  <title>Data Values in PL/Perl</title> 
  -->
  <title>PL/Perl里的数据值</title>

  <!--
<para>
   The argument values supplied to a PL/Perl function's code are
   simply the input arguments converted to text form (just as if they
   had been displayed by a <command>SELECT</command> statement).
   Conversely, the <function>return</function> and <function>return_next</function>
   commands will accept any string that is acceptable input format
   for the function's declared return type.
  </para>
-->
<para>
提供给 PL/Perl 函数代码的参数值只是简单地将输入参数转换成文本形式(就像它们被
<command>SELECT</command>语句显示的那样)。与之相对的是，<function>return</function>和
<function>return_next</function>命令将接受任何函数声明的返回类型可以接受的输入格式的字符串。
</para>
 </sect1>

 <sect1 id="plperl-builtins">
  <!-- 
  <title>Built-in Functions</title> 
  -->
  <title>内置函数</title>

 <sect2 id="plperl-database">
  <!-- 
  <title>Database Access from PL/Perl</title> 
  -->
  <title>从PL/Perl访问数据库</title>

  <!--
<para>
   Access to the database itself from your Perl function can be done
   via the following functions:
  </para>
-->
<para>
从 Perl 函数里访问数据库本身可以通过下面的函数做到：
</para>

   <variablelist>
    <varlistentry>
     <indexterm>
      <primary>spi_exec_query</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>
     <indexterm>
      <primary>spi_query</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>
     <indexterm>
      <primary>spi_fetchrow</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>
     <indexterm>
      <primary>spi_prepare</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>
     <indexterm>
      <primary>spi_exec_prepared</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>
     <indexterm>
      <primary>spi_query_prepared</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>
     <indexterm>
      <primary>spi_cursor_close</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>
     <indexterm>
      <primary>spi_freeplan</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>

     <term><literal><function>spi_exec_query</>(<replaceable>query</replaceable> [, <replaceable>max-rows</replaceable>])</literal></term>
     <listitem>

<para>
<!-- 
       <literal>spi_exec_query</literal> executes an SQL command and
returns the entire row set as a reference to an array of hash
references.  <emphasis>You should only use this command when you know
that the result set will be relatively small.</emphasis>  Here is an
example of a query (<command>SELECT</command> command) with the
optional maximum number of rows:
 -->
<literal>spi_exec_query</literal>执行一个 SQL 命令然后把整个结果集当作一个指向散列引用的引用返回。
<emphasis>只有在你知道结果集相对比较小的时候才能用这个命令。</emphasis>
下面是一个带有额外的最大行数的查询(<command>SELECT</command>命令)的例子。
<programlisting>
$rv = spi_exec_query('SELECT * FROM my_table', 5);
</programlisting>
<!-- 
        This returns up to 5 rows from the table
        <literal>my_table</literal>.  If <literal>my_table</literal>
        has a column <literal>my_column</literal>, you can get that
        value from row <literal>$i</literal> of the result like this: 
-->
它从<literal>my_table</literal>里返回最多 5 行。如果<literal>my_table</literal>
有一个字段是<literal>my_column</literal>，那么可以用下面的方法从结果的第<literal>$i</literal>行获取其值：
<programlisting>
$foo = $rv-&gt;{rows}[$i]-&gt;{my_column};
</programlisting>
<!-- 
       The total number of rows returned from a <command>SELECT</command>
       query can be accessed like this:
-->
从一个<command>SELECT</command>查询返回的总行数可以这样访问：
<programlisting>
$nrows = $rv-&gt;{processed}
</programlisting>
      </para>

<para>
       <!-- 
   Here is an example using a different command type: 
   -->
   这里是一个使用其它命令的例子：
<programlisting>
$query = "INSERT INTO my_table VALUES (1, 'test')";
$rv = spi_exec_query($query);
</programlisting>
       <!-- 
   You can then access the command status (e.g.,
       <literal>SPI_OK_INSERT</literal>) like this: 
   -->
   你可以用下面方法访问状态(如<literal>SPI_OK_INSERT</literal>)：
<programlisting>
$res = $rv-&gt;{status};
</programlisting>
       <!-- 
   To get the number of rows affected, do: 
   -->
   这样获取影响的行数：
<programlisting>
$nrows = $rv-&gt;{processed};
</programlisting>
      </para>

<para>
       <!-- 
   Here is a complete example: 
   -->
   下面是一个完整的例子：
<programlisting>
CREATE TABLE test (
    i int,
    v varchar
);

INSERT INTO test (i, v) VALUES (1, 'first line');
INSERT INTO test (i, v) VALUES (2, 'second line');
INSERT INTO test (i, v) VALUES (3, 'third line');
INSERT INTO test (i, v) VALUES (4, 'immortal');

CREATE OR REPLACE FUNCTION test_munge() RETURNS SETOF test AS $$
    my $rv = spi_exec_query('select i, v from test;');
    my $status = $rv-&gt;{status};
    my $nrows = $rv-&gt;{processed};
    foreach my $rn (0 .. $nrows - 1) {
        my $row = $rv-&gt;{rows}[$rn];
        $row-&gt;{i} += 200 if defined($row-&gt;{i});
        $row-&gt;{v} =~ tr/A-Za-z/a-zA-Z/ if (defined($row-&gt;{v}));
        return_next($row);
    }
    return undef;
$$ LANGUAGE plperl;

SELECT * FROM test_munge();
</programlisting>
    </para>
    </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal><function>spi_query(<replaceable>command</replaceable>)</function></literal></term>
     <term><literal><function>spi_fetchrow(<replaceable>cursor</replaceable>)</function></literal></term>
     <term><literal><function>spi_cursor_close(<replaceable>cursor</replaceable>)</function></literal></term>

    <listitem>

<para>
<!-- 
    <literal>spi_query</literal> and <literal>spi_fetchrow</literal>
    work together as a pair for row sets which might be large, or for cases
    where you wish to return rows as they arrive.
    <literal>spi_fetchrow</literal> works <emphasis>only</emphasis> with
    <literal>spi_query</literal>. The following example illustrates how
    you use them together:
 -->
<literal>spi_query</literal>和<literal>spi_fetchrow</literal>一起用于处理那些行集可能比较大，
或者是在你收到行的时候就返回的场合。<literal>spi_fetchrow</literal><emphasis>只能</emphasis>
和<literal>spi_query</literal>一起使用。下面的例子演示了如何使用：
<programlisting>
CREATE TYPE foo_type AS (the_num INTEGER, the_text TEXT);

CREATE OR REPLACE FUNCTION lotsa_md5 (INTEGER) RETURNS SETOF foo_type AS $$
    use Digest::MD5 qw(md5_hex);
    my $file = '/usr/share/dict/words';
    my $t = localtime;
    elog(NOTICE, "opening file $file at $t" );
    open my $fh, '&lt;', $file # <!-- ooh, it's a file access! -->这是访问文件！
        or elog(ERROR, "cannot open $file for reading: $!");
    my @words = &lt;$fh&gt;;
    close $fh;
    $t = localtime;
    elog(NOTICE, "closed file $file at $t");
    chomp(@words);
    my $row;
    my $sth = spi_query("SELECT * FROM generate_series(1,$_[0]) AS b(a)");
    while (defined ($row = spi_fetchrow($sth))) {
        return_next({
            the_num =&gt; $row-&gt;{a},
            the_text =&gt; md5_hex($words[rand @words])
        });
    }
    return;
$$ LANGUAGE plperlu;

SELECT * from lotsa_md5(500);
</programlisting>
    </para>

    <!--
<para>
     Normally, <function>spi_fetchrow</> should be repeated until it
     returns <literal>undef</literal>, indicating that there are no more
     rows to read.  The cursor returned by <literal>spi_query</literal>
     is automatically freed when
     <function>spi_fetchrow</> returns <literal>undef</literal>.
     If you do not wish to read all the rows, instead call
     <function>spi_cursor_close</> to free the cursor.
     Failure to do so will result in memory leaks.
    </para>
-->
<para>
通常，应当重复<function>spi_fetchrow</>直到其返回<literal>undef</literal>
以表示没有行可以读取了，此时由<literal>spi_query</literal>返回的游标将被自动释放。
如果你确实不想读取所有行，可以明确调用<function>spi_cursor_close</>来释放游标，
否则将会导致内存泄漏。
</para>

    </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal><function>spi_prepare(<replaceable>command</replaceable>, <replaceable>argument types</replaceable>)</function></literal></term>
     <term><literal><function>spi_query_prepared(<replaceable>plan</replaceable>, <replaceable>arguments</replaceable>)</function></literal></term>
     <term><literal><function>spi_exec_prepared(<replaceable>plan</replaceable> [, <replaceable>attributes</replaceable>], <replaceable>arguments</replaceable>)</function></literal></term>
     <term><literal><function>spi_freeplan(<replaceable>plan</replaceable>)</function></literal></term>

    <listitem>

<para>
<!-- 
    <literal>spi_prepare</literal>, <literal>spi_query_prepared</literal>, <literal>spi_exec_prepared</literal>,
    and <literal>spi_freeplan</literal> implement the same functionality but for prepared queries.
    <literal>spi_prepare</literal> accepts a query string with numbered argument placeholders ($1, $2, etc)
    and a string list of argument types:
-->
<literal>spi_prepare</literal>, <literal>spi_query_prepared</literal>, <literal>spi_exec_prepared</literal>, 
<literal>spi_freeplan</literal>为预备查询实现同样的功能。<literal>spi_prepare</literal>
接受一个带有编号的参数占位符的字符串和一个参数类型的字符串列表：
<programlisting>
$plan = spi_prepare('SELECT * FROM test WHERE id &gt; $1 AND name = $2',
                                                     'INTEGER', 'TEXT');
</programlisting>
<!-- 
    Once a query plan is prepared by a call to <literal>spi_prepare</literal>, the plan can be used instead
    of the string query, either in <literal>spi_exec_prepared</literal>, where the result is the same as returned
    by <literal>spi_exec_query</literal>, or in <literal>spi_query_prepared</literal> which returns a cursor
    exactly as <literal>spi_query</literal> does, which can be later passed to <literal>spi_query</literal>.
    The optional second parameter to <literal>spi_exec_prepared</literal> is a hash reference of attributes;
    the only attribute currently supported is <literal>limit</literal>, which sets the maximum number of rows returned by a query.
-->
一旦一个查询规划通过调用<literal>spi_prepare</literal>准备好，该规划就可以代替查询字符串，
不管是在<literal>spi_exec_prepared</literal>中(与<literal>spi_exec_query</literal>返回的结果相同)
还是在<literal>spi_query_prepared</literal>中(与<literal>spi_query</literal>返回的游标相同)，
之后可以被传递给<literal>spi_query</literal>。<literal>spi_exec_prepared</literal>
可选的第二个参数是一个属性的哈希引用；当前唯一支持的属性是<literal>limit</literal>，
设置查询返回行的最小数量。
    </para>

<para>
<!-- 
    The advantage of prepared queries is that is it possible to use one prepared plan for more
    than one query execution. After the plan is not needed anymore, it can be freed with
    <literal>spi_freeplan</literal>:
-->
预备查询的好处是可以为多个查询的执行使用一个预备规划。在规划不再被需要之后，
可以通过<literal>spi_freeplan</literal>释放：
<programlisting>
CREATE OR REPLACE FUNCTION init() RETURNS VOID AS $$
        $_SHARED{my_plan} = spi_prepare('SELECT (now() + $1)::date AS now',
                                        'INTERVAL');
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION add_time( INTERVAL ) RETURNS TEXT AS $$
        return spi_exec_prepared(
                $_SHARED{my_plan},
                $_[0]
        )->{rows}->[0]->{now};
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION done() RETURNS VOID AS $$
        spi_freeplan( $_SHARED{my_plan});
        undef $_SHARED{my_plan};
$$ LANGUAGE plperl;

SELECT init();
SELECT add_time('1 day'), add_time('2 days'), add_time('3 days');
SELECT done();

  add_time  |  add_time  |  add_time
------------+------------+------------
 2005-12-10 | 2005-12-11 | 2005-12-12
</programlisting>
<!-- 
    Note that the parameter subscript in <literal>spi_prepare</literal> is defined via
    $1, $2, $3, etc, so avoid declaring query strings in double quotes that might easily
    lead to hard-to-catch bugs.
-->
注意，<literal>spi_prepare</literal>中的参数是通过 $1, $2, $3 ... 表示的，
因此避免在双引号中声明查询字符串，那样可能会导致难以发现的臭虫。
    </para>


<para>
<!-- 
    Another example illustrates usage of an optional parameter in <literal>spi_exec_prepared</literal>:
-->
另外一个说明<literal>spi_exec_prepared</literal>里的可选参数的使用的例子：
<programlisting>
CREATE TABLE hosts AS SELECT id, ('192.168.1.'||id)::inet AS address
                      FROM generate_series(1,3) AS id;

CREATE OR REPLACE FUNCTION init_hosts_query() RETURNS VOID AS $$
        $_SHARED{plan} = spi_prepare('SELECT * FROM hosts
                                      WHERE address &lt;&lt; $1', 'inet');
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION query_hosts(inet) RETURNS SETOF hosts AS $$
        return spi_exec_prepared(
                $_SHARED{plan},
                {limit =&gt; 2},
                $_[0]
        )->{rows};
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION release_hosts_query() RETURNS VOID AS $$
        spi_freeplan($_SHARED{plan});
        undef $_SHARED{plan};
$$ LANGUAGE plperl;

SELECT init_hosts_query();
SELECT query_hosts('192.168.1.0/30');
SELECT release_hosts_query();

    query_hosts    
-----------------
 (1,192.168.1.1)
 (2,192.168.1.2)
(2 rows)
</programlisting>
    </para>
    </listitem>
    </varlistentry>
   </variablelist>
 </sect2>

 <sect2 id="plperl-utility-functions">
  <!-- 
  <title>Utility Functions in PL/Perl</title> 
  -->
  <title>PL/Perl里的效用函数</title>

   <variablelist>
    <varlistentry>
     <indexterm>
      <primary>elog</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>

     <term><literal><function>elog(<replaceable>level</replaceable>, <replaceable>msg</replaceable>)</function></literal></term>
     <listitem>
      <!--
<para>
       Emit a log or error message. Possible levels are
       <literal>DEBUG</>, <literal>LOG</>, <literal>INFO</>,
       <literal>NOTICE</>, <literal>WARNING</>, and <literal>ERROR</>.
       <literal>ERROR</>
        raises an error condition; if this is not trapped by the surrounding
        Perl code, the error propagates out to the calling query, causing
        the current transaction or subtransaction to be aborted.  This
        is effectively the same as the Perl <literal>die</> command.
        The other levels only generate messages of different
        priority levels.
        Whether messages of a particular priority are reported to the client,
        written to the server log, or both is controlled by the
        <xref linkend="guc-log-min-messages"> and
        <xref linkend="guc-client-min-messages"> configuration
        variables. See <xref linkend="runtime-config"> for more
        information.
      </para>
-->
<para>
发出一条日志或者错误信息。可能的级别是<literal>DEBUG</>, <literal>LOG</>, <literal>INFO</>, 
<literal>NOTICE</>, <literal>WARNING</>, <literal>ERROR</>。<literal>ERROR</>抛出一个错误条件。
如果这个错误没有被周围的 Perl 代码捕获，那么错误将传播到调用的查询里，
导致当前事务或者子事务退出。这实际上相当于 Perl 的<literal>die</>命令。
其它级别只是生成不同优先级的消息。特定优先级的消息是否报告给客户端、写到服务器日志、
或者两个都做，是由配置参数<xref linkend="guc-log-min-messages">和<xref linkend="guc-client-min-messages">
控制的。参阅<xref linkend="runtime-config">获取更多信息。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <indexterm>
      <primary>quote_literal</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>

     <term><literal><function>quote_literal(<replaceable>string</replaceable>)</function></literal></term>
     <listitem>
      <!--
<para>
        Return the given string suitably quoted to be used as a string literal in an SQL
        statement string. Embedded single-quotes and backslashes are properly doubled.
        Note that <function>quote_literal</> returns undef on undef input; if the argument
        might be undef, <function>quote_nullable</> is often more suitable.
      </para>
-->
<para>
适当的返回在一个SQL语句字符串中作为字符串文本引用的给定字符串。嵌入的单引号和反斜杠要加一倍。
请注意，<function>quote_literal</>在未定义的输入上返回未定义；如果参数是未定义的，
<function>quote_nullable</>往往是更合适的。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <indexterm>
      <primary>quote_nullable</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>

     <term><literal><function>quote_nullable(<replaceable>string</replaceable>)</function></literal></term>
     <listitem>
      <!--
<para>
        Return the given string suitably quoted to be used as a string literal in an SQL
        statement string; or, if the argument is undef, return the unquoted string "NULL".
        Embedded single-quotes and backslashes are properly doubled.
      </para>
-->
<para>
适当的返回在一个SQL语句字符串中作为字符串文本引用的给定字符串。或者，如果参数是未定义的，
返回不加引号的字符串"NULL"。嵌入的单引号和反斜杠要加一倍。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <indexterm>
      <primary>quote_ident</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>

     <term><literal><function>quote_ident(<replaceable>string</replaceable>)</function></literal></term>
     <listitem>
      <!--
<para>
        Return the given string suitably quoted to be used as an identifier in
        an SQL statement string. Quotes are added only if necessary (i.e., if
        the string contains non-identifier characters or would be case-folded).
        Embedded quotes are properly doubled.
      </para>
-->
<para>
适当的返回在一个SQL语句字符串中作为一个标识符引用的给定字符串。只有在必要时添加引号
（也就是，如果字符串包含非标识符字符或是case-folded）。嵌入的单引号和反斜杠要加一倍。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <indexterm>
      <primary>decode_bytea</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>

     <term><literal><function>decode_bytea(<replaceable>string</replaceable>)</function></literal></term>
     <listitem>
      <!--
<para>
        Return the unescaped binary data represented by the contents of the given string,
        which should be <type>bytea</type> encoded.
        </para>
-->
<para>
返回通过给定字符串内容表示的非逃逸二进制数据，应该是<type>bytea</type>编码。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <indexterm>
      <primary>encode_bytea</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>

     <term><literal><function>encode_bytea(<replaceable>string</replaceable>)</function></literal></term>
     <listitem>
      <!--
<para>
        Return the <type>bytea</type> encoded form of the binary data contents of the given string.
        </para>
-->
<para>
返回给定字符串的二进制数据内容的<type>bytea</type>编码格式。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <indexterm>
      <primary>encode_array_literal</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>

     <term><literal><function>encode_array_literal(<replaceable>array</replaceable>)</function></literal></term>
     <term><literal><function>encode_array_literal(<replaceable>array</replaceable>, <replaceable>delimiter</replaceable>)</function></literal></term>
     <listitem>
      <!--
<para>
        Returns the contents of the referenced array as a string in array literal format
        (see <xref linkend="arrays-input">).
        Returns the argument value unaltered if it's not a reference to an array.
        The delimiter used between elements of the array literal defaults to "<literal>, </literal>"
        if a delimiter is not specified or is undef.
        </para>
-->
<para>
返回引用的数组的内容，以在数组里的字符串文本的格式(参阅<xref linkend="arrays-input">)。
如果不是一个数组的引用则返回未改变的参数值。如果分隔符没用指定或是未定义的，
则数组文字元素之间的分隔符缺省是"<literal>, </literal>"。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <indexterm>
      <primary>encode_typed_literal</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>

     <term><literal><function>encode_typed_literal(<replaceable>value</replaceable>, <replaceable>typename</replaceable>)</function></literal></term>
      <listitem>
       <!--
<para>
         Converts a Perl variable to the value of the data type passed as a
         second argument and returns a string representation of this value.
         Correctly handles nested arrays and values of composite types.
       </para>
-->
<para>
转换一个Perl变量为作为第二个参数传递的数据类型的值和返回一个这个值的字符串表示。
正确处理嵌套数组和复合类型的值。
</para>
      </listitem>
    </varlistentry>

    <varlistentry>
     <indexterm>
      <primary>encode_array_constructor</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>

     <term><literal><function>encode_array_constructor(<replaceable>array</replaceable>)</function></literal></term>
     <listitem>
      <!--
<para>
        Returns the contents of the referenced array as a string in array constructor format
        (see <xref linkend="sql-syntax-array-constructors">).
        Individual values are quoted using <function>quote_nullable</function>.
        Returns the argument value, quoted using <function>quote_nullable</function>,
        if it's not a reference to an array.
        </para>
-->
<para>
返回引用的数组的内容，以在数组构造器里的字符串的格式(参阅<xref linkend="sql-syntax-array-constructors">)。
个别的值用<function>quote_nullable</function>引用。如果不是对数组的引用，那么返回参数值用
<function>quote_nullable</function>引用。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <indexterm>
      <primary>looks_like_number</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>

     <term><literal><function>looks_like_number(<replaceable>string</replaceable>)</function></literal></term>
     <listitem>
      <!--
<para>
        Returns a true value if the content of the given string looks like a
        number, according to Perl, returns false otherwise.
        Returns undef if the argument is undef.  Leading and trailing space is
        ignored. <literal>Inf</> and <literal>Infinity</> are regarded as numbers.
        </para>
-->
<para>
根据Perl，如果给定字符串的内容看起来像一个数字则返回真，否则返回假。如果参数是未定义则返回未定义。
忽略前置和后置的空格。<literal>Inf</>和<literal>Infinity</>被认为是数字。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <indexterm>
      <primary>is_array_ref</primary>
      <secondary>in PL/Perl</secondary>
     </indexterm>

     <term><literal><function>is_array_ref(<replaceable>argument</replaceable>)</function></literal></term>
     <listitem>
      <!--
<para>
        Returns a true value if the given argument may be treated as an
        array reference, that is, if ref of the argument is <literal>ARRAY</> or
        <literal>PostgreSQL::InServer::ARRAY</>.  Returns false otherwise.
      </para>
-->
<para>
如果给定参数可能被视为一个数组引用则返回真，也就是，如果参数的参考是<literal>ARRAY</>或
<literal>PostgreSQL::InServer::ARRAY</>。否则返回假。
</para>
     </listitem>
    </varlistentry>

   </variablelist>
  </sect2>
 </sect1>

 <sect1 id="plperl-global">
  <!-- 
  <title>Global Values in PL/Perl</title> 
  -->
  <title>PL/Perl里的全局变量</title>

  <!--
<para>
    You can use the global hash <varname>%_SHARED</varname> to store
    data, including code references, between function calls for the
    lifetime of the current session.
  </para>
-->
<para>
你可以利用全局散列<varname>%_SHARED</varname>保存数据，包括代码引用，
持续时间可以达到当前会话的生命期。
</para>
 
<para>
<!--
    Here is a simple example for shared data:
-->
下面是一个共享数据的例子：
<programlisting>
CREATE OR REPLACE FUNCTION set_var(name text, val text) RETURNS text AS $$
    if ($_SHARED{$_[0]} = $_[1]) {
        return 'ok';
    } else {
        return "cannot set shared variable $_[0] to $_[1]";
    }
$$ LANGUAGE plperl;

CREATE OR REPLACE FUNCTION get_var(name text) RETURNS text AS $$
    return $_SHARED{$_[0]};
$$ LANGUAGE plperl;

SELECT set_var('sample', 'Hello, PL/Perl!  How''s tricks?');
SELECT get_var('sample');
</programlisting>
  </para>

<para>
<!-- 
   Here is a slightly more complicated example using a code reference:
-->
下面是一个使用代码引用的稍微复杂些的例子：
<programlisting>
CREATE OR REPLACE FUNCTION myfuncs() RETURNS void AS $$
    $_SHARED{myquote} = sub {
        my $arg = shift;
        $arg =~ s/(['\\])/\\$1/g;
        return "'$arg'";
    };
$$ LANGUAGE plperl;

SELECT myfuncs(); /* <!-- initializes the function -->初始化函数 */

/* <!-- Set up a function that uses the quote function -->建立一个使用引用的函数的函数 */

CREATE OR REPLACE FUNCTION use_quote(TEXT) RETURNS text AS $$
    my $text_to_quote = shift;
    my $qfunc = $_SHARED{myquote};
    return &amp;$qfunc($text_to_quote);
$$ LANGUAGE plperl;
</programlisting>
<!-- 
   (You could have replaced the above with the one-liner
   <literal>return $_SHARED{myquote}-&gt;($_[0]);</literal>
   at the expense of readability.)
-->
如果不在乎易读性，你可以用一行<literal>return $_SHARED{myquote}-&gt;($_[0]);</literal> 代替上面的三行。
  </para>

  <!--
<para>
   For security reasons, PL/Perl executes functions called by any one SQL role
   in a separate Perl interpreter for that role.  This prevents accidental or
   malicious interference by one user with the behavior of another user's
   PL/Perl functions.  Each such interpreter has its own value of the
   <varname>%_SHARED</varname> variable and other global state.  Thus, two
   PL/Perl functions will share the same value of <varname>%_SHARED</varname>
   if and only if they are executed by the same SQL role.  In an application
   wherein a single session executes code under multiple SQL roles (via
   <literal>SECURITY DEFINER</> functions, use of <command>SET ROLE</>, etc)
   you may need to take explicit steps to ensure that PL/Perl functions can
   share data via <varname>%_SHARED</varname>.  To do that, make sure that
   functions that should communicate are owned by the same user, and mark
   them <literal>SECURITY DEFINER</>.  You must of course take care that
   such functions can't be used to do anything unintended.
  </para>
-->
<para>
为了安全原因，PL/Perl通过一个SQL角色在一个单独为这个角色的解释器里执行函数调用。
这阻止了有另一个用户的PL/Perl函数的表现的用户的恶意干扰或事故。每个这样的解释器有它自己的
<varname>%_SHARED</varname>变量值和其他全局状态。因此，当且仅当通过相同的SQL角色执行时，
两个PL/Perl函数才将分享相同的<varname>%_SHARED</varname>值。在多个SQL角色下，
只有一个会话执行代码的应用中（通过<literal>SECURITY DEFINER</>函数，使用<command>SET ROLE</>等），
可能需要采取明确的步骤保证PL/Perl函数可以通过<varname>%_SHARED</varname>分享数据。
要做到这点，确保应该沟通的函数是由相同的用户所有的，并且标记他们为<literal>SECURITY DEFINER</>。
当然必须要注意这样的函数不能用来做意料之外的事情。
</para>
 </sect1>

 <sect1 id="plperl-trusted">
  <!-- 
  <title>Trusted and Untrusted PL/Perl</title> 
  -->
  <title>可信的和不可信的 PL/Perl</title>

  <indexterm zone="plperl-trusted">
   <!-- 
   <primary>trusted</primary> 
   -->
   <primary>可信的</primary>
   <secondary>PL/Perl</secondary>
  </indexterm>

  <!--
<para>
   Normally, PL/Perl is installed as a <quote>trusted</> programming
   language named <literal>plperl</>.  In this setup, certain Perl
   operations are disabled to preserve security.  In general, the
   operations that are restricted are those that interact with the
   environment. This includes file handle operations,
   <literal>require</literal>, and <literal>use</literal> (for
   external modules).  There is no way to access internals of the
   database server process or to gain OS-level access with the
   permissions of the server process,
   as a C function can do.  Thus, any unprivileged database user can
   be permitted to use this language.
  </para>
-->
<para>
通常，PL/Perl 是作为一种叫<literal>plperl</>的<quote>可信</>编程语言安装的。在这种设置中，
为了保持安全，某些 Perl 操作被关闭掉了。通常，受限制的操作都是那些和环境相互交互的动作。
这包括文件句柄操作、<literal>require</literal> 、<literal>use</literal>(对于外部模块)。
没有办法访问数据库服务器进程内部或者获取具有服务器进程权限的 OS 级别的访问，就像 C 函数那样。
因此，任何非特权的数据库用户都可以允许使用这种语言。
</para>

<para>
<!-- 
   Here is an example of a function that will not work because file
   system operations are not allowed for security reasons:
-->
这里是一个无法运转的函数的例子，因为出于安全原因，文件系统的操作是不允许的：
<programlisting>
CREATE FUNCTION badfunc() RETURNS integer AS $$
    my $tmpfile = "/tmp/badfile";
    open my $fh, '&gt;', $tmpfile
        or elog(ERROR, qq{could not open the file "$tmpfile": $!});
    print $fh "Testing writing to a file\n";
    close $fh or elog(ERROR, qq{could not close the file "$tmpfile": $!});
    return 1;
$$ LANGUAGE plperl;
</programlisting>
<!-- 
    The creation of this function will fail as its use of a forbidden
    operation will be caught by the validator. 
-->
创建这个函数将会失败，因为它使用的非法调用将会被验证器捕获。
  </para>

  <!--
<para>
   Sometimes it is desirable to write Perl functions that are not
   restricted.  For example, one might want a Perl function that sends
   mail.  To handle these cases, PL/Perl can also be installed as an
   <quote>untrusted</> language (usually called
   <application>PL/PerlU</application><indexterm><primary>PL/PerlU</></indexterm>).
   In this case the full Perl language is available.  When installing the
   language, the language name <literal>plperlu</literal> will select
   the untrusted PL/Perl variant.
  </para>
-->
<para>
有时候想写不受限制的 Perl 函数。比如，可能需要一个能发送邮件的 Perl 函数。为了处理这种情况，
PL/Perl 也可以安装为<quote>不可信的</>的语言<application>PL/PerlU</application><indexterm><primary>PL/PerlU</></indexterm>。
在这种情况下，可以使用完整的 Perl 语言。当安装这个语言时，<literal>plperlu</literal>
这个名字可以选取不可信的 PL/Perl 变种。
</para>

  <!--
<para>
   The writer of a <application>PL/PerlU</> function must take care that the function
   cannot be used to do anything unwanted, since it will be able to do
   anything that could be done by a user logged in as the database
   administrator.  Note that the database system allows only database
   superusers to create functions in untrusted languages.
  </para>
-->
<para>
<application>PL/PerlU</>函数的作者必须注意不能把该函数用于做任何不想做的事情，
因为它可以干任何数据库管理员能干的事情。请注意数据库系统只允许数据库超级用户创建不可信语言写的函数。
</para>

  <!--
<para>
   If the above function was created by a superuser using the language
   <literal>plperlu</>, execution would succeed.
  </para>
-->
<para>
如果上面的函数由超级用户用<literal>plperlu</>创建，那么执行就会成功。
</para>

  <!--
<para>
   In the same way, anonymous code blocks written in Perl can use
   restricted operations if the language is specified as
   <literal>plperlu</> rather than <literal>plperl</>, but the caller
   must be a superuser.
  </para>
-->
<para>
同样的方式，如果语言被声明为<literal>plperlu</>而不是<literal>plperl</>，
那么用Perl写的匿名代码块可以使用受限制的操作，但是调用者必须是超级用户。
</para>

  <note>
   <!--
<para>
    While <application>PL/Perl</> functions run in a separate Perl
    interpreter for each SQL role, all <application>PL/PerlU</> functions
    executed in a given session run in a single Perl interpreter (which is
    not any of the ones used for <application>PL/Perl</> functions).
    This allows <application>PL/PerlU</> functions to share data freely,
    but no communication can occur between <application>PL/Perl</> and
    <application>PL/PerlU</> functions.
   </para>
-->
<para>
当<application>PL/Perl</>函数在一个单独的为每个SQL用户的Perl解释器里运行时，
所有的<application>PL/PerlU</>函数在一个单独的Perl解释器里的给定会话中执行
（不是用于<application>PL/Perl</>函数的那个解释器）。这允许<application>PL/PerlU</>
函数自由的分享数据，但是在<application>PL/Perl</>和<application>PL/PerlU</>
函数之间不会有通讯发生。
</para>
  </note>

  <note>
   <!--
<para>
    Perl cannot support multiple interpreters within one process unless
    it was built with the appropriate flags, namely either
    <literal>usemultiplicity</> or <literal>useithreads</>.
    (<literal>usemultiplicity</> is preferred unless you actually need
    to use threads.  For more details, see the
    <citerefentry><refentrytitle>perlembed</></citerefentry> man page.)
    If <application>PL/Perl</> is used with a copy of Perl that was not built
    this way, then it is only possible to have one Perl interpreter per
    session, and so any one session can only execute either
    <application>PL/PerlU</> functions, or <application>PL/Perl</> functions
    that are all called by the same SQL role.
   </para>
-->
<para>
Perl在一个进程中不能支持多个解释器，除非在编译时给它适当的标志，<literal>usemultiplicity</> 
或 <literal>useithreads</>。（<literal>usemultiplicity</>是首选的，除非你实际需要使用线程。
获取更多信息，请参阅<citerefentry><refentrytitle>perlembed</></citerefentry>手册页。）
如果<application>PL/Perl</>与一个没有这样编译的Perl的副本一起使用，那么每个会话只可能有一个Perl解释器，
所以任意一个会话只能执行<application>PL/PerlU</>函数，或<application>PL/Perl</>函数，
他们都是通过同一个SQL角色调用的。
</para>
  </note>

 </sect1>

 <sect1 id="plperl-triggers">
  <!-- 
  <title>PL/Perl Triggers</title> 
  -->
  <title>PL/Perl 触发器</title>

<para>
<!-- 
   PL/Perl can be used to write trigger functions.  In a trigger function,
   the hash reference <varname>$_TD</varname> contains information about the
   current trigger event. <varname>$_TD</> is a global variable,
   which gets a separate local value for each invocation of the trigger.
   The fields of the <varname>$_TD</varname> hash reference are:
-->
PL/Perl 可以用来书写触发器函数。在一个触发器函数中，散列引用<varname>$_TD</varname>
包含了当前触发事件的信息。<varname>$_TD</>是一个全局变量，
它对于每次触发器调用都能够获取一个局部值。<varname>$_TD</varname>散列引用的字段有：
   <variablelist>
    <varlistentry>
     <term><literal>$_TD-&gt;{new}{foo}</literal></term>
     <listitem>
      <para>
       <!-- 
   <literal>NEW</literal> value of column <literal>foo</literal> 
   -->
   字段<literal>foo</literal>的<literal>NEW</literal>值
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{old}{foo}</literal></term>
     <listitem>
      <!--
<para>
       <literal>OLD</literal> value of column <literal>foo</literal>
      </para>
-->
<para>
字段<literal>foo</literal>的<literal>OLD</literal>值
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{name}</literal></term>
     <listitem>
      <!--
<para>
       Name of the trigger being called
      </para>
-->
<para>
被调用的触发器的名字
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{event}</literal></term>
     <listitem>
      <!--
<para>
       Trigger event: <literal>INSERT</>, <literal>UPDATE</>,
       <literal>DELETE</>, <literal>TRUNCATE</>, or <literal>UNKNOWN</>
      </para>
-->
<para>
触发器事件：<literal>INSERT</>, <literal>UPDATE</>,
       <literal>DELETE</>, <literal>TRUNCATE</>, 或 <literal>UNKNOWN</>
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{when}</literal></term>
     <listitem>
      <!--
<para>
       When the trigger was called: <literal>BEFORE</literal>,
       <literal>AFTER</literal>, <literal>INSTEAD OF</literal>, or
       <literal>UNKNOWN</literal>
      </para>
-->
<para>
何时调用触发器：<literal>BEFORE</literal>,
       <literal>AFTER</literal>, <literal>INSTEAD OF</literal>, 或
       <literal>UNKNOWN</literal>
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{level}</literal></term>
     <listitem>
      <!--
<para>
       The trigger level: <literal>ROW</literal>, <literal>STATEMENT</literal>, or <literal>UNKNOWN</literal>
      </para>
-->
<para>
触发器的级别： <literal>ROW</literal>, <literal>STATEMENT</literal>, 或 <literal>UNKNOWN</literal>
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{relid}</literal></term>
     <listitem>
      <!--
<para>
       OID of the table on which the trigger fired
      </para>
-->
<para>
触发触发器的表的 OID
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{table_name}</literal></term>
     <listitem>
      <!--
<para>
       Name of the table on which the trigger fired
      </para>
-->
<para>
触发触发器的表的名字
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{relname}</literal></term>
     <listitem>
      <!--
<para>
       Name of the table on which the trigger fired. This has been deprecated,
       and could be removed in a future release.
       Please use $_TD-&gt;{table_name} instead.
      </para>
-->
<para>
触发触发器的表的名字。已经废弃了，并且可能在将来的版本中移除。请使用$_TD-&gt;{table_name}。
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{table_schema}</literal></term>
     <listitem>
      <!--
<para>
       Name of the schema in which the table on which the trigger fired, is
      </para>
-->
<para>
触发触发器的表的模式名
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>$_TD-&gt;{argc}</literal></term>
     <listitem>
      <!--
<para>
       Number of arguments of the trigger function
      </para>
-->
<para>
触发器函数的参数个数
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>@{$_TD-&gt;{args}}</literal></term>
     <listitem>
      <!--
<para>
       Arguments of the trigger function.  Does not exist if <literal>$_TD-&gt;{argc}</literal> is 0.
      </para>
-->
<para>
触发器函数的参数，如果<literal>$_TD-&gt;{argc}</literal>为 0 则不存在。
</para>
     </listitem>
    </varlistentry>

   </variablelist>
  </para>


<para>
<!-- 
   Row-level triggers can return one of the following:
 -->
 行级别的触发器返回下列之一：
   <variablelist>
    <varlistentry>
     <term><literal>return;</literal></term>
     <listitem>
  <!--
  <para>
       Execute the operation
      </para>
-->
<para>
执行该操作
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>"SKIP"</literal></term>
     <listitem>
      <!--
<para>
       Don't execute the operation
      </para>
-->
<para>
不执行该操作
</para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>"MODIFY"</literal></term>
     <listitem>
      <!--
<para>
       Indicates that the <literal>NEW</literal> row was modified by
       the trigger function
      </para>
-->
<para>
表明<literal>NEW</literal>行被触发器函数修改过
</para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

<para>
<!-- 
   Here is an example of a trigger function, illustrating some of the
   above:
-->
下面是一个触发器函数，演示了上面的一些东西。
<programlisting>
CREATE TABLE test (
    i int,
    v varchar
);

CREATE OR REPLACE FUNCTION valid_id() RETURNS trigger AS $$
    if (($_TD-&gt;{new}{i} &gt;= 100) || ($_TD-&gt;{new}{i} &lt;= 0)) {
        return "SKIP";    <!-- # skip INSERT/UPDATE command -->#跳过 INSERT/UPDATE 命令
    } elsif ($_TD-&gt;{new}{v} ne "immortal") {
        $_TD-&gt;{new}{v} .= "(modified by trigger)";
        return "MODIFY";  <!-- # modify row and execute INSERT/UPDATE command -->#修改一行并且执行 INSERT/UPDATE 命令

    } else {
        return;           <!-- # execute INSERT/UPDATE command --># 执行 INSERT/UPDATE 命令
    }
$$ LANGUAGE plperl;

CREATE TRIGGER test_valid_id_trig
    BEFORE INSERT OR UPDATE ON test
    FOR EACH ROW EXECUTE PROCEDURE valid_id();
</programlisting>
  </para>
 </sect1>

 <sect1 id="plperl-under-the-hood">
  <!-- 
  <title>PL/Perl Under the Hood</title>
  -->
  <title>后台PL/Perl</title>

 <sect2 id="plperl-config">
  <!-- 
  <title>Configuration</title> 
  -->
  <title>配置</title>

  <!--
<para>
  This section lists configuration parameters that affect <application>PL/Perl</>.
  </para>
-->
<para>
本节列出影响<application>PL/Perl</>的配置参数。
</para>

  <variablelist>

     <varlistentry id="guc-plperl-on-init" xreflabel="plperl.on_init">
      <term><varname>plperl.on_init</varname> (<type>string</type>)</term>
      <indexterm>
       <!-- 
   <primary><varname>plperl.on_init</> configuration parameter</primary> 
   -->
   <primary><varname>plperl.on_init</> 配置参数</primary>
      </indexterm>
      <listitem>
       <!--
<para>
        Specifies Perl code to be executed when a Perl interpreter is first
        initialized, before it is specialized for use by <literal>plperl</> or
        <literal>plperlu</>.
        The SPI functions are not available when this code is executed.
        If the code fails with an error it will abort the initialization of
        the interpreter and propagate out to the calling query, causing the
        current transaction or subtransaction to be aborted.
       </para>
-->
<para>
指定当Perl触发器第一次初始化时执行Perl代码，在这之前是专业为了<literal>plperl</>或
<literal>plperlu</>使用的。当这段代码执行时SPI函数是不适用的。如果代码因错误而失败，
那么它将退出解释器的初始化，并且传播错误到调用的查询，导致当前事务或子事务退出。
</para>

<para>
<!-- 
       The Perl code is limited to a single string. Longer code can be placed
       into a module and loaded by the <literal>on_init</> string.
       Examples: 
-->
Perl代码限制为单个字符串。更长的代码可以放入一个模块，并且由<literal>on_init</>字符串加载。例子：
<programlisting>
plperl.on_init = 'require "plperlinit.pl"'
plperl.on_init = 'use lib "/my/app"; use MyApp::PgInit;'
</programlisting>
       </para>

<para>
<!-- 
       Any modules loaded by <literal>plperl.on_init</>, either directly or
       indirectly, will be available for use by <literal>plperl</>.  This may
       create a security risk. To see what modules have been loaded you can use: 
-->
任何由<literal>plperl.on_init</>直接或非直接加载的模块，都将适用于<literal>plperl</>使用。
这可能会创建一个安全风险。要查看哪个模块被加载了可以使用：
<programlisting>
DO 'elog(WARNING, join ", ", sort keys %INC)' LANGUAGE plperl;
</programlisting>
       </para>

       <!--
<para>
        Initialization will happen in the postmaster if the plperl library is
        included in <xref linkend="guc-shared-preload-libraries">, in which
        case extra consideration should be given to the risk of destabilizing
        the postmaster.  The principal reason for making use of this feature
        is that Perl modules loaded by <literal>plperl.on_init</> need be
        loaded only at postmaster start, and will be instantly available
        without loading overhead in individual database sessions.  However,
        keep in mind that the overhead is avoided only for the first Perl
        interpreter used by a database session &mdash; either PL/PerlU, or
        PL/Perl for the first SQL role that calls a PL/Perl function.  Any
        additional Perl interpreters created in a database session will have
        to execute <literal>plperl.on_init</> afresh.  Also, on Windows there
        will be no savings whatsoever from preloading, since the Perl
        interpreter created in the postmaster process does not propagate to
        child processes.
       </para>
-->
<para>
如果plperl库包含在<xref linkend="guc-shared-preload-libraries">里面，那么初始化将在postmaster中发生，
这种情况下要额外考虑postmaster不稳定的风险。利用这一特性的首要原因是Perl模块通过<literal>plperl.on_init</>
加载需要在postmaster启动的情况下，并且在个人的数据库会话中不会有额外开销加载，立即可用。然而，
请记住，额外开销只是在第一次Perl解释器被数据库会话使用的时候避免，
也就是PL/PerlU或PL/Perl是调用PL/Perl函数的第一个SQL角色。
在一个数据库会话中创建的任何额外的Perl解释器必须重新执行<literal>plperl.on_init</>。同样，在Windows上，
从预加载中不会有任何节省，因为在postmaster进程中创建的Perl解释器不会传播到子进程。
</para>
       <!--
<para>
       This parameter can only be set in the <filename>postgresql.conf</filename> file or on the server command line.
       </para>
-->
<para>
这个postmaster只能在<filename>postgresql.conf</filename>文件或服务器命令行中设置。
</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-plperl-on-plperl-init" xreflabel="plperl.on_plperl_init">
      <term><varname>plperl.on_plperl_init</varname> (<type>string</type>)</term>
      <term><varname>plperl.on_plperlu_init</varname> (<type>string</type>)</term>
      <indexterm>
       <!-- 
   <primary><varname>plperl.on_plperl_init</> configuration parameter</primary> 
   -->
   <primary><varname>plperl.on_plperl_init</> 配置参数</primary>
      </indexterm>
      <indexterm>
       <!-- 
   <primary><varname>plperl.on_plperlu_init</> configuration parameter</primary> 
   -->
   <primary><varname>plperl.on_plperlu_init</> 配置参数</primary>
      </indexterm>
      <listitem>
       <!--
<para>
        These parameters specify Perl code to be executed when a Perl
        interpreter is specialized for <literal>plperl</> or
        <literal>plperlu</> respectively.  This will happen when a PL/Perl or
        PL/PerlU function is first executed in a database session, or when
        an additional interpreter has to be created because the other language
        is called or a PL/Perl function is called by a new SQL role.  This
        follows any initialization done by <literal>plperl.on_init</>.
        The SPI functions are not available when this code is executed.
        The Perl code in <literal>plperl.on_plperl_init</> is executed after
        <quote>locking down</> the interpreter, and thus it can only perform
        trusted operations.
       </para>
-->
<para>
这些参数指定当Perl解释器专门分别为<literal>plperl</>或<literal>plperlu</>时执行Perl代码。
当PL/Perl或PL/PerlU函数在一个数据库会话中第一次执行时会发生这种情况，
或当一个额外的解释器因为其他语言的调用或一个PL/Perl函数被一个新的SQL角色调用而创建时，
也会发生这种情况。这遵循任何由<literal>plperl.on_init</>所做的初始化。
当执行Perl代码时无法使用SPI函数。在<literal>plperl.on_plperl_init</>里面的Perl代码在
<quote>锁定</>解释器后执行，并且因此只能执行信任的操作。
</para>
       <!--
<para>
        If the code fails with an error it will abort the initialization and
        propagate out to the calling query, causing the current transaction or
        subtransaction to be aborted.  Any actions already done within Perl
        won't be undone; however, that interpreter won't be used again.
        If the language is used again the initialization will be attempted
        again within a fresh Perl interpreter.
       </para>
-->
<para>
如果代码因错误而失败，那么它将退出解释器的初始化，并且传播错误到调用的查询，导致当前事务或子事务退出。
任何Perl已经做的动作不会回滚；但是，那个解释器将不会再使用。如果语言再次被使用，
那么初始化将在一个新的Perl解释器中尝试。
</para>
       <!--
<para>
        Only superusers can change these settings.  Although these settings
        can be changed within a session, such changes will not affect Perl
        interpreters that have already been used to execute functions.
       </para>
-->
<para>
只有超级用户可以改变这些设置。尽管这些设置可以在一个会话中改变，
但是这些改变将不会影响到已经用来执行函数的Perl解释器。
</para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-plperl-use-strict" xreflabel="plperl.use_strict">
      <term><varname>plperl.use_strict</varname> (<type>boolean</type>)</term>
      <indexterm>
       <!-- 
   <primary><varname>plperl.use_strict</> configuration parameter</primary> 
   -->
   <primary><varname>plperl.use_strict</> 配置参数</primary>
      </indexterm>
      <listitem>
       <!--
<para>
        When set true subsequent compilations of PL/Perl functions will have
        the <literal>strict</> pragma enabled.  This parameter does not affect
        functions already compiled in the current session.
       </para>
-->
<para>
当设置PL/Perl函数的真实的后续编译时，将启用<literal>strict</>编译指示。
这个参数不影响已经用当前会话编译过的函数。
</para>
      </listitem>
     </varlistentry>

  </variablelist>
</sect2>

 <sect2 id="plperl-missing">
  <!-- 
  <title>Limitations and Missing Features</title> 
  -->
  <title>限制及缺少的特性</title>

  
<para>
<!-- 
   The following features are currently missing from PL/Perl, but they
   would make welcome contributions.
 -->
 下面的特性目前还在 PL/Perl 里面缺少，但是欢迎贡献。
   <itemizedlist>
    <listitem>
<!--
     <para>
      PL/Perl functions cannot call each other directly.
     </para>
-->
<para>
PL/Perl 函数无法相互直接调用。
</para>
    </listitem>

    <listitem>
     <!--
<para>
      SPI is not yet fully implemented.
     </para>
-->
<para>
SPI 目前尚未完全实现。
</para>
    </listitem>

    <listitem>
     <!--
<para>
      If you are fetching very large data sets using
      <literal>spi_exec_query</literal>, you should be aware that
      these will all go into memory.  You can avoid this by using
      <literal>spi_query</literal>/<literal>spi_fetchrow</literal> as
      illustrated earlier.
     </para>
-->
<para>
如果你用<literal>spi_exec_query</literal>抓取非常大的数据集，你应该明白这些数据都会放到内存里。
你可以用前面演示的<literal>spi_query</literal>/<literal>spi_fetchrow</literal>来避免这些。
</para>
     <!--
<para>
        A similar problem occurs if a set-returning function passes a
        large set of rows back to PostgreSQL via <literal>return</literal>. You
        can avoid this problem too by instead using
        <literal>return_next</literal> for each row returned, as shown
        previously.
     </para>
-->
<para>
类似的问题也会发生在一个返回集合的函数用<literal>return</literal>
给 PostgreSQL 传递回去一个巨大的行集合。你也可以像前面演示的那样用<literal>return_next</literal>
返回每个返回行的方法避免这个问题。
</para>
    </listitem>

     <listitem>
      <!--
<para>
        When a session ends normally, not due to a fatal error, any
        <literal>END</> blocks that have been defined are executed.
        Currently no other actions are performed. Specifically,
        file handles are not automatically flushed and objects are
        not automatically destroyed.
      </para>
-->
<para>
当一个会话正常结束时，不是因为一个致命的错误而结束，执行任何已经定义的<literal>END</>块。
当前没有其他动作执行。特别的，文件句柄不自动刷新并且对象不自动销毁。
</para>
     </listitem>
   </itemizedlist>
  </para>
 </sect2>

 </sect1>

</chapter>
