<!-- doc/src/sgml/pgcrypto.sgml -->

<sect1 id="pgcrypto" xreflabel="pgcrypto">
 <title>pgcrypto</title>

 <indexterm zone="pgcrypto">
  <primary>pgcrypto</primary>
 </indexterm>

 <indexterm zone="pgcrypto">
  <!--
  <primary>encryption</primary>
  <secondary>for specific columns</secondary>
  -->
  <primary>加密</primary>
  <secondary>为特定字段</secondary>
 </indexterm>

 <!--
<para>
  The <filename>pgcrypto</> module provides cryptographic functions for
  <productname>PostgreSQL</>.
 </para>
-->
<para>
<filename>pgcrypto</>模块为<productname>PostgreSQL</>提供cryptographic函数。
</para>

 <sect2>
  <!--
  <title>General Hashing Functions</title>
  -->
  <title>一般散列函数</title>

  <sect3>
   <title><function>digest()</function></title>

   <indexterm>
    <primary>digest</primary>
   </indexterm>

<synopsis>
digest(data text, type text) returns bytea
digest(data bytea, type text) returns bytea
</synopsis>

   <!--
<para>
    Computes a binary hash of the given <parameter>data</>.
    <parameter>type</> is the algorithm to use.
    Standard algorithms are <literal>md5</literal>, <literal>sha1</literal>,
    <literal>sha224</literal>, <literal>sha256</literal>,
    <literal>sha384</literal> and <literal>sha512</literal>.
    If <filename>pgcrypto</> was built with
    OpenSSL, more algorithms are available, as detailed in
    <xref linkend="pgcrypto-with-without-openssl">.
   </para>
-->
<para>
计算给定<parameter>data</>的二进制散列。<parameter>type</>是要使用的算法。
标准算法是<literal>md5</literal>, <literal>sha1</literal>,
<literal>sha224</literal>, <literal>sha256</literal>,
<literal>sha384</literal> 和 <literal>sha512</literal>。
如果<filename>pgcrypto</>带有OpenSSL建立，那么更多算法可用，在
<xref linkend="pgcrypto-with-without-openssl">中详细说明。
</para>

   <!--
<para>
    If you want the digest as a hexadecimal string, use
    <function>encode()</> on the result.  For example:
<programlisting>
CREATE OR REPLACE FUNCTION sha1(bytea) returns text AS $$
    SELECT encode(digest($1, 'sha1'), 'hex')
$$ LANGUAGE SQL STRICT IMMUTABLE;
</programlisting>
   </para>
-->
<para>
如果你希望digest作为一个十六进制字符串，那么在结果上使用<function>encode()</>。
例如：
<programlisting>
CREATE OR REPLACE FUNCTION sha1(bytea) returns text AS $$
    SELECT encode(digest($1, 'sha1'), 'hex')
$$ LANGUAGE SQL STRICT IMMUTABLE;
</programlisting>
</para>
  </sect3>

  <sect3>
   <title><function>hmac()</function></title>

   <indexterm>
    <primary>hmac</primary>
   </indexterm>

<synopsis>
hmac(data text, key text, type text) returns bytea
hmac(data bytea, key text, type text) returns bytea
</synopsis>

   <!--
<para>
    Calculates hashed MAC for <parameter>data</> with key <parameter>key</>.
    <parameter>type</> is the same as in <function>digest()</>.
   </para>
-->
<para>
为带有键<parameter>key</>的<parameter>data</>计算散列的MAC。<parameter>type</>
和在<function>digest()</>中相同。
</para>

   <!--
<para>
    This is similar to <function>digest()</> but the hash can only be
    recalculated knowing the key.  This prevents the scenario of someone
    altering data and also changing the hash to match.
   </para>
-->
<para>
类似于<function>digest()</>但是散列只能在知道键的时候计算。
这样就阻止了某个人更改数据并改变匹配的散列的情况。
</para>

   <!--
<para>
    If the key is larger than the hash block size it will first be hashed and
    the result will be used as key.
   </para>
-->
<para>
如果键比散列块大小要大，那么将首先把键散列然后散列的结果作为键使用。
</para>
  </sect3>
 </sect2>

 <sect2>
  <!--
  <title>Password Hashing Functions</title>
  -->
  <title>口令散列函数</title>

  <!--
<para>
   The functions <function>crypt()</> and <function>gen_salt()</>
   are specifically designed for hashing passwords.
   <function>crypt()</> does the hashing and <function>gen_salt()</>
   prepares algorithm parameters for it.
  </para>
-->
<para>
函数<function>crypt()</>和<function>gen_salt()</>是特别为散列口令设计的。
<function>crypt()</>做散列法，<function>gen_salt()</>为其准备算法参数。
</para>

  <!--
<para>
   The algorithms in <function>crypt()</> differ from usual hashing algorithms
   like MD5 or SHA1 in the following respects:
  </para>
-->
<para>
<function>crypt()</>中的算法与普通散列算法（如MD5或SHA1）有以下方面的不同：
</para>

  <orderedlist>
   <listitem>
    <!--
<para>
     They are slow.  As the amount of data is so small, this is the only
     way to make brute-forcing passwords hard.
    </para>
-->
<para>
他们的速度很慢。因为数据很少，所以这是唯一的让蛮力破解口令困难些的方法。
</para>
   </listitem>
   <listitem>
    <!--
<para>
     They use a random value, called the <firstterm>salt</>, so that users
     having the same password will have different encrypted passwords.
     This is also an additional defense against reversing the algorithm.
    </para>
-->
<para>
它们使用随机值，称为<firstterm>salt</>，所以有相同口令的用户将会有不同加密了的口令。
也是也对反向算法的附加防御。
</para>
   </listitem>
   <listitem>
    <!--
<para>
     They include the algorithm type in the result, so passwords hashed with
     different algorithms can co-exist.
    </para>
-->
<para>
它们在结果中包括算法类型，所以不同算法的口令散列可以共存。
</para>
   </listitem>
   <listitem>
    <!--
<para>
     Some of them are adaptive &mdash; that means when computers get
     faster, you can tune the algorithm to be slower, without
     introducing incompatibility with existing passwords.
    </para>
-->
<para>
它们中的一些是自适应的，这意味着当计算机更快速时，你可以将算法调整的慢一些，
而不会引入与现有口令的不相容。
</para>
   </listitem>
  </orderedlist>

  <!--
<para>
   <xref linkend="pgcrypto-crypt-algorithms"> lists the algorithms
   supported by the <function>crypt()</function> function.
  </para>
-->
<para>
<xref linkend="pgcrypto-crypt-algorithms">列出了<function>crypt()</function>
函数支持的算法。
</para>

  <table id="pgcrypto-crypt-algorithms">
   <!--
   <title>Supported Algorithms for <function>crypt()</></title>
   -->
   <title><function>crypt()</>支持的算法</title>
   <tgroup cols="5">
    <thead>
     <row>
      <!--
  <entry>Algorithm</entry>
      <entry>Max Password Length</entry>
      <entry>Adaptive?</entry>
      <entry>Salt Bits</entry>
      <entry>Description</entry>
  -->
  <entry>算法</entry>
      <entry>最大口令长度</entry>
      <entry>自适应?</entry>
      <entry>Salt位</entry>
      <entry>描述</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><literal>bf</></entry>
      <entry>72</entry>
      <entry>yes</entry>
      <entry>128</entry>
      <!--
  <entry>Blowfish-based, variant 2a</entry>
  -->
  <entry>基于Blowfish，2a的变体</entry>
     </row>
     <row>
      <entry><literal>md5</></entry>
      <entry>unlimited</entry>
      <entry>no</entry>
      <entry>48</entry>
      <!--
  <entry>MD5-based crypt</entry>
  -->
  <entry>基于MD5加密</entry>
     </row>
     <row>
      <entry><literal>xdes</></entry>
      <entry>8</entry>
      <entry>yes</entry>
      <entry>24</entry>
      <!--
  <entry>Extended DES</entry>
  -->
  <entry>扩展的DES</entry>
     </row>
     <row>
      <entry><literal>des</></entry>
      <entry>8</entry>
      <entry>no</entry>
      <entry>12</entry>
      <!--
  <entry>Original UNIX crypt</entry>
  -->
  <entry>原始的UNIX加密</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <sect3>
   <title><function>crypt()</></title>

   <indexterm>
    <primary>crypt</primary>
   </indexterm>

<synopsis>
crypt(password text, salt text) returns text
</synopsis>

   <!--
<para>
    Calculates a crypt(3)-style hash of <parameter>password</>.
    When storing a new password, you need to use
    <function>gen_salt()</> to generate a new <parameter>salt</> value.
    To check a password, pass the stored hash value as <parameter>salt</>,
    and test whether the result matches the stored value.
   </para>
-->
<para>
计算一个<parameter>password</>的crypt(3)类型散列。当存储一个新的口令时，
需要使用<function>gen_salt()</>生成一个新的<parameter>salt</>值。
要检查一个口令，作为<parameter>salt</>传递存储的散列值，
然后检验结果是否匹配存储的值。
</para>
   <!--
<para>
    Example of setting a new password:
<programlisting>
UPDATE ... SET pswhash = crypt('new password', gen_salt('md5'));
</programlisting>
   </para>
-->
<para>
设置一个新的口令的示例：
<programlisting>
UPDATE ... SET pswhash = crypt('new password', gen_salt('md5'));
</programlisting>
</para>
   <!--
<para>
    Example of authentication:
<programlisting>
SELECT pswhash = crypt('entered password', pswhash) FROM ... ;
</programlisting>
    This returns <literal>true</> if the entered password is correct.
   </para>
-->
<para>
认证的示例：
<programlisting>
SELECT pswhash = crypt('entered password', pswhash) FROM ... ;
</programlisting>
如果输入的口令是正确的这个就返回<literal>true</>。
</para>
  </sect3>

  <sect3>
   <title><function>gen_salt()</></title>

  <indexterm>
   <primary>gen_salt</primary>
  </indexterm>

<synopsis>
gen_salt(type text [, iter_count integer ]) returns text
</synopsis>

   <!--
<para>
    Generates a new random salt string for use in <function>crypt()</>.
    The salt string also tells <function>crypt()</> which algorithm to use.
   </para>
-->
<para>
为<function>crypt()</>的使用生成一个新的随机salt字符串。
salt字符串也告诉<function>crypt()</>使用哪种算法。
</para>

   <!--
<para>
    The <parameter>type</> parameter specifies the hashing algorithm.
    The accepted types are: <literal>des</literal>, <literal>xdes</literal>,
    <literal>md5</literal> and <literal>bf</literal>.
   </para>
-->
<para>
<parameter>type</>参数指定散列算法。接受的类型有：<literal>des</literal>, <literal>xdes</literal>,
<literal>md5</literal> 和 <literal>bf</literal>。
</para>

   <!--
<para>
    The <parameter>iter_count</> parameter lets the user specify the iteration
    count, for algorithms that have one.
    The higher the count, the more time it takes to hash
    the password and therefore the more time to break it.  Although with
    too high a count the time to calculate a hash may be several years
    &mdash; which is somewhat impractical.  If the <parameter>iter_count</>
    parameter is omitted, the default iteration count is used.
    Allowed values for <parameter>iter_count</> depend on the algorithm and
    are shown in <xref linkend="pgcrypto-icfc-table">.
   </para>
-->
<para>
<parameter>iter_count</>参数让用户指定重复计数，为这一个算法。计数值越高，
拿它去散列口令的次数越多，因此解开它的次数也越多。尽管太高的计数来计算一个散列可能会用几年的时间，
这有点不切实际。如果省略了<parameter>iter_count</>参数，那么使用缺省的重复计数。
<parameter>iter_count</>的允许值取决于算法，在<xref linkend="pgcrypto-icfc-table">中显示。
</para>

   <table id="pgcrypto-icfc-table">
    <!--
<title>Iteration Counts for <function>crypt()</></title>
-->
<title><function>crypt()</>的重复计数</title>
    <tgroup cols="4">
     <thead>
      <row>
       <!--
   <entry>Algorithm</entry>
       <entry>Default</entry>
       <entry>Min</entry>
       <entry>Max</entry>
   -->
   <entry>算法</entry>
       <entry>缺省</entry>
       <entry>最小</entry>
       <entry>最大</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><literal>xdes</></entry>
       <entry>725</entry>
       <entry>1</entry>
       <entry>16777215</entry>
      </row>
      <row>
       <entry><literal>bf</></entry>
       <entry>6</entry>
       <entry>4</entry>
       <entry>31</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <!--
<para>
    For <literal>xdes</literal> there is an additional limitation that the
    iteration count must be an odd number.
   </para>
-->
<para>
对于<literal>xdes</literal>，这里有一个附加的限制，那就是重复计数必须是奇数。
</para>

   <!--
<para>
    To pick an appropriate iteration count, consider that
    the original DES crypt was designed to have the speed of 4 hashes per
    second on the hardware of that time.
    Slower than 4 hashes per second would probably dampen usability.
    Faster than 100 hashes per second is probably too fast.
   </para>
-->
<para>
要选择一个合适的重复计数，考虑原始的DES加密设计是要在那个时间的硬件上每秒有4个散列的速度。
比4个散列每秒慢的可能会降低可用性。高于100散列每秒的可能太快了。
</para>

   <!--
<para>
    <xref linkend="pgcrypto-hash-speed-table"> gives an overview of the relative slowness
    of different hashing algorithms.
    The table shows how much time it would take to try all
    combinations of characters in an 8-character password, assuming
    that the password contains either only lower case letters, or
    upper- and lower-case letters and numbers.
    In the <literal>crypt-bf</literal> entries, the number after a slash is
    the <parameter>iter_count</parameter> parameter of
    <function>gen_salt</function>.
   </para>
-->
<para>
<xref linkend="pgcrypto-hash-speed-table">给出了不同散列算法的相对缓慢的概述。
该表显示了在8字符口令里尝试所有字符的组合将会花费多长时间，假设口令只包含小写字母，
或者包含大小写字母和数字。在<literal>crypt-bf</literal>记录中，
斜线后的数字是<function>gen_salt</function>的<parameter>iter_count</parameter>参数。
</para>

   <table id="pgcrypto-hash-speed-table">
    <!--
<title>Hash Algorithm Speeds</title>
-->
<title>散列算法速度</title>
    <tgroup cols="4">
     <thead>
      <row>
       <!-- 
   <entry>Algorithm</entry>
       <entry>Hashes/sec</entry>
       <entry>For <literal>[a-z]</></entry>
       <entry>For <literal>[A-Za-z0-9]</></entry>
   -->
   <entry>算法</entry>
       <entry>散列/sec</entry>
       <entry>对于 <literal>[a-z]</></entry>
       <entry>对于 <literal>[A-Za-z0-9]</></entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><literal>crypt-bf/8</></entry>
       <entry>28</entry>
       <!--
   <entry>246 years</entry>
       <entry>251322 years</entry>
   -->
   <entry>246 年</entry>
       <entry>251322 年</entry>
      </row>
      <row>
       <entry><literal>crypt-bf/7</></entry>
       <entry>57</entry>
       <!--
   <entry>121 years</entry>
       <entry>123457 years</entry>
   -->
   <entry>121 年</entry>
       <entry>123457 年</entry>
      </row>
      <row>
       <entry><literal>crypt-bf/6</></entry>
       <entry>112</entry>
       <!--
   <entry>62 years</entry>
       <entry>62831 years</entry>
   -->
   <entry>62 年</entry>
       <entry>62831 年</entry>
      </row>
      <row>
       <entry><literal>crypt-bf/5</></entry>
       <entry>211</entry>
       <!--
   <entry>33 years</entry>
       <entry>33351 years</entry>
   -->
   <entry>33 年</entry>
       <entry>33351 年</entry>
      </row>
      <row>
       <entry><literal>crypt-md5</></entry>
       <entry>2681</entry>
       <!--
   <entry>2.6 years</entry>
       <entry>2625 years</entry>
   -->
   <entry>2.6 年</entry>
       <entry>2625 年</entry>
      </row>
      <row>
       <entry><literal>crypt-des</></entry>
       <entry>362837</entry>
       <!--
   <entry>7 days</entry>
       <entry>19 years</entry>
   -->
   <entry>7 天</entry>
       <entry>19 年</entry>
      </row>
      <row>
       <entry><literal>sha1</></entry>
       <entry>590223</entry>
       <!--
   <entry>4 days</entry>
       <entry>12 years</entry>
   -->
   <entry>4 天</entry>
       <entry>12 年</entry>
      </row>
      <row>
       <entry><literal>md5</></entry>
       <entry>2345086</entry>
       <!--
   <entry>1 day</entry>
       <entry>3 years</entry>
   -->
   <entry>1 天</entry>
       <entry>3 年</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <!--
<para>
    Notes:
   </para>
-->
<para>
注意：
</para>

   <itemizedlist>
    <listitem>
     <!--
<para>
     The machine used is a 1.5GHz Pentium 4.
     </para>
-->
<para>
使用的这个机器是1.5GHz Pentium 4。
</para>
    </listitem>
    <listitem>
     <!--
<para>
      <literal>crypt-des</> and <literal>crypt-md5</> algorithm numbers are
      taken from John the Ripper v1.6.38 <literal>-test</> output.
     </para>
-->
<para>
<literal>crypt-des</>和<literal>crypt-md5</>计算的数字是从
John the Ripper v1.6.38 <literal>-test</>的输出获得的。
</para>
    </listitem>
    <listitem>
     <!--
<para>
      <literal>md5</> numbers are from mdcrack 1.2.
     </para>
-->
<para>
<literal>md5</>数字来自mdcrack 1.2。
</para>
    </listitem>
    <listitem>
     <!--
<para>
      <literal>sha1</> numbers are from lcrack-20031130-beta.
     </para>
-->
<para>
<literal>sha1</>数字来自lcrack-20031130-beta。
</para>
    </listitem>
    <listitem>
     <!--
<para>
      <literal>crypt-bf</literal> numbers are taken using a simple program that
      loops over 1000 8-character passwords.  That way I can show the speed
      with different numbers of iterations.  For reference: <literal>john
      -test</literal> shows 213 loops/sec for <literal>crypt-bf/5</>.
      (The very small
      difference in results is in accordance with the fact that the
      <literal>crypt-bf</literal> implementation in <filename>pgcrypto</>
      is the same one used in John the Ripper.)
     </para>
-->
<para>
<literal>crypt-bf</literal>数字使用一个简单的程序获得，这个程序重复超过1000次8字符口令。
这样可以显示速度和不同数字的迭代。例如：<literal>john -test</literal>显示了
<literal>crypt-bf/5</>的213次循环/秒。（结果中非常小的不同与事实一致，
<filename>pgcrypto</>中的<literal>crypt-bf</literal>实现和John the Ripper中使用的是同一个。）
</para>
    </listitem>
   </itemizedlist>

   <!--
<para>
    Note that <quote>try all combinations</quote> is not a realistic exercise.
    Usually password cracking is done with the help of dictionaries, which
    contain both regular words and various mutations of them.  So, even
    somewhat word-like passwords could be cracked much faster than the above
    numbers suggest, while a 6-character non-word-like password may escape
    cracking.  Or not.
   </para>
-->
<para>
请注意，<quote>尝试所有组合</quote>是不现实的。不寻常的密码破解在字典的帮助下完成，
包含普通的单词和它们的各种转变。所以，即使有点类似单词的密码可能比上述建议的数字破解的更快，
而一个6字符不像单词的密码可能避开破解。或者不能。
</para>
  </sect3>
 </sect2>

 <sect2>
  <!--
  <title>PGP Encryption Functions</title>
  -->
  <title>PGP 加密功能</title>

  <!--
<para>
   The functions here implement the encryption part of the OpenPGP (RFC 4880)
   standard.  Supported are both symmetric-key and public-key encryption.
  </para>
-->
<para>
该功能实现了部分OpenPGP (RFC 4880)标准的加密。支持对称秘钥和公共秘钥的加密。
</para>

  <!--
<para>
   An encrypted PGP message consists of 2 parts, or <firstterm>packets</>:
  </para>
-->
<para>
一条加密的PGP消息包含2个部分，或<firstterm>数据包</>：
</para>
  <itemizedlist>
   <listitem>
    <!--
<para>
     Packet containing a session key &mdash; either symmetric-key or public-key
     encrypted.
    </para>
-->
<para>
数据包包含一个会话秘钥&mdash;加密了的对称秘钥或者是公共秘钥。
</para>
   </listitem>
   <listitem>
    <!--
<para>
     Packet containing data encrypted with the session key.
    </para>
-->
<para>
数据包包含带有会话秘钥的加密数据。
</para>
   </listitem>
  </itemizedlist>

  <!--
<para>
   When encrypting with a symmetric key (i.e., a password):
  </para>
-->
<para>
当带有对称秘钥（如一个口令）加密时：
</para>
  <orderedlist>
   <listitem>
    <!--
<para>
     The given password is hashed using a String2Key (S2K) algorithm.  This is
     rather similar to <function>crypt()</> algorithms &mdash; purposefully
     slow and with random salt &mdash; but it produces a full-length binary
     key.
    </para>
-->
<para>
给定的口令使用String2Key (S2K)算法散列。这和<function>crypt()</>算法很相似&mdash;
自觉地变慢并且带有随机salt&mdash;但是它产生一个全长的二进制秘钥。
</para>
   </listitem>
   <listitem>
    <!--
<para>
     If a separate session key is requested, a new random key will be
     generated.  Otherwise the S2K key will be used directly as the session
     key.
    </para>
-->
<para>
如果需要一个单独的会话秘钥，将会产生一个新的随机秘钥。否则将直接使用S2K秘钥作为会话秘钥。
</para>
   </listitem>
   <listitem>
    <!--
<para>
     If the S2K key is to be used directly, then only S2K settings will be put
     into the session key packet.  Otherwise the session key will be encrypted
     with the S2K key and put into the session key packet.
    </para>
-->
<para>
如果直接使用S2K秘钥，那么只有S2K设置将被放入到会话秘钥包。
否则会话秘钥将用S2K秘钥加密然后放入会话秘钥包。
</para>
   </listitem>
  </orderedlist>

  <!--
<para>
   When encrypting with a public key:
  </para>
-->
<para>
当使用公共秘钥加密时：
</para>
  <orderedlist>
   <listitem>
    <!--
<para>
     A new random session key is generated.
    </para>
-->
<para>
将会产生一个新的随机会话秘钥。
</para>
   </listitem>
   <listitem>
    <!--
<para>
     It is encrypted using the public key and put into the session key packet.
    </para>
-->
<para>
它使用公共密钥加密并放入会话秘钥包中。
</para>
   </listitem>
  </orderedlist>

  <!--
<para>
   In either case the data to be encrypted is processed as follows:
  </para>
-->
<para>
两种情况下数据被加密的处理如下：
</para>
  <orderedlist>
   <listitem>
    <!--
<para>
     Optional data-manipulation: compression, conversion to UTF-8,
     and/or conversion of line-endings.
    </para>
-->
<para>
可选的数据操作：压缩，转换成UTF-8，和/或行尾的转换。
</para>
   </listitem>
   <listitem>
    <!--
<para>
     The data is prefixed with a block of random bytes.  This is equivalent
     to using a random IV.
    </para>
-->
<para>
数据带有一块随机字节的前缀。这相当于使用一个随机的IV。
</para>
   </listitem>
   <listitem>
    <!--
<para>
     An SHA1 hash of the random prefix and data is appended.
    </para>
-->
<para>
附加上一个随机前缀和数据的SHA1散列。
</para>
   </listitem>
   <listitem>
    <!--
<para>
     All this is encrypted with the session key and placed in the data packet.
    </para>
-->
<para>
所有这些都带有会话秘钥加密，并放入数据包中。
</para>
   </listitem>
  </orderedlist>

  <sect3>
   <title><function>pgp_sym_encrypt()</function></title>

   <indexterm>
    <primary>pgp_sym_encrypt</primary>
   </indexterm>

   <indexterm>
    <primary>pgp_sym_encrypt_bytea</primary>
   </indexterm>

<synopsis>
pgp_sym_encrypt(data text, psw text [, options text ]) returns bytea
pgp_sym_encrypt_bytea(data bytea, psw text [, options text ]) returns bytea
</synopsis>
   <!--
<para>
    Encrypt <parameter>data</> with a symmetric PGP key <parameter>psw</>.
    The <parameter>options</> parameter can contain option settings,
    as described below.
   </para>
-->
<para>
带有一个对称的PGP秘钥<parameter>psw</>加密<parameter>data</>。
<parameter>options</>参数可以包含选项设置，就像下面描述的那样。
</para>
  </sect3>

  <sect3>
   <title><function>pgp_sym_decrypt()</function></title>

   <indexterm>
    <primary>pgp_sym_decrypt</primary>
   </indexterm>

   <indexterm>
    <primary>pgp_sym_decrypt_bytea</primary>
   </indexterm>

<synopsis>
pgp_sym_decrypt(msg bytea, psw text [, options text ]) returns text
pgp_sym_decrypt_bytea(msg bytea, psw text [, options text ]) returns bytea
</synopsis>
   <!--
<para>
    Decrypt a symmetric-key-encrypted PGP message.
   </para>
-->
<para>
解密一个对称秘钥加密的PGP信息。
</para>
   <!--
<para>
    Decrypting <type>bytea</> data with <function>pgp_sym_decrypt</> is disallowed.
    This is to avoid outputting invalid character data.  Decrypting
    originally textual data with <function>pgp_sym_decrypt_bytea</> is fine.
   </para>
-->
<para>
用<function>pgp_sym_decrypt</>解密<type>bytea</>数据是不允许的。
这是为了避免输出不合法的字符数据。用<function>pgp_sym_decrypt_bytea</>
解密原始的文本数据是可以的。
</para>
   <!--
<para>
    The <parameter>options</> parameter can contain option settings,
    as described below.
   </para>
-->
<para>
<parameter>options</>参数可以包含选项设置，就像下面描述的那样。
</para>
  </sect3>

  <sect3>
   <title><function>pgp_pub_encrypt()</function></title>

   <indexterm>
    <primary>pgp_pub_encrypt</primary>
   </indexterm>

   <indexterm>
    <primary>pgp_pub_encrypt_bytea</primary>
   </indexterm>

<synopsis>
pgp_pub_encrypt(data text, key bytea [, options text ]) returns bytea
pgp_pub_encrypt_bytea(data bytea, key bytea [, options text ]) returns bytea
</synopsis>
   <!--
<para>
    Encrypt <parameter>data</> with a public PGP key <parameter>key</>.
    Giving this function a secret key will produce a error.
   </para>
-->
<para>
用一个公共的PGP秘钥<parameter>key</>加密<parameter>data</>。
给这个函数一个秘密秘钥将产生一个错误。
</para>
   <!--
<para>
    The <parameter>options</> parameter can contain option settings,
    as described below.
   </para>
-->
<para>
<parameter>options</>参数可以包含选项设置，就像下面描述的那样。
</para>
  </sect3>

  <sect3>
   <title><function>pgp_pub_decrypt()</function></title>

   <indexterm>
    <primary>pgp_pub_decrypt</primary>
   </indexterm>

   <indexterm>
    <primary>pgp_pub_decrypt_bytea</primary>
   </indexterm>

<synopsis>
pgp_pub_decrypt(msg bytea, key bytea [, psw text [, options text ]]) returns text
pgp_pub_decrypt_bytea(msg bytea, key bytea [, psw text [, options text ]]) returns bytea
</synopsis>
   <!--
<para>
    Decrypt a public-key-encrypted message.  <parameter>key</> must be the
    secret key corresponding to the public key that was used to encrypt.
    If the secret key is password-protected, you must give the password in
    <parameter>psw</>.  If there is no password, but you want to specify
    options, you need to give an empty password.
   </para>
-->
<para>
解密一个公共密钥加密的信息。<parameter>key</>必须是与用来加密的公共秘钥对应的秘密秘钥。
如果该秘密秘钥是密码保护的，你必须在<parameter>psw</>中给出密码。
如果没有密码，但是你希望指定选项，你需要给出一个空的密码。
</para>
   <!--
<para>
    Decrypting <type>bytea</> data with <function>pgp_pub_decrypt</> is disallowed.
    This is to avoid outputting invalid character data.  Decrypting
    originally textual data with <function>pgp_pub_decrypt_bytea</> is fine.
   </para>
-->
<para>
用<function>pgp_pub_decrypt</>解密<type>bytea</>数据是不允许的。
这是为了避免输出不合法的字符数据。用<function>pgp_pub_decrypt_bytea</>
解密原始的文本数据是可以的。
</para>
   <!--
<para>
    The <parameter>options</> parameter can contain option settings,
    as described below.
   </para>
-->
<para>
<parameter>options</>参数可以包含选项设置，就像下面描述的那样。
</para>
  </sect3>

  <sect3>
   <title><function>pgp_key_id()</function></title>

   <indexterm>
    <primary>pgp_key_id</primary>
   </indexterm>

<synopsis>
pgp_key_id(bytea) returns text
</synopsis>
   <!--
<para>
    <function>pgp_key_id</> extracts the key ID of a PGP public or secret key.
    Or it gives the key ID that was used for encrypting the data, if given
    an encrypted message.
   </para>
-->
<para>
<function>pgp_key_id</>摘取一个PGP公共或秘密秘钥的秘钥 ID。
或如果给出一个加密的信息，它给出用于加密数据的秘钥 ID。
</para>
   <!--
<para>
    It can return 2 special key IDs:
   </para>
-->
<para>
它可以返回两个特殊的秘钥 ID：
</para>
   <itemizedlist>
    <listitem>
<para>
      <literal>SYMKEY</>
     </para>

     <!--
<para>
      The message is encrypted with a symmetric key.
     </para>
-->
<para>
该信息是用对称秘钥加密的。
</para>
    </listitem>
    <listitem>

<para>
      <literal>ANYKEY</>
     </para>

     <!--
<para>
      The message is public-key encrypted, but the key ID has been removed.
      That means you will need to try all your secret keys on it to see
      which one decrypts it.  <filename>pgcrypto</> itself does not produce
      such messages.
     </para>
-->
<para>
该信息是公共秘钥加密的，但是秘钥ID已经删除了。这意味着你将要尝试所有你的秘密秘钥，
看看哪个能解密它。<filename>pgcrypto</>本身并不产生这样的信息。
</para>
    </listitem>
   </itemizedlist>
   <!--
<para>
    Note that different keys may have the same ID.   This is rare but a normal
    event. The client application should then try to decrypt with each one,
    to see which fits &mdash; like handling <literal>ANYKEY</>.
   </para>
-->
<para>
请注意，不同的秘钥可能有相同的ID。这是稀少的，但是是一个普通事件。
然后客户端应用应该尝试解密每一个，看看哪个合适&mdash;类似处理<literal>ANYKEY</>。
</para>
  </sect3>

  <sect3>
   <title><function>armor()</function>, <function>dearmor()</function></title>

   <indexterm>
    <primary>armor</primary>
   </indexterm>

   <indexterm>
    <primary>dearmor</primary>
   </indexterm>

<synopsis>
armor(data bytea) returns text
dearmor(data text) returns bytea
</synopsis>
   <!--
<para>
    These functions wrap/unwrap binary data into PGP ASCII-armor format,
    which is basically Base64 with CRC and additional formatting.
   </para>
-->
<para>
这些功能打包/解包二进制数据到PGP ASCII-armor格式，
这些基本上是带有CRC的Base64和额外的格式。
</para>
  </sect3>

  <sect3>
   <!--
   <title>Options for PGP Functions</title>
   -->
   <title>PGP功能的选项</title>

   <!--
<para>
    Options are named to be similar to GnuPG.  An option's value should be
    given after an equal sign; separate options from each other with commas.
    For example:
<programlisting>
pgp_sym_encrypt(data, psw, 'compress-algo=1, cipher-algo=aes256')
</programlisting>
   </para>
-->
<para>
选项的命名类似于GnuPG。选项的值应该在等号后面给出；选项之间用逗号隔开。例如：
<programlisting>
pgp_sym_encrypt(data, psw, 'compress-algo=1, cipher-algo=aes256')
</programlisting>
</para>

   <!--
<para>
    All of the options except <literal>convert-crlf</literal> apply only to
    encrypt functions.  Decrypt functions get the parameters from the PGP
    data.
   </para>
-->
<para>
除了<literal>convert-crlf</literal>之外的所有选项只应用到加密函数。
解密函数从PGP数据中获得参数。
</para>

   <!--
<para>
    The most interesting options are probably
    <literal>compress-algo</literal> and <literal>unicode-mode</literal>.
    The rest should have reasonable defaults.
   </para>
-->
<para>
最有趣的选项可能就是<literal>compress-algo</literal>和<literal>unicode-mode</literal>了。
其余的应该有合理的默认值。
</para>

  <sect4>
   <title>cipher-algo</title>

   <!--
<para>
    Which cipher algorithm to use.
   </para>
-->
<para>
要使用的密码算法。
</para>
<literallayout>
<!--
Values: bf, aes128, aes192, aes256 (OpenSSL-only: <literal>3des</literal>, <literal>cast5</literal>)
Default: aes128
Applies to: pgp_sym_encrypt, pgp_pub_encrypt
-->
值: bf, aes128, aes192, aes256 (OpenSSL-only: <literal>3des</literal>, <literal>cast5</literal>)
缺省: aes128
适用于: pgp_sym_encrypt, pgp_pub_encrypt
</literallayout>
  </sect4>

  <sect4>
   <title>compress-algo</title>

   <!--
<para>
    Which compression algorithm to use.  Only available if
    <productname>PostgreSQL</productname> was built with zlib.
   </para>
-->
<para>
要使用的压缩算法。只有<productname>PostgreSQL</productname>带有zlib建立时可以使用。
</para>
<literallayout>
<!-- 
Values:
  0 - no compression
  1 - ZIP compression
  2 - ZLIB compression (= ZIP plus meta-data and block CRCs)
Default: 0
Applies to: pgp_sym_encrypt, pgp_pub_encrypt 
-->
值:
  0 - 没有压缩
  1 - ZIP 压缩
  2 - ZLIB 压缩 (= ZIP 加上元数据和块 CRCs)
缺省: 0
适用于: pgp_sym_encrypt, pgp_pub_encrypt
</literallayout>
  </sect4>

  <sect4>
   <!--
   <title>compress-level</title>
   -->
   <title>压缩级别</title>

   <!--
<para>
    How much to compress.  Higher levels compress smaller but are slower.
    0 disables compression.
   </para>
-->
<para>
压缩多少。较高层次压缩较小但是较慢。0表示禁用压缩。
</para>
<literallayout>
<!-- 
Values: 0, 1-9
Default: 6
Applies to: pgp_sym_encrypt, pgp_pub_encrypt 
-->
值: 0, 1-9
缺省: 6
适用于: pgp_sym_encrypt, pgp_pub_encrypt
</literallayout>
  </sect4>

  <sect4>
   <!--
   <title>convert-crlf</title>
   -->
   <title>转换 crlf</title>

   <!--
<para>
    Whether to convert <literal>\n</literal> into <literal>\r\n</literal> when
    encrypting and <literal>\r\n</literal> to <literal>\n</literal> when
    decrypting.  RFC 4880 specifies that text data should be stored using
    <literal>\r\n</literal> line-feeds.  Use this to get fully RFC-compliant
    behavior.
   </para>
-->
<para>
在加密时是否将<literal>\n</literal>转换为<literal>\r\n</literal>和在解密时是否将
<literal>\r\n</literal>转换为<literal>\n</literal>。RFC 4880指定文本数据应该使用
<literal>\r\n</literal>换行存储。使用这个获得全部的RFC兼容性能。
</para>
<literallayout>
<!--
Values: 0, 1
Default: 0
Applies to: pgp_sym_encrypt, pgp_pub_encrypt, pgp_sym_decrypt, pgp_pub_decrypt
-->
值: 0, 1
缺省: 0
适用于: pgp_sym_encrypt, pgp_pub_encrypt, pgp_sym_decrypt, pgp_pub_decrypt
</literallayout>
  </sect4>

  <sect4>
   <!-- 
   <title>disable-mdc</title>
   -->
   <title>禁用 mdc</title>

   <!--
<para>
    Do not protect data with SHA-1.  The only good reason to use this
    option is to achieve compatibility with ancient PGP products, predating
    the addition of SHA-1 protected packets to RFC 4880.
    Recent gnupg.org and pgp.com software supports it fine.
   </para>
-->
<para>
不要用SHA-1保护数据。唯一使用这个选项的理由是为了实现与古老的PGP产品的兼容，
该产品早于SHA-1受保护的包添加到RFC 4880。最近的gnupg.org和pgp.com软件也很好的支持它。
</para>
<literallayout>
<!--
Values: 0, 1
Default: 0
Applies to: pgp_sym_encrypt, pgp_pub_encrypt 
-->
值: 0, 1
缺省: 0
适用于: pgp_sym_encrypt, pgp_pub_encrypt
</literallayout>
  </sect4>

  <sect4>
   <!--
   <title>enable-session-key</title>
   -->
   <title>启用会话秘钥</title>

   <!--
<para>
    Use separate session key.  Public-key encryption always uses a separate
    session key; this is for symmetric-key encryption, which by default
    uses the S2K key directly.
   </para>
-->
<para>
使用单独的会话秘钥。公共秘钥加密总是使用一个单独的会话秘钥；这是为了对称秘钥加密，
这在默认情况下是直接使用S2K秘钥的。
</para>
<literallayout>
<!-- 
Values: 0, 1
Default: 0
Applies to: pgp_sym_encrypt 
-->
值: 0, 1
缺省: 0
适用于: pgp_sym_encrypt
</literallayout>
  </sect4>

  <sect4>
   <!--
   <title>s2k-mode</title>
   -->
   <title>s2k 模式</title>

   <!--
<para>
    Which S2K algorithm to use.
   </para>
-->
<para>
使用S2K算法。
</para>
<literallayout>
<!-- 
Values:
  0 - Without salt.  Dangerous!
  1 - With salt but with fixed iteration count.
  3 - Variable iteration count.
Default: 3
Applies to: pgp_sym_encrypt 
-->
值:
  0 - 没有salt。 危险的!
  1 - 有salt但是带有固定的重复计数。
  3 - 变量重复计数。
缺省: 3
适用于: pgp_sym_encrypt
</literallayout>
  </sect4>

  <sect4>
   <!-- 
   <title>s2k-digest-algo</title>
   -->
   <title>s2k 摘要算法</title>

   <!--
<para>
    Which digest algorithm to use in S2K calculation.
   </para>
-->
<para>
在S2K计算中使用哪个摘要算法。
</para>
<literallayout>
<!-- 
Values: md5, sha1
Default: sha1
Applies to: pgp_sym_encrypt 
-->
值: md5, sha1
缺省: sha1
适用于: pgp_sym_encrypt
</literallayout>
  </sect4>

  <sect4>
   <!--
   <title>s2k-cipher-algo</title>
   -->
   <title>s2k 密码算法</title>

   <!--
<para>
    Which cipher to use for encrypting separate session key.
   </para>
-->
<para>
加密单独的会话秘钥使用哪个密码。
</para>
<literallayout>
<!-- 
Values: bf, aes, aes128, aes192, aes256
Default: use cipher-algo
Applies to: pgp_sym_encrypt 
-->
值: bf, aes, aes128, aes192, aes256
缺省: use cipher-algo
适用于: pgp_sym_encrypt
</literallayout>
  </sect4>

  <sect4>
   <!--
   <title>unicode-mode</title>
   -->
   <title>unicode 模式</title>

   <!--
<para>
    Whether to convert textual data from database internal encoding to
    UTF-8 and back.  If your database already is UTF-8, no conversion will
    be done, but the message will be tagged as UTF-8.  Without this option
    it will not be.
   </para>
-->
<para>
是否要转换文本数据从数据库内部编码到UTF-8及以前。如果你的数据库已经是UTF-8，
将不需要转换，但是消息将被标记为UTF-8。没有这个选项将不会这样。
</para>
<literallayout>
<!-- 
Values: 0, 1
Default: 0
Applies to: pgp_sym_encrypt, pgp_pub_encrypt 
-->
值: 0, 1
缺省: 0
适用于: pgp_sym_encrypt, pgp_pub_encrypt
</literallayout>
  </sect4>
  </sect3>

 <sect3>
  <!--
  <title>Generating PGP Keys with GnuPG</title>
  -->
  <title>用 GnuPG 产生 PGP 秘钥</title>

<para>
   <!--
   To generate a new key:
   -->
   要生成一个新的秘钥：
<programlisting>
gpg --gen-key
</programlisting>
  </para>

  <!--
<para>
   The preferred key type is <quote>DSA and Elgamal</>.
  </para>
-->
<para>
首选的秘钥类型是<quote>DSA and Elgamal</>。
</para>
  <!--
<para>
   For RSA encryption you must create either DSA or RSA sign-only key
   as master and then add an RSA encryption subkey with
   <literal>gpg -&#045;edit-key</literal>.
  </para>
-->
<para>
对于RSA加密，你必须创建DSA或RSA唯一签署秘钥作为主秘钥，然后用
<literal>gpg --edit-key</literal>添加一个RSA加密子秘钥。
</para>

<para>
   <!--
   To list keys:
   -->
   要列出秘钥：
<programlisting>
gpg --list-secret-keys
</programlisting>
  </para>
  
<para>
   <!--
   To export a public key in ASCII-armor format:
   -->
   以ASCII-armor格式导出一个公共秘钥：
<programlisting>
gpg -a --export KEYID > public.key
</programlisting>
  </para>

<para>
   <!--
   To export a secret key in ASCII-armor format:
   -->
   以ASCII-armor格式导出一个秘密秘钥：
<programlisting>
gpg -a --export-secret-keys KEYID > secret.key
</programlisting>
  </para>

  <!--
<para>
   You need to use <function>dearmor()</> on these keys before giving them to
   the PGP functions.  Or if you can handle binary data, you can drop
   <literal>-a</literal> from the command.
  </para>
-->
<para>
在将它们送给PGP函数之前需要在这些秘钥上使用<function>dearmor()</>。
或者如果你可以处理二进制数据，你可以从命令行中删除<literal>-a</literal>。
</para>
  <!--
<para>
   For more details see <literal>man gpg</literal>,
   <ulink url="http://www.gnupg.org/gph/en/manual.html">The GNU
   Privacy Handbook</ulink> and other documentation on
   <ulink url="http://www.gnupg.org"></ulink>.
  </para>
-->
<para>
要获取更多详细信息，请参阅<literal>man gpg</literal>，
<ulink url="http://www.gnupg.org/gph/en/manual.html">The GNU
   Privacy Handbook</ulink>和其他<ulink url="http://www.gnupg.org"></ulink>上的文档。
</para>
 </sect3>

 <sect3>
  <!--
  <title>Limitations of PGP Code</title>
  -->
  <title>PGP 代码的限制</title>

  <itemizedlist>
   <listitem>
    <!--
<para>
    No support for signing.  That also means that it is not checked
    whether the encryption subkey belongs to the master key.
    </para>
-->
<para>
不支持签名。这也意味着不检查加密子秘钥是否属于主秘钥。
</para>
   </listitem>
   <listitem>
    <!--
<para>
    No support for encryption key as master key.  As such practice
    is generally discouraged, this should not be a problem.
    </para>
-->
<para>
不支持加密秘钥作为主秘钥。因为通常不建议这样的做法，这应该不是一个问题。
</para>
   </listitem>
   <listitem>
    <!--
<para>
    No support for several subkeys.  This may seem like a problem, as this
    is common practice.  On the other hand, you should not use your regular
    GPG/PGP keys with <filename>pgcrypto</>, but create new ones,
    as the usage scenario is rather different.
    </para>
-->
<para>
不支持几个子秘钥。这可能看起来像是一个问题，因为这是习惯的做法。另一方面，
不应该使用带有<filename>pgcrypto</>的定期GPG/PGP秘钥，而是创建一个新的秘钥，
因为使用场景相当不同。
</para>
   </listitem>
  </itemizedlist>
  </sect3>
 </sect2>

 <sect2>
  <!--
  <title>Raw Encryption Functions</title>
  -->
  <title>行加密功能</title>

  <!--
<para>
   These functions only run a cipher over data; they don't have any advanced
   features of PGP encryption.  Therefore they have some major problems:
  </para>
-->
<para>
这些功能在数据上只运行一个密码；它们没有任何比PGP加密更先进的特性。
因此它们有一些主要的问题：
</para>
  <orderedlist>
   <listitem>
    <!--
<para>
    They use user key directly as cipher key.
    </para>
-->
<para>
它们使用用户秘钥直接作为加密秘钥。
</para>
   </listitem>
   <listitem>
    <!--
<para>
    They don't provide any integrity checking, to see
    if the encrypted data was modified.
    </para>
-->
<para>
它们不提供任何完整性检查，来看看加密的数据是否被修改了。
</para>
   </listitem>
   <listitem>
    <!--
<para>
    They expect that users manage all encryption parameters
    themselves, even IV.
    </para>
-->
<para>
它们希望用户自己管理所有加密参数，即使是IV。
</para>
   </listitem>
   <listitem>
    <!--
<para>
    They don't handle text.
    </para>
-->
<para>
它们不处理文本。
</para>
   </listitem>
  </orderedlist>
  <!--
<para>
   So, with the introduction of PGP encryption, usage of raw
   encryption functions is discouraged.
  </para>
-->
<para>
所以，随着PGP加密的引入，不建议使用行加密功能了。
</para>

  <indexterm>
   <!--
   <primary>encrypt</primary>
   -->
   <primary>加密</primary>
  </indexterm>

  <indexterm>
   <!--
   <primary>decrypt</primary>
   -->
   <primary>解密</primary>
  </indexterm>

  <indexterm>
   <primary>encrypt_iv</primary>
  </indexterm>

  <indexterm>
   <primary>decrypt_iv</primary>
  </indexterm>

<synopsis>
encrypt(data bytea, key bytea, type text) returns bytea
decrypt(data bytea, key bytea, type text) returns bytea

encrypt_iv(data bytea, key bytea, iv bytea, type text) returns bytea
decrypt_iv(data bytea, key bytea, iv bytea, type text) returns bytea
</synopsis>

  
<para>
   <!-- 
   Encrypt/decrypt data using the cipher method specified by
   <parameter>type</parameter>.  The syntax of the
   <parameter>type</parameter> string is: 
   -->
   加密/解密数据使用<parameter>type</parameter>指定的加密方法。
   <parameter>type</parameter>字符串的语法是：

<synopsis>
<replaceable>algorithm</> <optional> <literal>-</> <replaceable>mode</> </optional> <optional> <literal>/pad:</> <replaceable>padding</> </optional>
</synopsis>
   <!--
   where <replaceable>algorithm</> is one of:
   -->
   而<replaceable>algorithm</>是下列之一：

  <itemizedlist>
   <listitem>
   <para><literal>bf</literal> &mdash; Blowfish</para>
</listitem>
   <listitem>
<para><literal>aes</literal> &mdash; AES (Rijndael-128)</para>
</listitem>
  </itemizedlist>
   <!--
   and <replaceable>mode</> is one of:
   -->
   <replaceable>mode</>是下列之一：
  <itemizedlist>
   <listitem>
    <!--
<para>
    <literal>cbc</literal> &mdash; next block depends on previous (default)
    </para>
-->
<para>
<literal>cbc</literal> &mdash; 下一个块取决于前一个块（缺省）
</para>
   </listitem>
   <listitem>
    <!--
<para>
    <literal>ecb</literal> &mdash; each block is encrypted separately (for
    testing only)
    </para>
-->
<para>
<literal>ecb</literal> &mdash; 每个块单独加密（只为了测试）
</para>
   </listitem>
  </itemizedlist>
   <!--
   and <replaceable>padding</> is one of:
   -->
   <replaceable>padding</>是下列之一：
  <itemizedlist>
   <listitem>
    <!--
<para>
    <literal>pkcs</literal> &mdash; data may be any length (default)
    </para>
-->
<para>
<literal>pkcs</literal> &mdash; 数据可以是任意长度（缺省）
</para>
   </listitem>
   <listitem>
    <!--
<para>
    <literal>none</literal> &mdash; data must be multiple of cipher block size
    </para>
-->
<para>
<literal>none</literal> &mdash; 数据必须是加密块尺寸的几倍
</para>
   </listitem>
  </itemizedlist>
  </para>

<para>
   <!--
   So, for example, these are equivalent:
   -->
   所以，例如，这些是相等的：
<programlisting>
encrypt(data, 'fooz', 'bf')
encrypt(data, 'fooz', 'bf-cbc/pad:pkcs')
</programlisting>
  </para>

  <!--
<para>
   In <function>encrypt_iv</> and <function>decrypt_iv</>, the
   <parameter>iv</> parameter is the initial value for the CBC mode;
   it is ignored for ECB.
   It is clipped or padded with zeroes if not exactly block size.
   It defaults to all zeroes in the functions without this parameter.
  </para>
-->
<para>
在<function>encrypt_iv</>和<function>decrypt_iv</>中，<parameter>iv</>
参数是CBC模式的初始值；在ECB中忽略。如果不正好是块的大小则截断或用0补齐。
在没有这个参数的函数里缺省全部为0。
</para>
 </sect2>

 <sect2>
  <!--
  <title>Random-Data Functions</title>
  -->
  <title>随机数据函数</title>

  <indexterm>
   <primary>gen_random_bytes</primary>
  </indexterm>

<synopsis>
gen_random_bytes(count integer) returns bytea
</synopsis>
  <!--
<para>
   Returns <parameter>count</> cryptographically strong random bytes.
   At most 1024 bytes can be extracted at a time.  This is to avoid
   draining the randomness generator pool.
  </para>
-->
<para>
密码强随机字节的返回<parameter>count</>。一次最多可以提取1024个字节。
这是为了避免排干随机发生器池。
</para>
 </sect2>

 <sect2>
  <!--
<title>Notes</title>
-->
<title>注意</title>

  <sect3>
   <!-- 
   <title>Configuration</title>
   -->
   <title>配置</title>

   <!--
<para>
    <filename>pgcrypto</> configures itself according to the findings of the
    main PostgreSQL <literal>configure</literal> script.  The options that
    affect it are <literal>-&#045;with-zlib</literal> and
    <literal>-&#045;with-openssl</literal>.
   </para>
-->
<para>
<filename>pgcrypto</>根据主PostgreSQL <literal>configure</literal>脚本的调查结果配置它本身。
影响它的选项是<literal>--with-zlib</literal>和<literal>--with-openssl</literal>。
</para>

   <!--
<para>
    When compiled with zlib, PGP encryption functions are able to
    compress data before encrypting.
   </para>
-->
<para>
当用zlib编译时，PGP加密函数可以在加密之前压缩数据。
</para>

   <!--
<para>
    When compiled with OpenSSL, there will be more algorithms available.
    Also public-key encryption functions will be faster as OpenSSL
    has more optimized BIGNUM functions.
   </para>
-->
<para>
当用OpenSSL编译时，有更多算法可用。公共秘钥加密函数也会更快，
因为OpenSSL有更多优化了的BIGNUM函数。
</para>

   <table id="pgcrypto-with-without-openssl">
    <!--
<title>Summary of Functionality with and without OpenSSL</title>
-->
<title>带有和不带有 OpenSSL 的功能性总结</title>
    <tgroup cols="3">
     <thead>
      <row>
       <!--
   <entry>Functionality</entry>
       <entry>Built-in</entry>
       <entry>With OpenSSL</entry>
   -->
   <entry>功能性</entry>
       <entry>内建</entry>
       <entry>带有 OpenSSL</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>MD5</entry>
       <entry>yes</entry>
       <entry>yes</entry>
      </row>
      <row>
       <entry>SHA1</entry>
       <entry>yes</entry>
       <entry>yes</entry>
      </row>
      <row>
       <entry>SHA224/256/384/512</entry>
       <entry>yes</entry>
       <!--
   <entry>yes (Note 1)</entry>
   -->
   <entry>yes (注意 1)</entry>
      </row>
      <row>
       <!--
   <entry>Other digest algorithms</entry>
   -->
   <entry>其他摘要算法</entry>
       <entry>no</entry>
       <!--
   <entry>yes (Note 2)</entry>
   -->
   <entry>yes (注意 2)</entry>
      </row>
      <row>
       <entry>Blowfish</entry>
       <entry>yes</entry>
       <entry>yes</entry>
      </row>
      <row>
       <entry>AES</entry>
       <entry>yes</entry>
       <!--
   <entry>yes (Note 3)</entry>
   -->
   <entry>yes (注意 3)</entry>
      </row>
      <row>
       <entry>DES/3DES/CAST5</entry>
       <entry>no</entry>
       <entry>yes</entry>
      </row>
      <row>
       <!-- 
   <entry>Raw encryption</entry>
   -->
   <entry>行加密</entry>
       <entry>yes</entry>
       <entry>yes</entry>
      </row>
      <row>
       <!--
   <entry>PGP Symmetric encryption</entry>
   -->
   <entry>PGP 对称加密</entry>
       <entry>yes</entry>
       <entry>yes</entry>
      </row>
      <row>
       <!--
   <entry>PGP Public-Key encryption</entry>
   -->
   <entry>PGP 公共秘钥加密</entry>
       <entry>yes</entry>
       <entry>yes</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <!--
<para>
    Notes:
   </para>
-->
<para>
注意：
</para>

   <orderedlist>
    <listitem>
     <!--
<para>
      SHA2 algorithms were added to OpenSSL in version 0.9.8.  For
      older versions, <filename>pgcrypto</> will use built-in code.
     </para>
-->
<para>
SHA2算法在版本 0.9.8 的时候添加到了OpenSSL。对于更老的版本，
<filename>pgcrypto</>使用内建的代码。
</para>
    </listitem>
    <listitem>
     <!--
<para>
      Any digest algorithm OpenSSL supports is automatically picked up.
      This is not possible with ciphers, which need to be supported
      explicitly.
     </para>
-->
<para>
任何OpenSSL支持的摘要算法是自动获得的。这对于密码来说是不可能的，密码需要明确的支持。
</para>
    </listitem>
    <listitem>
     <!--
<para>
      AES is included in OpenSSL since version 0.9.7.  For
      older versions, <filename>pgcrypto</> will use built-in code.
     </para>
-->
<para>
AES自版本 0.9.7 以来包含在OpenSSL中了。对于更老的版本，
<filename>pgcrypto</>使用内建的代码。
</para>
    </listitem>
   </orderedlist>
  </sect3>

  <sect3>
   <!--
   <title>NULL Handling</title>
   -->
   <title>NULL 处理</title>

   <!--
<para>
    As is standard in SQL, all functions return NULL, if any of the arguments
    are NULL.  This may create security risks on careless usage.
   </para>
-->
<para>
就像SQL中的标准，如果任一参数是NULL，那么所有函数都返回NULL。
这在粗心的使用中可能会造成安全风险。
</para>
  </sect3>

  <sect3>
   <!--
   <title>Security Limitations</title>
   -->
   <title>安全限制</title>

   <!--
<para>
    All <filename>pgcrypto</> functions run inside the database server.
    That means that all
    the data and passwords move between <filename>pgcrypto</> and client
    applications in clear text.  Thus you must:
   </para>
-->
<para>
所有<filename>pgcrypto</>函数在数据库服务器内部运行。这意味着<filename>pgcrypto</>
和客户端应用之间的所有数据和口令移动都是以明文的形式。因此必须：
</para>

   <orderedlist>
    <listitem>
     <!--
<para>Connect locally or use SSL connections.</para>
-->
<para>
本地连接或使用SSL连接。
</para>
    </listitem>
    <listitem>
     <!--
<para>Trust both system and database administrator.</para>
-->
<para>
同时信任系统和数据库管理员。
</para>
    </listitem>
   </orderedlist>

   <!--
<para>
    If you cannot, then better do crypto inside client application.
   </para>
-->
<para>
如果你做不到，那么最好在客户端应用内部做crypto。
</para>
  </sect3>

  <sect3>
   <!--
   <title>Useful Reading</title>
   -->
   <title>有用的阅读</title>

   <itemizedlist>
    <listitem>
<para><ulink url="http://www.gnupg.org/gph/en/manual.html"></ulink></para>

     <!--
<para>The GNU Privacy Handbook.</para>
-->
<para>
GNU 隐私手册。
</para>
    </listitem>
    <listitem>
<para><ulink url="http://www.openwall.com/crypt/"></ulink></para>

     <!--
<para>Describes the crypt-blowfish algorithm.</para>
-->
<para>
crypt-blowfish算法描述。
</para>
    </listitem>
    <listitem>
<para>
      <ulink url="http://www.stack.nl/~galactus/remailers/passphrase-faq.html"></ulink>
     </para>

     <!--
<para>How to choose a good password.</para>
-->
<para>
如何选择一个好的密码。
</para>
    </listitem>
    <listitem>
<para><ulink url="http://world.std.com/~reinhold/diceware.html"></ulink></para>
     <!--
<para>Interesting idea for picking passwords.</para>
-->
<para>
选择密码的有趣想法。
</para>
    </listitem>
    <listitem>
<para>
      <ulink url="http://www.interhack.net/people/cmcurtin/snake-oil-faq.html"></ulink>
     </para>
     <!--
<para>Describes good and bad cryptography.</para>
-->
<para>
描述密码学的优劣。
</para>
    </listitem>
   </itemizedlist>
  </sect3>

  <sect3>
   <!-- 
   <title>Technical References</title>
   -->
   <title>技术参考文献</title>

   <itemizedlist>
    <listitem>
<para><ulink url="http://www.ietf.org/rfc/rfc4880.txt"></ulink></para>
     <!--
<para>OpenPGP message format.</para>
-->
<para>
OpenPGP 消息格式。
</para>
    </listitem>
    <listitem>
<para><ulink url="http://www.ietf.org/rfc/rfc1321.txt"></ulink></para>
     <!--
<para>The MD5 Message-Digest Algorithm.</para>
-->
<para>
MD5 消息摘要算法。
</para>
    </listitem>
    <listitem>
<para><ulink url="http://www.ietf.org/rfc/rfc2104.txt"></ulink></para>
     <!--
<para>HMAC: Keyed-Hashing for Message Authentication.</para>
-->
<para>
HMAC:散列的消息认证。
</para>
    </listitem>
    <listitem>
<para>
      <ulink url="http://www.usenix.org/events/usenix99/provos.html"></ulink>
     </para>
     <!--
<para>Comparison of crypt-des, crypt-md5 and bcrypt algorithms.</para>
-->
<para>
crypt-des、crypt-md5和bcrypt算法的比较。
</para>
    </listitem>
    <listitem>
<para><ulink url="http://csrc.nist.gov/cryptval/des.htm"></ulink></para>
     <!--
<para>Standards for DES, 3DES and AES.</para>
-->
<para>
DES、3DES和AES标准。
</para>
    </listitem>
    <listitem>
<para>
      <ulink url="http://en.wikipedia.org/wiki/Fortuna_(PRNG)"></ulink>
     </para>
     <!--
<para>Description of Fortuna CSPRNG.</para>
-->
<para>
Fortuna CSPRNG的描述。
</para>
    </listitem>
    <listitem>
<para><ulink url="http://jlcooke.ca/random/"></ulink></para>
     <!--
<para>Jean-Luc Cooke Fortuna-based <filename>/dev/random</> driver for Linux.</para>
-->
<para>
基于Jean-Luc Cooke Fortuna的Linux <filename>/dev/random</>驱动器。
</para>
    </listitem>
    <listitem>
<para><ulink url="http://research.cyber.ee/~lipmaa/crypto/"></ulink></para>
     <!--
<para>Collection of cryptology pointers.</para>
-->
<para>
密码学指针集合。
</para>
    </listitem>
   </itemizedlist>
  </sect3>
 </sect2>

 <sect2>
  <!--
  <title>Author</title>
  -->
  <title>作者</title>

<para>
   Marko Kreen <email>markokr@gmail.com</email>
  </para>

  <!--
<para>
   <filename>pgcrypto</filename> uses code from the following sources:
  </para>
-->
<para>
<filename>pgcrypto</filename>使用来自下列源码的代码：
</para>

  <informaltable>
   <tgroup cols="3">
    <thead>
     <row>
      <!--
  <entry>Algorithm</entry>
      <entry>Author</entry>
      <entry>Source origin</entry>
  -->
  <entry>算法</entry>
      <entry>作者</entry>
      <entry>起源</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <!--
  <entry>DES crypt</entry>
      <entry>David Burren and others</entry>
      <entry>FreeBSD libcrypt</entry>
  -->
  <entry>DES 加密</entry>
      <entry>David Burren 和其他人</entry>
      <entry>FreeBSD libcrypt</entry>
     </row>
     <row>
      <!--
  <entry>MD5 crypt</entry>
      <entry>Poul-Henning Kamp</entry>
      <entry>FreeBSD libcrypt</entry>
  -->
  <entry>MD5 加密</entry>
      <entry>Poul-Henning Kamp</entry>
      <entry>FreeBSD libcrypt</entry>
     </row>
     <row>
      <!--
  <entry>Blowfish crypt</entry>
      <entry>Solar Designer</entry>
      <entry>www.openwall.com</entry>
  -->
  <entry>Blowfish 加密</entry>
      <entry>Solar Designer</entry>
      <entry>www.openwall.com</entry>
     </row>
     <row>
      <!--
  <entry>Blowfish cipher</entry>
  -->
  <entry>Blowfish 密码</entry>
      <entry>Simon Tatham</entry>
      <entry>PuTTY</entry>
     </row>
     <row>
      <!--
  <entry>Rijndael cipher</entry>
  -->
  <entry>Rijndael 密码</entry>
      <entry>Brian Gladman</entry>
      <entry>OpenBSD sys/crypto</entry>
     </row>
     <row>
      <!--
  <entry>MD5 and SHA1</entry>
  -->
  <entry>MD5 和 SHA1</entry>
      <entry>WIDE Project</entry>
      <entry>KAME kame/sys/crypto</entry>
     </row>
     <row>
      <entry>SHA256/384/512 </entry>
      <entry>Aaron D. Gifford</entry>
      <entry>OpenBSD sys/crypto</entry>
     </row>
     <row>
      <entry>BIGNUM math</entry>
      <entry>Michael J. Fromberger</entry>
      <entry>dartmouth.edu/~sting/sw/imath</entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
 </sect2>

</sect1>
